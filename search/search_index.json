{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Adatvez\u00e9relt rendszerek \u00b6 Jegyzetek, gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAC01 Adatvez\u00e9relt rendszerek c. t\u00e1rgyhoz. Jav\u00edt\u00e1s az anyagban A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request -et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod. Felhaszn\u00e1l\u00e1si felt\u00e9telek Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC01 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet. Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.","title":"Adatvez\u00e9relt rendszerek"},{"location":"#adatvezerelt-rendszerek","text":"Jegyzetek, gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAC01 Adatvez\u00e9relt rendszerek c. t\u00e1rgyhoz. Jav\u00edt\u00e1s az anyagban A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request -et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod. Felhaszn\u00e1l\u00e1si felt\u00e9telek Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC01 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet. Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.","title":"Adatvez\u00e9relt rendszerek"},{"location":"db/","text":"Minta adatb\u00e1zis s\u00e9m\u00e1ja \u00b6 A f\u00e9l\u00e9v sor\u00e1n a gyakorlati p\u00e9ld\u00e1kat egy egys\u00e9ges mintap\u00e9ld\u00e1n kereszt\u00fcl szeml\u00e9ltetj\u00fck. A mintap\u00e9lda egy egyszer\u0171 vev\u0151-megrendel\u00e9snyilv\u00e1ntart\u00e1si rendszer. Az al\u00e1bbi le\u00edr\u00e1s a Microsoft SQL Server rel\u00e1ci\u00f3s s\u00e9m\u00e1j\u00e1t ismerteti, a MongoDB \"s\u00e9ma\" ennek \u00e1t\u00fcltet\u00e9se. Az adatb\u00e1zis kontextusa \u00b6 A rendszer term\u00e9kek \u00e9rt\u00e9kes\u00edt\u00e9si folyamat\u00e1nak a k\u00f6vet\u00e9s\u00e9re szolg\u00e1l. A term\u00e9keket ( product ) kateg\u00f3ri\u00e1kba ( category ) lehet sorolni, mely kateg\u00f3ri\u00e1k hierarchikusan egym\u00e1sra \u00e9p\u00fclhetnek. A vev\u0151k ( customer ) megrendel\u00e9seiket ( order ) \u00e9s azok st\u00e1tusz\u00e1t ( status ) nyomon tudj\u00e1k k\u00f6vetni. Az \u00fcgyfeleknek t\u00f6bb telephely\u00fck ( customer site ) is lehet, az egyes megrendel\u00e9sek ( order ) felad\u00e1sakor, tiszt\u00e1zni kell, hogy az \u00fcgyf\u00e9l mely telephely\u00e9re t\u00f6rt\u00e9nik meg a kisz\u00e1ll\u00edt\u00e1s. Minden vev\u0151nek kell rendelkeznie k\u00f6zponti telephellyel, mely a sz\u00e1ml\u00e1z\u00e1si c\u00edm\u00fcl is szolg\u00e1l. Term\u00e9szetesen egy megrendel\u00e9shez t\u00f6bb t\u00e9tel ( order item ) is tartozhat, az egyes t\u00e9telek st\u00e1tusza k\u00fcl\u00f6n-k\u00fcl\u00f6n is k\u00f6vethet\u0151, ez\u00e1ltal a vev\u0151 l\u00e1tja, hogy esetleg mely term\u00e9kre kell v\u00e1rnia. A k\u00e9sz megrendel\u00e9sekr\u0151l sz\u00e1ml\u00e1t ( invoice ) kell k\u00e9sz\u00edteni. A sz\u00e1mla ( invoice ) olyan bizonylat, melynek az adatai k\u00e9s\u0151bb nem v\u00e1ltoztathat\u00f3k, valamint az els\u0151 nyomtat\u00e1st k\u00f6vet\u0151en sz\u00e1mlam\u00e1solatot lehet csak ki\u00e1ll\u00edtani. Figyelembe kell venni azt is, hogy az egyes term\u00e9kek \u00c1FA besorol\u00e1sa ( VAT = value added tax ) ill. \u00c1FA kulcsa megv\u00e1ltozhat az id\u0151k sor\u00e1n, viszont a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1kon term\u00e9szetesen m\u00e1r ez az inform\u00e1ci\u00f3 sem v\u00e1ltozhat meg. Adatmodell \u00b6 Az al\u00e1bbi \u00e1bra szeml\u00e9lteti a nyilv\u00e1ntart\u00f3rendszer adatmodellj\u00e9t. T\u00e1bl\u00e1k \u00e9s attrib\u00fatumok \u00b6 T\u00e1bla Oszlop Le\u00edr\u00e1s VAT ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Percentage \u00c1FA kulcs \u00e9rt\u00e9ke sz\u00e1zal\u00e9kban megadva. PaymentMethod ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Mode Fizet\u00e9si m\u00f3d megnevez\u00e9se (pl.: K\u00e9szp\u00e9nz, \u00c1tutal\u00e1s 8 napon bel\u00fcl). Deadline A fizet\u00e9si m\u00f3dhoz tartoz\u00f3 hat\u00e1rid\u0151, azaz a sz\u00e1mla teljes\u00edt\u00e9si d\u00e1tum\u00e1hoz k\u00e9pest, h\u00e1ny nappal van k\u00e9s\u0151bb a fizet\u00e9si hat\u00e1rid\u0151. Status ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Megrendel\u00e9s st\u00e1tusz megnevez\u00e9se (pl.: \u00faj, feldolgozva, \u00e1rura v\u00e1r, csomagolva,\u2026). Category ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name Term\u00e9kkateg\u00f3ria megnevez\u00e9se (pl.: \u00e9lelmiszer, tejterm\u00e9k, \u2026). ParentCategoryID Kateg\u00f3ria hierarchi\u00e1t le\u00edr\u00f3 idegen kulcs, egy adott kateg\u00f3ria sz\u00fcl\u0151j\u00e9re mutat. A gy\u00f6k\u00e9relemekn\u00e9l, a sz\u00fcl\u0151kateg\u00f3ria azonos\u00edt\u00f3ja NULL. Product ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Term\u00e9k neve Price Term\u00e9k nett\u00f3 \u00e1ra Stock A term\u00e9kb\u0151l a rakt\u00e1rban tal\u00e1lhat\u00f3 mennyis\u00e9g. VATID Idegen kulcs a term\u00e9k \u00c1FA kulcs\u00e1ra (VAT t\u00e1bla). CategoryID Idegen kulcs a term\u00e9k kateg\u00f3ri\u00e1j\u00e1ra (Category t\u00e1bla). Description A term\u00e9khez tartoz\u00f3 XML form\u00e1tum\u00fa le\u00edr\u00e1s Customer ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Vev\u0151 megnevez\u00e9se. BankAccount Vev\u0151 banksz\u00e1mla sz\u00e1ma. Login Vev\u0151 login neve a webes rendszerhez. Password Vev\u0151 jelszava a webes rendszerhez. Email Vev\u0151 email c\u00edme. MainCustomerSiteID A vev\u0151 k\u00f6zponti telephely\u00e9nek azonos\u00edt\u00f3ja, k\u00fcls\u0151 kulcs a CustomerSite t\u00e1bl\u00e1ra. CustomerSite ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Zip A c\u00edm ir\u00e1ny\u00edt\u00f3sz\u00e1m r\u00e9sze. City A c\u00edm v\u00e1ros r\u00e9sze. Street A c\u00edm utca \u00e9s h\u00e1zsz\u00e1m r\u00e9sze. Tel A telephelyhez kapcsol\u00f3d\u00f3 telefonsz\u00e1m. Fax A telephelyhez kapcsol\u00f3d\u00f3 fax sz\u00e1m. CustomerID K\u00fcls\u0151 kulcs a vev\u0151re (Customer t\u00e1bla). Order ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Date Megrendel\u00e9s d\u00e1tuma. Deadline V\u00e1llalt sz\u00e1ll\u00edt\u00e1si hat\u00e1rid\u0151. CustomerSiteID K\u00fcls\u0151 kulcs a vev\u0151 telephely\u00e9re, ide kell kisz\u00e1ll\u00edtani a megrendelt \u00e1rukat (CustomerSite t\u00e1bla). StatusID K\u00fcls\u0151 kulcs a st\u00e1tuszra, ez mutatja, hogy mi a teljes st\u00e1tusza a megrendel\u00e9snek (Status t\u00e1bla). PaymentMethodID K\u00fcls\u0151 kulcs a fizet\u00e9si m\u00f3dra. A megrendel\u00e9shez tartoz\u00f3 sz\u00e1ml\u00e1t az itt megadott m\u00f3don fogj\u00e1k kiegyenl\u00edteni (PaymentMethod t\u00e1bla). OrderItem ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Amount Mennyis\u00e9g, azaz az adott \u00e1rub\u00f3l ennyi darabot rendeltek meg. Price Egy egys\u00e9g nett\u00f3 \u00e1ra. Alap\u00e9rtelmez\u00e9sk\u00e9nt az term\u00e9kben tal\u00e1lhat\u00f3 nett\u00f3 \u00e1r m\u00e1sol\u00f3dik ide, de ett\u0151l elt\u00e9rhet az \u00e9rt\u00e9kes\u00edt\u0151. OrderID Idegen kulcs a megrendel\u00e9sre, azaz ez azonos\u00edtja, hogy az adott t\u00e9tel mely megrendel\u00e9shez tartozik (Order t\u00e1bla). ProductID Idegen kulcs a Product t\u00e1bl\u00e1ra, ez azonos\u00edtja a megrendelt term\u00e9ket. StatusID Idegen kulcs a Status t\u00e1bl\u00e1ra, ezzel lehet le\u00edrni a megrendel\u00e9s t\u00e9tel st\u00e1tusz\u00e1t. InvoiceIssuer ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name C\u00e9gn\u00e9v, aki a keresked\u00e9st folytatja, ez szerepel a sz\u00e1ml\u00e1n. Zip A c\u00edm ir\u00e1ny\u00edt\u00f3sz\u00e1m r\u00e9sze. City A c\u00edm v\u00e1ros r\u00e9sze. Street A c\u00edm utca r\u00e9sze. TaxIdentifier A c\u00e9g ad\u00f3sz\u00e1ma. BankAccount A c\u00e9g banksz\u00e1mlasz\u00e1ma. Invoice ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs CustomerName Megrendel\u0151 neve, ez az inform\u00e1ci\u00f3 fog a sz\u00e1mla vev\u0151 r\u00e9sz\u00e9n megjelenni. CustomerZipCode A vev\u0151 c\u00edm\u00e9nek ir\u00e1ny\u00edt\u00f3sz\u00e1ma. CustomerCity A vev\u0151 c\u00edm\u00e9nek v\u00e1ros r\u00e9sze. CustomerStreet A vev\u0151 c\u00edm\u00e9nek utca r\u00e9sze. PrintedCopies A sz\u00e1mla h\u00e1nyszor lett kinyomtatva. Cancelled A sz\u00e1mla sztorn\u00f3zva lett-e? PaymentMethod A sz\u00e1mla fizet\u00e9si m\u00f3dja. CreationDate A sz\u00e1mla ki\u00e1ll\u00edt\u00e1s\u00e1nak kelte. DeliveryDate A sz\u00e1mla teljes\u00edt\u00e9si d\u00e1tuma. PaymentDeadline A sz\u00e1mla fizet\u00e9si hat\u00e1rideje. InvoiceIssuerID Idegen kulcs a sz\u00e1mla ki\u00e1ll\u00edt\u00f3ra (InvoiceIssuer t\u00e1ba). OrderID Idegen kulcs a megrendel\u00e9sre, a sz\u00e1mla ezen megrendel\u00e9s alapj\u00e1n ker\u00fclt ki\u00e1ll\u00edt\u00e1sra (Order t\u00e1bla). InvoiceItem ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name Term\u00e9k neve, mely a sz\u00e1mlat\u00e9telben szerepel. Amount A v\u00e1s\u00e1rolt mennyis\u00e9g. Price A t\u00e9tel nett\u00f3 egys\u00e9g\u00e1ra. VATPercentage A t\u00e9tel \u00c1FA kulcsa InvoiceID Idegen kulcs a sz\u00e1ml\u00e1ra, melyhez a a sz\u00e1mlat\u00e9tel tartozik (Order t\u00e1bla). OrderItemID Idegen kulcs a megrendel\u00e9s t\u00e9telre (OrderItem t\u00e1bla), melyb\u0151l a sz\u00e1mlat\u00e9tel keletkezett. Saj\u00e1toss\u00e1gok \u00b6 Sz\u00e1ml\u00e1z\u00e1s \u00b6 Adatmodell saj\u00e1toss\u00e1ga, a sz\u00e1ml\u00e1z\u00e1si adatok t\u00e1rol\u00e1sa. A sz\u00e1mla adatait nem lehet megv\u00e1ltoztatni kinyomtat\u00e1s ut\u00e1n, sz\u00e1ml\u00e1t nem lehet t\u00f6r\u00f6lni csak sztorn\u00f3zni. Ebb\u0151l ad\u00f3d\u00f3n a sz\u00e1ml\u00e1hoz tartoz\u00f3 \u00f6sszes inform\u00e1ci\u00f3t az Invoice \u00e9s az InvoiceItem t\u00e1bl\u00e1k tartalmazz\u00e1k, a sz\u00e1mlaki\u00e1ll\u00edt\u00e1s sor\u00e1n minden inform\u00e1ci\u00f3t le kell m\u00e1solni a vonatkoz\u00f3 megrendel\u00e9sb\u0151l. Valamint az els\u0151 nyomtat\u00e1st k\u00f6vet\u0151en a sz\u00e1ml\u00e1b\u00f3l m\u00e1r csak m\u00e1solatot lehet nyomtatni, eredeti p\u00e9ld\u00e1nyt nem. Sz\u00e1mla ki\u00e1ll\u00edt\u00f3 \u00b6 Speci\u00e1lis a InvoiceIssuerID attrib\u00fatum az Invoice t\u00e1bl\u00e1ban, mivel a c\u00e9g saj\u00e1t adatai ritk\u00e1n v\u00e1ltoznak. Viszont a v\u00e1ltoztathatatlans\u00e1g k\u00f6vetelm\u00e9nye miatt a sz\u00e1mla ki\u00e1ll\u00edt\u00f3 adatait nem lehet m\u00f3dos\u00edtani, ha m\u00e1r van hozz\u00e1 sz\u00e1mla. Ebben az esetben a sz\u00e1mla ki\u00e1ll\u00edt\u00f3 t\u00e1bl\u00e1ba \u00faj rekordot kell felvenni, ebb\u0151l ad\u00f3d\u00f3an az aktu\u00e1lis c\u00e9gadatokat minidig a legmagasabb ID-vel rendelkez\u0151 sz\u00e1mla ki\u00e1ll\u00edt\u00f3 rekord tartalmazza. \u00c1FA \u00b6 Egy term\u00e9k \u00c1FA kulcsa ( VAT ) b\u00e1rmikor megv\u00e1ltozhat, de ez a megrendel\u00e9s sor\u00e1n teljesen term\u00e9szetes, de a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1k \u00c1FA tartalma m\u00e1r nem v\u00e1ltozhat meg. Ez\u00e9rt a megrendel\u00e9s sor\u00e1n az \u00c1F\u00c1-ra idegen kulccsal kell hivatkozni, hogy a v\u00e1ltoz\u00e1st k\u00f6vetni lehessen, viszont a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1ban le kell t\u00e1rolni a ki\u00e1ll\u00edt\u00e1s pillanat\u00e1ban az aktu\u00e1lis \u00c1FA kulcsot. Term\u00e9k le\u00edr\u00e1s \u00b6 A term\u00e9kekhez tartozhat egy XML form\u00e1tum\u00fa le\u00edr\u00e1s, ennek tartalm\u00e1t szeml\u00e9lteti az al\u00e1bbi p\u00e9lda. Ezen le\u00edr\u00e1s a term\u00e9khez tartoz\u00f3 egy\u00e9b extra inform\u00e1ci\u00f3kat tartalmazza, amelyeket nem fejtett\u00fcnk ki a rel\u00e1ci\u00f3s modellben <product> <product_size> <unit> cm </unit> <width> 150 </width> <height> 50 </height> <depth> 150 </depth> </product_size> <package_parameters> <number_of_packages> 1 </number_of_packages> <package_size> <unit> cm </unit> <width> 150 </width> <height> 20 </height> <depth> 20 </depth> </package_size> </package_parameters> <description> Requires battery (not part of the package). </description> <recommended_age> 0-18 m </recommended_age> </product>","title":"Minta adatb\u00e1zis s\u00e9m\u00e1ja"},{"location":"db/#minta-adatbazis-semaja","text":"A f\u00e9l\u00e9v sor\u00e1n a gyakorlati p\u00e9ld\u00e1kat egy egys\u00e9ges mintap\u00e9ld\u00e1n kereszt\u00fcl szeml\u00e9ltetj\u00fck. A mintap\u00e9lda egy egyszer\u0171 vev\u0151-megrendel\u00e9snyilv\u00e1ntart\u00e1si rendszer. Az al\u00e1bbi le\u00edr\u00e1s a Microsoft SQL Server rel\u00e1ci\u00f3s s\u00e9m\u00e1j\u00e1t ismerteti, a MongoDB \"s\u00e9ma\" ennek \u00e1t\u00fcltet\u00e9se.","title":"Minta adatb\u00e1zis s\u00e9m\u00e1ja"},{"location":"db/#az-adatbazis-kontextusa","text":"A rendszer term\u00e9kek \u00e9rt\u00e9kes\u00edt\u00e9si folyamat\u00e1nak a k\u00f6vet\u00e9s\u00e9re szolg\u00e1l. A term\u00e9keket ( product ) kateg\u00f3ri\u00e1kba ( category ) lehet sorolni, mely kateg\u00f3ri\u00e1k hierarchikusan egym\u00e1sra \u00e9p\u00fclhetnek. A vev\u0151k ( customer ) megrendel\u00e9seiket ( order ) \u00e9s azok st\u00e1tusz\u00e1t ( status ) nyomon tudj\u00e1k k\u00f6vetni. Az \u00fcgyfeleknek t\u00f6bb telephely\u00fck ( customer site ) is lehet, az egyes megrendel\u00e9sek ( order ) felad\u00e1sakor, tiszt\u00e1zni kell, hogy az \u00fcgyf\u00e9l mely telephely\u00e9re t\u00f6rt\u00e9nik meg a kisz\u00e1ll\u00edt\u00e1s. Minden vev\u0151nek kell rendelkeznie k\u00f6zponti telephellyel, mely a sz\u00e1ml\u00e1z\u00e1si c\u00edm\u00fcl is szolg\u00e1l. Term\u00e9szetesen egy megrendel\u00e9shez t\u00f6bb t\u00e9tel ( order item ) is tartozhat, az egyes t\u00e9telek st\u00e1tusza k\u00fcl\u00f6n-k\u00fcl\u00f6n is k\u00f6vethet\u0151, ez\u00e1ltal a vev\u0151 l\u00e1tja, hogy esetleg mely term\u00e9kre kell v\u00e1rnia. A k\u00e9sz megrendel\u00e9sekr\u0151l sz\u00e1ml\u00e1t ( invoice ) kell k\u00e9sz\u00edteni. A sz\u00e1mla ( invoice ) olyan bizonylat, melynek az adatai k\u00e9s\u0151bb nem v\u00e1ltoztathat\u00f3k, valamint az els\u0151 nyomtat\u00e1st k\u00f6vet\u0151en sz\u00e1mlam\u00e1solatot lehet csak ki\u00e1ll\u00edtani. Figyelembe kell venni azt is, hogy az egyes term\u00e9kek \u00c1FA besorol\u00e1sa ( VAT = value added tax ) ill. \u00c1FA kulcsa megv\u00e1ltozhat az id\u0151k sor\u00e1n, viszont a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1kon term\u00e9szetesen m\u00e1r ez az inform\u00e1ci\u00f3 sem v\u00e1ltozhat meg.","title":"Az adatb\u00e1zis kontextusa"},{"location":"db/#adatmodell","text":"Az al\u00e1bbi \u00e1bra szeml\u00e9lteti a nyilv\u00e1ntart\u00f3rendszer adatmodellj\u00e9t.","title":"Adatmodell"},{"location":"db/#tablak-es-attributumok","text":"T\u00e1bla Oszlop Le\u00edr\u00e1s VAT ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Percentage \u00c1FA kulcs \u00e9rt\u00e9ke sz\u00e1zal\u00e9kban megadva. PaymentMethod ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Mode Fizet\u00e9si m\u00f3d megnevez\u00e9se (pl.: K\u00e9szp\u00e9nz, \u00c1tutal\u00e1s 8 napon bel\u00fcl). Deadline A fizet\u00e9si m\u00f3dhoz tartoz\u00f3 hat\u00e1rid\u0151, azaz a sz\u00e1mla teljes\u00edt\u00e9si d\u00e1tum\u00e1hoz k\u00e9pest, h\u00e1ny nappal van k\u00e9s\u0151bb a fizet\u00e9si hat\u00e1rid\u0151. Status ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Megrendel\u00e9s st\u00e1tusz megnevez\u00e9se (pl.: \u00faj, feldolgozva, \u00e1rura v\u00e1r, csomagolva,\u2026). Category ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name Term\u00e9kkateg\u00f3ria megnevez\u00e9se (pl.: \u00e9lelmiszer, tejterm\u00e9k, \u2026). ParentCategoryID Kateg\u00f3ria hierarchi\u00e1t le\u00edr\u00f3 idegen kulcs, egy adott kateg\u00f3ria sz\u00fcl\u0151j\u00e9re mutat. A gy\u00f6k\u00e9relemekn\u00e9l, a sz\u00fcl\u0151kateg\u00f3ria azonos\u00edt\u00f3ja NULL. Product ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Term\u00e9k neve Price Term\u00e9k nett\u00f3 \u00e1ra Stock A term\u00e9kb\u0151l a rakt\u00e1rban tal\u00e1lhat\u00f3 mennyis\u00e9g. VATID Idegen kulcs a term\u00e9k \u00c1FA kulcs\u00e1ra (VAT t\u00e1bla). CategoryID Idegen kulcs a term\u00e9k kateg\u00f3ri\u00e1j\u00e1ra (Category t\u00e1bla). Description A term\u00e9khez tartoz\u00f3 XML form\u00e1tum\u00fa le\u00edr\u00e1s Customer ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Vev\u0151 megnevez\u00e9se. BankAccount Vev\u0151 banksz\u00e1mla sz\u00e1ma. Login Vev\u0151 login neve a webes rendszerhez. Password Vev\u0151 jelszava a webes rendszerhez. Email Vev\u0151 email c\u00edme. MainCustomerSiteID A vev\u0151 k\u00f6zponti telephely\u00e9nek azonos\u00edt\u00f3ja, k\u00fcls\u0151 kulcs a CustomerSite t\u00e1bl\u00e1ra. CustomerSite ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Zip A c\u00edm ir\u00e1ny\u00edt\u00f3sz\u00e1m r\u00e9sze. City A c\u00edm v\u00e1ros r\u00e9sze. Street A c\u00edm utca \u00e9s h\u00e1zsz\u00e1m r\u00e9sze. Tel A telephelyhez kapcsol\u00f3d\u00f3 telefonsz\u00e1m. Fax A telephelyhez kapcsol\u00f3d\u00f3 fax sz\u00e1m. CustomerID K\u00fcls\u0151 kulcs a vev\u0151re (Customer t\u00e1bla). Order ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Date Megrendel\u00e9s d\u00e1tuma. Deadline V\u00e1llalt sz\u00e1ll\u00edt\u00e1si hat\u00e1rid\u0151. CustomerSiteID K\u00fcls\u0151 kulcs a vev\u0151 telephely\u00e9re, ide kell kisz\u00e1ll\u00edtani a megrendelt \u00e1rukat (CustomerSite t\u00e1bla). StatusID K\u00fcls\u0151 kulcs a st\u00e1tuszra, ez mutatja, hogy mi a teljes st\u00e1tusza a megrendel\u00e9snek (Status t\u00e1bla). PaymentMethodID K\u00fcls\u0151 kulcs a fizet\u00e9si m\u00f3dra. A megrendel\u00e9shez tartoz\u00f3 sz\u00e1ml\u00e1t az itt megadott m\u00f3don fogj\u00e1k kiegyenl\u00edteni (PaymentMethod t\u00e1bla). OrderItem ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Amount Mennyis\u00e9g, azaz az adott \u00e1rub\u00f3l ennyi darabot rendeltek meg. Price Egy egys\u00e9g nett\u00f3 \u00e1ra. Alap\u00e9rtelmez\u00e9sk\u00e9nt az term\u00e9kben tal\u00e1lhat\u00f3 nett\u00f3 \u00e1r m\u00e1sol\u00f3dik ide, de ett\u0151l elt\u00e9rhet az \u00e9rt\u00e9kes\u00edt\u0151. OrderID Idegen kulcs a megrendel\u00e9sre, azaz ez azonos\u00edtja, hogy az adott t\u00e9tel mely megrendel\u00e9shez tartozik (Order t\u00e1bla). ProductID Idegen kulcs a Product t\u00e1bl\u00e1ra, ez azonos\u00edtja a megrendelt term\u00e9ket. StatusID Idegen kulcs a Status t\u00e1bl\u00e1ra, ezzel lehet le\u00edrni a megrendel\u00e9s t\u00e9tel st\u00e1tusz\u00e1t. InvoiceIssuer ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name C\u00e9gn\u00e9v, aki a keresked\u00e9st folytatja, ez szerepel a sz\u00e1ml\u00e1n. Zip A c\u00edm ir\u00e1ny\u00edt\u00f3sz\u00e1m r\u00e9sze. City A c\u00edm v\u00e1ros r\u00e9sze. Street A c\u00edm utca r\u00e9sze. TaxIdentifier A c\u00e9g ad\u00f3sz\u00e1ma. BankAccount A c\u00e9g banksz\u00e1mlasz\u00e1ma. Invoice ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs CustomerName Megrendel\u0151 neve, ez az inform\u00e1ci\u00f3 fog a sz\u00e1mla vev\u0151 r\u00e9sz\u00e9n megjelenni. CustomerZipCode A vev\u0151 c\u00edm\u00e9nek ir\u00e1ny\u00edt\u00f3sz\u00e1ma. CustomerCity A vev\u0151 c\u00edm\u00e9nek v\u00e1ros r\u00e9sze. CustomerStreet A vev\u0151 c\u00edm\u00e9nek utca r\u00e9sze. PrintedCopies A sz\u00e1mla h\u00e1nyszor lett kinyomtatva. Cancelled A sz\u00e1mla sztorn\u00f3zva lett-e? PaymentMethod A sz\u00e1mla fizet\u00e9si m\u00f3dja. CreationDate A sz\u00e1mla ki\u00e1ll\u00edt\u00e1s\u00e1nak kelte. DeliveryDate A sz\u00e1mla teljes\u00edt\u00e9si d\u00e1tuma. PaymentDeadline A sz\u00e1mla fizet\u00e9si hat\u00e1rideje. InvoiceIssuerID Idegen kulcs a sz\u00e1mla ki\u00e1ll\u00edt\u00f3ra (InvoiceIssuer t\u00e1ba). OrderID Idegen kulcs a megrendel\u00e9sre, a sz\u00e1mla ezen megrendel\u00e9s alapj\u00e1n ker\u00fclt ki\u00e1ll\u00edt\u00e1sra (Order t\u00e1bla). InvoiceItem ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name Term\u00e9k neve, mely a sz\u00e1mlat\u00e9telben szerepel. Amount A v\u00e1s\u00e1rolt mennyis\u00e9g. Price A t\u00e9tel nett\u00f3 egys\u00e9g\u00e1ra. VATPercentage A t\u00e9tel \u00c1FA kulcsa InvoiceID Idegen kulcs a sz\u00e1ml\u00e1ra, melyhez a a sz\u00e1mlat\u00e9tel tartozik (Order t\u00e1bla). OrderItemID Idegen kulcs a megrendel\u00e9s t\u00e9telre (OrderItem t\u00e1bla), melyb\u0151l a sz\u00e1mlat\u00e9tel keletkezett.","title":"T\u00e1bl\u00e1k \u00e9s attrib\u00fatumok"},{"location":"db/#sajatossagok","text":"","title":"Saj\u00e1toss\u00e1gok"},{"location":"db/#szamlazas","text":"Adatmodell saj\u00e1toss\u00e1ga, a sz\u00e1ml\u00e1z\u00e1si adatok t\u00e1rol\u00e1sa. A sz\u00e1mla adatait nem lehet megv\u00e1ltoztatni kinyomtat\u00e1s ut\u00e1n, sz\u00e1ml\u00e1t nem lehet t\u00f6r\u00f6lni csak sztorn\u00f3zni. Ebb\u0151l ad\u00f3d\u00f3n a sz\u00e1ml\u00e1hoz tartoz\u00f3 \u00f6sszes inform\u00e1ci\u00f3t az Invoice \u00e9s az InvoiceItem t\u00e1bl\u00e1k tartalmazz\u00e1k, a sz\u00e1mlaki\u00e1ll\u00edt\u00e1s sor\u00e1n minden inform\u00e1ci\u00f3t le kell m\u00e1solni a vonatkoz\u00f3 megrendel\u00e9sb\u0151l. Valamint az els\u0151 nyomtat\u00e1st k\u00f6vet\u0151en a sz\u00e1ml\u00e1b\u00f3l m\u00e1r csak m\u00e1solatot lehet nyomtatni, eredeti p\u00e9ld\u00e1nyt nem.","title":"Sz\u00e1ml\u00e1z\u00e1s"},{"location":"db/#szamla-kiallito","text":"Speci\u00e1lis a InvoiceIssuerID attrib\u00fatum az Invoice t\u00e1bl\u00e1ban, mivel a c\u00e9g saj\u00e1t adatai ritk\u00e1n v\u00e1ltoznak. Viszont a v\u00e1ltoztathatatlans\u00e1g k\u00f6vetelm\u00e9nye miatt a sz\u00e1mla ki\u00e1ll\u00edt\u00f3 adatait nem lehet m\u00f3dos\u00edtani, ha m\u00e1r van hozz\u00e1 sz\u00e1mla. Ebben az esetben a sz\u00e1mla ki\u00e1ll\u00edt\u00f3 t\u00e1bl\u00e1ba \u00faj rekordot kell felvenni, ebb\u0151l ad\u00f3d\u00f3an az aktu\u00e1lis c\u00e9gadatokat minidig a legmagasabb ID-vel rendelkez\u0151 sz\u00e1mla ki\u00e1ll\u00edt\u00f3 rekord tartalmazza.","title":"Sz\u00e1mla ki\u00e1ll\u00edt\u00f3"},{"location":"db/#afa","text":"Egy term\u00e9k \u00c1FA kulcsa ( VAT ) b\u00e1rmikor megv\u00e1ltozhat, de ez a megrendel\u00e9s sor\u00e1n teljesen term\u00e9szetes, de a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1k \u00c1FA tartalma m\u00e1r nem v\u00e1ltozhat meg. Ez\u00e9rt a megrendel\u00e9s sor\u00e1n az \u00c1F\u00c1-ra idegen kulccsal kell hivatkozni, hogy a v\u00e1ltoz\u00e1st k\u00f6vetni lehessen, viszont a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1ban le kell t\u00e1rolni a ki\u00e1ll\u00edt\u00e1s pillanat\u00e1ban az aktu\u00e1lis \u00c1FA kulcsot.","title":"\u00c1FA"},{"location":"db/#termek-leiras","text":"A term\u00e9kekhez tartozhat egy XML form\u00e1tum\u00fa le\u00edr\u00e1s, ennek tartalm\u00e1t szeml\u00e9lteti az al\u00e1bbi p\u00e9lda. Ezen le\u00edr\u00e1s a term\u00e9khez tartoz\u00f3 egy\u00e9b extra inform\u00e1ci\u00f3kat tartalmazza, amelyeket nem fejtett\u00fcnk ki a rel\u00e1ci\u00f3s modellben <product> <product_size> <unit> cm </unit> <width> 150 </width> <height> 50 </height> <depth> 150 </depth> </product_size> <package_parameters> <number_of_packages> 1 </number_of_packages> <package_size> <unit> cm </unit> <width> 150 </width> <height> 20 </height> <depth> 20 </depth> </package_size> </package_parameters> <description> Requires battery (not part of the package). </description> <recommended_age> 0-18 m </recommended_age> </product>","title":"Term\u00e9k le\u00edr\u00e1s"},{"location":"db/mongodb/","text":"MongoDB haszn\u00e1lata \u00b6 A MongoDB ingyenes, open-source adatb\u00e1zis kiszolg\u00e1l\u00f3. Mi az un. community v\u00e1ltozat\u00e1t haszn\u00e1ljuk, kliens szoftvernek pedig a Robo 3T alkalmaz\u00e1st. Let\u00f6lt\u00e9si linkek: https://www.mongodb.com/download-center/community https://robomongo.org/download Telep\u00edt\u00e9si \u00fatmutat\u00f3: https://docs.mongodb.com/manual/administration/install-community/ Eszk\u00f6z haszn\u00e1lata vide\u00f3 Az eszk\u00f6z haszn\u00e1lat\u00e1nak bemutat\u00e1sa: https://web.microsoftstream.com/video/d1d25850-30af-43c8-ad0a-7139facda7f9 MongoDB szerver elind\u00edt\u00e1sa \u00b6 A telep\u00edt\u00e9si modell f\u00fcggv\u00e9ny\u00e9ben lehet, hogy a MongoDB szerver automatikusan elindul. Ha nem k\u00e9rt\u00fck ezt a telep\u00edt\u00e9skor, akkor a telep\u00edt\u00e9si k\u00f6nyvt\u00e1rban az al\u00e1bbi paranccsal tudjuk elind\u00edtani a szervert. (\u00dcgyelj\u00fcnk r\u00e1, hogy a szerver a mongo\u200b d exe.) mongod.exe --dbpath = \"<munkak\u00f6nyvt\u00e1r>\" A munkak\u00f6nyvt\u00e1rban fog t\u00e1rol\u00f3dni az adatb\u00e1zis. Ha ilyen m\u00f3don, konzolb\u00f3l ind\u00edtottuk a szervert, akkor addig fut, am\u00edg a konzult be nem z\u00e1rjuk. Le\u00e1ll\u00edtani a Ctrl + C billenty\u0171kombin\u00e1ci\u00f3val kell. Mongo shell \u00b6 A Mongo shell egy egyszer\u0171 konzolos kliens alkalmaz\u00e1s. A hivatalos dokument\u00e1ci\u00f3ban szerepl\u0151 p\u00e9ld\u00e1k \u00e1ltal\u00e1ban ezt haszn\u00e1lj\u00e1k. Mi nem fogjuk ezt a programot haszn\u00e1lni. Robo 3T \u00b6 A Robo 3T egy egyszer\u0171 \u00e9s ingyenes kliensprogram MongoDB adatb\u00e1zis haszn\u00e1lat\u00e1hoz. L\u00e9tezik t\u00f6bb funkci\u00f3val rendelkez\u0151, fizet\u0151s kliensprogram is (Studio 3T), nek\u00fcnk azonban megfelel az egyszer\u0171bb is. A program indul\u00e1sakor kiv\u00e1laszthatjuk a m\u00e1r kor\u00e1bban l\u00e9trehozott kapcsolatunkat, vagy k\u00e9sz\u00edthet\u00fcnk egy \u00fajat. Alap\u00e9rtelmez\u00e9sk\u00e9nt a helyben fut\u00f3 szervert a localhost c\u00edmen \u00e9s a 27017 porton \u00e9rhetj\u00fck el. A sikeres kapcsol\u00f3d\u00e1s ut\u00e1n az alkalmaz\u00e1s bal oldal\u00e1n a faszerkezetben l\u00e1tjuk a kapcsol\u00f3dott kiszolg\u00e1l\u00f3t, az adatb\u00e1zisokat \u00e9s a gy\u0171jtem\u00e9nyeket. Kezdetben se adatb\u00e1zisunk, se gy\u0171jtem\u00e9nyeink nem lesznek. (Ezeket l\u00e9trehozhatjuk k\u00e9zzel is: jobb eg\u00e9rrel kattintva a szerver nev\u00e9n tal\u00e1ljuk p\u00e9ld\u00e1ul a Create Database parancsot. Mi azonban ezt nem haszn\u00e1ljuk.) A gy\u0171jtem\u00e9nyek tartalm\u00e1t dupla kattint\u00e1ssal tekinthetj\u00fck meg. Ez egy \u00faj tab f\u00fclet nyit, ahol is egy keres\u00e9st v\u00e9gzett a kliens nek\u00fcnk. Ezt a keres\u00e9si parancsot lecser\u00e9lhetj\u00fck, \u00e1t\u00edrhatjuk, ha sz\u00fcks\u00e9g\u00fcnk van r\u00e1. A gy\u0171jtem\u00e9ny tartalma a parancs alatt tal\u00e1lhat\u00f3. Egy-egy dokumentum egy-egy sor. A dokumentumot t\u00f6r\u00f6lni, szerkeszteni a rekordra val\u00f3 jobb eg\u00e9r kattint\u00e1ssal tudjuk. A szerkeszt\u00e9s sor\u00e1n a JSON dokumentumot szerkesztj\u00fck. \u00daj dokumentumot besz\u00farni szint\u00e9n jobb eg\u00e9rrel kattintva tudunk. Itt egy \u00fcres szerkeszt\u0151t kapunk. Ha \u00faj rekordot akarunk l\u00e9trehozni, c\u00e9lszer\u0171 egy meglev\u0151 dokumentum JSON-j\u00e9t lem\u00e1solni \u00e9s \u00fagy hozni l\u00e9tre az \u00fajat, hogy a kulcsok nevei biztosan j\u00f3k legyenek.","title":"MongoDB haszn\u00e1lata"},{"location":"db/mongodb/#mongodb-hasznalata","text":"A MongoDB ingyenes, open-source adatb\u00e1zis kiszolg\u00e1l\u00f3. Mi az un. community v\u00e1ltozat\u00e1t haszn\u00e1ljuk, kliens szoftvernek pedig a Robo 3T alkalmaz\u00e1st. Let\u00f6lt\u00e9si linkek: https://www.mongodb.com/download-center/community https://robomongo.org/download Telep\u00edt\u00e9si \u00fatmutat\u00f3: https://docs.mongodb.com/manual/administration/install-community/ Eszk\u00f6z haszn\u00e1lata vide\u00f3 Az eszk\u00f6z haszn\u00e1lat\u00e1nak bemutat\u00e1sa: https://web.microsoftstream.com/video/d1d25850-30af-43c8-ad0a-7139facda7f9","title":"MongoDB haszn\u00e1lata"},{"location":"db/mongodb/#mongodb-szerver-elinditasa","text":"A telep\u00edt\u00e9si modell f\u00fcggv\u00e9ny\u00e9ben lehet, hogy a MongoDB szerver automatikusan elindul. Ha nem k\u00e9rt\u00fck ezt a telep\u00edt\u00e9skor, akkor a telep\u00edt\u00e9si k\u00f6nyvt\u00e1rban az al\u00e1bbi paranccsal tudjuk elind\u00edtani a szervert. (\u00dcgyelj\u00fcnk r\u00e1, hogy a szerver a mongo\u200b d exe.) mongod.exe --dbpath = \"<munkak\u00f6nyvt\u00e1r>\" A munkak\u00f6nyvt\u00e1rban fog t\u00e1rol\u00f3dni az adatb\u00e1zis. Ha ilyen m\u00f3don, konzolb\u00f3l ind\u00edtottuk a szervert, akkor addig fut, am\u00edg a konzult be nem z\u00e1rjuk. Le\u00e1ll\u00edtani a Ctrl + C billenty\u0171kombin\u00e1ci\u00f3val kell.","title":"MongoDB szerver elind\u00edt\u00e1sa"},{"location":"db/mongodb/#mongo-shell","text":"A Mongo shell egy egyszer\u0171 konzolos kliens alkalmaz\u00e1s. A hivatalos dokument\u00e1ci\u00f3ban szerepl\u0151 p\u00e9ld\u00e1k \u00e1ltal\u00e1ban ezt haszn\u00e1lj\u00e1k. Mi nem fogjuk ezt a programot haszn\u00e1lni.","title":"Mongo shell"},{"location":"db/mongodb/#robo-3t","text":"A Robo 3T egy egyszer\u0171 \u00e9s ingyenes kliensprogram MongoDB adatb\u00e1zis haszn\u00e1lat\u00e1hoz. L\u00e9tezik t\u00f6bb funkci\u00f3val rendelkez\u0151, fizet\u0151s kliensprogram is (Studio 3T), nek\u00fcnk azonban megfelel az egyszer\u0171bb is. A program indul\u00e1sakor kiv\u00e1laszthatjuk a m\u00e1r kor\u00e1bban l\u00e9trehozott kapcsolatunkat, vagy k\u00e9sz\u00edthet\u00fcnk egy \u00fajat. Alap\u00e9rtelmez\u00e9sk\u00e9nt a helyben fut\u00f3 szervert a localhost c\u00edmen \u00e9s a 27017 porton \u00e9rhetj\u00fck el. A sikeres kapcsol\u00f3d\u00e1s ut\u00e1n az alkalmaz\u00e1s bal oldal\u00e1n a faszerkezetben l\u00e1tjuk a kapcsol\u00f3dott kiszolg\u00e1l\u00f3t, az adatb\u00e1zisokat \u00e9s a gy\u0171jtem\u00e9nyeket. Kezdetben se adatb\u00e1zisunk, se gy\u0171jtem\u00e9nyeink nem lesznek. (Ezeket l\u00e9trehozhatjuk k\u00e9zzel is: jobb eg\u00e9rrel kattintva a szerver nev\u00e9n tal\u00e1ljuk p\u00e9ld\u00e1ul a Create Database parancsot. Mi azonban ezt nem haszn\u00e1ljuk.) A gy\u0171jtem\u00e9nyek tartalm\u00e1t dupla kattint\u00e1ssal tekinthetj\u00fck meg. Ez egy \u00faj tab f\u00fclet nyit, ahol is egy keres\u00e9st v\u00e9gzett a kliens nek\u00fcnk. Ezt a keres\u00e9si parancsot lecser\u00e9lhetj\u00fck, \u00e1t\u00edrhatjuk, ha sz\u00fcks\u00e9g\u00fcnk van r\u00e1. A gy\u0171jtem\u00e9ny tartalma a parancs alatt tal\u00e1lhat\u00f3. Egy-egy dokumentum egy-egy sor. A dokumentumot t\u00f6r\u00f6lni, szerkeszteni a rekordra val\u00f3 jobb eg\u00e9r kattint\u00e1ssal tudjuk. A szerkeszt\u00e9s sor\u00e1n a JSON dokumentumot szerkesztj\u00fck. \u00daj dokumentumot besz\u00farni szint\u00e9n jobb eg\u00e9rrel kattintva tudunk. Itt egy \u00fcres szerkeszt\u0151t kapunk. Ha \u00faj rekordot akarunk l\u00e9trehozni, c\u00e9lszer\u0171 egy meglev\u0151 dokumentum JSON-j\u00e9t lem\u00e1solni \u00e9s \u00fagy hozni l\u00e9tre az \u00fajat, hogy a kulcsok nevei biztosan j\u00f3k legyenek.","title":"Robo 3T"},{"location":"db/mssql/","text":"Microsoft SQL Server haszn\u00e1lata \u00b6 A Microsoft SQL Server kiszolg\u00e1l\u00f3hoz az SQL Server Management Studio szoftverrel kapcsol\u00f3dunk. Fejleszt\u00e9s k\u00f6zben a kiszolg\u00e1l\u00f3 helyben fut, az un. LocalDB verzi\u00f3t haszn\u00e1ljuk, de otthoni haszn\u00e1latra megfelel az Express v\u00e1ltozat is (b\u00e1rmely verzi\u00f3). Let\u00f6lt\u00e9si linkek: A LocalDB Visual Studio-val telep\u00fcl https://www.microsoft.com/en-us/sql-server/sql-server-editions-express https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms Eszk\u00f6z haszn\u00e1lata vide\u00f3 Az eszk\u00f6z haszn\u00e1lat\u00e1nak bemutat\u00e1sa: https://web.microsoftstream.com/video/e3a83d16-b5c4-4fe9-b027-703347951621 SQL Server Management Studio haszn\u00e1lata \u00b6 A tansz\u00e9ki laborokban a programot a start men\u00fcb\u0151l ind\u00edthatjuk. A program indul\u00e1sa ut\u00e1n kapcsol\u00f3dhatunk az adatb\u00e1zishoz a felugr\u00f3 ablakban. LocalDB haszn\u00e1lata eset\u00e9n a Server name (localdb)\\mssqllocaldb , Express Edition haszn\u00e1lata eset\u00e9n .\\sqlexpress (alapbe\u00e1ll\u00edt\u00e1sokkal val\u00f3 telep\u00edt\u00e9s eset\u00e9n). Mindk\u00e9t esetben Windows Authentication -t haszn\u00e1lunk. A sikeres kapcsol\u00f3d\u00e1st k\u00f6vet\u0151en a f\u0151ablak bal oldal\u00e1n az Object Explorer -ben kibonthat\u00f3 a Databases elem, \u00e9s ha m\u00e1r l\u00e9trehoztunk adatb\u00e1zist, azt is kibontva l\u00e1that\u00f3ak a t\u00e1bl\u00e1ink \u00e9s egy\u00e9b s\u00e9ma elemek. SQL k\u00f3d futtat\u00e1s\u00e1hoz egy \u00faj Query ablakra van sz\u00fcks\u00e9g\u00fcnk, amelyet az eszk\u00f6zt\u00e1ron tal\u00e1lhat\u00f3 ikonnal nyithatunk. A Query ablak parancsai az aktu\u00e1lisan kiv\u00e1lasztott adatb\u00e1zison fognak lefutni, ezt az adatb\u00e1zist az eszk\u00f6zt\u00e1ron a leg\u00f6rd\u00fcl\u0151 men\u00fcben tudjuk megv\u00e1ltoztatni (l\u00e1sd az al\u00e1bbi k\u00e9pen s\u00e1rg\u00e1val). T\u00f6bb Query ablak is lehet nyitva egyszerre. Az SQL utas\u00edt\u00e1sokat lefuttatni a gombbal tudjuk. Ha van kijel\u00f6lt utas\u00edt\u00e1s, csak azt futtatja, ellenkez\u0151 esetben az ablak teljes tartalm\u00e1t v\u00e9grehajtja. Az eredm\u00e9ny, vagy a hiba\u00fczenet a script alatt l\u00e1that\u00f3. \u00daj adatb\u00e1zis l\u00e9trehoz\u00e1sa \u00b6 Ha m\u00e9g nincs adatb\u00e1zisunk, el\u0151sz\u00f6r l\u00e9tre kell hozni egyet. Ezt az Object Explorer -ben a Databases -en jobb kattint\u00e1ssal tehetj\u00fck meg. Az adatb\u00e1zisnak csak nevet kell adni, m\u00e1s be\u00e1ll\u00edt\u00e1sra nincs sz\u00fcks\u00e9g. Az adatb\u00e1zis l\u00e9trehoz\u00e1sa ut\u00e1n a Query ablakban ne felejts\u00fck \u00e1t\u00e1ll\u00edtani az aktu\u00e1lis adatb\u00e1zist! P\u00e1rhuzamos tranzakci\u00f3k \u00b6 P\u00e1rhuzamos tranzakci\u00f3k szimul\u00e1l\u00e1s\u00e1hoz k\u00e9t Query ablakra van sz\u00fcks\u00e9g a New Query gomb k\u00e9tszeri megnyom\u00e1s\u00e1val. \u00c9rdemes az ablakokat egym\u00e1s mell\u00e9 tenni: a Query f\u00fcl fejl\u00e9c\u00e9re jobb eg\u00e9rrel kattintva v\u00e1lasszuk a New Vertical Tab Group opci\u00f3t. T\u00e1bl\u00e1k tartalm\u00e1nak list\u00e1z\u00e1sa, egyszer\u0171s\u00edtett m\u00f3dos\u00edt\u00e1s \u00b6 A t\u00e1bl\u00e1k tartalm\u00e1nak list\u00e1z\u00e1s\u00e1hoz az Object Explorer -ben bontsuk ki az adatb\u00e1zisunk alatt a Tables mapp\u00e1t. B\u00e1rmely t\u00e1bl\u00e1ra jobb eg\u00e9rrel kattintva haszn\u00e1ljuk a Select Top 1000 Rows elemet. Hasonl\u00f3 m\u00f3don lehet\u0151s\u00e9g van a t\u00e1bla tartalm\u00e1nak szerkeszt\u00e9s\u00e9re is (az els\u0151 200 sorra, amely a minta adatb\u00e1zisban pont elegend\u0151) az Edit Top 200 Rows men\u00fcelemmel. Intellisense \u00fajrat\u00f6lt\u00e9se \u00b6 Az SQL Management Studio query ablakban az intellisense els\u0151 k\u00f6rben sosem m\u0171k\u00f6dik mag\u00e1t\u00f3l, haszn\u00e1lni kell a Control+Shift+R-t az intellisense cache friss\u00edt\u00e9s\u00e9re. Akkor is, ha \u00faj objektumot (pl. t\u00e1rolt elj\u00e1r\u00e1st) hozunk l\u00e9tre. T\u00e1rolt elj\u00e1r\u00e1sok \u00e9s triggerek k\u00e9sz\u00edt\u00e9se \u00b6 T\u00e1rolt elj\u00e1r\u00e1s \u00e9s trigger l\u00e9trehoz\u00e1s\u00e1ra a Query ablak haszn\u00e1lhat\u00f3, amelyben a megfelel\u0151 l\u00e9trehoz\u00f3-m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st futtatjuk. \u00dcgyelj\u00fcnk r\u00e1, hogy ha m\u00e1r l\u00e9trej\u00f6tt egyszer a trigger vagy t\u00e1rolt elj\u00e1r\u00e1s, ut\u00e1na m\u00e1r csak m\u00f3dos\u00edtani tudjuk. A m\u00e1r l\u00e9tez\u0151 t\u00e1rolt elj\u00e1r\u00e1sok az Object Explorer -ben az adatb\u00e1zisunk alatti a Programability/Stored Procedures mapp\u00e1ban l\u00e1that\u00f3ak. (Az \u00fajonnan l\u00e9trehozott elemek nem jelennek meg automatikusan a m\u00e1r kibontott mapp\u00e1ban. A friss\u00edt\u00e9shez a Stored Procedures mapp\u00e1n jobb eg\u00e9rrel kattintva v\u00e1lasszuk a Refresh -t.) A triggerek az Object Explorer -ben megkereshet\u0151ek, a t\u00e1bl\u00e1ra defini\u00e1lt triggerek a t\u00e1bla kibont\u00e1s\u00e1val a Triggers mapp\u00e1ban l\u00e1that\u00f3ak (a rendszer szint\u0171 triggerek pedig az adatb\u00e1zis alatti Programability mapp\u00e1ban). A t\u00e1rolj elj\u00e1r\u00e1saink \u00e9s triggereink k\u00f3dj\u00e1t megtekinthetj\u00fck, ha a fentebb ismertetett m\u00f3don megkeress\u00fck \u0151ket, \u00e9s jobb eg\u00e9rrel kattintva a Modify men\u00fct v\u00e1lasztjuk. Ez a m\u0171velet egy \u00faj Query ablakot nyit, amelybe gener\u00e1l egy alter utas\u00edt\u00e1st az aktu\u00e1lis programk\u00f3ddal.","title":"Microsoft SQL Server haszn\u00e1lata"},{"location":"db/mssql/#microsoft-sql-server-hasznalata","text":"A Microsoft SQL Server kiszolg\u00e1l\u00f3hoz az SQL Server Management Studio szoftverrel kapcsol\u00f3dunk. Fejleszt\u00e9s k\u00f6zben a kiszolg\u00e1l\u00f3 helyben fut, az un. LocalDB verzi\u00f3t haszn\u00e1ljuk, de otthoni haszn\u00e1latra megfelel az Express v\u00e1ltozat is (b\u00e1rmely verzi\u00f3). Let\u00f6lt\u00e9si linkek: A LocalDB Visual Studio-val telep\u00fcl https://www.microsoft.com/en-us/sql-server/sql-server-editions-express https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms Eszk\u00f6z haszn\u00e1lata vide\u00f3 Az eszk\u00f6z haszn\u00e1lat\u00e1nak bemutat\u00e1sa: https://web.microsoftstream.com/video/e3a83d16-b5c4-4fe9-b027-703347951621","title":"Microsoft SQL Server haszn\u00e1lata"},{"location":"db/mssql/#sql-server-management-studio-hasznalata","text":"A tansz\u00e9ki laborokban a programot a start men\u00fcb\u0151l ind\u00edthatjuk. A program indul\u00e1sa ut\u00e1n kapcsol\u00f3dhatunk az adatb\u00e1zishoz a felugr\u00f3 ablakban. LocalDB haszn\u00e1lata eset\u00e9n a Server name (localdb)\\mssqllocaldb , Express Edition haszn\u00e1lata eset\u00e9n .\\sqlexpress (alapbe\u00e1ll\u00edt\u00e1sokkal val\u00f3 telep\u00edt\u00e9s eset\u00e9n). Mindk\u00e9t esetben Windows Authentication -t haszn\u00e1lunk. A sikeres kapcsol\u00f3d\u00e1st k\u00f6vet\u0151en a f\u0151ablak bal oldal\u00e1n az Object Explorer -ben kibonthat\u00f3 a Databases elem, \u00e9s ha m\u00e1r l\u00e9trehoztunk adatb\u00e1zist, azt is kibontva l\u00e1that\u00f3ak a t\u00e1bl\u00e1ink \u00e9s egy\u00e9b s\u00e9ma elemek. SQL k\u00f3d futtat\u00e1s\u00e1hoz egy \u00faj Query ablakra van sz\u00fcks\u00e9g\u00fcnk, amelyet az eszk\u00f6zt\u00e1ron tal\u00e1lhat\u00f3 ikonnal nyithatunk. A Query ablak parancsai az aktu\u00e1lisan kiv\u00e1lasztott adatb\u00e1zison fognak lefutni, ezt az adatb\u00e1zist az eszk\u00f6zt\u00e1ron a leg\u00f6rd\u00fcl\u0151 men\u00fcben tudjuk megv\u00e1ltoztatni (l\u00e1sd az al\u00e1bbi k\u00e9pen s\u00e1rg\u00e1val). T\u00f6bb Query ablak is lehet nyitva egyszerre. Az SQL utas\u00edt\u00e1sokat lefuttatni a gombbal tudjuk. Ha van kijel\u00f6lt utas\u00edt\u00e1s, csak azt futtatja, ellenkez\u0151 esetben az ablak teljes tartalm\u00e1t v\u00e9grehajtja. Az eredm\u00e9ny, vagy a hiba\u00fczenet a script alatt l\u00e1that\u00f3.","title":"SQL Server Management Studio haszn\u00e1lata"},{"location":"db/mssql/#uj-adatbazis-letrehozasa","text":"Ha m\u00e9g nincs adatb\u00e1zisunk, el\u0151sz\u00f6r l\u00e9tre kell hozni egyet. Ezt az Object Explorer -ben a Databases -en jobb kattint\u00e1ssal tehetj\u00fck meg. Az adatb\u00e1zisnak csak nevet kell adni, m\u00e1s be\u00e1ll\u00edt\u00e1sra nincs sz\u00fcks\u00e9g. Az adatb\u00e1zis l\u00e9trehoz\u00e1sa ut\u00e1n a Query ablakban ne felejts\u00fck \u00e1t\u00e1ll\u00edtani az aktu\u00e1lis adatb\u00e1zist!","title":"\u00daj adatb\u00e1zis l\u00e9trehoz\u00e1sa"},{"location":"db/mssql/#parhuzamos-tranzakciok","text":"P\u00e1rhuzamos tranzakci\u00f3k szimul\u00e1l\u00e1s\u00e1hoz k\u00e9t Query ablakra van sz\u00fcks\u00e9g a New Query gomb k\u00e9tszeri megnyom\u00e1s\u00e1val. \u00c9rdemes az ablakokat egym\u00e1s mell\u00e9 tenni: a Query f\u00fcl fejl\u00e9c\u00e9re jobb eg\u00e9rrel kattintva v\u00e1lasszuk a New Vertical Tab Group opci\u00f3t.","title":"P\u00e1rhuzamos tranzakci\u00f3k"},{"location":"db/mssql/#tablak-tartalmanak-listazasa-egyszerusitett-modositas","text":"A t\u00e1bl\u00e1k tartalm\u00e1nak list\u00e1z\u00e1s\u00e1hoz az Object Explorer -ben bontsuk ki az adatb\u00e1zisunk alatt a Tables mapp\u00e1t. B\u00e1rmely t\u00e1bl\u00e1ra jobb eg\u00e9rrel kattintva haszn\u00e1ljuk a Select Top 1000 Rows elemet. Hasonl\u00f3 m\u00f3don lehet\u0151s\u00e9g van a t\u00e1bla tartalm\u00e1nak szerkeszt\u00e9s\u00e9re is (az els\u0151 200 sorra, amely a minta adatb\u00e1zisban pont elegend\u0151) az Edit Top 200 Rows men\u00fcelemmel.","title":"T\u00e1bl\u00e1k tartalm\u00e1nak list\u00e1z\u00e1sa, egyszer\u0171s\u00edtett m\u00f3dos\u00edt\u00e1s"},{"location":"db/mssql/#intellisense-ujratoltese","text":"Az SQL Management Studio query ablakban az intellisense els\u0151 k\u00f6rben sosem m\u0171k\u00f6dik mag\u00e1t\u00f3l, haszn\u00e1lni kell a Control+Shift+R-t az intellisense cache friss\u00edt\u00e9s\u00e9re. Akkor is, ha \u00faj objektumot (pl. t\u00e1rolt elj\u00e1r\u00e1st) hozunk l\u00e9tre.","title":"Intellisense \u00fajrat\u00f6lt\u00e9se"},{"location":"db/mssql/#tarolt-eljarasok-es-triggerek-keszitese","text":"T\u00e1rolt elj\u00e1r\u00e1s \u00e9s trigger l\u00e9trehoz\u00e1s\u00e1ra a Query ablak haszn\u00e1lhat\u00f3, amelyben a megfelel\u0151 l\u00e9trehoz\u00f3-m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st futtatjuk. \u00dcgyelj\u00fcnk r\u00e1, hogy ha m\u00e1r l\u00e9trej\u00f6tt egyszer a trigger vagy t\u00e1rolt elj\u00e1r\u00e1s, ut\u00e1na m\u00e1r csak m\u00f3dos\u00edtani tudjuk. A m\u00e1r l\u00e9tez\u0151 t\u00e1rolt elj\u00e1r\u00e1sok az Object Explorer -ben az adatb\u00e1zisunk alatti a Programability/Stored Procedures mapp\u00e1ban l\u00e1that\u00f3ak. (Az \u00fajonnan l\u00e9trehozott elemek nem jelennek meg automatikusan a m\u00e1r kibontott mapp\u00e1ban. A friss\u00edt\u00e9shez a Stored Procedures mapp\u00e1n jobb eg\u00e9rrel kattintva v\u00e1lasszuk a Refresh -t.) A triggerek az Object Explorer -ben megkereshet\u0151ek, a t\u00e1bl\u00e1ra defini\u00e1lt triggerek a t\u00e1bla kibont\u00e1s\u00e1val a Triggers mapp\u00e1ban l\u00e1that\u00f3ak (a rendszer szint\u0171 triggerek pedig az adatb\u00e1zis alatti Programability mapp\u00e1ban). A t\u00e1rolj elj\u00e1r\u00e1saink \u00e9s triggereink k\u00f3dj\u00e1t megtekinthetj\u00fck, ha a fentebb ismertetett m\u00f3don megkeress\u00fck \u0151ket, \u00e9s jobb eg\u00e9rrel kattintva a Modify men\u00fct v\u00e1lasztjuk. Ez a m\u0171velet egy \u00faj Query ablakot nyit, amelybe gener\u00e1l egy alter utas\u00edt\u00e1st az aktu\u00e1lis programk\u00f3ddal.","title":"T\u00e1rolt elj\u00e1r\u00e1sok \u00e9s triggerek k\u00e9sz\u00edt\u00e9se"},{"location":"gyakorlat/ef/","text":"Entity Framework \u00b6 A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a Linq lek\u00e9rdez\u00e9sek haszn\u00e1lat\u00e1t, valamint az Entity Framework m\u0171k\u00f6d\u00e9s\u00e9t. Entity Framework Core A gyakorlat sor\u00e1n a .NET Framework-ben haszn\u00e1lt Entity Framework-\u00f6t haszn\u00e1ljuk, nem a platformf\u00fcggetlen Core v\u00e1ltozatot. A Linq lek\u00e9rdez\u00e9sek tekintet\u00e9ben a k\u00e9t technol\u00f3gia k\u00f6zel azonos \u00e9lm\u00e9nyt ny\u00fajt, de az al\u00e1bb haszn\u00e1lt vizu\u00e1lis k\u00f3d gener\u00e1l\u00e1s \u00e9s szerkeszt\u0151 csak .NET Framework \u00e9s Entity Framework eset\u00e9n \u00e9rhet\u0151 el. El\u0151felt\u00e9telek \u00b6 A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft Visual Studio 2015/2017/2019 ( nem VS Code) Microsoft SQL Server (LocalDB vagy Express edition) SQL Server Management Studio Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Amit \u00e9rdemes \u00e1tn\u00e9zned: C# nyelv Entity Framework \u00e9s Linq Gyakorlat menete \u00b6 A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot! Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se \u00b6 Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban .) Feladat 1: Projekt l\u00e9trehoz\u00e1sa, adatb\u00e1zis lek\u00e9pz\u00e9se \u00b6 Hozz l\u00e9tre Visual Studio seg\u00edts\u00e9g\u00e9vel egy C# konzolalkalmaz\u00e1st. VS 2019 eset\u00e9n keress\u00fcnk r\u00e1 a \"console framework\" szavakra, \u00edgy a legegyszer\u0171bb megtal\u00e1lni a projekt t\u00edpust. Ne .NET Core alkalmaz\u00e1st hozzunk l\u00e9tre, mert abban nincs vizu\u00e1lis Database First lek\u00e9pz\u00e9s, amit haszn\u00e1lni fogunk. \u00dcgyelj\u00fcnk a projekt nyelv\u00e9re is, C# nyelv\u0171 projekt legyen. Hozd l\u00e9tre a projektet. A c:\\work mapp\u00e1ba dolgozz. Adj a projekthez egy ADO.NET Entity Data Model -t. Solution Explorer-ben a projektre jobb eg\u00e9r / Add / New Item / Data / ADO.NET Entity Data Model . Az ablak alj\u00e1n a Name mez\u0151ben AdatvezEntities -t adj meg. A modellt megl\u00e9v\u0151 adatb\u00e1zis alapj\u00e1n \u00e9p\u00edtsd fel (a var\u00e1zsl\u00f3ban \"EF designer from database\"). A kapcsolatok megad\u00e1s\u00e1n\u00e1l a saj\u00e1t adatb\u00e1zishoz kapcsol\u00f3dj. Hozz l\u00e9tre egy \u00faj kapcsolatot a var\u00e1zsl\u00f3 seg\u00edts\u00e9g\u00e9vel, \u00e9s mentsd el a kapcsol\u00f3d\u00e1si adatokat a config f\u00e1jlba. Data source : Microsoft SQL Server Server name : (localdb)\\mssqllocaldb Select or enter database name : adjuk meg az adatb\u00e1zis nev\u00e9t Save connection settings in App.Config : igen (pipa) alatta a szerkeszt\u0151mez\u0151ben az AdatvezEntities -t add meg (ilyen n\u00e9ven fog a DbContext oszt\u00e1ly legener\u00e1l\u00f3dni) Entity Framework 6.0-as lek\u00e9pz\u00e9st haszn\u00e1lj. Az \u00f6sszes t\u00e1bl\u00e1t k\u00e9pezz\u00fck le (ki kell pip\u00e1lni a Tables -t). Model namespace : pl. AdatvezEntitiesModel V\u00e1rjuk meg, am\u00edg elk\u00e9sz\u00fcl a modell. Ha k\u00f6zben a VS k\u00e9rdezne \"template\" futtat\u00e1s\u00e1r\u00f3l, enged\u00e9lyezz\u00fck. Keress\u00fck meg a connection stringet az app.config f\u00e1jlban. N\u00e9zz\u00fck meg a tartalm\u00e1t. app.config Az\u00e9rt j\u00f3, ha ide ker\u00fcl a connection string , mert az alkalmaz\u00e1shoz tartoz\u00f3 adatb\u00e1zis helye telep\u00edt\u00e9senk\u00e9nt v\u00e1ltozhat. Ha a forr\u00e1sk\u00f3dban van a szerver el\u00e9rhet\u0151s\u00e9ge, akkor \u00fajra kell ford\u00edtani az alkalmaz\u00e1st minden telep\u00edt\u00e9shez. Az app.config f\u00e1jl viszont az exe mellett r\u00e9sze az alkalmaz\u00e1snak, \u00e9s szerkeszthet\u0151. Ha sz\u00fcks\u00e9ges, kiemelhet\u0151 a f\u00e1jl m\u00e1s konfigur\u00e1ci\u00f3s \u00e1llom\u00e1nyba is. Nyissuk meg az EF adatmodellt (dupla kattint\u00e1s a Solution Explorer-ben). Vizsg\u00e1ljuk meg: n\u00e9zz\u00fck meg az entit\u00e1sokat \u00e9s kapcsolatokat. Ha szerkeszteni akarjuk a modellt, az Entity Data Model Browser \u00e9s Entity Data Model Mapping Details ablakokon kereszt\u00fcl lehet szerkeszteni (ezek a View men\u00fc, Other windows men\u00fcponton kereszt\u00fcl \u00e9rhet\u0151k el). Jav\u00edtsuk ki az al\u00e1bbi entit\u00e1s tulajdons\u00e1g neveket, hogy jobban illeszkedjenek a val\u00f3s\u00e1ghoz: Customer.CustomerSite1 -> .Sites CustomerSite.Customer1 -> .MainCustomer Order.OrderItem -> .OrderItem\u200b s Product.OrderItem -> .OrderItem\u200b s VAT.Product -> .Product\u200b s Category.Product -> .Product\u200b s Ments\u00fck a v\u00e1ltoztat\u00e1sok ut\u00e1n a modellt. N\u00e9zz\u00fck meg a DbContext \u00e9s egy v\u00e1lasztott entit\u00e1s oszt\u00e1ly C# k\u00f3dj\u00e1t. Bontsd ki a Solution Explorer -ben az EDM modell f\u00e1jlj\u00e1t, \u00e9s alatta ott tal\u00e1lhat\u00f3ak a C# f\u00e1jlok. Ezen f\u00e1jlokba nem szerkeszt\u00fcnk bele, mert minden EDM m\u00f3dos\u00edt\u00e1s ut\u00e1n \u00fajragener\u00e1l\u00f3dnak. Viszont figyelj\u00fck meg, hogy minden oszt\u00e1ly partial -k\u00e9nt van defini\u00e1lva, \u00edgy ha sz\u00fcks\u00e9ges, tudunk a meglev\u0151 k\u00f3d \"mell\u00e9\" \u00faj forr\u00e1sf\u00e1jlokba saj\u00e1tot is \u00edrni. Feladat 2: Lek\u00e9rdez\u00e9sek \u00b6 A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket Linq haszn\u00e1lat\u00e1val. \u00cdrd ki konzolra az eredm\u00e9nyeket. Debugger seg\u00edts\u00e9g\u00e9vel n\u00e9zd meg, hogy milyen SQL utas\u00edt\u00e1s gener\u00e1l\u00f3dik: az IQueryable t\u00edpus\u00fa v\u00e1ltoz\u00f3ra h\u00fazva az egeret l\u00e1that\u00f3 a gener\u00e1lt SQL, amint az eredm\u00e9nyhalmaz iter\u00e1l\u00e1sa elkezd\u0151dik. List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron! \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek! K\u00e9sz\u00edts olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azokat a megrendel\u00e9seket, melyek \u00f6ssz\u00e9rt\u00e9ke t\u00f6bb mint 30.000 Ft! Az eredm\u00e9nyhalmaz ki\u00edr\u00e1sakor a vev\u0151 nevet k\u00f6vet\u0151en soronk\u00e9nt szerepeljenek az egyes t\u00e9telek (Term\u00e9k n\u00e9v, mennyis\u00e9g, nett\u00f3 \u00e1r). List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait! List\u00e1zd ki azokat a vev\u0151 p\u00e1rokat, akiknek ugyanabban a v\u00e1rosban van telephely\u00fck. Egy p\u00e1r, csak egyszer szerepeljen a list\u00e1ban. Megold\u00e1s Console . WriteLine ( \"***** M\u00e1sodik feladat *****\" ); using ( var db = new AdatvezEntities ()) { // 2.1 Console . WriteLine ( \"\\t2.1:\" ); var qProductStock = from p in db . Product where p . Stock > 30 select p ; foreach ( var p in qProductStock ) Console . WriteLine ( \"\\t\\tName={0}\\tStock={1}\" , p . Name , p . Stock ); // 2.2 Console . WriteLine ( \"\\t2.2:\" ); var qProductOrder = from p in db . Product where p . OrderItems . Count >= 2 select p ; foreach ( var p in qProductOrder ) Console . WriteLine ( \"\\t\\tName={0}\" , p . Name ); // 2.3 Console . WriteLine ( \"\\t2.3:\" ); var qOrderTotal = from o in db . Order where o . OrderItems . Sum ( oi => oi . Amount * oi . Price ) > 30000 select o ; foreach ( var o in qOrderTotal ) { Console . WriteLine ( \"\\t\\tName={0}\" , o . CustomerSite . MainCustomer . Name ); foreach ( var oi in o . OrderItems ) Console . WriteLine ( \"\\t\\t\\tProduct={0}\\tPrice={1}\\tAmount={2}\" , oi . Product . Name , oi . Price , oi . Amount ); } // 2.3 m\u00e1sodik megold\u00e1s // Ehhez sz\u00fcks\u00e9g van a k\u00f6vetkez\u0151 n\u00e9vt\u00e9r import\u00e1l\u00e1s\u00e1ra: innen vegy\u00fck ki \u00e9s tegy\u00fck be // a f\u00e1jl elej\u00e9re !!! // using System.Data.Entity; // Csak egy lek\u00e9rdez\u00e9st fog gener\u00e1lni, a Navigation Propertyket is felt\u00f6lti r\u00f6gt\u00f6n Console . WriteLine ( \"\\tc 2.3 alternat\u00edv megold\u00e1s:\" ); var qOrderTotal2 = from o in db . Order . Include ( o => o . OrderItems ) // vagy .Include(\"OrderItem\") . Include ( o => o . OrderItems . Select ( oi => oi . Product )) // vagy .Include(\"OrderItem.Product\") . Include ( o => o . CustomerSite ) // vagy .Include(\"CustomerSite\") . Include ( o => o . CustomerSite . MainCustomer ) // vagy .Include(\"CustomerSite.Customer\") where o . OrderItems . Sum ( oi => oi . Amount * oi . Price ) > 30000 select o ; foreach ( var o in qOrderTotal2 ) { Console . WriteLine ( \"\\t\\tName={0}\" , o . CustomerSite . MainCustomer . Name ); foreach ( var oi in o . OrderItems ) Console . WriteLine ( \"\\t\\t\\tProduct={0}\\tPrice={1}\\tAmount={2}\" , oi . Product . Name , oi . Price , oi . Amount ); } // 2.4 Console . WriteLine ( \"\\t2.4:\" ); var qPriceMax = from p in db . Product where p . Price == db . Product . Max ( a => a . Price ) select p ; foreach ( var t in qPriceMax ) Console . WriteLine ( \"\\t\\tName={0}\\tPrice={1}\" , t . Name , t . Price ); // 2.5 Console . WriteLine ( \"\\t2.5:\" ); var qJoin = from s1 in db . CustomerSite join s2 in db . CustomerSite on s1 . City equals s2 . City where s1 . CustomerID > s2 . CustomerID select new { c1 = s1 . MainCustomer , c2 = s2 . MainCustomer }; foreach ( var v in qJoin ) Console . WriteLine ( \"\\t\\tCustomer 1={0}\\tCustomer 2={1}\" , v . c1 . Name , v . c2 . Name ); } Feladat 3: Adatm\u00f3dos\u00edt\u00e1sok \u00b6 A DbContext nem csak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl m\u00f3dos\u00edt\u00e1sok is v\u00e9grehajthat\u00f3ak. \u00cdrj olyan Linq-ra \u00e9p\u00fcl\u0151 C# k\u00f3dot, mely az \"LEGO\" kateg\u00f3ri\u00e1s term\u00e9kek \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal! Hozz l\u00e9tre egy \u00faj kateg\u00f3ri\u00e1t Expensive toys n\u00e9ven, \u00e9s sorod \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft! Megold\u00e1s Console . WriteLine ( \"***** Harmadik feladat *****\" ); using ( var db = new AdatvezEntities ()) { // 3.1 Console . WriteLine ( \"\\t3.1:\" ); var qProductsLego = from p in db . Product where p . Category . Name == \"LEGO\" select p ; Console . WriteLine ( \"\\tM\u00f3dos\u00edt\u00e1s el\u0151tt:\" ); foreach ( var p in qProductsLego ) { Console . WriteLine ( \"\\t\\t\\tName={0}\\tStock={1}\\tPrice={2}\" , p . Name , p . Stock , p . Price ); p . Price = 1.1 * p . Price ; } db . SaveChanges (); qProductsLego = from p in db . Product where p . Category . Name == \"LEGO\" select p ; Console . WriteLine ( \"\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n:\" ); foreach ( var p in qProductsLego ) Console . WriteLine ( \"\\t\\t\\tName={0}\\tStock={1}\\tPrice={2}\" , p . Name , p . Stock , p . Price ); // 3.2 Console . WriteLine ( \"\\t3.2:\" ); Category categoryExpensiveToys = ( from c in db . Category where c . Name == \"Expensive toys\" select c ). SingleOrDefault (); if ( categoryExpensiveToys == null ) { categoryExpensiveToys = new Category { Name = \"Expensive toys\" }; // Erre nem feltetlenul van szukseg: ha van atrendelt termek, ahhoz hozzakotjuk a kategoria entitast // es bekerul automatikusan a kategoria tablaba is. Igy viszont, hogy explicit felvesszuk, (1) jobban // kifejezi a szandekunkat; es (2) akkor is felvesszuk a kategoriat, ha vegul nincs atrendelt termek. db . Category . Add ( categoryExpensiveToys ); } var qProductExpensive = from p in db . Product where p . Price > 8000 select p ; foreach ( var p in qProductExpensive ) p . Category = categoryExpensiveToys ; db . SaveChanges (); qProductExpensive = from p in db . Product where p . Category . Name == \"Expensive toys\" select p ; foreach ( var t in qProductExpensive ) Console . WriteLine ( \"\\t\\tName={0}\\tPrice={1}\" , t . Name , t . Price ); } Feladat 4: T\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata \u00b6 T\u00e1rolt elj\u00e1r\u00e1sok is felvehet\u0151k az EDM modellbe modellfriss\u00edt\u00e9s sor\u00e1n. A t\u00e1rolj elj\u00e1r\u00e1s vagy a DbContext f\u00fcggv\u00e9nyek\u00e9nt, vagy entit\u00e1s m\u00f3dos\u00edt\u00f3 m\u0171velet\u00e9re k\u00f6thet\u0151 be. T\u00e1rolt elj\u00e1r\u00e1s az EDM-ben A t\u00e1rolt elj\u00e1r\u00e1s lek\u00e9pz\u00e9s\u00e9nek be\u00e1ll\u00edt\u00e1sait (pl. a t\u00e1rolt elj\u00e1r\u00e1s visszat\u00e9r\u00e9si t\u00edpus\u00e1t) az Entity Data Model Browser -ben, az adott f\u00fcggv\u00e9ny Function Import -j\u00e1hoz tartoz\u00f3 tulajdons\u00e1gain\u00e1l szerkeszten\u00fcnk. K\u00e9sz\u00edts egy t\u00e1rolt elj\u00e1r\u00e1st, mely \u00faj fizet\u00e9si m\u00f3d r\u00f6gz\u00edt\u00e9s\u00e9re szolg\u00e1l, \u00e9s visszaadja az \u00faj rekord azonos\u00edt\u00f3j\u00e1t! Haszn\u00e1ld ezt a t\u00e1rolt elj\u00e1r\u00e1st \u00faj entit\u00e1s felv\u00e9tel\u00e9hez! Hozd l\u00e9tre a t\u00e1rolt elj\u00e1r\u00e1st SQL Management Studio seg\u00edts\u00e9g\u00e9vel. CREATE PROCEDURE CreateNewPaymentMethod ( @ Method nvarchar ( 20 ), @ Deadline int ) AS insert into PaymentMethod values ( @ Method , @ Deadline ) select scope_identity () as NewId A t\u00e1rolt elj\u00e1r\u00e1st \u00e1ll\u00edtsd be a PaymentMethod entit\u00e1s insert met\u00f3dus\u00e1nak. Add hozz\u00e1 a t\u00e1rolt elj\u00e1r\u00e1st az EDM-hez. Az EDM Browser-ben jobb kantit\u00e1ssal hozd el\u0151 a kontextus men\u00fct, haszn\u00e1ld az \"Update model from database\"-t, \u00e9s import\u00e1ld ( Add ) az \u00faj t\u00e1rolt elj\u00e1r\u00e1st. Mentsd el a modell v\u00e1ltoz\u00e1sait. Ekkor gener\u00e1l\u00f3dik a h\u00e1tt\u00e9rben a C# k\u00f3d. \u00c1ll\u00edtsd be ezt a met\u00f3dust a PaymentMethod entit\u00e1s insert met\u00f3dusak\u00e9nt: kiv\u00e1lasztva az EDM-ben a PaymentMethod elemet a Mapping Details ablakban v\u00e1lts \u00e1t a Map Entity to Functions n\u00e9zetre, \u00e9s \u00e1ll\u00edtsd be Insert met\u00f3dusnak. A visszat\u00e9r\u00e9si \u00e9rt\u00e9ket feleltesd meg az ID tulajdons\u00e1gnak. Mentsd el a modell v\u00e1ltoz\u00e1sait. Pr\u00f3b\u00e1ld ki a m\u0171k\u00f6d\u00e9st: C# k\u00f3db\u00f3l adj hozz\u00e1 egy \u00faj fizet\u00e9si m\u00f3dot a DbContext PaymentMethod gy\u0171jtem\u00e9ny\u00e9hez az Add met\u00f3dussal. Ellen\u0151rizd az adatb\u00e1zisban a rekord l\u00e9trej\u00f6tt\u00e9t. K\u00e9sz\u00edts egy t\u00e1rolt elj\u00e1r\u00e1st, mely kilist\u00e1zza azon term\u00e9keket melyb\u0151l legal\u00e1bb egy megadott darabsz\u00e1m felett adtak el. H\u00edvd meg a t\u00e1rolj elj\u00e1r\u00e1st C# k\u00f3db\u00f3l! Hozd l\u00e9tre a t\u00e1rolt elj\u00e1r\u00e1st az al\u00e1bbi k\u00f3ddal. CREATE PROCEDURE dbo . PopularProducts ( @ MinAmount int = 10 ) AS SELECT Product . * FROM Product INNER JOIN ( SELECT OrderItem . ProductID FROM OrderItem GROUP BY OrderItem . ProductID HAVING SUM ( OrderItem . Amount ) > @ MinAmount ) a ON Product . ID = a . ProductID Import\u00e1ld az EDM-be a t\u00e1rolt elj\u00e1r\u00e1st. Az elj\u00e1r\u00e1s be\u00e1ll\u00edt\u00e1sain\u00e1l ( EDM Model Browser -ben a function -re dupla kattint\u00e1ssal ny\u00edlik) \u00e1ll\u00edtsd be a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket Product t\u00edpus\u00fara. Mentsd el a modell v\u00e1ltoz\u00e1sait. Haszn\u00e1ld a DbContext-en gener\u00e1lt \u00faj f\u00fcggv\u00e9nyt a t\u00e1rolt elj\u00e1r\u00e1s megh\u00edv\u00e1s\u00e1hoz, \u00e9s \u00edrasd ki a term\u00e9kek nev\u00e9t! Megold\u00e1s Console . WriteLine ( \"***** Negyedik feladat *****\" ); using ( var db = new AdatvezEntities ()) { // 4.3 Console . WriteLine ( \"\\t4.3:\" ); var pm = new PaymentMethod { Method = \"Apple pay\" , Deadline = 99999 }; db . PaymentMethod . Add ( pm ); db . SaveChanges (); // 4.6 Console . WriteLine ( \"\\t4.6:\" ); var qPopularProducts = db . PopularProducts ( 5 ); foreach ( var p in qPopularProducts ) Console . WriteLine ( \"\\t\\tName={0}\\tStock={1}\\tPrice={2}\" , p . Name , p . Stock , p . Price ); }","title":"Entity Framework"},{"location":"gyakorlat/ef/#entity-framework","text":"A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a Linq lek\u00e9rdez\u00e9sek haszn\u00e1lat\u00e1t, valamint az Entity Framework m\u0171k\u00f6d\u00e9s\u00e9t. Entity Framework Core A gyakorlat sor\u00e1n a .NET Framework-ben haszn\u00e1lt Entity Framework-\u00f6t haszn\u00e1ljuk, nem a platformf\u00fcggetlen Core v\u00e1ltozatot. A Linq lek\u00e9rdez\u00e9sek tekintet\u00e9ben a k\u00e9t technol\u00f3gia k\u00f6zel azonos \u00e9lm\u00e9nyt ny\u00fajt, de az al\u00e1bb haszn\u00e1lt vizu\u00e1lis k\u00f3d gener\u00e1l\u00e1s \u00e9s szerkeszt\u0151 csak .NET Framework \u00e9s Entity Framework eset\u00e9n \u00e9rhet\u0151 el.","title":"Entity Framework"},{"location":"gyakorlat/ef/#elofeltetelek","text":"A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft Visual Studio 2015/2017/2019 ( nem VS Code) Microsoft SQL Server (LocalDB vagy Express edition) SQL Server Management Studio Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Amit \u00e9rdemes \u00e1tn\u00e9zned: C# nyelv Entity Framework \u00e9s Linq","title":"El\u0151felt\u00e9telek"},{"location":"gyakorlat/ef/#gyakorlat-menete","text":"A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!","title":"Gyakorlat menete"},{"location":"gyakorlat/ef/#feladat-0-adatbazis-letrehozasa-ellenorzese","text":"Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban .)","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se"},{"location":"gyakorlat/ef/#feladat-1-projekt-letrehozasa-adatbazis-lekepzese","text":"Hozz l\u00e9tre Visual Studio seg\u00edts\u00e9g\u00e9vel egy C# konzolalkalmaz\u00e1st. VS 2019 eset\u00e9n keress\u00fcnk r\u00e1 a \"console framework\" szavakra, \u00edgy a legegyszer\u0171bb megtal\u00e1lni a projekt t\u00edpust. Ne .NET Core alkalmaz\u00e1st hozzunk l\u00e9tre, mert abban nincs vizu\u00e1lis Database First lek\u00e9pz\u00e9s, amit haszn\u00e1lni fogunk. \u00dcgyelj\u00fcnk a projekt nyelv\u00e9re is, C# nyelv\u0171 projekt legyen. Hozd l\u00e9tre a projektet. A c:\\work mapp\u00e1ba dolgozz. Adj a projekthez egy ADO.NET Entity Data Model -t. Solution Explorer-ben a projektre jobb eg\u00e9r / Add / New Item / Data / ADO.NET Entity Data Model . Az ablak alj\u00e1n a Name mez\u0151ben AdatvezEntities -t adj meg. A modellt megl\u00e9v\u0151 adatb\u00e1zis alapj\u00e1n \u00e9p\u00edtsd fel (a var\u00e1zsl\u00f3ban \"EF designer from database\"). A kapcsolatok megad\u00e1s\u00e1n\u00e1l a saj\u00e1t adatb\u00e1zishoz kapcsol\u00f3dj. Hozz l\u00e9tre egy \u00faj kapcsolatot a var\u00e1zsl\u00f3 seg\u00edts\u00e9g\u00e9vel, \u00e9s mentsd el a kapcsol\u00f3d\u00e1si adatokat a config f\u00e1jlba. Data source : Microsoft SQL Server Server name : (localdb)\\mssqllocaldb Select or enter database name : adjuk meg az adatb\u00e1zis nev\u00e9t Save connection settings in App.Config : igen (pipa) alatta a szerkeszt\u0151mez\u0151ben az AdatvezEntities -t add meg (ilyen n\u00e9ven fog a DbContext oszt\u00e1ly legener\u00e1l\u00f3dni) Entity Framework 6.0-as lek\u00e9pz\u00e9st haszn\u00e1lj. Az \u00f6sszes t\u00e1bl\u00e1t k\u00e9pezz\u00fck le (ki kell pip\u00e1lni a Tables -t). Model namespace : pl. AdatvezEntitiesModel V\u00e1rjuk meg, am\u00edg elk\u00e9sz\u00fcl a modell. Ha k\u00f6zben a VS k\u00e9rdezne \"template\" futtat\u00e1s\u00e1r\u00f3l, enged\u00e9lyezz\u00fck. Keress\u00fck meg a connection stringet az app.config f\u00e1jlban. N\u00e9zz\u00fck meg a tartalm\u00e1t. app.config Az\u00e9rt j\u00f3, ha ide ker\u00fcl a connection string , mert az alkalmaz\u00e1shoz tartoz\u00f3 adatb\u00e1zis helye telep\u00edt\u00e9senk\u00e9nt v\u00e1ltozhat. Ha a forr\u00e1sk\u00f3dban van a szerver el\u00e9rhet\u0151s\u00e9ge, akkor \u00fajra kell ford\u00edtani az alkalmaz\u00e1st minden telep\u00edt\u00e9shez. Az app.config f\u00e1jl viszont az exe mellett r\u00e9sze az alkalmaz\u00e1snak, \u00e9s szerkeszthet\u0151. Ha sz\u00fcks\u00e9ges, kiemelhet\u0151 a f\u00e1jl m\u00e1s konfigur\u00e1ci\u00f3s \u00e1llom\u00e1nyba is. Nyissuk meg az EF adatmodellt (dupla kattint\u00e1s a Solution Explorer-ben). Vizsg\u00e1ljuk meg: n\u00e9zz\u00fck meg az entit\u00e1sokat \u00e9s kapcsolatokat. Ha szerkeszteni akarjuk a modellt, az Entity Data Model Browser \u00e9s Entity Data Model Mapping Details ablakokon kereszt\u00fcl lehet szerkeszteni (ezek a View men\u00fc, Other windows men\u00fcponton kereszt\u00fcl \u00e9rhet\u0151k el). Jav\u00edtsuk ki az al\u00e1bbi entit\u00e1s tulajdons\u00e1g neveket, hogy jobban illeszkedjenek a val\u00f3s\u00e1ghoz: Customer.CustomerSite1 -> .Sites CustomerSite.Customer1 -> .MainCustomer Order.OrderItem -> .OrderItem\u200b s Product.OrderItem -> .OrderItem\u200b s VAT.Product -> .Product\u200b s Category.Product -> .Product\u200b s Ments\u00fck a v\u00e1ltoztat\u00e1sok ut\u00e1n a modellt. N\u00e9zz\u00fck meg a DbContext \u00e9s egy v\u00e1lasztott entit\u00e1s oszt\u00e1ly C# k\u00f3dj\u00e1t. Bontsd ki a Solution Explorer -ben az EDM modell f\u00e1jlj\u00e1t, \u00e9s alatta ott tal\u00e1lhat\u00f3ak a C# f\u00e1jlok. Ezen f\u00e1jlokba nem szerkeszt\u00fcnk bele, mert minden EDM m\u00f3dos\u00edt\u00e1s ut\u00e1n \u00fajragener\u00e1l\u00f3dnak. Viszont figyelj\u00fck meg, hogy minden oszt\u00e1ly partial -k\u00e9nt van defini\u00e1lva, \u00edgy ha sz\u00fcks\u00e9ges, tudunk a meglev\u0151 k\u00f3d \"mell\u00e9\" \u00faj forr\u00e1sf\u00e1jlokba saj\u00e1tot is \u00edrni.","title":"Feladat 1: Projekt l\u00e9trehoz\u00e1sa, adatb\u00e1zis lek\u00e9pz\u00e9se"},{"location":"gyakorlat/ef/#feladat-2-lekerdezesek","text":"A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket Linq haszn\u00e1lat\u00e1val. \u00cdrd ki konzolra az eredm\u00e9nyeket. Debugger seg\u00edts\u00e9g\u00e9vel n\u00e9zd meg, hogy milyen SQL utas\u00edt\u00e1s gener\u00e1l\u00f3dik: az IQueryable t\u00edpus\u00fa v\u00e1ltoz\u00f3ra h\u00fazva az egeret l\u00e1that\u00f3 a gener\u00e1lt SQL, amint az eredm\u00e9nyhalmaz iter\u00e1l\u00e1sa elkezd\u0151dik. List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron! \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek! K\u00e9sz\u00edts olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azokat a megrendel\u00e9seket, melyek \u00f6ssz\u00e9rt\u00e9ke t\u00f6bb mint 30.000 Ft! Az eredm\u00e9nyhalmaz ki\u00edr\u00e1sakor a vev\u0151 nevet k\u00f6vet\u0151en soronk\u00e9nt szerepeljenek az egyes t\u00e9telek (Term\u00e9k n\u00e9v, mennyis\u00e9g, nett\u00f3 \u00e1r). List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait! List\u00e1zd ki azokat a vev\u0151 p\u00e1rokat, akiknek ugyanabban a v\u00e1rosban van telephely\u00fck. Egy p\u00e1r, csak egyszer szerepeljen a list\u00e1ban. Megold\u00e1s Console . WriteLine ( \"***** M\u00e1sodik feladat *****\" ); using ( var db = new AdatvezEntities ()) { // 2.1 Console . WriteLine ( \"\\t2.1:\" ); var qProductStock = from p in db . Product where p . Stock > 30 select p ; foreach ( var p in qProductStock ) Console . WriteLine ( \"\\t\\tName={0}\\tStock={1}\" , p . Name , p . Stock ); // 2.2 Console . WriteLine ( \"\\t2.2:\" ); var qProductOrder = from p in db . Product where p . OrderItems . Count >= 2 select p ; foreach ( var p in qProductOrder ) Console . WriteLine ( \"\\t\\tName={0}\" , p . Name ); // 2.3 Console . WriteLine ( \"\\t2.3:\" ); var qOrderTotal = from o in db . Order where o . OrderItems . Sum ( oi => oi . Amount * oi . Price ) > 30000 select o ; foreach ( var o in qOrderTotal ) { Console . WriteLine ( \"\\t\\tName={0}\" , o . CustomerSite . MainCustomer . Name ); foreach ( var oi in o . OrderItems ) Console . WriteLine ( \"\\t\\t\\tProduct={0}\\tPrice={1}\\tAmount={2}\" , oi . Product . Name , oi . Price , oi . Amount ); } // 2.3 m\u00e1sodik megold\u00e1s // Ehhez sz\u00fcks\u00e9g van a k\u00f6vetkez\u0151 n\u00e9vt\u00e9r import\u00e1l\u00e1s\u00e1ra: innen vegy\u00fck ki \u00e9s tegy\u00fck be // a f\u00e1jl elej\u00e9re !!! // using System.Data.Entity; // Csak egy lek\u00e9rdez\u00e9st fog gener\u00e1lni, a Navigation Propertyket is felt\u00f6lti r\u00f6gt\u00f6n Console . WriteLine ( \"\\tc 2.3 alternat\u00edv megold\u00e1s:\" ); var qOrderTotal2 = from o in db . Order . Include ( o => o . OrderItems ) // vagy .Include(\"OrderItem\") . Include ( o => o . OrderItems . Select ( oi => oi . Product )) // vagy .Include(\"OrderItem.Product\") . Include ( o => o . CustomerSite ) // vagy .Include(\"CustomerSite\") . Include ( o => o . CustomerSite . MainCustomer ) // vagy .Include(\"CustomerSite.Customer\") where o . OrderItems . Sum ( oi => oi . Amount * oi . Price ) > 30000 select o ; foreach ( var o in qOrderTotal2 ) { Console . WriteLine ( \"\\t\\tName={0}\" , o . CustomerSite . MainCustomer . Name ); foreach ( var oi in o . OrderItems ) Console . WriteLine ( \"\\t\\t\\tProduct={0}\\tPrice={1}\\tAmount={2}\" , oi . Product . Name , oi . Price , oi . Amount ); } // 2.4 Console . WriteLine ( \"\\t2.4:\" ); var qPriceMax = from p in db . Product where p . Price == db . Product . Max ( a => a . Price ) select p ; foreach ( var t in qPriceMax ) Console . WriteLine ( \"\\t\\tName={0}\\tPrice={1}\" , t . Name , t . Price ); // 2.5 Console . WriteLine ( \"\\t2.5:\" ); var qJoin = from s1 in db . CustomerSite join s2 in db . CustomerSite on s1 . City equals s2 . City where s1 . CustomerID > s2 . CustomerID select new { c1 = s1 . MainCustomer , c2 = s2 . MainCustomer }; foreach ( var v in qJoin ) Console . WriteLine ( \"\\t\\tCustomer 1={0}\\tCustomer 2={1}\" , v . c1 . Name , v . c2 . Name ); }","title":"Feladat 2: Lek\u00e9rdez\u00e9sek"},{"location":"gyakorlat/ef/#feladat-3-adatmodositasok","text":"A DbContext nem csak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl m\u00f3dos\u00edt\u00e1sok is v\u00e9grehajthat\u00f3ak. \u00cdrj olyan Linq-ra \u00e9p\u00fcl\u0151 C# k\u00f3dot, mely az \"LEGO\" kateg\u00f3ri\u00e1s term\u00e9kek \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal! Hozz l\u00e9tre egy \u00faj kateg\u00f3ri\u00e1t Expensive toys n\u00e9ven, \u00e9s sorod \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft! Megold\u00e1s Console . WriteLine ( \"***** Harmadik feladat *****\" ); using ( var db = new AdatvezEntities ()) { // 3.1 Console . WriteLine ( \"\\t3.1:\" ); var qProductsLego = from p in db . Product where p . Category . Name == \"LEGO\" select p ; Console . WriteLine ( \"\\tM\u00f3dos\u00edt\u00e1s el\u0151tt:\" ); foreach ( var p in qProductsLego ) { Console . WriteLine ( \"\\t\\t\\tName={0}\\tStock={1}\\tPrice={2}\" , p . Name , p . Stock , p . Price ); p . Price = 1.1 * p . Price ; } db . SaveChanges (); qProductsLego = from p in db . Product where p . Category . Name == \"LEGO\" select p ; Console . WriteLine ( \"\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n:\" ); foreach ( var p in qProductsLego ) Console . WriteLine ( \"\\t\\t\\tName={0}\\tStock={1}\\tPrice={2}\" , p . Name , p . Stock , p . Price ); // 3.2 Console . WriteLine ( \"\\t3.2:\" ); Category categoryExpensiveToys = ( from c in db . Category where c . Name == \"Expensive toys\" select c ). SingleOrDefault (); if ( categoryExpensiveToys == null ) { categoryExpensiveToys = new Category { Name = \"Expensive toys\" }; // Erre nem feltetlenul van szukseg: ha van atrendelt termek, ahhoz hozzakotjuk a kategoria entitast // es bekerul automatikusan a kategoria tablaba is. Igy viszont, hogy explicit felvesszuk, (1) jobban // kifejezi a szandekunkat; es (2) akkor is felvesszuk a kategoriat, ha vegul nincs atrendelt termek. db . Category . Add ( categoryExpensiveToys ); } var qProductExpensive = from p in db . Product where p . Price > 8000 select p ; foreach ( var p in qProductExpensive ) p . Category = categoryExpensiveToys ; db . SaveChanges (); qProductExpensive = from p in db . Product where p . Category . Name == \"Expensive toys\" select p ; foreach ( var t in qProductExpensive ) Console . WriteLine ( \"\\t\\tName={0}\\tPrice={1}\" , t . Name , t . Price ); }","title":"Feladat 3: Adatm\u00f3dos\u00edt\u00e1sok"},{"location":"gyakorlat/ef/#feladat-4-tarolt-eljarasok-hasznalata","text":"T\u00e1rolt elj\u00e1r\u00e1sok is felvehet\u0151k az EDM modellbe modellfriss\u00edt\u00e9s sor\u00e1n. A t\u00e1rolj elj\u00e1r\u00e1s vagy a DbContext f\u00fcggv\u00e9nyek\u00e9nt, vagy entit\u00e1s m\u00f3dos\u00edt\u00f3 m\u0171velet\u00e9re k\u00f6thet\u0151 be. T\u00e1rolt elj\u00e1r\u00e1s az EDM-ben A t\u00e1rolt elj\u00e1r\u00e1s lek\u00e9pz\u00e9s\u00e9nek be\u00e1ll\u00edt\u00e1sait (pl. a t\u00e1rolt elj\u00e1r\u00e1s visszat\u00e9r\u00e9si t\u00edpus\u00e1t) az Entity Data Model Browser -ben, az adott f\u00fcggv\u00e9ny Function Import -j\u00e1hoz tartoz\u00f3 tulajdons\u00e1gain\u00e1l szerkeszten\u00fcnk. K\u00e9sz\u00edts egy t\u00e1rolt elj\u00e1r\u00e1st, mely \u00faj fizet\u00e9si m\u00f3d r\u00f6gz\u00edt\u00e9s\u00e9re szolg\u00e1l, \u00e9s visszaadja az \u00faj rekord azonos\u00edt\u00f3j\u00e1t! Haszn\u00e1ld ezt a t\u00e1rolt elj\u00e1r\u00e1st \u00faj entit\u00e1s felv\u00e9tel\u00e9hez! Hozd l\u00e9tre a t\u00e1rolt elj\u00e1r\u00e1st SQL Management Studio seg\u00edts\u00e9g\u00e9vel. CREATE PROCEDURE CreateNewPaymentMethod ( @ Method nvarchar ( 20 ), @ Deadline int ) AS insert into PaymentMethod values ( @ Method , @ Deadline ) select scope_identity () as NewId A t\u00e1rolt elj\u00e1r\u00e1st \u00e1ll\u00edtsd be a PaymentMethod entit\u00e1s insert met\u00f3dus\u00e1nak. Add hozz\u00e1 a t\u00e1rolt elj\u00e1r\u00e1st az EDM-hez. Az EDM Browser-ben jobb kantit\u00e1ssal hozd el\u0151 a kontextus men\u00fct, haszn\u00e1ld az \"Update model from database\"-t, \u00e9s import\u00e1ld ( Add ) az \u00faj t\u00e1rolt elj\u00e1r\u00e1st. Mentsd el a modell v\u00e1ltoz\u00e1sait. Ekkor gener\u00e1l\u00f3dik a h\u00e1tt\u00e9rben a C# k\u00f3d. \u00c1ll\u00edtsd be ezt a met\u00f3dust a PaymentMethod entit\u00e1s insert met\u00f3dusak\u00e9nt: kiv\u00e1lasztva az EDM-ben a PaymentMethod elemet a Mapping Details ablakban v\u00e1lts \u00e1t a Map Entity to Functions n\u00e9zetre, \u00e9s \u00e1ll\u00edtsd be Insert met\u00f3dusnak. A visszat\u00e9r\u00e9si \u00e9rt\u00e9ket feleltesd meg az ID tulajdons\u00e1gnak. Mentsd el a modell v\u00e1ltoz\u00e1sait. Pr\u00f3b\u00e1ld ki a m\u0171k\u00f6d\u00e9st: C# k\u00f3db\u00f3l adj hozz\u00e1 egy \u00faj fizet\u00e9si m\u00f3dot a DbContext PaymentMethod gy\u0171jtem\u00e9ny\u00e9hez az Add met\u00f3dussal. Ellen\u0151rizd az adatb\u00e1zisban a rekord l\u00e9trej\u00f6tt\u00e9t. K\u00e9sz\u00edts egy t\u00e1rolt elj\u00e1r\u00e1st, mely kilist\u00e1zza azon term\u00e9keket melyb\u0151l legal\u00e1bb egy megadott darabsz\u00e1m felett adtak el. H\u00edvd meg a t\u00e1rolj elj\u00e1r\u00e1st C# k\u00f3db\u00f3l! Hozd l\u00e9tre a t\u00e1rolt elj\u00e1r\u00e1st az al\u00e1bbi k\u00f3ddal. CREATE PROCEDURE dbo . PopularProducts ( @ MinAmount int = 10 ) AS SELECT Product . * FROM Product INNER JOIN ( SELECT OrderItem . ProductID FROM OrderItem GROUP BY OrderItem . ProductID HAVING SUM ( OrderItem . Amount ) > @ MinAmount ) a ON Product . ID = a . ProductID Import\u00e1ld az EDM-be a t\u00e1rolt elj\u00e1r\u00e1st. Az elj\u00e1r\u00e1s be\u00e1ll\u00edt\u00e1sain\u00e1l ( EDM Model Browser -ben a function -re dupla kattint\u00e1ssal ny\u00edlik) \u00e1ll\u00edtsd be a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket Product t\u00edpus\u00fara. Mentsd el a modell v\u00e1ltoz\u00e1sait. Haszn\u00e1ld a DbContext-en gener\u00e1lt \u00faj f\u00fcggv\u00e9nyt a t\u00e1rolt elj\u00e1r\u00e1s megh\u00edv\u00e1s\u00e1hoz, \u00e9s \u00edrasd ki a term\u00e9kek nev\u00e9t! Megold\u00e1s Console . WriteLine ( \"***** Negyedik feladat *****\" ); using ( var db = new AdatvezEntities ()) { // 4.3 Console . WriteLine ( \"\\t4.3:\" ); var pm = new PaymentMethod { Method = \"Apple pay\" , Deadline = 99999 }; db . PaymentMethod . Add ( pm ); db . SaveChanges (); // 4.6 Console . WriteLine ( \"\\t4.6:\" ); var qPopularProducts = db . PopularProducts ( 5 ); foreach ( var p in qPopularProducts ) Console . WriteLine ( \"\\t\\tName={0}\\tStock={1}\\tPrice={2}\" , p . Name , p . Stock , p . Price ); }","title":"Feladat 4: T\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata"},{"location":"gyakorlat/jpa/","text":"JPA & Spring Data \u00b6 A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a JPA \u00e9s a Spring Data haszn\u00e1lat\u00e1t. A f\u0151bb t\u00e9m\u00e1k: entit\u00e1sok fejleszt\u00e9se, lek\u00e9rdez\u00e9sek megfogalmaz\u00e1sa k\u00fcl\u00f6nb\u00f6z\u0151 m\u00f3dokon, m\u00f3dos\u00edt\u00e1sok v\u00e9grehajt\u00e1sa. A k\u00f3dokat egy webalkalmaz\u00e1s projektbe integr\u00e1ljuk, amiben a projekt alapvet\u0151 konfigur\u00e1ci\u00f3ja \u00e9s egy tesztel\u00e9shez haszn\u00e1lhat\u00f3 egyszer\u0171 webes fel\u00fcletet m\u00e1r k\u00e9szen \u00e1ll. El\u0151felt\u00e9telek \u00b6 A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Eclipse for Java EE Microsoft SQL Server Express edition (localdb ez\u00fattal nem j\u00f3) SQL Server Management Studio Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Kiindul\u00f3 webalkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-jpa-kiindulo Amit \u00e9rdemes \u00e1tn\u00e9zned \u00b6 JPA el\u0151ad\u00e1s EJB, Spring el\u0151ad\u00e1s Gyakorlat menete \u00b6 A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot! Tippek az Eclipse haszn\u00e1lat\u00e1hoz \u00b6 T\u00edpus (oszt\u00e1ly, interf\u00e9sz, enum) keres\u00e9se: Ctrl+Shift+T (Nem \u00e9rdemes a Project explorer-ben a mapp\u00e1kat nyitogatni) F\u00e1jl keres\u00e9se: Ctrl+Shift+R Hi\u00e1nyz\u00f3 importok megjav\u00edt\u00e1sa: Ctrl+Shift+O K\u00f3d form\u00e1z\u00e1sa: Ctrl+Shift+F Ha a Java Resources alatt egy package-en jobb klikk / New Class/Interfaces, akkor abba a package-be rakja az \u00faj elemet Ha a n\u00e9zeteket becsukjuk/\u00e1trendezz\u00fck, a default elrendez\u00e9s vissza\u00e1ll\u00edthat\u00f3: Window / Reset perspective Font megn\u00f6vel\u00e9se (a tan\u00e1ri g\u00e9pen hasznos): Window men\u00fc / Preferences, ott elkezdj\u00fck g\u00e9pelni, hogy font , \u00edgy megtal\u00e1lja azt a be\u00e1ll\u00edt\u00e1st, hogy Fonts and Colors Azt kiv\u00e1lasztva, a Basic kateg\u00f3ria alatt kell a Text Fontot kijel\u00f6lni, \u00e9s a m\u00e9ret\u00e9t pl. 18-asra \u00e1ll\u00edtani Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa \u00b6 Csatlakozzunk Microsoft SQL Server Management Studio -val a szerverhez. Ez\u00fattal nem localdb -t haszn\u00e1lunk, a szerver c\u00edme: localhost\\sqlexpress . A bejelentkez\u00e9shez SQL Server Authentication m\u00f3dot v\u00e1lasszuk. Hozzunk l\u00e9tre egy adatvez nev\u0171 adatb\u00e1zist. \u00dcgyelj\u00fcnk a n\u00e9vre, k\u00fcl\u00f6nben a Java projektben m\u00f3dos\u00edtanunk kell . Az adatb\u00e1zis l\u00e9trehoz\u00e1s\u00e1nak mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban . Ha a g\u00e9pen m\u00e1r l\u00e9tezik az adatb\u00e1zis, akkor nem kell \u00fajat l\u00e9trehozni. Futtassuk le az adatb\u00e1zis inicializ\u00e1l\u00f3 sql szkriptet az adatb\u00e1zisban. Akkor is futtassuk le a szkriptet, ha m\u00e1r l\u00e9tezne az adatb\u00e1zis (hogy a kezdeti \u00e1llapotot visszakapjuk.) Feladat 1: Eclipse ind\u00edt\u00e1sa \u00b6 Ind\u00edtsuk el az Eclipse-et innen: C:\\work\\javaee\\eclipse\\eclipse.exe . (Fontos, hogy lehet egy D:\\eclipse mappa is, nek\u00fcnk nem az kell.) Ind\u00edt\u00e1skor megk\u00e9rdezi, hova akarunk dolgozni (workspace), itt v\u00e1lasszuk ezt: C:\\work\\javaee\\workspaces\\adatvez Ha az indul\u00e1s ut\u00e1n a Project Explorer-ben ott van egy kor\u00e1bbi gyakorlatr\u00f3l a webshop nev\u0171 projekt, azt t\u00f6r\u00f6lj\u00fck ki: a projekten jobb klikk / Delete , amikor r\u00e1k\u00e9rdez, pip\u00e1ljuk be, hogy a f\u00e1jlrendszerr\u0151l is t\u00f6rl\u0151dj\u00f6n. Feladat 2: Projekt import\u00e1l\u00e1sa \u00b6 T\u00f6lts\u00fck le a m\u00e9r\u00e9shez tartoz\u00f3 projekt v\u00e1zat! Nyissunk egy command prompt -ot Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN Adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone --depth 1 https://github.com/bmeviauac01/gyakorlat-jpa-kiindulo.git Import\u00e1ljuk a let\u00f6lt\u00f6tt forr\u00e1sk\u00f3dot a workspace-be: Nyissuk meg a File / Import... -ot Kezdj\u00fck el g\u00e9pelni a textboxba, hogy Existing projects into workspace , \u00edgy r\u00e1 fog sz\u0171rni \u00e9s v\u00e1lasszuk ki ezt Keress\u00fck meg a let\u00f6lt\u00f6tt webshop projektet (a webshop mapp\u00e1t a saj\u00e1t k\u00f6nyvt\u00e1runk alatt), OK, ut\u00e1na a dialogban pip\u00e1ljuk be a webshop-ot (lehet, hogy by default be lesz pip\u00e1lva) Finish Tekints\u00fck \u00e1t r\u00f6viden a projektet: Ez egy maven alap\u00fa projekt. A maven parancssori build eszk\u00f6z, ami IDE-khez is illeszthet\u0151. Fontos tulajdons\u00e1ga, hogy k\u00e9pes a sz\u00fcks\u00e9ges library f\u00fcgg\u0151s\u00e9geket online repository-kb\u00f3l let\u00f6lteni. Ha megnyitjuk a projekt gy\u00f6ker\u00e9ben pom.xml -t, a maven konfig f\u00e1jlj\u00e1t, dependency tagekben f\u00fcgg\u0151s\u00e9geket l\u00e1tunk, amik (tranzit\u00edv m\u00f3don) beh\u00fazz\u00e1k a Hibernate -et mint JPA implement\u00e1ci\u00f3t, a Spring Boot -ot, a Spring Data -t \u00e9s a webr\u00e9teghez sz\u00fcks\u00e9ges Spring MVC -t \u00e9s Thymeleaf -et. A laborban a maven offline m\u0171k\u00f6d\u00e9sre van konfigur\u00e1lva, \u00e9s el\u0151re le van t\u00f6ltve az \u00f6sszes f\u00fcgg\u0151s\u00e9g, \u00edgy megel\u0151zz\u00fck az esetleges h\u00e1l\u00f3zati probl\u00e9m\u00e1kat. Az application.properties -ben van p\u00e1r alapvet\u0151 be\u00e1ll\u00edt\u00e1s, itt a DB el\u00e9r\u00e9shez ellen\u0151rizz\u00fck a usernevet \u00e9s jelsz\u00f3t . Figyelj\u00fck meg az adatb\u00e1zis JNDI nev\u00e9nek be\u00e1ll\u00edt\u00e1s\u00e1hoz ezt a sort: spring.datasource.jndi-name=jdbc/termekDB . Klasszikus Java EE alkalmaz\u00e1sban ezt a persistence.xml -be \u00edrn\u00e1nk be, de a Spring Boot XML n\u00e9lk\u00fcli konfigur\u00e1ci\u00f3t is t\u00e1mogat, itt ezt haszn\u00e1ljuk ki. (Egy apr\u00f3s\u00e1g: a projektben m\u00e9gis van persistence.xml , ezt ig\u00e9nyli az Eclipse-es JPA plugin, aminek k\u00f6sz\u00f6nhet\u0151en pl. k\u00f3dkieg\u00e9sz\u00edt\u00e9s m\u0171k\u00f6dik a NamedQuery-kben. Viszont, mivel igaz\u00e1b\u00f3l nem haszn\u00e1lja az alkalmaz\u00e1sunk fut\u00e1s k\u00f6zben, \u00fcres a persistence.xml.) A ConnectionProperties az el\u0151z\u0151 konfig f\u00e1jl egy r\u00e9sz\u00e9nek Java-beli reprezent\u00e1ci\u00f3ja A WebshopApplication a Spring Boot alkalmaz\u00e1s bel\u00e9p\u00e9si pontja \u00e9s konfigja is. Egy hagyom\u00e1nyos webalkalmaz\u00e1st egy k\u00fcl\u00f6n processzben fut\u00f3 webkont\u00e9nerre (pl. Tomcat, Jetty) kellene telep\u00edteni. Spring Boot-os fejleszt\u00e9s eset\u00e9ben viszont maga a Spring Boot fog elind\u00edtani egy be\u00e1gyazott webkont\u00e9nert (alap\u00e9rtelmez\u00e9sben Tomcat-et). A tomcatFactory met\u00f3dusban regisztr\u00e1ljuk be az SQL Server JDBC driver\u00e9t jdbc/termekDB JNDI n\u00e9ven, hogy a JPA majd megtal\u00e1lja. Ha nem adatvez az adatb\u00e1zisunk neve, akkor a JDBC URL-t m\u00f3dos\u00edtani kell a megfelel\u0151 sorn\u00e1l: resource.setProperty(\"url\", \"jdbc:sqlserver://localhost;database= adatvez \"); A webes fel\u00fclet egyetlen oldal, az src\\main\\resources\\templates\\testPage.html . Ebbe nem fogunk majd beleny\u00falni. Standard html + Thymeleaf-es attrib\u00fatumok l\u00e1taht\u00f3ak benne. WebshopController : a webr\u00e9teget megval\u00f3s\u00edt\u00f3 controller oszt\u00e1ly, ennek met\u00f3dusai kezelik az alkalmaz\u00e1shoz \u00e9rkez\u0151 HTTP k\u00e9r\u00e9seket. Jellemz\u0151en lek\u00e9rdez\u00e9sek eredm\u00e9ny\u00e9t akarjuk megjelen\u00edteni az oldalon, ez\u00e9rt a lek\u00e9rdez\u00e9s eredm\u00e9ny\u00e9t a modellbe tessz\u00fck valamilyen n\u00e9ven, amire hivatkozni tudunk a Thymeleaf seg\u00edts\u00e9g\u00e9vel. A //TODO r\u00e9szekre kell majd bek\u00f6tni az egyes feladatokat megval\u00f3s\u00edt\u00f3 met\u00f3dusok megh\u00edv\u00e1s\u00e1t. Feladat 3: Entit\u00e1sok \u00e1ttekint\u00e9se \u00b6 Az entit\u00e1sok m\u00e1r el\u0151re k\u00e9szen a hu.bme.aut.adatvez.webshop.model package-ben tal\u00e1lhat\u00f3k. Ezeket \u00e1ltal\u00e1ban vagy k\u00e9zzel \u00edrjuk meg, vagy gener\u00e1ljuk a DB t\u00e1bl\u00e1kb\u00f3l pl. az Eclipse-es JPA plugin seg\u00edts\u00e9g\u00e9vel. Az entit\u00e1sok k\u00f6z\u00fcl nyissunk meg egyet, pl. Vat , l\u00e1tszik benne a @Entity , a @Id annot\u00e1ci\u00f3, illetve a kapcsolatok defini\u00e1l\u00e1s\u00e1ra @OneToMany vagy @ManyToOne Az entit\u00e1sokhoz a Criteria API haszn\u00e1latakor hasznos metamodel oszt\u00e1lyok is gener\u00e1l\u00f3dnak, ezekb\u0151l n\u00e9zz\u00fcnk meg egyet a target\\generated-sources\\apt alatt (A pom.xml -ben l\u00e1that\u00f3 maven-precessor-plugin gener\u00e1lja egy\u00e9bk\u00e9nt \u0151ket a build sor\u00e1n.) Feladat 4: Lek\u00e9rdez\u00e9sek \u00b6 A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket! A lek\u00e9rdez\u00e9seket JPA \u00e9s Spring Data haszn\u00e1lata eset\u00e9n t\u00f6bb m\u00f3don is megval\u00f3s\u00edthatjuk. Az al\u00e1bbi feladatokban azt is megadjuk, milyen m\u00f3don kell elk\u00e9sz\u00edteni a lek\u00e9rdez\u00e9st, hogy mindegyikre l\u00e1ssunk p\u00e9ld\u00e1t. Fontos megjegyezni, hogy ezek a m\u00f3dszerre vonatkoz\u00f3 megk\u00f6t\u00e9sek csak oktat\u00e1si szempontok miatt szerepelnek, val\u00f3j\u00e1ban b\u00e1rmelyik m\u00f3dszerrel b\u00e1rmelyik lek\u00e9rdez\u00e9s megval\u00f3s\u00edthat\u00f3 lenne. Az egyes feladatokat megval\u00f3s\u00edt\u00f3 met\u00f3dusokat mindig a WebshopController oszt\u00e1ly megfelel\u0151 //TODO kommentjein\u00e9l kell megh\u00edvni, majd a webalkalmaz\u00e1st futtatni \u00e9s b\u00f6ng\u00e9sz\u0151b\u0151l tesztelni a http://localhost:9080 URL-en. a) List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron! M\u00f3dszer: Spring Data repository interf\u00e9sz, met\u00f3dusn\u00e9vb\u0151l sz\u00e1rmaztatott lek\u00e9rdez\u00e9s. b) \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek! M\u00f3dszer: Spring Data repository custom implement\u00e1ci\u00f3val, injekt\u00e1lt EntityManagerrel k\u00e9sz\u00edtett JPQL query. c) List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait! M\u00f3dszer: Named query, amelyet Spring Data repository-b\u00f3l h\u00edvunk meg, vagy custom implement\u00e1ci\u00f3b\u00f3l, injekt\u00e1lt EntityManagerrel h\u00edvunk meg, vagy a met\u00f3dusn\u00e9v \u00e9s query n\u00e9v egyez\u00e9se alapj\u00e1n. Fut\u00e1s k\u00f6zben a Console n\u00e9zetben l\u00e1tsz\u00f3dnak a Hibernate \u00e1ltal gener\u00e1lt SQL utas\u00edt\u00e1sok az application.properties -beli spring.jpa.show-sql=true konfig miatt. Futtat\u00e1s \u00b6 A projektben megtal\u00e1lhat\u00f3 (a legals\u00f3 f\u00e1jl a Project Explorerben) a webshop run.launch nev\u0171 konfig f\u00e1jl. Ezen jobb klikk / Debug As / webshop run . Ez debug m\u00f3dban ind\u00edtja a Spring Boot maven plugin-t, aminek hat\u00e1s\u00e1ra a be\u00e1gyazott webkont\u00e9ner elindul, \u00e9s b\u00f6ng\u00e9sz\u0151b\u0151l a http://localhost:9080 URL-en el\u00e9rhet\u0151 az alkalmaz\u00e1s. Ha ezt egyszer jobb klikkel megcsin\u00e1ltuk, akkor k\u00e9s\u0151bb a toolbar Debug ikonj\u00e1t lenyitva is megtehetj\u00fck: Ha a Debug ikon alatt m\u00e1r ott van a webshop run , akkor az eg\u00e9sz fentebb le\u00edrt webshop run.launch -os m\u00f3dszer sz\u00fcks\u00e9gtelen. A fut\u00f3 alkalmaz\u00e1st a Console n\u00e9zet piros Terminate ikonj\u00e1val lehet le\u00e1ll\u00edtani. Ha le\u00e1ll\u00edt\u00e1s n\u00e9lk\u00fcl pr\u00f3b\u00e1ljuk \u00fajra futtatni, akkor a m\u00e1sodik processz \u00fctk\u00f6z\u00e9st jelent a 8080-as porton, \u00e9s le\u00e1ll. Ilyenkor a sikertelen m\u00e1sodik futtat\u00e1s l\u00e1tszik a Console n\u00e9zetben, a Terminate gomb pedig inakt\u00edv, mivel ez a fut\u00e1s m\u00e1r le\u00e1llt. Nyomjuk meg a Terminate ikon melletti dupla sz\u00fcrke X ikont, ez el fogja t\u00e1vol\u00edtani a m\u00e1r le\u00e1ll\u00edtott futtat\u00e1sokat, \u00e9s csak az akt\u00edv futtat\u00e1s l\u00e1tszik, amin viszont m\u00e1r tudunk Terminate -et nyomni. Ha a teljes Console n\u00e9zetet bez\u00e1rjuk v\u00e9letlen\u00fcl, el\u0151 lehet szedni Alt+Shift+Q, C gyorsbillenyt\u0171vel, vagy Window / Show View / Console men\u00fcvel. A le\u00e1ll\u00edt\u00e1s ut\u00e1ni \u00fajrafuttat\u00e1shoz az F11-et is haszn\u00e1lhatjuk. A debug m\u00f3dban val\u00f3 futtat\u00e1s jellegzetess\u00e9ge, hogy a HTML \u00e9s bizonyos Java k\u00f3d m\u00f3dos\u00edt\u00e1sok azonnal \u00e9letbe l\u00e9pnek. (A b\u00f6ng\u00e9sz\u0151t persze friss\u00edteni kell.) \u00dajra kell viszont ind\u00edtani az alkalmaz\u00e1st, ha a Java k\u00f3dban: \u00faj t\u00edpust adtunk hozz\u00e1 annot\u00e1ci\u00f3t adtunk hozz\u00e1/t\u00f6r\u00f6lt\u00fcnk/m\u00f3dos\u00edtottunk \u00faj oszt\u00e1ly- vagy tagv\u00e1ltoz\u00f3t, met\u00f3dust vett\u00fcnk fel met\u00f3dus szignat\u00far\u00e1t m\u00f3dos\u00edtottunk R\u00f6viden: a met\u00f3dus t\u00f6rzs\u00f6n bel\u00fcli v\u00e1ltoz\u00e1sokon k\u00edv\u00fcl mindig \u00fajraind\u00edt\u00e1s lesz sz\u00fcks\u00e9ges. Megold\u00e1s 4.a feladat Nyissuk meg a dao package-ben l\u00e9v\u0151 ProductRepository interf\u00e9szt, amely a Spring Data-s JpaRepository -b\u00f3l sz\u00e1rmazik (\u00e9s az egyel\u0151re \u00fcres ProductRepositoryCustom -b\u00f3l). Tal\u00e1lunk benne k\u00e9s\u0151bbi feladathoz kapcsol\u00f3d\u00f3 met\u00f3dusokat, azokat csak figyelj\u00fck meg. Valamelyik @Query annot\u00e1ci\u00f3val defini\u00e1lja a futtatand\u00f3 lek\u00e9rdez\u00e9st, valamelyikn\u00e9l az is hi\u00e1nyzik. Nek\u00fcnk sem lesz sz\u00fcks\u00e9g @Query annot\u00e1ci\u00f3ra, mert a met\u00f3dus neve alapj\u00e1n a Spring Data k\u00e9pes kital\u00e1lni a query-t. Tegy\u00fck teh\u00e1t bele ezt az \u00faj met\u00f3dust: package hu.bme.aut.adatvez.webshop.dao ; import java.math.BigDecimal ; import java.util.List ; import hu.bme.aut.adatvez.webshop.model.Product ; import org.springframework.data.jpa.repository.JpaRepository ; public interface ProductRepository extends JpaRepository < Product , Long > , ProductRepositoryCustom { ... List < Product > findByStockGreaterThan ( BigDecimal limit ); } A WebshopController -ben m\u00e1r be van injekt\u00e1lva egy ProductRepository t\u00edpus\u00fa tagv\u00e1ltoz\u00f3, h\u00edvjuk meg rajta a met\u00f3dust az 4.a TODO-n\u00e1l: @Controller public class WebshopController { @Autowired ProductRepository productRepository ; //... // 4.a feladat private List < Product > findProductsOver30 () { return productRepository . findByStockGreaterThan ( BigDecimal . valueOf ( 30 )); } } 4.b feladat A dao package-ben l\u00e9v\u0151 ProductRepositoryCustom interf\u00e9szbe vegy\u00fck fel egy findProductsOrderedAtLeastTwice nev\u0171 met\u00f3dust: package hu.bme.aut.adatvez.webshop.dao ; import hu.bme.aut.adatvez.webshop.model.Product ; import java.util.List ; public interface ProductRepositoryCustom { List < Product > findProductsOrderedAtLeastTwice (); } A dao package-ben l\u00e9v\u0151 ProductRepositoryImpl oszt\u00e1ly hib\u00e1s lesz emiatt, mert nem implement\u00e1lja a ProductRepositoryCustom -ot. Nyissuk meg az oszt\u00e1lyt, \u00e9s az oszt\u00e1ly elej\u00e9n, a sor elej\u00e9n megjelen\u0151 kis villanyk\u00f6rt\u00e9re kattintva belegener\u00e1ltathatjuk a nem implement\u00e1lt met\u00f3dus v\u00e1z\u00e1t: Ut\u00e1na a t\u00f6rzsbe \u00edrhatjuk az implement\u00e1ci\u00f3t, melynek l\u00e9nyege: injekt\u00e1lt EntityManager-rel hozzuk l\u00e9tre \u00e9s futtatjuk le a query-t. (Most l\u00e1tszik igaz\u00e1n, hogy az el\u0151z\u0151, Spring Data-s megold\u00e1s mennyi boilerplate k\u00f3dot sp\u00f3rolt meg nek\u00fcnk.) package hu.bme.aut.adatvez.webshop.dao ; import hu.bme.aut.adatvez.webshop.model.Product ; import java.util.List ; import javax.persistence.EntityManager ; import javax.persistence.PersistenceContext ; public class ProductRepositoryImpl implements ProductRepositoryCustom { @PersistenceContext EntityManager em ; @Override public List < Product > findProductsOrderedAtLeastTwice (){ return em . createQuery ( \"SELECT DISTINCT p FROM Product p LEFT JOIN FETCH p.orderitems WHERE size(p.orderitems) >= :itemsMin\" , Product . class ) . setParameter ( \"itemsMin\" , 2 ) . getResultList (); } } Megjegyz\u00e9s a megold\u00e1shoz: az els\u0151 \u00f6tlet\u00fcnk ez lehetne: SELECT p FROM Product p WHERE size(p.orderitems) /= :itemsMin . \u00cdrjuk be \u00e9s pr\u00f3b\u00e1ljuk ki el\u0151bb ezt, ilyenkor viszont org.hibernate.LazyInitializationException dob\u00f3dik tesztel\u00e9skor, mert lecsatolt \u00e1llapotban akarunk kapcsol\u00f3d\u00f3 entit\u00e1st el\u00e9rni (amikor a t\u00e1bl\u00e1zatot gener\u00e1lja a webr\u00e9teg, \u00e9s a orderitems list\u00e1ra hivatkozunk). Lehets\u00e9ges megold\u00e1sok: Az application.properties -ben spring.jpa.open-in-view=true (ez lenne am\u00fagy a default Spring Boot eset\u00e9ben, de a p\u00e9lda projektben direkt false-ra van \u00e1ll\u00edtva): Ilyenkor az EntityManager m\u00e1r a webes k\u00e9r\u00e9s legelej\u00e9n l\u00e9trej\u00f6n, \u00e9s csak a view renderel\u00e9se ut\u00e1n z\u00e1r\u00f3dik be, vagyis a Spring bean-beli met\u00f3dusok visszat\u00e9r\u00e9se ut\u00e1n is menedzselt \u00e1llapotban lenne a Product entit\u00e1s, \u00e9s el lehetne k\u00e9rni a kapcsol\u00f3d\u00f3 orderitems list\u00e1t. vagy @OneToMany(fetch=EAGER) a orderitems v\u00e1ltoz\u00f3ra vagy EntityGraph defini\u00e1l\u00e1sa \u00e9s annak alkalmaz\u00e1sa a query l\u00e9trehoz\u00e1sakor vagy LEFT JOIN FETCH , mi ezt v\u00e1lasztottuk a fenti megold\u00e1sban. E mell\u00e9 a DISTINCT is kell, k\u00fcl\u00f6nben minden kapcsol\u00f3d\u00f3 Orderitem p\u00e9ld\u00e1nyra k\u00fcl\u00f6n Product sor is lesz. A megh\u00edv\u00e1s a WebshopController -ben trivi\u00e1lis: // 4.b feladat private List < Product > findProductsOrderedAtLeastTwice () { // TODO return productRepository . findProductsOrderedAtLeastTwice (); } 4.c feladat A Product oszt\u00e1lyt nyissuk meg, ott a gyorsabb halad\u00e1s \u00e9rdek\u00e9ben m\u00e1r fogunk tal\u00e1lni k\u00e9sz named query-ket, a m\u00e1sodikat kell haszn\u00e1lnunk: @NamedQueries ({ @NamedQuery ( name = \"Product.findAll\" , query = \"SELECT p FROM Product p\" ), @NamedQuery ( name = \"Product.findMostExpensive\" , query = \"SELECT p FROM Product p WHERE p.price IN (SELECT MAX(p2.price) FROM Product p2)\" ) }) A named query-t k\u00e9t m\u00f3don is megh\u00edvhatjuk. Ha lass\u00fa a halad\u00e1s, el\u00e9g az els\u0151 m\u00f3dszerrel megcsin\u00e1lni. Az els\u0151 m\u00f3dszer, hogy a named query-vel egyez\u0151 nev\u0171 met\u00f3dust tesz\u00fcnk a ProductRepository -ba (lesz\u00e1m\u00edtva a Product. el\u0151tagot.) Vagyis: public List < Product > findMostExpensive (); A m\u00e1sik lehet\u0151s\u00e9g, hogy a ProductRepositoryImpl -ben, EntityManager -en kereszt\u00fcl h\u00edvjuk meg a named query-t: @Override public List < Product > findMostExpensiveProducts (){ return em . createNamedQuery ( \"Product.findMostExpensive\" , Product . class ). getResultList (); } Ilyenkor ezt a met\u00f3dust ki kell m\u00e9g tenni a ProductRepositoryCustom interf\u00e9szbe. Leggyorsabb \u00edgy: Jobb klikk / Refactor / Pull up , \u00e9s ott a met\u00f3dus kiv\u00e1laszthat\u00f3 V\u00e9g\u00fcl valamelyik verzi\u00f3t h\u00edvjuk meg a WebshopController megfelel\u0151 pontj\u00e1n: // 4.c feladat private List < Product > findMostExpensiveProducts () { // TODO // return productRepository.findMostExpensiveProducts(); return productRepository . findMostExpensive (); } Feladat 5: Adatm\u00f3dos\u00edt\u00e1s \u00b6 A JPA nemcsak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl m\u00f3dos\u00edt\u00e1sok is v\u00e9grehajthat\u00f3ak. a) \u00cdrj olyan JPQL lek\u00e9rdez\u00e9st a ProductRepository interf\u00e9szbe, mely a \"Building items\" \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal! b) \u00cdrj egy olyan met\u00f3dust, amely l\u00e9trehoz egy \u00faj kateg\u00f3ri\u00e1t \"Expensive toys\" n\u00e9vvel, ha m\u00e9g nem l\u00e9tezik ilyen, \u00e9s sorold \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft! c) Egyszer\u0171 \u00f6n\u00e1ll\u00f3 feladat: az 5.b feladat k\u00f6z\u00f6s megold\u00e1s\u00e1ban egy EntityManager -en kereszt\u00fcl lefuttatott lek\u00e9rdez\u00e9ssel ellen\u0151rizz\u00fck, hogy l\u00e9tezik-e \"Expensive toys\" nev\u0171 kateg\u00f3ria. Val\u00f3s\u00edtsd meg ugyanezt a lek\u00e9rdez\u00e9st Spring Data repository interf\u00e9szben, met\u00f3dus n\u00e9vb\u0151l sz\u00e1rmaztatott lek\u00e9rdez\u00e9ssel, \u00e9s h\u00edvd meg a megfelel\u0151 ponton. Megold\u00e1s 5.a feladat A ProductRepository interf\u00e9szben egy UPDATE query -t defini\u00e1lunk. Azt, hogy ez m\u00f3dos\u00edt\u00f3 query, k\u00f6z\u00f6lni kell a Spring Data-val ( @Modifying ), valamint tranzakci\u00f3ba is kell tenn\u00fcnk @Transactional , az org.springframework... package-b\u0151l): @Modifying @Transactional @Query ( \"UPDATE Product p SET p.price=p.price*1.1 WHERE p.id IN (SELECT p2.id FROM Product p2 WHERE p2.category.name=:categoryName)\" ) void categoryRaisePrice ( @Param ( \"categoryName\" ) String categoryName ); Megh\u00edv\u00e1sa a WebshopController -b\u0151l: // 5.a feladat @RequestMapping ( value = \"/raisePriceOfBuildingItems\" , method = { RequestMethod . POST , RequestMethod . GET }) private String raisePriceOfBuildingItems () { // TODO productRepository . categoryRaisePrice ( \"Building items\" ); return \"redirect:/\" ; } B\u00f6ng\u00e9sz\u0151ben a gomb megnyom\u00e1sa ut\u00e1n a gomb alatti t\u00e1bl\u00e1zatban l\u00e1tsz\u00f3dik az \u00e1t\u00e1raz\u00e1s hat\u00e1sa. 5.b feladat A dao package-be \u00faj oszt\u00e1ly, CategoryService n\u00e9ven, @Service annot\u00e1ci\u00f3val, szint\u00e9n @Transactional met\u00f3dussal: @Service public class CategoryService { @PersistenceContext private EntityManager em ; @Autowired ProductRepository productRepository ; @Transactional public void moveToExpensiveToys ( double priceLimit ){ String name = \"Expensive toys\" ; Category categoryExpensive = null ; List < Category > resultList = em . createQuery ( \"SELECT c from Category c WHERE c.name=:name\" , Category . class ) . setParameter ( \"name\" , name ) . getResultList (); if ( resultList . isEmpty ()){ //0 vagy null id \u00e9rt\u00e9k eset\u00e9n fog a @GeneratedValue m\u0171k\u00f6d\u00e9sbe l\u00e9pni. Most primit\u00edv long az id-nk, az csak 0 tud lenni, null nem. categoryExpensive = new Category ( 0 , name ); em . persist ( categoryExpensive ); } else { categoryExpensive = resultList . get ( 0 ); } List < Product > expensiveProducts = productRepository . findByPriceGreaterThan ( priceLimit ); for ( Product product : expensiveProducts ) { categoryExpensive . addProduct ( product ); } } } Figyelj\u00fck meg, hogy a menedzselt entit\u00e1s p\u00e9ld\u00e1nyokat (amit tranzakci\u00f3n bel\u00fcl tal\u00e1lunk meg query-vel, vagy most persist-\u00e1ltunk frissen) nem kell explicit m\u00f3don visszamenteni, tranzakci\u00f3 v\u00e9g\u00e9n automatikusan DB-be \u00edr\u00f3dnak a mem\u00f3riabeli v\u00e1ltoz\u00e1sok. Megh\u00edv\u00e1s a WebshopController -b\u0151l: @Autowired CategoryService categoryService ; ... // 5.b feladat @RequestMapping ( value = \"/moveToExpensiveToys\" , method = { RequestMethod . POST , RequestMethod . GET }) private String moveToExpensiveToys () { // TODO categoryService . moveToExpensiveToys ( 8000.0 ); return \"redirect:/\" ; } B\u00f6ng\u00e9sz\u0151ben a gomb megnyom\u00e1sa ut\u00e1n l\u00e1tsz\u00f3dik a Dr\u00e1ga j\u00e1t\u00e9kok kateg\u00f3ria tartalma 5.c feladat A dao package-be \u00faj interf\u00e9sz, CategoryRepository n\u00e9ven, a ProductRepository mint\u00e1j\u00e1ra (a Custom-os lesz\u00e1rmaz\u00e1s nem kell, mert nem lesznek custom lek\u00e9rdez\u00e9seink) egy met\u00f3dussal: public interface CategoryRepository extends JpaRepository < Category , Long > { List < Category > findByName ( String name ); } Ezut\u00e1n a CategoryService \u00edgy egyszer\u0171s\u00f6dik le: @Service public class CategoryService { ... @Autowired CategoryRepository categoryRepository ; @Transactional public void moveToExpensiveToys ( double priceLimit ){ // ... List < Category > resultList = categoryRepository . findByName ( name ); // ... } } Feladat 6: T\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata \u00b6 H\u00edvd meg a JPA-b\u00f3l a CreateNewPaymentMethod nev\u0171 t\u00e1rolt elj\u00e1r\u00e1st, mely \u00faj fizet\u00e9si m\u00f3d r\u00f6gz\u00edt\u00e9s\u00e9re szolg\u00e1l, \u00e9s visszaadja az \u00faj rekord azonos\u00edt\u00f3j\u00e1t! Az SQL Server Management Studioban ellen\u0151rizz\u00fck, hogy az adatb\u00e1zis tartalmazza-e a CreateNewPaymentMethod nev\u0171 t\u00e1rolt elj\u00e1r\u00e1st! Ha nem, akkor az al\u00e1bbi k\u00f3dot futtasd le a Management Studioban a t\u00e1rolt elj\u00e1r\u00e1s l\u00e9trehoz\u00e1s\u00e1hoz! CREATE PROCEDURE CreateNewPaymentMethod ( @ Method nvarchar ( 20 ), @ Deadline int ) AS insert into PaymentMethod values ( @ Method , @ Deadline ) select scope_identity () as NewId Megold\u00e1s A PaymentMethod entit\u00e1son megtal\u00e1ljuk az al\u00e1bbi annot\u00e1ci\u00f3t. Vess\u00fck \u00f6ssze a t\u00e1rolt elj\u00e1r\u00e1st defini\u00e1l\u00f3 k\u00f3ddal a v\u00e1ltoz\u00f3 neveket! @NamedStoredProcedureQueries ({ @NamedStoredProcedureQuery ( name = \"createMethodSP\" , procedureName = \"CreateNewPaymentMethod\" , parameters = { @StoredProcedureParameter ( mode = ParameterMode . IN , name = \"Method\" , type = String . class ), @StoredProcedureParameter ( mode = ParameterMode . IN , name = \"Deadline\" , type = BigDecimal . class ) }) }) public class Paymentmethod implements Serializable { ... A named stored procedure query megh\u00edvhat\u00f3 Spring Data repositoryb\u00f3l ( dao package-en New Interface ... / PaymentmethodRepository ): public interface PaymentmethodRepository extends JpaRepository < Paymentmethod , Long > { @Procedure ( name = \"createMethodSP\" ) void newMethod ( @Param ( \"Method\" ) String method , @Param ( \"Deadline\" ) BigDecimal deadline ); } Spring Data n\u00e9lk\u00fcl \u00edgy menne, EntityManager -en kereszt\u00fcl, erre val\u00f3sz\u00edn\u0171leg m\u00e1r nem lesz id\u0151: @Service public class PaymentmethodService { @PersistenceContext private EntityManager em ; public void createNewMethod ( Paymentmethod paymentMethod ){ StoredProcedureQuery sp = em . createNamedStoredProcedureQuery ( \"createMethodSP\" ); sp . setParameter ( \"Method\" , paymentMethod . getMethod ()); sp . setParameter ( \"Deadline\" , paymentMethod . getDeadline ()); sp . execute (); } } A webr\u00e9tegbeli megh\u00edv\u00e1s: Injekt\u00e1ljuk a WebshopController -be a PaymentmethodRepository interf\u00e9szt: @Autowired PaymentmethodRepository paymentmethodRepository ; A WebshopController utols\u00f3 TODO-j\u00e1n\u00e1l h\u00edvjuk meg paymentmethodRepository . newMethod ( paymentMethod . getMethod (), paymentMethod . getDeadline ()); A Paymentmethod entit\u00e1s deadline \u00e9s method tagv\u00e1ltoz\u00f3in valid\u00e1ci\u00f3s constraint -eket tal\u00e1lunk. Ezek az annot\u00e1ci\u00f3k a Bean Validation API r\u00e9szei, amivel a webes r\u00e9tegben haszn\u00e1lt Spring MVC, de a JPA \u00e9s integr\u00e1l\u00f3dik, \u00edgy a webr\u00e9tegbeli \u00e9s adatr\u00e9tegbeli valid\u00e1ci\u00f3 konzisztens m\u00f3don, redundanciamentesen defini\u00e1lhat\u00f3. @NotNull private BigDecimal deadline ; @Column ( name = \"METHOD\" ) @NotEmpty private String method ;","title":"JPA & Spring Data"},{"location":"gyakorlat/jpa/#jpa-spring-data","text":"A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a JPA \u00e9s a Spring Data haszn\u00e1lat\u00e1t. A f\u0151bb t\u00e9m\u00e1k: entit\u00e1sok fejleszt\u00e9se, lek\u00e9rdez\u00e9sek megfogalmaz\u00e1sa k\u00fcl\u00f6nb\u00f6z\u0151 m\u00f3dokon, m\u00f3dos\u00edt\u00e1sok v\u00e9grehajt\u00e1sa. A k\u00f3dokat egy webalkalmaz\u00e1s projektbe integr\u00e1ljuk, amiben a projekt alapvet\u0151 konfigur\u00e1ci\u00f3ja \u00e9s egy tesztel\u00e9shez haszn\u00e1lhat\u00f3 egyszer\u0171 webes fel\u00fcletet m\u00e1r k\u00e9szen \u00e1ll.","title":"JPA &amp; Spring Data"},{"location":"gyakorlat/jpa/#elofeltetelek","text":"A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Eclipse for Java EE Microsoft SQL Server Express edition (localdb ez\u00fattal nem j\u00f3) SQL Server Management Studio Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Kiindul\u00f3 webalkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-jpa-kiindulo","title":"El\u0151felt\u00e9telek"},{"location":"gyakorlat/jpa/#amit-erdemes-atnezned","text":"JPA el\u0151ad\u00e1s EJB, Spring el\u0151ad\u00e1s","title":"Amit \u00e9rdemes \u00e1tn\u00e9zned"},{"location":"gyakorlat/jpa/#gyakorlat-menete","text":"A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!","title":"Gyakorlat menete"},{"location":"gyakorlat/jpa/#tippek-az-eclipse-hasznalatahoz","text":"T\u00edpus (oszt\u00e1ly, interf\u00e9sz, enum) keres\u00e9se: Ctrl+Shift+T (Nem \u00e9rdemes a Project explorer-ben a mapp\u00e1kat nyitogatni) F\u00e1jl keres\u00e9se: Ctrl+Shift+R Hi\u00e1nyz\u00f3 importok megjav\u00edt\u00e1sa: Ctrl+Shift+O K\u00f3d form\u00e1z\u00e1sa: Ctrl+Shift+F Ha a Java Resources alatt egy package-en jobb klikk / New Class/Interfaces, akkor abba a package-be rakja az \u00faj elemet Ha a n\u00e9zeteket becsukjuk/\u00e1trendezz\u00fck, a default elrendez\u00e9s vissza\u00e1ll\u00edthat\u00f3: Window / Reset perspective Font megn\u00f6vel\u00e9se (a tan\u00e1ri g\u00e9pen hasznos): Window men\u00fc / Preferences, ott elkezdj\u00fck g\u00e9pelni, hogy font , \u00edgy megtal\u00e1lja azt a be\u00e1ll\u00edt\u00e1st, hogy Fonts and Colors Azt kiv\u00e1lasztva, a Basic kateg\u00f3ria alatt kell a Text Fontot kijel\u00f6lni, \u00e9s a m\u00e9ret\u00e9t pl. 18-asra \u00e1ll\u00edtani","title":"Tippek az Eclipse haszn\u00e1lat\u00e1hoz"},{"location":"gyakorlat/jpa/#feladat-0-adatbazis-letrehozasa","text":"Csatlakozzunk Microsoft SQL Server Management Studio -val a szerverhez. Ez\u00fattal nem localdb -t haszn\u00e1lunk, a szerver c\u00edme: localhost\\sqlexpress . A bejelentkez\u00e9shez SQL Server Authentication m\u00f3dot v\u00e1lasszuk. Hozzunk l\u00e9tre egy adatvez nev\u0171 adatb\u00e1zist. \u00dcgyelj\u00fcnk a n\u00e9vre, k\u00fcl\u00f6nben a Java projektben m\u00f3dos\u00edtanunk kell . Az adatb\u00e1zis l\u00e9trehoz\u00e1s\u00e1nak mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban . Ha a g\u00e9pen m\u00e1r l\u00e9tezik az adatb\u00e1zis, akkor nem kell \u00fajat l\u00e9trehozni. Futtassuk le az adatb\u00e1zis inicializ\u00e1l\u00f3 sql szkriptet az adatb\u00e1zisban. Akkor is futtassuk le a szkriptet, ha m\u00e1r l\u00e9tezne az adatb\u00e1zis (hogy a kezdeti \u00e1llapotot visszakapjuk.)","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa"},{"location":"gyakorlat/jpa/#feladat-1-eclipse-inditasa","text":"Ind\u00edtsuk el az Eclipse-et innen: C:\\work\\javaee\\eclipse\\eclipse.exe . (Fontos, hogy lehet egy D:\\eclipse mappa is, nek\u00fcnk nem az kell.) Ind\u00edt\u00e1skor megk\u00e9rdezi, hova akarunk dolgozni (workspace), itt v\u00e1lasszuk ezt: C:\\work\\javaee\\workspaces\\adatvez Ha az indul\u00e1s ut\u00e1n a Project Explorer-ben ott van egy kor\u00e1bbi gyakorlatr\u00f3l a webshop nev\u0171 projekt, azt t\u00f6r\u00f6lj\u00fck ki: a projekten jobb klikk / Delete , amikor r\u00e1k\u00e9rdez, pip\u00e1ljuk be, hogy a f\u00e1jlrendszerr\u0151l is t\u00f6rl\u0151dj\u00f6n.","title":"Feladat 1: Eclipse ind\u00edt\u00e1sa"},{"location":"gyakorlat/jpa/#feladat-2-projekt-importalasa","text":"T\u00f6lts\u00fck le a m\u00e9r\u00e9shez tartoz\u00f3 projekt v\u00e1zat! Nyissunk egy command prompt -ot Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN Adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone --depth 1 https://github.com/bmeviauac01/gyakorlat-jpa-kiindulo.git Import\u00e1ljuk a let\u00f6lt\u00f6tt forr\u00e1sk\u00f3dot a workspace-be: Nyissuk meg a File / Import... -ot Kezdj\u00fck el g\u00e9pelni a textboxba, hogy Existing projects into workspace , \u00edgy r\u00e1 fog sz\u0171rni \u00e9s v\u00e1lasszuk ki ezt Keress\u00fck meg a let\u00f6lt\u00f6tt webshop projektet (a webshop mapp\u00e1t a saj\u00e1t k\u00f6nyvt\u00e1runk alatt), OK, ut\u00e1na a dialogban pip\u00e1ljuk be a webshop-ot (lehet, hogy by default be lesz pip\u00e1lva) Finish Tekints\u00fck \u00e1t r\u00f6viden a projektet: Ez egy maven alap\u00fa projekt. A maven parancssori build eszk\u00f6z, ami IDE-khez is illeszthet\u0151. Fontos tulajdons\u00e1ga, hogy k\u00e9pes a sz\u00fcks\u00e9ges library f\u00fcgg\u0151s\u00e9geket online repository-kb\u00f3l let\u00f6lteni. Ha megnyitjuk a projekt gy\u00f6ker\u00e9ben pom.xml -t, a maven konfig f\u00e1jlj\u00e1t, dependency tagekben f\u00fcgg\u0151s\u00e9geket l\u00e1tunk, amik (tranzit\u00edv m\u00f3don) beh\u00fazz\u00e1k a Hibernate -et mint JPA implement\u00e1ci\u00f3t, a Spring Boot -ot, a Spring Data -t \u00e9s a webr\u00e9teghez sz\u00fcks\u00e9ges Spring MVC -t \u00e9s Thymeleaf -et. A laborban a maven offline m\u0171k\u00f6d\u00e9sre van konfigur\u00e1lva, \u00e9s el\u0151re le van t\u00f6ltve az \u00f6sszes f\u00fcgg\u0151s\u00e9g, \u00edgy megel\u0151zz\u00fck az esetleges h\u00e1l\u00f3zati probl\u00e9m\u00e1kat. Az application.properties -ben van p\u00e1r alapvet\u0151 be\u00e1ll\u00edt\u00e1s, itt a DB el\u00e9r\u00e9shez ellen\u0151rizz\u00fck a usernevet \u00e9s jelsz\u00f3t . Figyelj\u00fck meg az adatb\u00e1zis JNDI nev\u00e9nek be\u00e1ll\u00edt\u00e1s\u00e1hoz ezt a sort: spring.datasource.jndi-name=jdbc/termekDB . Klasszikus Java EE alkalmaz\u00e1sban ezt a persistence.xml -be \u00edrn\u00e1nk be, de a Spring Boot XML n\u00e9lk\u00fcli konfigur\u00e1ci\u00f3t is t\u00e1mogat, itt ezt haszn\u00e1ljuk ki. (Egy apr\u00f3s\u00e1g: a projektben m\u00e9gis van persistence.xml , ezt ig\u00e9nyli az Eclipse-es JPA plugin, aminek k\u00f6sz\u00f6nhet\u0151en pl. k\u00f3dkieg\u00e9sz\u00edt\u00e9s m\u0171k\u00f6dik a NamedQuery-kben. Viszont, mivel igaz\u00e1b\u00f3l nem haszn\u00e1lja az alkalmaz\u00e1sunk fut\u00e1s k\u00f6zben, \u00fcres a persistence.xml.) A ConnectionProperties az el\u0151z\u0151 konfig f\u00e1jl egy r\u00e9sz\u00e9nek Java-beli reprezent\u00e1ci\u00f3ja A WebshopApplication a Spring Boot alkalmaz\u00e1s bel\u00e9p\u00e9si pontja \u00e9s konfigja is. Egy hagyom\u00e1nyos webalkalmaz\u00e1st egy k\u00fcl\u00f6n processzben fut\u00f3 webkont\u00e9nerre (pl. Tomcat, Jetty) kellene telep\u00edteni. Spring Boot-os fejleszt\u00e9s eset\u00e9ben viszont maga a Spring Boot fog elind\u00edtani egy be\u00e1gyazott webkont\u00e9nert (alap\u00e9rtelmez\u00e9sben Tomcat-et). A tomcatFactory met\u00f3dusban regisztr\u00e1ljuk be az SQL Server JDBC driver\u00e9t jdbc/termekDB JNDI n\u00e9ven, hogy a JPA majd megtal\u00e1lja. Ha nem adatvez az adatb\u00e1zisunk neve, akkor a JDBC URL-t m\u00f3dos\u00edtani kell a megfelel\u0151 sorn\u00e1l: resource.setProperty(\"url\", \"jdbc:sqlserver://localhost;database= adatvez \"); A webes fel\u00fclet egyetlen oldal, az src\\main\\resources\\templates\\testPage.html . Ebbe nem fogunk majd beleny\u00falni. Standard html + Thymeleaf-es attrib\u00fatumok l\u00e1taht\u00f3ak benne. WebshopController : a webr\u00e9teget megval\u00f3s\u00edt\u00f3 controller oszt\u00e1ly, ennek met\u00f3dusai kezelik az alkalmaz\u00e1shoz \u00e9rkez\u0151 HTTP k\u00e9r\u00e9seket. Jellemz\u0151en lek\u00e9rdez\u00e9sek eredm\u00e9ny\u00e9t akarjuk megjelen\u00edteni az oldalon, ez\u00e9rt a lek\u00e9rdez\u00e9s eredm\u00e9ny\u00e9t a modellbe tessz\u00fck valamilyen n\u00e9ven, amire hivatkozni tudunk a Thymeleaf seg\u00edts\u00e9g\u00e9vel. A //TODO r\u00e9szekre kell majd bek\u00f6tni az egyes feladatokat megval\u00f3s\u00edt\u00f3 met\u00f3dusok megh\u00edv\u00e1s\u00e1t.","title":"Feladat 2: Projekt import\u00e1l\u00e1sa"},{"location":"gyakorlat/jpa/#feladat-3-entitasok-attekintese","text":"Az entit\u00e1sok m\u00e1r el\u0151re k\u00e9szen a hu.bme.aut.adatvez.webshop.model package-ben tal\u00e1lhat\u00f3k. Ezeket \u00e1ltal\u00e1ban vagy k\u00e9zzel \u00edrjuk meg, vagy gener\u00e1ljuk a DB t\u00e1bl\u00e1kb\u00f3l pl. az Eclipse-es JPA plugin seg\u00edts\u00e9g\u00e9vel. Az entit\u00e1sok k\u00f6z\u00fcl nyissunk meg egyet, pl. Vat , l\u00e1tszik benne a @Entity , a @Id annot\u00e1ci\u00f3, illetve a kapcsolatok defini\u00e1l\u00e1s\u00e1ra @OneToMany vagy @ManyToOne Az entit\u00e1sokhoz a Criteria API haszn\u00e1latakor hasznos metamodel oszt\u00e1lyok is gener\u00e1l\u00f3dnak, ezekb\u0151l n\u00e9zz\u00fcnk meg egyet a target\\generated-sources\\apt alatt (A pom.xml -ben l\u00e1that\u00f3 maven-precessor-plugin gener\u00e1lja egy\u00e9bk\u00e9nt \u0151ket a build sor\u00e1n.)","title":"Feladat 3: Entit\u00e1sok \u00e1ttekint\u00e9se"},{"location":"gyakorlat/jpa/#feladat-4-lekerdezesek","text":"A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket! A lek\u00e9rdez\u00e9seket JPA \u00e9s Spring Data haszn\u00e1lata eset\u00e9n t\u00f6bb m\u00f3don is megval\u00f3s\u00edthatjuk. Az al\u00e1bbi feladatokban azt is megadjuk, milyen m\u00f3don kell elk\u00e9sz\u00edteni a lek\u00e9rdez\u00e9st, hogy mindegyikre l\u00e1ssunk p\u00e9ld\u00e1t. Fontos megjegyezni, hogy ezek a m\u00f3dszerre vonatkoz\u00f3 megk\u00f6t\u00e9sek csak oktat\u00e1si szempontok miatt szerepelnek, val\u00f3j\u00e1ban b\u00e1rmelyik m\u00f3dszerrel b\u00e1rmelyik lek\u00e9rdez\u00e9s megval\u00f3s\u00edthat\u00f3 lenne. Az egyes feladatokat megval\u00f3s\u00edt\u00f3 met\u00f3dusokat mindig a WebshopController oszt\u00e1ly megfelel\u0151 //TODO kommentjein\u00e9l kell megh\u00edvni, majd a webalkalmaz\u00e1st futtatni \u00e9s b\u00f6ng\u00e9sz\u0151b\u0151l tesztelni a http://localhost:9080 URL-en. a) List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron! M\u00f3dszer: Spring Data repository interf\u00e9sz, met\u00f3dusn\u00e9vb\u0151l sz\u00e1rmaztatott lek\u00e9rdez\u00e9s. b) \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek! M\u00f3dszer: Spring Data repository custom implement\u00e1ci\u00f3val, injekt\u00e1lt EntityManagerrel k\u00e9sz\u00edtett JPQL query. c) List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait! M\u00f3dszer: Named query, amelyet Spring Data repository-b\u00f3l h\u00edvunk meg, vagy custom implement\u00e1ci\u00f3b\u00f3l, injekt\u00e1lt EntityManagerrel h\u00edvunk meg, vagy a met\u00f3dusn\u00e9v \u00e9s query n\u00e9v egyez\u00e9se alapj\u00e1n. Fut\u00e1s k\u00f6zben a Console n\u00e9zetben l\u00e1tsz\u00f3dnak a Hibernate \u00e1ltal gener\u00e1lt SQL utas\u00edt\u00e1sok az application.properties -beli spring.jpa.show-sql=true konfig miatt.","title":"Feladat 4: Lek\u00e9rdez\u00e9sek"},{"location":"gyakorlat/jpa/#futtatas","text":"A projektben megtal\u00e1lhat\u00f3 (a legals\u00f3 f\u00e1jl a Project Explorerben) a webshop run.launch nev\u0171 konfig f\u00e1jl. Ezen jobb klikk / Debug As / webshop run . Ez debug m\u00f3dban ind\u00edtja a Spring Boot maven plugin-t, aminek hat\u00e1s\u00e1ra a be\u00e1gyazott webkont\u00e9ner elindul, \u00e9s b\u00f6ng\u00e9sz\u0151b\u0151l a http://localhost:9080 URL-en el\u00e9rhet\u0151 az alkalmaz\u00e1s. Ha ezt egyszer jobb klikkel megcsin\u00e1ltuk, akkor k\u00e9s\u0151bb a toolbar Debug ikonj\u00e1t lenyitva is megtehetj\u00fck: Ha a Debug ikon alatt m\u00e1r ott van a webshop run , akkor az eg\u00e9sz fentebb le\u00edrt webshop run.launch -os m\u00f3dszer sz\u00fcks\u00e9gtelen. A fut\u00f3 alkalmaz\u00e1st a Console n\u00e9zet piros Terminate ikonj\u00e1val lehet le\u00e1ll\u00edtani. Ha le\u00e1ll\u00edt\u00e1s n\u00e9lk\u00fcl pr\u00f3b\u00e1ljuk \u00fajra futtatni, akkor a m\u00e1sodik processz \u00fctk\u00f6z\u00e9st jelent a 8080-as porton, \u00e9s le\u00e1ll. Ilyenkor a sikertelen m\u00e1sodik futtat\u00e1s l\u00e1tszik a Console n\u00e9zetben, a Terminate gomb pedig inakt\u00edv, mivel ez a fut\u00e1s m\u00e1r le\u00e1llt. Nyomjuk meg a Terminate ikon melletti dupla sz\u00fcrke X ikont, ez el fogja t\u00e1vol\u00edtani a m\u00e1r le\u00e1ll\u00edtott futtat\u00e1sokat, \u00e9s csak az akt\u00edv futtat\u00e1s l\u00e1tszik, amin viszont m\u00e1r tudunk Terminate -et nyomni. Ha a teljes Console n\u00e9zetet bez\u00e1rjuk v\u00e9letlen\u00fcl, el\u0151 lehet szedni Alt+Shift+Q, C gyorsbillenyt\u0171vel, vagy Window / Show View / Console men\u00fcvel. A le\u00e1ll\u00edt\u00e1s ut\u00e1ni \u00fajrafuttat\u00e1shoz az F11-et is haszn\u00e1lhatjuk. A debug m\u00f3dban val\u00f3 futtat\u00e1s jellegzetess\u00e9ge, hogy a HTML \u00e9s bizonyos Java k\u00f3d m\u00f3dos\u00edt\u00e1sok azonnal \u00e9letbe l\u00e9pnek. (A b\u00f6ng\u00e9sz\u0151t persze friss\u00edteni kell.) \u00dajra kell viszont ind\u00edtani az alkalmaz\u00e1st, ha a Java k\u00f3dban: \u00faj t\u00edpust adtunk hozz\u00e1 annot\u00e1ci\u00f3t adtunk hozz\u00e1/t\u00f6r\u00f6lt\u00fcnk/m\u00f3dos\u00edtottunk \u00faj oszt\u00e1ly- vagy tagv\u00e1ltoz\u00f3t, met\u00f3dust vett\u00fcnk fel met\u00f3dus szignat\u00far\u00e1t m\u00f3dos\u00edtottunk R\u00f6viden: a met\u00f3dus t\u00f6rzs\u00f6n bel\u00fcli v\u00e1ltoz\u00e1sokon k\u00edv\u00fcl mindig \u00fajraind\u00edt\u00e1s lesz sz\u00fcks\u00e9ges. Megold\u00e1s 4.a feladat Nyissuk meg a dao package-ben l\u00e9v\u0151 ProductRepository interf\u00e9szt, amely a Spring Data-s JpaRepository -b\u00f3l sz\u00e1rmazik (\u00e9s az egyel\u0151re \u00fcres ProductRepositoryCustom -b\u00f3l). Tal\u00e1lunk benne k\u00e9s\u0151bbi feladathoz kapcsol\u00f3d\u00f3 met\u00f3dusokat, azokat csak figyelj\u00fck meg. Valamelyik @Query annot\u00e1ci\u00f3val defini\u00e1lja a futtatand\u00f3 lek\u00e9rdez\u00e9st, valamelyikn\u00e9l az is hi\u00e1nyzik. Nek\u00fcnk sem lesz sz\u00fcks\u00e9g @Query annot\u00e1ci\u00f3ra, mert a met\u00f3dus neve alapj\u00e1n a Spring Data k\u00e9pes kital\u00e1lni a query-t. Tegy\u00fck teh\u00e1t bele ezt az \u00faj met\u00f3dust: package hu.bme.aut.adatvez.webshop.dao ; import java.math.BigDecimal ; import java.util.List ; import hu.bme.aut.adatvez.webshop.model.Product ; import org.springframework.data.jpa.repository.JpaRepository ; public interface ProductRepository extends JpaRepository < Product , Long > , ProductRepositoryCustom { ... List < Product > findByStockGreaterThan ( BigDecimal limit ); } A WebshopController -ben m\u00e1r be van injekt\u00e1lva egy ProductRepository t\u00edpus\u00fa tagv\u00e1ltoz\u00f3, h\u00edvjuk meg rajta a met\u00f3dust az 4.a TODO-n\u00e1l: @Controller public class WebshopController { @Autowired ProductRepository productRepository ; //... // 4.a feladat private List < Product > findProductsOver30 () { return productRepository . findByStockGreaterThan ( BigDecimal . valueOf ( 30 )); } } 4.b feladat A dao package-ben l\u00e9v\u0151 ProductRepositoryCustom interf\u00e9szbe vegy\u00fck fel egy findProductsOrderedAtLeastTwice nev\u0171 met\u00f3dust: package hu.bme.aut.adatvez.webshop.dao ; import hu.bme.aut.adatvez.webshop.model.Product ; import java.util.List ; public interface ProductRepositoryCustom { List < Product > findProductsOrderedAtLeastTwice (); } A dao package-ben l\u00e9v\u0151 ProductRepositoryImpl oszt\u00e1ly hib\u00e1s lesz emiatt, mert nem implement\u00e1lja a ProductRepositoryCustom -ot. Nyissuk meg az oszt\u00e1lyt, \u00e9s az oszt\u00e1ly elej\u00e9n, a sor elej\u00e9n megjelen\u0151 kis villanyk\u00f6rt\u00e9re kattintva belegener\u00e1ltathatjuk a nem implement\u00e1lt met\u00f3dus v\u00e1z\u00e1t: Ut\u00e1na a t\u00f6rzsbe \u00edrhatjuk az implement\u00e1ci\u00f3t, melynek l\u00e9nyege: injekt\u00e1lt EntityManager-rel hozzuk l\u00e9tre \u00e9s futtatjuk le a query-t. (Most l\u00e1tszik igaz\u00e1n, hogy az el\u0151z\u0151, Spring Data-s megold\u00e1s mennyi boilerplate k\u00f3dot sp\u00f3rolt meg nek\u00fcnk.) package hu.bme.aut.adatvez.webshop.dao ; import hu.bme.aut.adatvez.webshop.model.Product ; import java.util.List ; import javax.persistence.EntityManager ; import javax.persistence.PersistenceContext ; public class ProductRepositoryImpl implements ProductRepositoryCustom { @PersistenceContext EntityManager em ; @Override public List < Product > findProductsOrderedAtLeastTwice (){ return em . createQuery ( \"SELECT DISTINCT p FROM Product p LEFT JOIN FETCH p.orderitems WHERE size(p.orderitems) >= :itemsMin\" , Product . class ) . setParameter ( \"itemsMin\" , 2 ) . getResultList (); } } Megjegyz\u00e9s a megold\u00e1shoz: az els\u0151 \u00f6tlet\u00fcnk ez lehetne: SELECT p FROM Product p WHERE size(p.orderitems) /= :itemsMin . \u00cdrjuk be \u00e9s pr\u00f3b\u00e1ljuk ki el\u0151bb ezt, ilyenkor viszont org.hibernate.LazyInitializationException dob\u00f3dik tesztel\u00e9skor, mert lecsatolt \u00e1llapotban akarunk kapcsol\u00f3d\u00f3 entit\u00e1st el\u00e9rni (amikor a t\u00e1bl\u00e1zatot gener\u00e1lja a webr\u00e9teg, \u00e9s a orderitems list\u00e1ra hivatkozunk). Lehets\u00e9ges megold\u00e1sok: Az application.properties -ben spring.jpa.open-in-view=true (ez lenne am\u00fagy a default Spring Boot eset\u00e9ben, de a p\u00e9lda projektben direkt false-ra van \u00e1ll\u00edtva): Ilyenkor az EntityManager m\u00e1r a webes k\u00e9r\u00e9s legelej\u00e9n l\u00e9trej\u00f6n, \u00e9s csak a view renderel\u00e9se ut\u00e1n z\u00e1r\u00f3dik be, vagyis a Spring bean-beli met\u00f3dusok visszat\u00e9r\u00e9se ut\u00e1n is menedzselt \u00e1llapotban lenne a Product entit\u00e1s, \u00e9s el lehetne k\u00e9rni a kapcsol\u00f3d\u00f3 orderitems list\u00e1t. vagy @OneToMany(fetch=EAGER) a orderitems v\u00e1ltoz\u00f3ra vagy EntityGraph defini\u00e1l\u00e1sa \u00e9s annak alkalmaz\u00e1sa a query l\u00e9trehoz\u00e1sakor vagy LEFT JOIN FETCH , mi ezt v\u00e1lasztottuk a fenti megold\u00e1sban. E mell\u00e9 a DISTINCT is kell, k\u00fcl\u00f6nben minden kapcsol\u00f3d\u00f3 Orderitem p\u00e9ld\u00e1nyra k\u00fcl\u00f6n Product sor is lesz. A megh\u00edv\u00e1s a WebshopController -ben trivi\u00e1lis: // 4.b feladat private List < Product > findProductsOrderedAtLeastTwice () { // TODO return productRepository . findProductsOrderedAtLeastTwice (); } 4.c feladat A Product oszt\u00e1lyt nyissuk meg, ott a gyorsabb halad\u00e1s \u00e9rdek\u00e9ben m\u00e1r fogunk tal\u00e1lni k\u00e9sz named query-ket, a m\u00e1sodikat kell haszn\u00e1lnunk: @NamedQueries ({ @NamedQuery ( name = \"Product.findAll\" , query = \"SELECT p FROM Product p\" ), @NamedQuery ( name = \"Product.findMostExpensive\" , query = \"SELECT p FROM Product p WHERE p.price IN (SELECT MAX(p2.price) FROM Product p2)\" ) }) A named query-t k\u00e9t m\u00f3don is megh\u00edvhatjuk. Ha lass\u00fa a halad\u00e1s, el\u00e9g az els\u0151 m\u00f3dszerrel megcsin\u00e1lni. Az els\u0151 m\u00f3dszer, hogy a named query-vel egyez\u0151 nev\u0171 met\u00f3dust tesz\u00fcnk a ProductRepository -ba (lesz\u00e1m\u00edtva a Product. el\u0151tagot.) Vagyis: public List < Product > findMostExpensive (); A m\u00e1sik lehet\u0151s\u00e9g, hogy a ProductRepositoryImpl -ben, EntityManager -en kereszt\u00fcl h\u00edvjuk meg a named query-t: @Override public List < Product > findMostExpensiveProducts (){ return em . createNamedQuery ( \"Product.findMostExpensive\" , Product . class ). getResultList (); } Ilyenkor ezt a met\u00f3dust ki kell m\u00e9g tenni a ProductRepositoryCustom interf\u00e9szbe. Leggyorsabb \u00edgy: Jobb klikk / Refactor / Pull up , \u00e9s ott a met\u00f3dus kiv\u00e1laszthat\u00f3 V\u00e9g\u00fcl valamelyik verzi\u00f3t h\u00edvjuk meg a WebshopController megfelel\u0151 pontj\u00e1n: // 4.c feladat private List < Product > findMostExpensiveProducts () { // TODO // return productRepository.findMostExpensiveProducts(); return productRepository . findMostExpensive (); }","title":"Futtat\u00e1s"},{"location":"gyakorlat/jpa/#feladat-5-adatmodositas","text":"A JPA nemcsak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl m\u00f3dos\u00edt\u00e1sok is v\u00e9grehajthat\u00f3ak. a) \u00cdrj olyan JPQL lek\u00e9rdez\u00e9st a ProductRepository interf\u00e9szbe, mely a \"Building items\" \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal! b) \u00cdrj egy olyan met\u00f3dust, amely l\u00e9trehoz egy \u00faj kateg\u00f3ri\u00e1t \"Expensive toys\" n\u00e9vvel, ha m\u00e9g nem l\u00e9tezik ilyen, \u00e9s sorold \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft! c) Egyszer\u0171 \u00f6n\u00e1ll\u00f3 feladat: az 5.b feladat k\u00f6z\u00f6s megold\u00e1s\u00e1ban egy EntityManager -en kereszt\u00fcl lefuttatott lek\u00e9rdez\u00e9ssel ellen\u0151rizz\u00fck, hogy l\u00e9tezik-e \"Expensive toys\" nev\u0171 kateg\u00f3ria. Val\u00f3s\u00edtsd meg ugyanezt a lek\u00e9rdez\u00e9st Spring Data repository interf\u00e9szben, met\u00f3dus n\u00e9vb\u0151l sz\u00e1rmaztatott lek\u00e9rdez\u00e9ssel, \u00e9s h\u00edvd meg a megfelel\u0151 ponton. Megold\u00e1s 5.a feladat A ProductRepository interf\u00e9szben egy UPDATE query -t defini\u00e1lunk. Azt, hogy ez m\u00f3dos\u00edt\u00f3 query, k\u00f6z\u00f6lni kell a Spring Data-val ( @Modifying ), valamint tranzakci\u00f3ba is kell tenn\u00fcnk @Transactional , az org.springframework... package-b\u0151l): @Modifying @Transactional @Query ( \"UPDATE Product p SET p.price=p.price*1.1 WHERE p.id IN (SELECT p2.id FROM Product p2 WHERE p2.category.name=:categoryName)\" ) void categoryRaisePrice ( @Param ( \"categoryName\" ) String categoryName ); Megh\u00edv\u00e1sa a WebshopController -b\u0151l: // 5.a feladat @RequestMapping ( value = \"/raisePriceOfBuildingItems\" , method = { RequestMethod . POST , RequestMethod . GET }) private String raisePriceOfBuildingItems () { // TODO productRepository . categoryRaisePrice ( \"Building items\" ); return \"redirect:/\" ; } B\u00f6ng\u00e9sz\u0151ben a gomb megnyom\u00e1sa ut\u00e1n a gomb alatti t\u00e1bl\u00e1zatban l\u00e1tsz\u00f3dik az \u00e1t\u00e1raz\u00e1s hat\u00e1sa. 5.b feladat A dao package-be \u00faj oszt\u00e1ly, CategoryService n\u00e9ven, @Service annot\u00e1ci\u00f3val, szint\u00e9n @Transactional met\u00f3dussal: @Service public class CategoryService { @PersistenceContext private EntityManager em ; @Autowired ProductRepository productRepository ; @Transactional public void moveToExpensiveToys ( double priceLimit ){ String name = \"Expensive toys\" ; Category categoryExpensive = null ; List < Category > resultList = em . createQuery ( \"SELECT c from Category c WHERE c.name=:name\" , Category . class ) . setParameter ( \"name\" , name ) . getResultList (); if ( resultList . isEmpty ()){ //0 vagy null id \u00e9rt\u00e9k eset\u00e9n fog a @GeneratedValue m\u0171k\u00f6d\u00e9sbe l\u00e9pni. Most primit\u00edv long az id-nk, az csak 0 tud lenni, null nem. categoryExpensive = new Category ( 0 , name ); em . persist ( categoryExpensive ); } else { categoryExpensive = resultList . get ( 0 ); } List < Product > expensiveProducts = productRepository . findByPriceGreaterThan ( priceLimit ); for ( Product product : expensiveProducts ) { categoryExpensive . addProduct ( product ); } } } Figyelj\u00fck meg, hogy a menedzselt entit\u00e1s p\u00e9ld\u00e1nyokat (amit tranzakci\u00f3n bel\u00fcl tal\u00e1lunk meg query-vel, vagy most persist-\u00e1ltunk frissen) nem kell explicit m\u00f3don visszamenteni, tranzakci\u00f3 v\u00e9g\u00e9n automatikusan DB-be \u00edr\u00f3dnak a mem\u00f3riabeli v\u00e1ltoz\u00e1sok. Megh\u00edv\u00e1s a WebshopController -b\u0151l: @Autowired CategoryService categoryService ; ... // 5.b feladat @RequestMapping ( value = \"/moveToExpensiveToys\" , method = { RequestMethod . POST , RequestMethod . GET }) private String moveToExpensiveToys () { // TODO categoryService . moveToExpensiveToys ( 8000.0 ); return \"redirect:/\" ; } B\u00f6ng\u00e9sz\u0151ben a gomb megnyom\u00e1sa ut\u00e1n l\u00e1tsz\u00f3dik a Dr\u00e1ga j\u00e1t\u00e9kok kateg\u00f3ria tartalma 5.c feladat A dao package-be \u00faj interf\u00e9sz, CategoryRepository n\u00e9ven, a ProductRepository mint\u00e1j\u00e1ra (a Custom-os lesz\u00e1rmaz\u00e1s nem kell, mert nem lesznek custom lek\u00e9rdez\u00e9seink) egy met\u00f3dussal: public interface CategoryRepository extends JpaRepository < Category , Long > { List < Category > findByName ( String name ); } Ezut\u00e1n a CategoryService \u00edgy egyszer\u0171s\u00f6dik le: @Service public class CategoryService { ... @Autowired CategoryRepository categoryRepository ; @Transactional public void moveToExpensiveToys ( double priceLimit ){ // ... List < Category > resultList = categoryRepository . findByName ( name ); // ... } }","title":"Feladat 5: Adatm\u00f3dos\u00edt\u00e1s"},{"location":"gyakorlat/jpa/#feladat-6-tarolt-eljarasok-hasznalata","text":"H\u00edvd meg a JPA-b\u00f3l a CreateNewPaymentMethod nev\u0171 t\u00e1rolt elj\u00e1r\u00e1st, mely \u00faj fizet\u00e9si m\u00f3d r\u00f6gz\u00edt\u00e9s\u00e9re szolg\u00e1l, \u00e9s visszaadja az \u00faj rekord azonos\u00edt\u00f3j\u00e1t! Az SQL Server Management Studioban ellen\u0151rizz\u00fck, hogy az adatb\u00e1zis tartalmazza-e a CreateNewPaymentMethod nev\u0171 t\u00e1rolt elj\u00e1r\u00e1st! Ha nem, akkor az al\u00e1bbi k\u00f3dot futtasd le a Management Studioban a t\u00e1rolt elj\u00e1r\u00e1s l\u00e9trehoz\u00e1s\u00e1hoz! CREATE PROCEDURE CreateNewPaymentMethod ( @ Method nvarchar ( 20 ), @ Deadline int ) AS insert into PaymentMethod values ( @ Method , @ Deadline ) select scope_identity () as NewId Megold\u00e1s A PaymentMethod entit\u00e1son megtal\u00e1ljuk az al\u00e1bbi annot\u00e1ci\u00f3t. Vess\u00fck \u00f6ssze a t\u00e1rolt elj\u00e1r\u00e1st defini\u00e1l\u00f3 k\u00f3ddal a v\u00e1ltoz\u00f3 neveket! @NamedStoredProcedureQueries ({ @NamedStoredProcedureQuery ( name = \"createMethodSP\" , procedureName = \"CreateNewPaymentMethod\" , parameters = { @StoredProcedureParameter ( mode = ParameterMode . IN , name = \"Method\" , type = String . class ), @StoredProcedureParameter ( mode = ParameterMode . IN , name = \"Deadline\" , type = BigDecimal . class ) }) }) public class Paymentmethod implements Serializable { ... A named stored procedure query megh\u00edvhat\u00f3 Spring Data repositoryb\u00f3l ( dao package-en New Interface ... / PaymentmethodRepository ): public interface PaymentmethodRepository extends JpaRepository < Paymentmethod , Long > { @Procedure ( name = \"createMethodSP\" ) void newMethod ( @Param ( \"Method\" ) String method , @Param ( \"Deadline\" ) BigDecimal deadline ); } Spring Data n\u00e9lk\u00fcl \u00edgy menne, EntityManager -en kereszt\u00fcl, erre val\u00f3sz\u00edn\u0171leg m\u00e1r nem lesz id\u0151: @Service public class PaymentmethodService { @PersistenceContext private EntityManager em ; public void createNewMethod ( Paymentmethod paymentMethod ){ StoredProcedureQuery sp = em . createNamedStoredProcedureQuery ( \"createMethodSP\" ); sp . setParameter ( \"Method\" , paymentMethod . getMethod ()); sp . setParameter ( \"Deadline\" , paymentMethod . getDeadline ()); sp . execute (); } } A webr\u00e9tegbeli megh\u00edv\u00e1s: Injekt\u00e1ljuk a WebshopController -be a PaymentmethodRepository interf\u00e9szt: @Autowired PaymentmethodRepository paymentmethodRepository ; A WebshopController utols\u00f3 TODO-j\u00e1n\u00e1l h\u00edvjuk meg paymentmethodRepository . newMethod ( paymentMethod . getMethod (), paymentMethod . getDeadline ()); A Paymentmethod entit\u00e1s deadline \u00e9s method tagv\u00e1ltoz\u00f3in valid\u00e1ci\u00f3s constraint -eket tal\u00e1lunk. Ezek az annot\u00e1ci\u00f3k a Bean Validation API r\u00e9szei, amivel a webes r\u00e9tegben haszn\u00e1lt Spring MVC, de a JPA \u00e9s integr\u00e1l\u00f3dik, \u00edgy a webr\u00e9tegbeli \u00e9s adatr\u00e9tegbeli valid\u00e1ci\u00f3 konzisztens m\u00f3don, redundanciamentesen defini\u00e1lhat\u00f3. @NotNull private BigDecimal deadline ; @Column ( name = \"METHOD\" ) @NotEmpty private String method ;","title":"Feladat 6: T\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata"},{"location":"gyakorlat/mongodb/","text":"MongoDB \u00b6 A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a MongoDB \u00e1ltal\u00e1nos c\u00e9l\u00fa dokumentumkezel\u0151 adatb\u00e1zis alapvet\u0151 m\u0171k\u00f6d\u00e9s\u00e9t, valamint a MongoDB C#/.NET Driver haszn\u00e1lat\u00e1t. El\u0151felt\u00e9telek \u00b6 A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft Visual Studio 2019 ( nem VS Code) MongoDB Community Edition Robo 3T Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mongo.js Kiindul\u00f3 alkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-mongo-kiindulo Amit \u00e9rdemes \u00e1tn\u00e9zned: C# nyelv \u00e9s Linq kifejez\u00e9sek MongoDB el\u0151ad\u00e1s MongoDB haszn\u00e1lata seg\u00e9dlet Gyakorlat menete \u00b6 A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot! Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, projekt megnyit\u00e1sa \u00b6 Hozzunk l\u00e9tre egy mapp\u00e1t, ahol dolgozni fogunk, p\u00e9ld\u00e1ul c:\\work\\NEPTUN . Munkak\u00f6nyvt\u00e1r A tov\u00e1bbiakban kezelj\u00fck ezt munkak\u00f6nyvt\u00e1rk\u00e9nt , teh\u00e1t minden \u00faj mapp\u00e1t ebben hozzunk l\u00e9tre. Ind\u00edtsuk el a MongoDB szervert. Hozzunk l\u00e9tre egy mapp\u00e1t az adatb\u00e1zisf\u00e1jloknak, p\u00e9ld\u00e1ul db n\u00e9ven. (Ezt a mapp\u00e1t az el\u0151bb l\u00e9trehozott munkak\u00f6nyvt\u00e1rban hozzuk l\u00e9tre.) Nyissunk egy command prompt -ot \u00e9s ind\u00edtsuk el a MongoDB szervert: mongod.exe --dbpath=\"c:\\work\\<NEPTUN>\\db\" Command prompt p\u00e9ld\u00e1ul a start men\u00fcben megkereshet\u0151 a \"cmd\" kulcssz\u00f3val. A laborokban a MongoDB a c:\\tools\\mongodb\\bin k\u00f6nyvt\u00e1rban van. Navig\u00e1ljunk el ide a cd utas\u00edt\u00e1ssal. Ezt a command promptot ne z\u00e1rjuk be, mert ebben fut a szerver. Le\u00e1ll\u00edtani Ctrl+C billenty\u0171kombin\u00e1ci\u00f3val lehet. Hozzuk l\u00e9tre az adatb\u00e1zis. T\u00f6lts\u00fck le az adatb\u00e1zisl\u00e9trehoz\u00f3 scriptet \u00e9s ments\u00fck el mongo.js n\u00e9ven a munkak\u00f6nyvt\u00e1runkba. Nyissunk egy \u00faj command prompt -ot \u00e9s hozzuk l\u00e9tre az adatb\u00e1zist: mongo.exe localhost:27017/datadriven c:\\work\\<NEPTUN>\\mongo.js Ez az exe most nem mongo\u200b d , csak mongo. Ez egy kliensprogram, amivel a szerverhez csatlakozva parancsokat futtathatunk. A laborokban ezt az exe-t is a c:\\tools\\mongodb\\bin k\u00f6nyvt\u00e1rban tal\u00e1ljuk. \u00dcgyelj\u00fcnk a connection stringre, amiben a szerver el\u00e9r\u00e9se ut\u00e1n az adatb\u00e1zis neve is benne van! Ellen\u0151rizz\u00fck, hogy l\u00e9trej\u00f6tt az adatb\u00e1zis Robo3T seg\u00edts\u00e9g\u00e9vel. Ind\u00edtsuk el a Robo3T programot (laborokban a c:\\tools\\robo3t k\u00f6nyvt\u00e1rban) \u00e9s csatlakozzunk a MongoDB szerverhez. Ellen\u0151rizz\u00fck, hogy l\u00e9trej\u00f6ttek a megfelel\u0151 Collection -\u00f6k. T\u00f6lts\u00fck le a m\u00e9r\u00e9shez tartoz\u00f3 projekt v\u00e1zat! Nyissunk egy \u00faj command prompt -ot a munkak\u00f6nyvt\u00e1runkba. Adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone --depth 1 https://github.com/bmeviauac01/gyakorlat-mongo-kiindulo.git Nyissuk meg a forr\u00e1sban az sln f\u00e1jlt Visual Studio-val. Vizsg\u00e1ljuk meg a projektet. Ez egy .NET Core konzol alkalmaz\u00e1s. Fel\u00e9p\u00edt\u00e9s\u00e9ben hasonl\u00edt az Entity Framework gyakorlaton l\u00e1totthoz: az Entities mapp\u00e1ban tal\u00e1lhat\u00f3k az entit\u00e1s oszt\u00e1lyok, a megold\u00e1st pedig a Program.cs f\u00e1jlba \u00edrjuk. N\u00e9zz\u00fck meg a Program.cs tartalm\u00e1t. Itt m\u00e1r megtal\u00e1lhat\u00f3 a MongoDB kommunik\u00e1ci\u00f3hoz sz\u00fcks\u00e9ges inicializ\u00e1ci\u00f3. Az IMongoClient interf\u00e9sz tartalmazza az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3hoz sz\u00fcks\u00e9ges met\u00f3dusokat. Ezeket nem fogjuk k\u00f6zvetlen\u00fcl haszn\u00e1lni. Az IMongoDatabase interf\u00e9sz reprezent\u00e1lja a datadriven adatb\u00e1zist a MongoDB-n bel\u00fcl. A k\u00fcl\u00f6nb\u00f6z\u0151 IMongoCollection<TEntity> interf\u00e9szek pedig a k\u00fcl\u00f6nb\u00f6z\u0151 kollekci\u00f3kat reprezent\u00e1lj\u00e1k. Ezeket haszn\u00e1lva tudunk lek\u00e9rdez\u00e9seket \u00e9s m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1sokat kiadni. Az adatb\u00e1zisunk entit\u00e1sainak C# oszt\u00e1lyra val\u00f3 lek\u00e9pez\u00e9se az Entities mapp\u00e1ban tal\u00e1lhat\u00f3. K\u00fcl\u00f6nbs\u00e9g itt az Entity Frameworkh\u00f6z k\u00e9pest, hogy itt ezt nek\u00fcnk k\u00e9zzel kell elk\u00e9sz\u00edten\u00fcnk. Az entit\u00e1sok egy r\u00e9sz\u00e9nek a lek\u00e9pez\u00e9se m\u00e1r megtal\u00e1lhat\u00f3 itt. A labor sor\u00e1n m\u00e9g visszat\u00e9r\u00fcnk ide, \u00e9s fogunk magunk is k\u00e9sz\u00edteni entit\u00e1s oszt\u00e1lyt. Feladat 1: Lek\u00e9rdez\u00e9sek \u00b6 A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket a MongoDB C#/.NET Driver haszn\u00e1lat\u00e1val. \u00cdrd ki konzolra az eredm\u00e9nyeket. List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron! \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon megrendel\u00e9seket, melyekhez legal\u00e1bb k\u00e9t megrendel\u00e9st\u00e9tel tartozik! K\u00e9sz\u00edts olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azokat a megrendel\u00e9seket, melyek \u00f6ssz\u00e9rt\u00e9ke t\u00f6bb mint 30000 Ft! Az eredm\u00e9nyhalmaz ki\u00edr\u00e1sakor a vev\u0151 ID-t k\u00f6vet\u0151en soronk\u00e9nt szerepeljenek az egyes t\u00e9telek (Term\u00e9k ID, mennyis\u00e9g, nett\u00f3 \u00e1r). List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait! \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek! Megold\u00e1s Ehhez a feladathoz csup\u00e1n a term\u00e9keket reprezent\u00e1l\u00f3 gy\u0171jtem\u00e9nyben kell egy egyszer\u0171 lek\u00e9rdez\u00e9st kiadnunk. A sz\u0171r\u00e9si felt\u00e9telt k\u00e9tf\u00e9lek\u00e9ppen is megfogalmazhatjuk: lambda kifejez\u00e9s seg\u00edts\u00e9g\u00e9vel, \u00e9s k\u00e9zzel \u00f6sszerakva is. Console . WriteLine ( \"***** Els\u0151 feladat *****\" ); // 1.1 els\u0151 megold\u00e1s Console . WriteLine ( \"\\t1.1 1. megold\u00e1s:\" ); var qProductAndStock1 = productsCollection . Find ( p => p . Stock > 30 ) . ToList (); foreach ( var p in qProductAndStock1 ) Console . WriteLine ( $ \"\\t\\tName={p.Name}\\tStock={p.Stock}\" ); // 1.1 m\u00e1sodik megold\u00e1s Console . WriteLine ( \"\\t1.1 2. megold\u00e1s:\" ); var qProductAndStock2 = productsCollection . Find ( Builders < Product >. Filter . Gt ( p => p . Stock , 30 )) . ToList (); foreach ( var p in qProductAndStock2 ) Console . WriteLine ( $ \"\\t\\tName={p.Name}\\tStock={p.Stock}\" ); Ez a feladat nagyon hasonl\u00f3 ez el\u0151z\u0151h\u00f6z. Figyelj\u00fck meg, hogy az SQL-es adatb\u00e1zis s\u00e9ma eset\u00e9n ehhez m\u00e1r JOIN -t ( Navigation Property ) kellett alkalmazni. Ezzel szemben itt minden sz\u00fcks\u00e9ges adat a megrendel\u00e9s kollekci\u00f3ban tal\u00e1lhat\u00f3. // 1.2 els\u0151 megold\u00e1s Console . WriteLine ( \"\\t1.2 1. megold\u00e1s:\" ); var qOrderItems1 = ordersCollection . Find ( o => o . OrderItems . Length >= 2 ) . ToList (); foreach ( var o in qOrderItems1 ) Console . WriteLine ( $ \"\\t\\tCustomerID={o.CustomerID}\\tOrderID={o.ID}\\tItems={o.OrderItems.Length}\" ); // 1.2 m\u00e1sodik megold\u00e1s Console . WriteLine ( \"\\t1.2 2. megold\u00e1s:\" ); var qOrderItems2 = ordersCollection . Find ( Builders < Order >. Filter . SizeGte ( o => o . OrderItems , 2 )) . ToList (); foreach ( var o in qOrderItems2 ) Console . WriteLine ( $ \"\\t\\tCustomerID={o.CustomerID}\\tOrderID={o.ID}\\tItems={o.OrderItems.Length}\" ); Ehhez a feladathoz m\u00e1r nem elegend\u0151 sz\u00e1munkra a sima lek\u00e9rdez\u00e9s kifejez\u0151ereje, \u00edgy az aggreg\u00e1ci\u00f3s pipeline-t kell alkalmaznunk. Figyelj\u00fck meg azonban, hogy a s\u00e9ma fel\u00e9p\u00edt\u00e9se miatt tov\u00e1bbra is minden sz\u00fcks\u00e9ges adat rendelkez\u00e9sre \u00e1ll egyetlen gy\u0171jtem\u00e9nyben. // 1.3 Console . WriteLine ( \"\\t1.3:\" ); var qOrderTotal = ordersCollection . Aggregate () . Project ( order => new { CustomerID = order . CustomerID , OrderItems = order . OrderItems , Total = order . OrderItems . Sum ( oi => oi . Amount * oi . Price ) }) . Match ( order => order . Total > 30000 ) . ToList (); foreach ( var o in qOrderTotal ) { Console . WriteLine ( $ \"\\t\\tCustomerID={o.CustomerID}\" ); foreach ( var oi in o . OrderItems ) Console . WriteLine ( $ \"\\t\\t\\tProductID={oi.ProductID}\\tPrice={oi.Price}\\tAmount={oi.Amount}\" ); } A legdr\u00e1g\u00e1bb term\u00e9kek lek\u00e9rdez\u00e9s\u00e9hez k\u00e9t lek\u00e9rdez\u00e9st kell kiadnunk: el\u0151sz\u00f6r lek\u00e9rdezz\u00fck a legmagasabb \u00e1rat, ut\u00e1na pedig lek\u00e9rdezz\u00fck azokat a term\u00e9keket, melyeknek a nett\u00f3\u00e1ra megegyezik ezzel az \u00e9rt\u00e9kkel. // 1.4 Console . WriteLine ( \"\\t1.4:\" ); var maxPrice = productsCollection . Find ( _ => true ) . SortByDescending ( p => p . Price ) . Limit ( 1 ) . Project ( p => p . Price ) . Single (); var qProductMax = productsCollection . Find ( p => p . Price == maxPrice ) . ToList (); foreach ( var t in qProductMax ) Console . WriteLine ( $ \"\\t\\tName={t.Name}\\tPrice={t.Price}\" ); Ez a feladat az\u00e9rt neh\u00e9z a jelenlegi adatb\u00e1ziss\u00e9m\u00e1nk mellett, mert itt m\u00e1r nem igaz az, hogy egyetlen kollekci\u00f3ban rendelkez\u00e9sre \u00e1ll minden adat. Sz\u00fcks\u00e9g\u00fcnk van ugyanis a term\u00e9k kollekci\u00f3b\u00f3l a term\u00e9k nev\u00e9re \u00e9s rakt\u00e1rk\u00e9szlet\u00e9re, a megrendel\u00e9sek kollekci\u00f3b\u00f3l pedig a term\u00e9khez tartoz\u00f3 megrendel\u00e9sek sz\u00e1m\u00e1ra. Ilyen helyzetben MongoDB eset\u00e9n k\u00e9nytelenek vagyunk kliensoldalon (\u00e9rtsd: C# k\u00f3db\u00f3l) \"joinolni\". A megold\u00e1s itt teh\u00e1t hogy lek\u00e9rdezz\u00fck az \u00f6sszes megrendel\u00e9st, majd pedig C#-b\u00f3l, LINQ seg\u00edts\u00e9g\u00e9vel \u00f6sszegy\u0171jtj\u00fck az adott term\u00e9khez tartoz\u00f3 megrendel\u00e9st\u00e9teleket. Ezut\u00e1n lek\u00e9rdezz\u00fck az adatb\u00e1zisb\u00f3l a term\u00e9keket is, hogy azok adatai is rendelkez\u00e9s\u00fcnkre \u00e1lljanak. // 1.5 Console . WriteLine ( \"\\t1.5:\" ); var qOrders = ordersCollection . Find ( _ => true ) . ToList (); var productOrders = qOrders . SelectMany ( o => o . OrderItems ) // Egyetlen list\u00e1ba gy\u0171jti a t\u00e9teleket . GroupBy ( oi => oi . ProductID ) . Where ( p => p . Count () >= 2 ); var qProducts = productsCollection . Find ( _ => true ) . ToList (); var productLookup = qProducts . ToDictionary ( p => p . ID ); foreach ( var p in productOrders ) { var product = productLookup . GetValueOrDefault ( p . Key ); Console . WriteLine ( $ \"\\t\\tName={product?.Name}\\tStock={product?.Stock}\\tOrders={p.Count()}\" ); } A fenti nem t\u00fal eleg\u00e1ns megold\u00e1s, \u00e9s csak kis adatb\u00e1zisok eset\u00e9n m\u0171k\u00f6dik. Ha val\u00f3di k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt szembes\u00fcl\u00fcnk ezzel a feladattal, k\u00e9t lehet\u0151s\u00e9g\u00fcnk van: \u00e1tdolgozni az adatb\u00e1zis s\u00e9m\u00e1t (pl. a megrendel\u00e9sbe belementeni a term\u00e9k adatait - denormaliz\u00e1ci\u00f3), avagy a MongoDB aggreg\u00e1c\u00f3s pipeline-j\u00e1nak haszn\u00e1lat\u00e1val a fenti m\u00f3dszerhes hasonl\u00f3ra \"r\u00e1venni\" a MongoDB szervert (amire k\u00e9pes ugyan, de le fogja terhelni) Feladat 2: Entit\u00e1soszt\u00e1ly l\u00e9trehoz\u00e1sa \u00b6 Vizsg\u00e1ld meg a Product \u00e9s a VAT entit\u00e1soszt\u00e1lyokat. Mi\u00e9rt van a Product entit\u00e1sban [BsonId] -val ell\u00e1tott mez\u0151, \u00e9s mi\u00e9rt nincs az VAT oszt\u00e1lyban? Hozz l\u00e9tre entit\u00e1soszt\u00e1lyt a Category entit\u00e1snak, \u00e9s vedd fel hozz\u00e1 a megfelel\u0151 IMongoCollection<Category> mez\u0151t. Megold\u00e1s A Product oszt\u00e1ly a products gy\u0171jtem\u00e9nyt reprezent\u00e1lja az adatb\u00e1zisban, ez\u00e9rt tartozik hozz\u00e1 egyedi ObjectID ami alapj\u00e1n hivatkozni tudunk r\u00e1 az adatb\u00e1zis fel\u00e9. Ezzel szemben az VAT oszt\u00e1ly a Product egy be\u00e1gyazott objektuma, \u00f6nmag\u00e1ban nem jelenik meg gy\u0171jtem\u00e9nyk\u00e9nt. Ez\u00e9rt nem tartozik hozz\u00e1 ObjectID \u00e9rt\u00e9k. Hozzunk l\u00e9tre \u00faj POCO oszt\u00e1lyt Category n\u00e9ven. N\u00e9zz\u00fck meg el\u0151sz\u00f6r a Robo3T program seg\u00edts\u00e9g\u00e9vel, hogy milyen adattagok tal\u00e1lhat\u00f3k a categories kollekci\u00f3ban l\u00e9v\u0151 dokumentumokban. Ez alapj\u00e1n l\u00e9tre tudjuk hozni a Category oszt\u00e1lyt an Entities mapp\u00e1ban. using MongoDB.Bson ; using MongoDB.Bson.Serialization.Attributes ; namespace BME.DataDriven.Mongo.Entitites { public class Category { [BsonId] public ObjectId ID { get ; set ; } public string Name { get ; set ; } public ObjectId ? ParentCategoryID { get ; set ; } } } A Program.cs f\u00e1jlban vegy\u00fcl fel az \u00faj kollekci\u00f3 interf\u00e9szt. private static IMongoCollection < Category > categoriesCollection ; Az initialize met\u00f3dusban pedig inicializ\u00e1ljuk is ezt a kollekci\u00f3t. categoriesCollection = database . GetCollection < Category >( \"categories\" ); Feladat 3: Adatm\u00f3dos\u00edt\u00e1sok \u00b6 Az IMongoColection<TEntity> interf\u00e9sz nem csak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl m\u00f3dos\u00edt\u00e1sok is v\u00e9grehajthat\u00f3ak. \u00cdrj olyan MongoDB C#/.NET Driverre \u00e9p\u00fcl\u0151 C# k\u00f3dot, mely a \"LEGO\" kateg\u00f3ri\u00e1j\u00fa term\u00e9kek \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal! Hozz l\u00e9tre egy \u00faj kateg\u00f3ri\u00e1t a Expensive toys n\u00e9ven, \u00e9s sorod \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft! T\u00f6r\u00f6ld ki az \u00f6sszes olyan kateg\u00f3ri\u00e1t, amelyhez nem tartozik term\u00e9k. Megold\u00e1s El\u0151sz\u00f6r lek\u00e9rdezz\u00fck a megfelel\u0151 kateg\u00f3ria ID-j\u00e1t, majd az ehhez tartoz\u00f3 term\u00e9kekre adunk ki m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st. Console . WriteLine ( \"***** Harmadik feladat *****\" ); //3.1 Console . WriteLine ( \"\\t3.1:\" ); var categoryLegoId = categoriesCollection . Find ( c => c . Name == \"LEGO\" ) . Project ( c => c . ID ) . Single (); var qProductLego = productsCollection . Find ( p => p . CategoryID == categoryLegoId ) . ToList (); Console . WriteLine ( \"\\t\\tM\u00f3dos\u00edt\u00e1s el\u0151tt:\" ); foreach ( var p in qProductLego ) Console . WriteLine ( $ \"\\t\\t\\tName={p.Name}\\tStock={p.Stock}\\t\u00c1r={p.Price}\" ); productsCollection . UpdateMany ( filter : p => p . CategoryID == categoryLegoId , update : Builders < Product >. Update . Mul ( p => p . Price , 1.1 )); qProductLego = productsCollection . Find ( p => p . CategoryID == categoryLegoId ) . ToList (); Console . WriteLine ( \"\\t\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n:\" ); foreach ( var p in qProductLego ) Console . WriteLine ( $ \"\\t\\t\\tName={p.Name}\\tStock={p.Stock}\\t\u00c1r={p.Price}\" ); MongoDB seg\u00edts\u00e9g\u00e9vel tranzakci\u00f3 n\u00e9lk\u00fcl atomikusan el tudjuk v\u00e9gezni a k\u00f6vetkez\u0151 feladatot: \"K\u00e9rem a Expensive toys kateg\u00f3ri\u00e1t. Amennyiben nem l\u00e9tezik, hozd l\u00e9tre.\" Ehhez a FindOneAndUpdate parancs haszn\u00e1lat\u00e1ra van sz\u00fcks\u00e9g\u00fcnk. //3.2 Console . WriteLine ( \"\\t3.2:\" ); var catExpensiveToys = categoriesCollection . FindOneAndUpdate < Category >( filter : c => c . Name == \"Expensive toys\" , update : Builders < Category >. Update . SetOnInsert ( c => c . Name , \"Expensive toys\" ), options : new FindOneAndUpdateOptions < Category , Category > { IsUpsert = true , ReturnDocument = ReturnDocument . After }); productsCollection . UpdateMany ( filter : p => p . Price > 8000 , update : Builders < Product >. Update . Set ( p => p . CategoryID , catExpensiveToys . ID )); var qProdExpensive = productsCollection . Find ( p => p . CategoryID == catExpensiveToys . ID ) . ToList (); foreach ( var p in qProdExpensive ) Console . WriteLine ( $ \"\\t\\tName={p.Name}\\tPrice={p.Price}\" ); Lek\u00e9rdezz\u00fck azokat a kateg\u00f3ri\u00e1kat amelyekhez tartozik term\u00e9k, majd pedig t\u00f6r\u00f6lj\u00fck azokat, amelyek nem tartoznak ezek k\u00f6z\u00e9. //3.3 Console . WriteLine ( \"\\t3.3:\" ); Console . WriteLine ( $ \"\\t\\tM\u00f3dos\u00edt\u00e1s el\u0151tt {categoriesCollection.CountDocuments(_ => true)} db kateg\u00f3ria\" ); var qProductCategory = new HashSet < ObjectId >( productsCollection . Find ( _ => true ) . Project ( p => p . CategoryID ) . ToList ()); categoriesCollection . DeleteMany ( c => ! qProductCategory . Contains ( c . ID )); Console . WriteLine ( $ \"\\t\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n {categoriesCollection.CountDocuments(_ => true)} db kateg\u00f3ria\" ); Vegy\u00fck \u00e9szre, hogy ez az utas\u00edt\u00e1s nem atomikus. Ha k\u00f6zben vettek fel \u00faj term\u00e9ket, akkor lehet, hogy olyan kateg\u00f3ri\u00e1t t\u00f6rl\u00fcnk amihez az\u00f3ta tartozik term\u00e9k. Nem vett\u00fck figyelembe tov\u00e1bb\u00e1 a kateg\u00f3ri\u00e1k hierarchi\u00e1j\u00e1t sem.","title":"MongoDB"},{"location":"gyakorlat/mongodb/#mongodb","text":"A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a MongoDB \u00e1ltal\u00e1nos c\u00e9l\u00fa dokumentumkezel\u0151 adatb\u00e1zis alapvet\u0151 m\u0171k\u00f6d\u00e9s\u00e9t, valamint a MongoDB C#/.NET Driver haszn\u00e1lat\u00e1t.","title":"MongoDB"},{"location":"gyakorlat/mongodb/#elofeltetelek","text":"A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft Visual Studio 2019 ( nem VS Code) MongoDB Community Edition Robo 3T Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mongo.js Kiindul\u00f3 alkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-mongo-kiindulo Amit \u00e9rdemes \u00e1tn\u00e9zned: C# nyelv \u00e9s Linq kifejez\u00e9sek MongoDB el\u0151ad\u00e1s MongoDB haszn\u00e1lata seg\u00e9dlet","title":"El\u0151felt\u00e9telek"},{"location":"gyakorlat/mongodb/#gyakorlat-menete","text":"A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!","title":"Gyakorlat menete"},{"location":"gyakorlat/mongodb/#feladat-0-adatbazis-letrehozasa-projekt-megnyitasa","text":"Hozzunk l\u00e9tre egy mapp\u00e1t, ahol dolgozni fogunk, p\u00e9ld\u00e1ul c:\\work\\NEPTUN . Munkak\u00f6nyvt\u00e1r A tov\u00e1bbiakban kezelj\u00fck ezt munkak\u00f6nyvt\u00e1rk\u00e9nt , teh\u00e1t minden \u00faj mapp\u00e1t ebben hozzunk l\u00e9tre. Ind\u00edtsuk el a MongoDB szervert. Hozzunk l\u00e9tre egy mapp\u00e1t az adatb\u00e1zisf\u00e1jloknak, p\u00e9ld\u00e1ul db n\u00e9ven. (Ezt a mapp\u00e1t az el\u0151bb l\u00e9trehozott munkak\u00f6nyvt\u00e1rban hozzuk l\u00e9tre.) Nyissunk egy command prompt -ot \u00e9s ind\u00edtsuk el a MongoDB szervert: mongod.exe --dbpath=\"c:\\work\\<NEPTUN>\\db\" Command prompt p\u00e9ld\u00e1ul a start men\u00fcben megkereshet\u0151 a \"cmd\" kulcssz\u00f3val. A laborokban a MongoDB a c:\\tools\\mongodb\\bin k\u00f6nyvt\u00e1rban van. Navig\u00e1ljunk el ide a cd utas\u00edt\u00e1ssal. Ezt a command promptot ne z\u00e1rjuk be, mert ebben fut a szerver. Le\u00e1ll\u00edtani Ctrl+C billenty\u0171kombin\u00e1ci\u00f3val lehet. Hozzuk l\u00e9tre az adatb\u00e1zis. T\u00f6lts\u00fck le az adatb\u00e1zisl\u00e9trehoz\u00f3 scriptet \u00e9s ments\u00fck el mongo.js n\u00e9ven a munkak\u00f6nyvt\u00e1runkba. Nyissunk egy \u00faj command prompt -ot \u00e9s hozzuk l\u00e9tre az adatb\u00e1zist: mongo.exe localhost:27017/datadriven c:\\work\\<NEPTUN>\\mongo.js Ez az exe most nem mongo\u200b d , csak mongo. Ez egy kliensprogram, amivel a szerverhez csatlakozva parancsokat futtathatunk. A laborokban ezt az exe-t is a c:\\tools\\mongodb\\bin k\u00f6nyvt\u00e1rban tal\u00e1ljuk. \u00dcgyelj\u00fcnk a connection stringre, amiben a szerver el\u00e9r\u00e9se ut\u00e1n az adatb\u00e1zis neve is benne van! Ellen\u0151rizz\u00fck, hogy l\u00e9trej\u00f6tt az adatb\u00e1zis Robo3T seg\u00edts\u00e9g\u00e9vel. Ind\u00edtsuk el a Robo3T programot (laborokban a c:\\tools\\robo3t k\u00f6nyvt\u00e1rban) \u00e9s csatlakozzunk a MongoDB szerverhez. Ellen\u0151rizz\u00fck, hogy l\u00e9trej\u00f6ttek a megfelel\u0151 Collection -\u00f6k. T\u00f6lts\u00fck le a m\u00e9r\u00e9shez tartoz\u00f3 projekt v\u00e1zat! Nyissunk egy \u00faj command prompt -ot a munkak\u00f6nyvt\u00e1runkba. Adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone --depth 1 https://github.com/bmeviauac01/gyakorlat-mongo-kiindulo.git Nyissuk meg a forr\u00e1sban az sln f\u00e1jlt Visual Studio-val. Vizsg\u00e1ljuk meg a projektet. Ez egy .NET Core konzol alkalmaz\u00e1s. Fel\u00e9p\u00edt\u00e9s\u00e9ben hasonl\u00edt az Entity Framework gyakorlaton l\u00e1totthoz: az Entities mapp\u00e1ban tal\u00e1lhat\u00f3k az entit\u00e1s oszt\u00e1lyok, a megold\u00e1st pedig a Program.cs f\u00e1jlba \u00edrjuk. N\u00e9zz\u00fck meg a Program.cs tartalm\u00e1t. Itt m\u00e1r megtal\u00e1lhat\u00f3 a MongoDB kommunik\u00e1ci\u00f3hoz sz\u00fcks\u00e9ges inicializ\u00e1ci\u00f3. Az IMongoClient interf\u00e9sz tartalmazza az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3hoz sz\u00fcks\u00e9ges met\u00f3dusokat. Ezeket nem fogjuk k\u00f6zvetlen\u00fcl haszn\u00e1lni. Az IMongoDatabase interf\u00e9sz reprezent\u00e1lja a datadriven adatb\u00e1zist a MongoDB-n bel\u00fcl. A k\u00fcl\u00f6nb\u00f6z\u0151 IMongoCollection<TEntity> interf\u00e9szek pedig a k\u00fcl\u00f6nb\u00f6z\u0151 kollekci\u00f3kat reprezent\u00e1lj\u00e1k. Ezeket haszn\u00e1lva tudunk lek\u00e9rdez\u00e9seket \u00e9s m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1sokat kiadni. Az adatb\u00e1zisunk entit\u00e1sainak C# oszt\u00e1lyra val\u00f3 lek\u00e9pez\u00e9se az Entities mapp\u00e1ban tal\u00e1lhat\u00f3. K\u00fcl\u00f6nbs\u00e9g itt az Entity Frameworkh\u00f6z k\u00e9pest, hogy itt ezt nek\u00fcnk k\u00e9zzel kell elk\u00e9sz\u00edten\u00fcnk. Az entit\u00e1sok egy r\u00e9sz\u00e9nek a lek\u00e9pez\u00e9se m\u00e1r megtal\u00e1lhat\u00f3 itt. A labor sor\u00e1n m\u00e9g visszat\u00e9r\u00fcnk ide, \u00e9s fogunk magunk is k\u00e9sz\u00edteni entit\u00e1s oszt\u00e1lyt.","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, projekt megnyit\u00e1sa"},{"location":"gyakorlat/mongodb/#feladat-1-lekerdezesek","text":"A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket a MongoDB C#/.NET Driver haszn\u00e1lat\u00e1val. \u00cdrd ki konzolra az eredm\u00e9nyeket. List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron! \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon megrendel\u00e9seket, melyekhez legal\u00e1bb k\u00e9t megrendel\u00e9st\u00e9tel tartozik! K\u00e9sz\u00edts olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azokat a megrendel\u00e9seket, melyek \u00f6ssz\u00e9rt\u00e9ke t\u00f6bb mint 30000 Ft! Az eredm\u00e9nyhalmaz ki\u00edr\u00e1sakor a vev\u0151 ID-t k\u00f6vet\u0151en soronk\u00e9nt szerepeljenek az egyes t\u00e9telek (Term\u00e9k ID, mennyis\u00e9g, nett\u00f3 \u00e1r). List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait! \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek! Megold\u00e1s Ehhez a feladathoz csup\u00e1n a term\u00e9keket reprezent\u00e1l\u00f3 gy\u0171jtem\u00e9nyben kell egy egyszer\u0171 lek\u00e9rdez\u00e9st kiadnunk. A sz\u0171r\u00e9si felt\u00e9telt k\u00e9tf\u00e9lek\u00e9ppen is megfogalmazhatjuk: lambda kifejez\u00e9s seg\u00edts\u00e9g\u00e9vel, \u00e9s k\u00e9zzel \u00f6sszerakva is. Console . WriteLine ( \"***** Els\u0151 feladat *****\" ); // 1.1 els\u0151 megold\u00e1s Console . WriteLine ( \"\\t1.1 1. megold\u00e1s:\" ); var qProductAndStock1 = productsCollection . Find ( p => p . Stock > 30 ) . ToList (); foreach ( var p in qProductAndStock1 ) Console . WriteLine ( $ \"\\t\\tName={p.Name}\\tStock={p.Stock}\" ); // 1.1 m\u00e1sodik megold\u00e1s Console . WriteLine ( \"\\t1.1 2. megold\u00e1s:\" ); var qProductAndStock2 = productsCollection . Find ( Builders < Product >. Filter . Gt ( p => p . Stock , 30 )) . ToList (); foreach ( var p in qProductAndStock2 ) Console . WriteLine ( $ \"\\t\\tName={p.Name}\\tStock={p.Stock}\" ); Ez a feladat nagyon hasonl\u00f3 ez el\u0151z\u0151h\u00f6z. Figyelj\u00fck meg, hogy az SQL-es adatb\u00e1zis s\u00e9ma eset\u00e9n ehhez m\u00e1r JOIN -t ( Navigation Property ) kellett alkalmazni. Ezzel szemben itt minden sz\u00fcks\u00e9ges adat a megrendel\u00e9s kollekci\u00f3ban tal\u00e1lhat\u00f3. // 1.2 els\u0151 megold\u00e1s Console . WriteLine ( \"\\t1.2 1. megold\u00e1s:\" ); var qOrderItems1 = ordersCollection . Find ( o => o . OrderItems . Length >= 2 ) . ToList (); foreach ( var o in qOrderItems1 ) Console . WriteLine ( $ \"\\t\\tCustomerID={o.CustomerID}\\tOrderID={o.ID}\\tItems={o.OrderItems.Length}\" ); // 1.2 m\u00e1sodik megold\u00e1s Console . WriteLine ( \"\\t1.2 2. megold\u00e1s:\" ); var qOrderItems2 = ordersCollection . Find ( Builders < Order >. Filter . SizeGte ( o => o . OrderItems , 2 )) . ToList (); foreach ( var o in qOrderItems2 ) Console . WriteLine ( $ \"\\t\\tCustomerID={o.CustomerID}\\tOrderID={o.ID}\\tItems={o.OrderItems.Length}\" ); Ehhez a feladathoz m\u00e1r nem elegend\u0151 sz\u00e1munkra a sima lek\u00e9rdez\u00e9s kifejez\u0151ereje, \u00edgy az aggreg\u00e1ci\u00f3s pipeline-t kell alkalmaznunk. Figyelj\u00fck meg azonban, hogy a s\u00e9ma fel\u00e9p\u00edt\u00e9se miatt tov\u00e1bbra is minden sz\u00fcks\u00e9ges adat rendelkez\u00e9sre \u00e1ll egyetlen gy\u0171jtem\u00e9nyben. // 1.3 Console . WriteLine ( \"\\t1.3:\" ); var qOrderTotal = ordersCollection . Aggregate () . Project ( order => new { CustomerID = order . CustomerID , OrderItems = order . OrderItems , Total = order . OrderItems . Sum ( oi => oi . Amount * oi . Price ) }) . Match ( order => order . Total > 30000 ) . ToList (); foreach ( var o in qOrderTotal ) { Console . WriteLine ( $ \"\\t\\tCustomerID={o.CustomerID}\" ); foreach ( var oi in o . OrderItems ) Console . WriteLine ( $ \"\\t\\t\\tProductID={oi.ProductID}\\tPrice={oi.Price}\\tAmount={oi.Amount}\" ); } A legdr\u00e1g\u00e1bb term\u00e9kek lek\u00e9rdez\u00e9s\u00e9hez k\u00e9t lek\u00e9rdez\u00e9st kell kiadnunk: el\u0151sz\u00f6r lek\u00e9rdezz\u00fck a legmagasabb \u00e1rat, ut\u00e1na pedig lek\u00e9rdezz\u00fck azokat a term\u00e9keket, melyeknek a nett\u00f3\u00e1ra megegyezik ezzel az \u00e9rt\u00e9kkel. // 1.4 Console . WriteLine ( \"\\t1.4:\" ); var maxPrice = productsCollection . Find ( _ => true ) . SortByDescending ( p => p . Price ) . Limit ( 1 ) . Project ( p => p . Price ) . Single (); var qProductMax = productsCollection . Find ( p => p . Price == maxPrice ) . ToList (); foreach ( var t in qProductMax ) Console . WriteLine ( $ \"\\t\\tName={t.Name}\\tPrice={t.Price}\" ); Ez a feladat az\u00e9rt neh\u00e9z a jelenlegi adatb\u00e1ziss\u00e9m\u00e1nk mellett, mert itt m\u00e1r nem igaz az, hogy egyetlen kollekci\u00f3ban rendelkez\u00e9sre \u00e1ll minden adat. Sz\u00fcks\u00e9g\u00fcnk van ugyanis a term\u00e9k kollekci\u00f3b\u00f3l a term\u00e9k nev\u00e9re \u00e9s rakt\u00e1rk\u00e9szlet\u00e9re, a megrendel\u00e9sek kollekci\u00f3b\u00f3l pedig a term\u00e9khez tartoz\u00f3 megrendel\u00e9sek sz\u00e1m\u00e1ra. Ilyen helyzetben MongoDB eset\u00e9n k\u00e9nytelenek vagyunk kliensoldalon (\u00e9rtsd: C# k\u00f3db\u00f3l) \"joinolni\". A megold\u00e1s itt teh\u00e1t hogy lek\u00e9rdezz\u00fck az \u00f6sszes megrendel\u00e9st, majd pedig C#-b\u00f3l, LINQ seg\u00edts\u00e9g\u00e9vel \u00f6sszegy\u0171jtj\u00fck az adott term\u00e9khez tartoz\u00f3 megrendel\u00e9st\u00e9teleket. Ezut\u00e1n lek\u00e9rdezz\u00fck az adatb\u00e1zisb\u00f3l a term\u00e9keket is, hogy azok adatai is rendelkez\u00e9s\u00fcnkre \u00e1lljanak. // 1.5 Console . WriteLine ( \"\\t1.5:\" ); var qOrders = ordersCollection . Find ( _ => true ) . ToList (); var productOrders = qOrders . SelectMany ( o => o . OrderItems ) // Egyetlen list\u00e1ba gy\u0171jti a t\u00e9teleket . GroupBy ( oi => oi . ProductID ) . Where ( p => p . Count () >= 2 ); var qProducts = productsCollection . Find ( _ => true ) . ToList (); var productLookup = qProducts . ToDictionary ( p => p . ID ); foreach ( var p in productOrders ) { var product = productLookup . GetValueOrDefault ( p . Key ); Console . WriteLine ( $ \"\\t\\tName={product?.Name}\\tStock={product?.Stock}\\tOrders={p.Count()}\" ); } A fenti nem t\u00fal eleg\u00e1ns megold\u00e1s, \u00e9s csak kis adatb\u00e1zisok eset\u00e9n m\u0171k\u00f6dik. Ha val\u00f3di k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt szembes\u00fcl\u00fcnk ezzel a feladattal, k\u00e9t lehet\u0151s\u00e9g\u00fcnk van: \u00e1tdolgozni az adatb\u00e1zis s\u00e9m\u00e1t (pl. a megrendel\u00e9sbe belementeni a term\u00e9k adatait - denormaliz\u00e1ci\u00f3), avagy a MongoDB aggreg\u00e1c\u00f3s pipeline-j\u00e1nak haszn\u00e1lat\u00e1val a fenti m\u00f3dszerhes hasonl\u00f3ra \"r\u00e1venni\" a MongoDB szervert (amire k\u00e9pes ugyan, de le fogja terhelni)","title":"Feladat 1: Lek\u00e9rdez\u00e9sek"},{"location":"gyakorlat/mongodb/#feladat-2-entitasosztaly-letrehozasa","text":"Vizsg\u00e1ld meg a Product \u00e9s a VAT entit\u00e1soszt\u00e1lyokat. Mi\u00e9rt van a Product entit\u00e1sban [BsonId] -val ell\u00e1tott mez\u0151, \u00e9s mi\u00e9rt nincs az VAT oszt\u00e1lyban? Hozz l\u00e9tre entit\u00e1soszt\u00e1lyt a Category entit\u00e1snak, \u00e9s vedd fel hozz\u00e1 a megfelel\u0151 IMongoCollection<Category> mez\u0151t. Megold\u00e1s A Product oszt\u00e1ly a products gy\u0171jtem\u00e9nyt reprezent\u00e1lja az adatb\u00e1zisban, ez\u00e9rt tartozik hozz\u00e1 egyedi ObjectID ami alapj\u00e1n hivatkozni tudunk r\u00e1 az adatb\u00e1zis fel\u00e9. Ezzel szemben az VAT oszt\u00e1ly a Product egy be\u00e1gyazott objektuma, \u00f6nmag\u00e1ban nem jelenik meg gy\u0171jtem\u00e9nyk\u00e9nt. Ez\u00e9rt nem tartozik hozz\u00e1 ObjectID \u00e9rt\u00e9k. Hozzunk l\u00e9tre \u00faj POCO oszt\u00e1lyt Category n\u00e9ven. N\u00e9zz\u00fck meg el\u0151sz\u00f6r a Robo3T program seg\u00edts\u00e9g\u00e9vel, hogy milyen adattagok tal\u00e1lhat\u00f3k a categories kollekci\u00f3ban l\u00e9v\u0151 dokumentumokban. Ez alapj\u00e1n l\u00e9tre tudjuk hozni a Category oszt\u00e1lyt an Entities mapp\u00e1ban. using MongoDB.Bson ; using MongoDB.Bson.Serialization.Attributes ; namespace BME.DataDriven.Mongo.Entitites { public class Category { [BsonId] public ObjectId ID { get ; set ; } public string Name { get ; set ; } public ObjectId ? ParentCategoryID { get ; set ; } } } A Program.cs f\u00e1jlban vegy\u00fcl fel az \u00faj kollekci\u00f3 interf\u00e9szt. private static IMongoCollection < Category > categoriesCollection ; Az initialize met\u00f3dusban pedig inicializ\u00e1ljuk is ezt a kollekci\u00f3t. categoriesCollection = database . GetCollection < Category >( \"categories\" );","title":"Feladat 2: Entit\u00e1soszt\u00e1ly l\u00e9trehoz\u00e1sa"},{"location":"gyakorlat/mongodb/#feladat-3-adatmodositasok","text":"Az IMongoColection<TEntity> interf\u00e9sz nem csak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl m\u00f3dos\u00edt\u00e1sok is v\u00e9grehajthat\u00f3ak. \u00cdrj olyan MongoDB C#/.NET Driverre \u00e9p\u00fcl\u0151 C# k\u00f3dot, mely a \"LEGO\" kateg\u00f3ri\u00e1j\u00fa term\u00e9kek \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal! Hozz l\u00e9tre egy \u00faj kateg\u00f3ri\u00e1t a Expensive toys n\u00e9ven, \u00e9s sorod \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft! T\u00f6r\u00f6ld ki az \u00f6sszes olyan kateg\u00f3ri\u00e1t, amelyhez nem tartozik term\u00e9k. Megold\u00e1s El\u0151sz\u00f6r lek\u00e9rdezz\u00fck a megfelel\u0151 kateg\u00f3ria ID-j\u00e1t, majd az ehhez tartoz\u00f3 term\u00e9kekre adunk ki m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st. Console . WriteLine ( \"***** Harmadik feladat *****\" ); //3.1 Console . WriteLine ( \"\\t3.1:\" ); var categoryLegoId = categoriesCollection . Find ( c => c . Name == \"LEGO\" ) . Project ( c => c . ID ) . Single (); var qProductLego = productsCollection . Find ( p => p . CategoryID == categoryLegoId ) . ToList (); Console . WriteLine ( \"\\t\\tM\u00f3dos\u00edt\u00e1s el\u0151tt:\" ); foreach ( var p in qProductLego ) Console . WriteLine ( $ \"\\t\\t\\tName={p.Name}\\tStock={p.Stock}\\t\u00c1r={p.Price}\" ); productsCollection . UpdateMany ( filter : p => p . CategoryID == categoryLegoId , update : Builders < Product >. Update . Mul ( p => p . Price , 1.1 )); qProductLego = productsCollection . Find ( p => p . CategoryID == categoryLegoId ) . ToList (); Console . WriteLine ( \"\\t\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n:\" ); foreach ( var p in qProductLego ) Console . WriteLine ( $ \"\\t\\t\\tName={p.Name}\\tStock={p.Stock}\\t\u00c1r={p.Price}\" ); MongoDB seg\u00edts\u00e9g\u00e9vel tranzakci\u00f3 n\u00e9lk\u00fcl atomikusan el tudjuk v\u00e9gezni a k\u00f6vetkez\u0151 feladatot: \"K\u00e9rem a Expensive toys kateg\u00f3ri\u00e1t. Amennyiben nem l\u00e9tezik, hozd l\u00e9tre.\" Ehhez a FindOneAndUpdate parancs haszn\u00e1lat\u00e1ra van sz\u00fcks\u00e9g\u00fcnk. //3.2 Console . WriteLine ( \"\\t3.2:\" ); var catExpensiveToys = categoriesCollection . FindOneAndUpdate < Category >( filter : c => c . Name == \"Expensive toys\" , update : Builders < Category >. Update . SetOnInsert ( c => c . Name , \"Expensive toys\" ), options : new FindOneAndUpdateOptions < Category , Category > { IsUpsert = true , ReturnDocument = ReturnDocument . After }); productsCollection . UpdateMany ( filter : p => p . Price > 8000 , update : Builders < Product >. Update . Set ( p => p . CategoryID , catExpensiveToys . ID )); var qProdExpensive = productsCollection . Find ( p => p . CategoryID == catExpensiveToys . ID ) . ToList (); foreach ( var p in qProdExpensive ) Console . WriteLine ( $ \"\\t\\tName={p.Name}\\tPrice={p.Price}\" ); Lek\u00e9rdezz\u00fck azokat a kateg\u00f3ri\u00e1kat amelyekhez tartozik term\u00e9k, majd pedig t\u00f6r\u00f6lj\u00fck azokat, amelyek nem tartoznak ezek k\u00f6z\u00e9. //3.3 Console . WriteLine ( \"\\t3.3:\" ); Console . WriteLine ( $ \"\\t\\tM\u00f3dos\u00edt\u00e1s el\u0151tt {categoriesCollection.CountDocuments(_ => true)} db kateg\u00f3ria\" ); var qProductCategory = new HashSet < ObjectId >( productsCollection . Find ( _ => true ) . Project ( p => p . CategoryID ) . ToList ()); categoriesCollection . DeleteMany ( c => ! qProductCategory . Contains ( c . ID )); Console . WriteLine ( $ \"\\t\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n {categoriesCollection.CountDocuments(_ => true)} db kateg\u00f3ria\" ); Vegy\u00fck \u00e9szre, hogy ez az utas\u00edt\u00e1s nem atomikus. Ha k\u00f6zben vettek fel \u00faj term\u00e9ket, akkor lehet, hogy olyan kateg\u00f3ri\u00e1t t\u00f6rl\u00fcnk amihez az\u00f3ta tartozik term\u00e9k. Nem vett\u00fck figyelembe tov\u00e1bb\u00e1 a kateg\u00f3ri\u00e1k hierarchi\u00e1j\u00e1t sem.","title":"Feladat 3: Adatm\u00f3dos\u00edt\u00e1sok"},{"location":"gyakorlat/mssql/","text":"Microsoft SQL Server programoz\u00e1sa \u00b6 A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k az Microsoft SQL Server platform szerver oldali programoz\u00e1s\u00e1nak alapjait, elsaj\u00e1t\u00edts\u00e1k az alapfogalmakat \u00e9s a fejleszt\u0151eszk\u00f6z haszn\u00e1lat\u00e1t. El\u0151felt\u00e9telek \u00b6 A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft SQL Server (LocalDB vagy Express edition) SQL Server Management Studio Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Amit \u00e9rdemes \u00e1tn\u00e9zned: SQL nyelv Microsoft SQL Server programoz\u00e1sa (t\u00e1rolt elj\u00e1r\u00e1sok, triggerek) Microsoft SQL Server haszn\u00e1lata seg\u00e9dlet Gyakorlat menete \u00b6 Az els\u0151 n\u00e9gy feladatot (bele\u00e9rtve a megold\u00e1sok tesztel\u00e9s\u00e9t is) a gyakorlatvezet\u0151vel egy\u00fctt oldjuk meg. Az utols\u00f3 feladat \u00f6n\u00e1ll\u00f3 munka, amennyiben marad r\u00e1 id\u0151. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot! Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se \u00b6 Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban .) Feladat 1: SQL parancsok (eml\u00e9keztet\u0151) \u00b6 \u00cdrjon SQL lek\u00e9rdez\u00e9s/utas\u00edt\u00e1st az al\u00e1bbi feladatokhoz. H\u00e1ny nem teljes\u00edtett megrendel\u00e9s\u00fcnk van (a st\u00e1tusz alapj\u00e1n)? Megold\u00e1s select count ( * ) from [ Order ] o join Status s on o . StatusID = s . ID where s . Name != 'Delivered' A join mellett az oszlopf\u00fcggv\u00e9ny (aggreg\u00e1ci\u00f3) haszn\u00e1lat\u00e1ra l\u00e1tunk p\u00e9ld\u00e1t. (A t\u00e1bl\u00e1k kapcsol\u00e1s\u00e1ra nem csak ez a szintaktika haszn\u00e1lhat\u00f3, el\u0151ad\u00e1son szerepelt alternat\u00edv is.) Melyek azok a fizet\u00e9si m\u00f3dok, amit soha nem v\u00e1lasztottak a megrendel\u0151ink? Megold\u00e1s select p . Method from [ Order ] o right outer join PaymentMethod p on o . PaymentMethodID = p . ID where o . ID is null A megold\u00e1s kulcsa az outer join , aminek k\u00f6sz\u00f6nhet\u0151en l\u00e1thatjuk, mely fizet\u00e9si m\u00f3d rekordhoz nem tartozik egyetlen megrendel\u00e9s se. R\u00f6gz\u00edts\u00fcnk be egy \u00faj vev\u0151t! K\u00e9rdezz\u00fck le az \u00fajonnan l\u00e9trej\u00f6tt rekord kulcs\u00e1t! Megold\u00e1s insert into Customer ( Name , Login , Password , Email ) values ( 'Teszt Elek' , 't.elek' , '********' , 't.elek@email.com' ) select @@ IDENTITY Az insert ut\u00e1n javasolt ki\u00edrni az oszlopneveket az egy\u00e9rtelm\u0171s\u00e9g v\u00e9gett, b\u00e1r nem k\u00f6telez\u0151. Vegy\u00fck \u00e9szre, hogy az ID oszlopnak nem adunk \u00e9rt\u00e9ket, mert azt a t\u00e1bla defin\u00edci\u00f3jakor meghat\u00e1rozva a szerver adja automatikusan. Ez\u00e9rt kell ut\u00e1na lek\u00e9rdezn\u00fcnk, hogy tudjuk, milyen ID-t adott. A kateg\u00f3ri\u00e1k k\u00f6z\u00f6tt hib\u00e1san szerepel a Tricycle kateg\u00f3ria n\u00e9v. Jav\u00edtsuk \u00e1t a kateg\u00f3ria nev\u00e9t Tricycles -re! Megold\u00e1s update Category set Name = 'Tricycles' where Name = 'Tricycle' Melyik term\u00e9k kateg\u00f3ri\u00e1ban van a legt\u00f6bb term\u00e9k? Megold\u00e1s select top 1 Name , ( select count ( * ) from Product where Product . CategoryID = c . ID ) as cnt from Category c order by cnt desc A k\u00e9rd\u00e9sre t\u00f6bb alternat\u00edv lek\u00e9rdez\u00e9s is esz\u00fcnkbe juthat. Ez csak egyike a lehets\u00e9ges megold\u00e1soknak. Itt l\u00e1thatunk p\u00e9ld\u00e1t az allek\u00e9rdez\u00e9sre is. Feladat 2: Term\u00e9kkateg\u00f3ria r\u00f6gz\u00edt\u00e9se \u00b6 Hozzon l\u00e9tre egy t\u00e1rolt elj\u00e1r\u00e1st, aminek a seg\u00edts\u00e9g\u00e9vel egy \u00faj kateg\u00f3ri\u00e1t vehet\u00fcnk fel. Az elj\u00e1r\u00e1s bemen\u0151 param\u00e9tere a felv\u00e9telre ker\u00fcl\u0151 kateg\u00f3ria neve, \u00e9s opcion\u00e1lisan a sz\u00fcl\u0151kateg\u00f3ria neve. Dobjon hib\u00e1t, ha a kateg\u00f3ria l\u00e9tezik, vagy a sz\u00fcl\u0151kateg\u00f3ria nem l\u00e9tezik. A kateg\u00f3ria els\u0151dleges kulcs\u00e1nak gener\u00e1l\u00e1s\u00e1t b\u00edzza az adatb\u00e1zisra. Megold\u00e1s T\u00e1rolt elj\u00e1r\u00e1s create or alter procedure AddNewCategory @ Name nvarchar ( 50 ), @ ParentName nvarchar ( 50 ) as begin tran -- L\u00e9tezik-e ilyen n\u00e9vvel m\u00e1r kateg\u00f3ria declare @ ID int select @ ID = ID from Category with ( TABLOCKX ) where upper ( Name ) = upper ( @ Name ) if @ ID is not null begin rollback raiserror ( 'Category %s already exists' , 16 , 1 , @ Name ) return end -- Sz\u00fcl\u0151 kateg\u00f3ri\u00e1nak l\u00e9teznie kell declare @ ParentID int if @ ParentName is not null begin select @ ParentID = ID from Category where upper ( Name ) = upper ( @ ParentName ) if @ ParentID is null begin rollback raiserror ( 'Category %s does not exist' , 16 , 1 , @ ParentName ) return end end insert into Category values ( @ Name , @ ParentID ) commit Tesztel\u00e9s Nyissunk egy \u00faj Query ablakot \u00e9s adjuk ki az al\u00e1bbi parancsot. exec AddNewCategory 'Beach balls', NULL Ennek siker\u00fclnie kell. Ellen\u0151rizz\u00fck ut\u00e1na a t\u00e1bla tartalm\u00e1t. Ism\u00e9telj\u00fck meg a fenti besz\u00far\u00e1st, ekkor m\u00e1r hib\u00e1t kell dobjon. Pr\u00f3b\u00e1ljuk ki sz\u00fcl\u0151kateg\u00f3ri\u00e1val is. exec AddNewCategory 'LEGO Star Wars', 'LEGO' Feladat 3: Megrendel\u00e9st\u00e9tel st\u00e1tusz\u00e1nak karbantart\u00e1sa \u00b6 \u00cdrjon triggert, ami a megrendel\u00e9s st\u00e1tusz\u00e1nak v\u00e1ltoz\u00e1sa eset\u00e9n a hozz\u00e1 tartoz\u00f3 egyes t\u00e9telek st\u00e1tusz\u00e1t a megfelel\u0151re m\u00f3dos\u00edtja, ha azok r\u00e9gi st\u00e1tusza megegyezett a megrendel\u00e9s r\u00e9gi st\u00e1tusz\u00e1val. A t\u00f6bbi t\u00e9telt nem \u00e9rinti a st\u00e1tusz v\u00e1ltoz\u00e1sa. Megold\u00e1s Trigger create or alter trigger UpdateOrderStatus on [ Order ] for update as update OrderItem set StatusID = i . StatusID from OrderItem oi inner join inserted i on i . Id = oi . OrderID inner join deleted d on d . ID = oi . OrderID where i . StatusID != d . StatusID and oi . StatusID = d . StatusID Sz\u00e1njunk egy kis id\u0151t az update ... from utas\u00edt\u00e1s m\u0171k\u00f6d\u00e9si elv\u00e9nek meg\u00e9rt\u00e9s\u00e9re. Az alapelvek a k\u00f6vetkez\u0151k. Akkor haszn\u00e1ljuk, ha a m\u00f3dos\u00edtand\u00f3 t\u00e1bla bizonyos mez\u0151it m\u00e1s t\u00e1bla vagy t\u00e1bl\u00e1k tartalma alapj\u00e1n szeretn\u00e9nk be\u00e1ll\u00edtani. A szintaktika alapvet\u0151en a m\u00e1r megszokott update ... set... form\u00e1t k\u00f6veti, kieg\u00e9sz\u00edtve egy from szakasszal, melyben m\u00e1r a select from utas\u00edt\u00e1sn\u00e1l megismerttel azonos szintaktik\u00e1val m\u00e1s t\u00e1bl\u00e1kb\u00f3l illeszthet\u00fcnk ( join ) adatokat a m\u00f3dos\u00edtand\u00f3 t\u00e1bl\u00e1hoz. \u00cdgy a set szakaszban az illesztett t\u00e1bl\u00e1k oszlopai is felhaszn\u00e1lhat\u00f3k adatforr\u00e1sk\u00e9nt (vagyis \u00e1llhatnak az egyenl\u0151s\u00e9g jobb oldal\u00e1n). Tesztel\u00e9s Ellen\u0151rizz\u00fck a megrendel\u00e9s \u00e9s a t\u00e9telek st\u00e1tusz\u00e1t: select OrderItem . StatusID , [ Order ]. StatusID from OrderItem join [ Order ] on OrderItem . OrderID = [ Order ]. ID where OrderID = 1 V\u00e1ltoztassuk meg a megrendel\u00e9st: update [ Order ] set StatusID = 4 where ID = 1 Ellen\u0151rizz\u00fck a megrendel\u00e9st \u00e9s a t\u00e9teleket (update ut\u00e1n minden st\u00e1tusznak meg kell v\u00e1ltoznia): select OrderItem . StatusID , [ Order ]. StatusID from OrderItem join [ Order ] on OrderItem . OrderID = [ Order ]. ID where OrderID = 1 Feladat 4: Vev\u0151 megrendel\u00e9seinek \u00f6sszegz\u00e9se \u00b6 T\u00e1roljuk el a vev\u0151 \u00f6sszes megrendel\u00e9s\u00e9nek v\u00e9g\u00f6sszeg\u00e9t a Vev\u0151 t\u00e1bl\u00e1ban! Adjuk hozz\u00e1 az a t\u00e1bl\u00e1hoz az \u00faj oszlopot: alter table Customer add Total float Sz\u00e1moljuk ki az aktu\u00e1lis v\u00e9g\u00f6sszeget. A megold\u00e1shoz haszn\u00e1ljunk kurzort, ami minden vev\u0151n megy v\u00e9gig. Megold\u00e1s declare cur_customer cursor for select ID from Customer declare @ CustomerId int declare @ Total float open cur_customer fetch next from cur_customer into @ CustomerId while @@ FETCH_STATUS = 0 begin select @ Total = sum ( oi . Amount * oi . Price ) from CustomerSite s inner join [ Order ] o on o . CustomerSiteID = s . ID inner join OrderItem oi on oi . OrderID = o . ID where s . CustomerID = @ CustomerId update Customer set Total = ISNULL ( @ Total , 0 ) where ID = @ CustomerId fetch next from cur_customer into @ CustomerId end close cur_customer deallocate cur_customer Ellen\u0151rizz\u00fck a Customer t\u00e1bla tartalm\u00e1t. Feladat 5: Vev\u0151 \u00f6sszmegrendel\u00e9s\u00e9nek karbantart\u00e1sa (\u00f6n\u00e1ll\u00f3 feladat) \u00b6 Az el\u0151z\u0151 feladatban kisz\u00e1molt \u00e9rt\u00e9k az aktu\u00e1lis \u00e1llapotot tartalmazza csak. K\u00e9sz\u00edts\u00fcnk triggert, amivel karbantartjuk azt az \u00f6sszeget minden megrendel\u00e9st \u00e9rint\u0151 v\u00e1ltoz\u00e1s eset\u00e9n. Az \u00f6sszeg \u00fajrasz\u00e1mol\u00e1sa helyett csak friss\u00edtse a v\u00e1ltoz\u00e1sokkal az \u00e9rt\u00e9ket! Megold\u00e1s A megold\u00e1s kulcsa meghat\u00e1rozni, mely t\u00e1bl\u00e1ra kell a triggert tenni. A megrendel\u00e9sek v\u00e1ltoz\u00e1sa \u00e9rdekes sz\u00e1munkra, de val\u00f3j\u00e1ban a v\u00e9g\u00f6sszeg a megrendel\u00e9shez felvett t\u00e9telek m\u00f3dosul\u00e1sakor fog v\u00e1ltozni, \u00edgy erre a t\u00e1bl\u00e1ra kell a trigger. A feladat neh\u00e9zs\u00e9g\u00e9t az adja, hogy az inserted \u00e9s deleted t\u00e1bl\u00e1kban nem csak egy vev\u0151 adatai m\u00f3dosulhatnak. Egy lehets\u00e9ges megold\u00e1s a kor\u00e1bban haszn\u00e1lt kurzoros megk\u00f6zel\u00edt\u00e9s (itt a v\u00e1ltoz\u00e1sokon kell iter\u00e1lni). Avagy megpr\u00f3b\u00e1lhatjuk meg\u00edrni egy utas\u00edt\u00e1sban is, \u00fcgyelve arra, hogy vev\u0151k szerint csoportos\u00edtsuk a v\u00e1ltoz\u00e1sokat. Trigger create or alter trigger CustomerTotalUpdate on OrderItem for insert , update , delete as update Customer set Total = isnull ( Total , 0 ) + TotalChange from Customer inner join ( select s . CustomerId , sum ( Amount * Price ) as TotalChange from CustomerSite s inner join [ Order ] o on o . CustomerSiteID = s . ID inner join inserted i on i . OrderID = o . ID group by s . CustomerId ) CustomerChange on Customer . ID = CustomerChange . CustomerId update Customer set Total = isnull ( Total , 0 ) - TotalChange from Customer inner join ( select s . CustomerId , sum ( Amount * Price ) as TotalChange from CustomerSite s inner join [ Order ] o on o . CustomerSiteID = s . ID inner join deleted d on d . OrderID = o . ID group by s . CustomerID ) CustomerChange on Customer . ID = CustomerChange . CustomerId Tesztel\u00e9s N\u00e9zz\u00fck meg az \u00f6sszmegrendel\u00e9sek aktu\u00e1lis \u00e9rt\u00e9k\u00e9t, jegyezz\u00fck meg a sz\u00e1mokat. select ID , Total from Customer M\u00f3dos\u00edtsunk egy megrendel\u00e9s mennyis\u00e9g\u00e9n. update OrderItem set Amount = 3 where ID = 1 N\u00e9zz\u00fck meg az \u00f6sszegeket ism\u00e9t, meg kellett v\u00e1ltoznia a sz\u00e1mnak. select ID , Total from Customer","title":"Microsoft SQL Server programoz\u00e1sa"},{"location":"gyakorlat/mssql/#microsoft-sql-server-programozasa","text":"A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k az Microsoft SQL Server platform szerver oldali programoz\u00e1s\u00e1nak alapjait, elsaj\u00e1t\u00edts\u00e1k az alapfogalmakat \u00e9s a fejleszt\u0151eszk\u00f6z haszn\u00e1lat\u00e1t.","title":"Microsoft SQL Server programoz\u00e1sa"},{"location":"gyakorlat/mssql/#elofeltetelek","text":"A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft SQL Server (LocalDB vagy Express edition) SQL Server Management Studio Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Amit \u00e9rdemes \u00e1tn\u00e9zned: SQL nyelv Microsoft SQL Server programoz\u00e1sa (t\u00e1rolt elj\u00e1r\u00e1sok, triggerek) Microsoft SQL Server haszn\u00e1lata seg\u00e9dlet","title":"El\u0151felt\u00e9telek"},{"location":"gyakorlat/mssql/#gyakorlat-menete","text":"Az els\u0151 n\u00e9gy feladatot (bele\u00e9rtve a megold\u00e1sok tesztel\u00e9s\u00e9t is) a gyakorlatvezet\u0151vel egy\u00fctt oldjuk meg. Az utols\u00f3 feladat \u00f6n\u00e1ll\u00f3 munka, amennyiben marad r\u00e1 id\u0151. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!","title":"Gyakorlat menete"},{"location":"gyakorlat/mssql/#feladat-0-adatbazis-letrehozasa-ellenorzese","text":"Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban .)","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se"},{"location":"gyakorlat/mssql/#feladat-1-sql-parancsok-emlekezteto","text":"\u00cdrjon SQL lek\u00e9rdez\u00e9s/utas\u00edt\u00e1st az al\u00e1bbi feladatokhoz. H\u00e1ny nem teljes\u00edtett megrendel\u00e9s\u00fcnk van (a st\u00e1tusz alapj\u00e1n)? Megold\u00e1s select count ( * ) from [ Order ] o join Status s on o . StatusID = s . ID where s . Name != 'Delivered' A join mellett az oszlopf\u00fcggv\u00e9ny (aggreg\u00e1ci\u00f3) haszn\u00e1lat\u00e1ra l\u00e1tunk p\u00e9ld\u00e1t. (A t\u00e1bl\u00e1k kapcsol\u00e1s\u00e1ra nem csak ez a szintaktika haszn\u00e1lhat\u00f3, el\u0151ad\u00e1son szerepelt alternat\u00edv is.) Melyek azok a fizet\u00e9si m\u00f3dok, amit soha nem v\u00e1lasztottak a megrendel\u0151ink? Megold\u00e1s select p . Method from [ Order ] o right outer join PaymentMethod p on o . PaymentMethodID = p . ID where o . ID is null A megold\u00e1s kulcsa az outer join , aminek k\u00f6sz\u00f6nhet\u0151en l\u00e1thatjuk, mely fizet\u00e9si m\u00f3d rekordhoz nem tartozik egyetlen megrendel\u00e9s se. R\u00f6gz\u00edts\u00fcnk be egy \u00faj vev\u0151t! K\u00e9rdezz\u00fck le az \u00fajonnan l\u00e9trej\u00f6tt rekord kulcs\u00e1t! Megold\u00e1s insert into Customer ( Name , Login , Password , Email ) values ( 'Teszt Elek' , 't.elek' , '********' , 't.elek@email.com' ) select @@ IDENTITY Az insert ut\u00e1n javasolt ki\u00edrni az oszlopneveket az egy\u00e9rtelm\u0171s\u00e9g v\u00e9gett, b\u00e1r nem k\u00f6telez\u0151. Vegy\u00fck \u00e9szre, hogy az ID oszlopnak nem adunk \u00e9rt\u00e9ket, mert azt a t\u00e1bla defin\u00edci\u00f3jakor meghat\u00e1rozva a szerver adja automatikusan. Ez\u00e9rt kell ut\u00e1na lek\u00e9rdezn\u00fcnk, hogy tudjuk, milyen ID-t adott. A kateg\u00f3ri\u00e1k k\u00f6z\u00f6tt hib\u00e1san szerepel a Tricycle kateg\u00f3ria n\u00e9v. Jav\u00edtsuk \u00e1t a kateg\u00f3ria nev\u00e9t Tricycles -re! Megold\u00e1s update Category set Name = 'Tricycles' where Name = 'Tricycle' Melyik term\u00e9k kateg\u00f3ri\u00e1ban van a legt\u00f6bb term\u00e9k? Megold\u00e1s select top 1 Name , ( select count ( * ) from Product where Product . CategoryID = c . ID ) as cnt from Category c order by cnt desc A k\u00e9rd\u00e9sre t\u00f6bb alternat\u00edv lek\u00e9rdez\u00e9s is esz\u00fcnkbe juthat. Ez csak egyike a lehets\u00e9ges megold\u00e1soknak. Itt l\u00e1thatunk p\u00e9ld\u00e1t az allek\u00e9rdez\u00e9sre is.","title":"Feladat 1: SQL parancsok (eml\u00e9keztet\u0151)"},{"location":"gyakorlat/mssql/#feladat-2-termekkategoria-rogzitese","text":"Hozzon l\u00e9tre egy t\u00e1rolt elj\u00e1r\u00e1st, aminek a seg\u00edts\u00e9g\u00e9vel egy \u00faj kateg\u00f3ri\u00e1t vehet\u00fcnk fel. Az elj\u00e1r\u00e1s bemen\u0151 param\u00e9tere a felv\u00e9telre ker\u00fcl\u0151 kateg\u00f3ria neve, \u00e9s opcion\u00e1lisan a sz\u00fcl\u0151kateg\u00f3ria neve. Dobjon hib\u00e1t, ha a kateg\u00f3ria l\u00e9tezik, vagy a sz\u00fcl\u0151kateg\u00f3ria nem l\u00e9tezik. A kateg\u00f3ria els\u0151dleges kulcs\u00e1nak gener\u00e1l\u00e1s\u00e1t b\u00edzza az adatb\u00e1zisra. Megold\u00e1s T\u00e1rolt elj\u00e1r\u00e1s create or alter procedure AddNewCategory @ Name nvarchar ( 50 ), @ ParentName nvarchar ( 50 ) as begin tran -- L\u00e9tezik-e ilyen n\u00e9vvel m\u00e1r kateg\u00f3ria declare @ ID int select @ ID = ID from Category with ( TABLOCKX ) where upper ( Name ) = upper ( @ Name ) if @ ID is not null begin rollback raiserror ( 'Category %s already exists' , 16 , 1 , @ Name ) return end -- Sz\u00fcl\u0151 kateg\u00f3ri\u00e1nak l\u00e9teznie kell declare @ ParentID int if @ ParentName is not null begin select @ ParentID = ID from Category where upper ( Name ) = upper ( @ ParentName ) if @ ParentID is null begin rollback raiserror ( 'Category %s does not exist' , 16 , 1 , @ ParentName ) return end end insert into Category values ( @ Name , @ ParentID ) commit Tesztel\u00e9s Nyissunk egy \u00faj Query ablakot \u00e9s adjuk ki az al\u00e1bbi parancsot. exec AddNewCategory 'Beach balls', NULL Ennek siker\u00fclnie kell. Ellen\u0151rizz\u00fck ut\u00e1na a t\u00e1bla tartalm\u00e1t. Ism\u00e9telj\u00fck meg a fenti besz\u00far\u00e1st, ekkor m\u00e1r hib\u00e1t kell dobjon. Pr\u00f3b\u00e1ljuk ki sz\u00fcl\u0151kateg\u00f3ri\u00e1val is. exec AddNewCategory 'LEGO Star Wars', 'LEGO'","title":"Feladat 2: Term\u00e9kkateg\u00f3ria r\u00f6gz\u00edt\u00e9se"},{"location":"gyakorlat/mssql/#feladat-3-megrendelestetel-statuszanak-karbantartasa","text":"\u00cdrjon triggert, ami a megrendel\u00e9s st\u00e1tusz\u00e1nak v\u00e1ltoz\u00e1sa eset\u00e9n a hozz\u00e1 tartoz\u00f3 egyes t\u00e9telek st\u00e1tusz\u00e1t a megfelel\u0151re m\u00f3dos\u00edtja, ha azok r\u00e9gi st\u00e1tusza megegyezett a megrendel\u00e9s r\u00e9gi st\u00e1tusz\u00e1val. A t\u00f6bbi t\u00e9telt nem \u00e9rinti a st\u00e1tusz v\u00e1ltoz\u00e1sa. Megold\u00e1s Trigger create or alter trigger UpdateOrderStatus on [ Order ] for update as update OrderItem set StatusID = i . StatusID from OrderItem oi inner join inserted i on i . Id = oi . OrderID inner join deleted d on d . ID = oi . OrderID where i . StatusID != d . StatusID and oi . StatusID = d . StatusID Sz\u00e1njunk egy kis id\u0151t az update ... from utas\u00edt\u00e1s m\u0171k\u00f6d\u00e9si elv\u00e9nek meg\u00e9rt\u00e9s\u00e9re. Az alapelvek a k\u00f6vetkez\u0151k. Akkor haszn\u00e1ljuk, ha a m\u00f3dos\u00edtand\u00f3 t\u00e1bla bizonyos mez\u0151it m\u00e1s t\u00e1bla vagy t\u00e1bl\u00e1k tartalma alapj\u00e1n szeretn\u00e9nk be\u00e1ll\u00edtani. A szintaktika alapvet\u0151en a m\u00e1r megszokott update ... set... form\u00e1t k\u00f6veti, kieg\u00e9sz\u00edtve egy from szakasszal, melyben m\u00e1r a select from utas\u00edt\u00e1sn\u00e1l megismerttel azonos szintaktik\u00e1val m\u00e1s t\u00e1bl\u00e1kb\u00f3l illeszthet\u00fcnk ( join ) adatokat a m\u00f3dos\u00edtand\u00f3 t\u00e1bl\u00e1hoz. \u00cdgy a set szakaszban az illesztett t\u00e1bl\u00e1k oszlopai is felhaszn\u00e1lhat\u00f3k adatforr\u00e1sk\u00e9nt (vagyis \u00e1llhatnak az egyenl\u0151s\u00e9g jobb oldal\u00e1n). Tesztel\u00e9s Ellen\u0151rizz\u00fck a megrendel\u00e9s \u00e9s a t\u00e9telek st\u00e1tusz\u00e1t: select OrderItem . StatusID , [ Order ]. StatusID from OrderItem join [ Order ] on OrderItem . OrderID = [ Order ]. ID where OrderID = 1 V\u00e1ltoztassuk meg a megrendel\u00e9st: update [ Order ] set StatusID = 4 where ID = 1 Ellen\u0151rizz\u00fck a megrendel\u00e9st \u00e9s a t\u00e9teleket (update ut\u00e1n minden st\u00e1tusznak meg kell v\u00e1ltoznia): select OrderItem . StatusID , [ Order ]. StatusID from OrderItem join [ Order ] on OrderItem . OrderID = [ Order ]. ID where OrderID = 1","title":"Feladat 3: Megrendel\u00e9st\u00e9tel st\u00e1tusz\u00e1nak karbantart\u00e1sa"},{"location":"gyakorlat/mssql/#feladat-4-vevo-megrendeleseinek-osszegzese","text":"T\u00e1roljuk el a vev\u0151 \u00f6sszes megrendel\u00e9s\u00e9nek v\u00e9g\u00f6sszeg\u00e9t a Vev\u0151 t\u00e1bl\u00e1ban! Adjuk hozz\u00e1 az a t\u00e1bl\u00e1hoz az \u00faj oszlopot: alter table Customer add Total float Sz\u00e1moljuk ki az aktu\u00e1lis v\u00e9g\u00f6sszeget. A megold\u00e1shoz haszn\u00e1ljunk kurzort, ami minden vev\u0151n megy v\u00e9gig. Megold\u00e1s declare cur_customer cursor for select ID from Customer declare @ CustomerId int declare @ Total float open cur_customer fetch next from cur_customer into @ CustomerId while @@ FETCH_STATUS = 0 begin select @ Total = sum ( oi . Amount * oi . Price ) from CustomerSite s inner join [ Order ] o on o . CustomerSiteID = s . ID inner join OrderItem oi on oi . OrderID = o . ID where s . CustomerID = @ CustomerId update Customer set Total = ISNULL ( @ Total , 0 ) where ID = @ CustomerId fetch next from cur_customer into @ CustomerId end close cur_customer deallocate cur_customer Ellen\u0151rizz\u00fck a Customer t\u00e1bla tartalm\u00e1t.","title":"Feladat 4: Vev\u0151 megrendel\u00e9seinek \u00f6sszegz\u00e9se"},{"location":"gyakorlat/mssql/#feladat-5-vevo-osszmegrendelesenek-karbantartasa-onallo-feladat","text":"Az el\u0151z\u0151 feladatban kisz\u00e1molt \u00e9rt\u00e9k az aktu\u00e1lis \u00e1llapotot tartalmazza csak. K\u00e9sz\u00edts\u00fcnk triggert, amivel karbantartjuk azt az \u00f6sszeget minden megrendel\u00e9st \u00e9rint\u0151 v\u00e1ltoz\u00e1s eset\u00e9n. Az \u00f6sszeg \u00fajrasz\u00e1mol\u00e1sa helyett csak friss\u00edtse a v\u00e1ltoz\u00e1sokkal az \u00e9rt\u00e9ket! Megold\u00e1s A megold\u00e1s kulcsa meghat\u00e1rozni, mely t\u00e1bl\u00e1ra kell a triggert tenni. A megrendel\u00e9sek v\u00e1ltoz\u00e1sa \u00e9rdekes sz\u00e1munkra, de val\u00f3j\u00e1ban a v\u00e9g\u00f6sszeg a megrendel\u00e9shez felvett t\u00e9telek m\u00f3dosul\u00e1sakor fog v\u00e1ltozni, \u00edgy erre a t\u00e1bl\u00e1ra kell a trigger. A feladat neh\u00e9zs\u00e9g\u00e9t az adja, hogy az inserted \u00e9s deleted t\u00e1bl\u00e1kban nem csak egy vev\u0151 adatai m\u00f3dosulhatnak. Egy lehets\u00e9ges megold\u00e1s a kor\u00e1bban haszn\u00e1lt kurzoros megk\u00f6zel\u00edt\u00e9s (itt a v\u00e1ltoz\u00e1sokon kell iter\u00e1lni). Avagy megpr\u00f3b\u00e1lhatjuk meg\u00edrni egy utas\u00edt\u00e1sban is, \u00fcgyelve arra, hogy vev\u0151k szerint csoportos\u00edtsuk a v\u00e1ltoz\u00e1sokat. Trigger create or alter trigger CustomerTotalUpdate on OrderItem for insert , update , delete as update Customer set Total = isnull ( Total , 0 ) + TotalChange from Customer inner join ( select s . CustomerId , sum ( Amount * Price ) as TotalChange from CustomerSite s inner join [ Order ] o on o . CustomerSiteID = s . ID inner join inserted i on i . OrderID = o . ID group by s . CustomerId ) CustomerChange on Customer . ID = CustomerChange . CustomerId update Customer set Total = isnull ( Total , 0 ) - TotalChange from Customer inner join ( select s . CustomerId , sum ( Amount * Price ) as TotalChange from CustomerSite s inner join [ Order ] o on o . CustomerSiteID = s . ID inner join deleted d on d . OrderID = o . ID group by s . CustomerID ) CustomerChange on Customer . ID = CustomerChange . CustomerId Tesztel\u00e9s N\u00e9zz\u00fck meg az \u00f6sszmegrendel\u00e9sek aktu\u00e1lis \u00e9rt\u00e9k\u00e9t, jegyezz\u00fck meg a sz\u00e1mokat. select ID , Total from Customer M\u00f3dos\u00edtsunk egy megrendel\u00e9s mennyis\u00e9g\u00e9n. update OrderItem set Amount = 3 where ID = 1 N\u00e9zz\u00fck meg az \u00f6sszegeket ism\u00e9t, meg kellett v\u00e1ltoznia a sz\u00e1mnak. select ID , Total from Customer","title":"Feladat 5: Vev\u0151 \u00f6sszmegrendel\u00e9s\u00e9nek karbantart\u00e1sa (\u00f6n\u00e1ll\u00f3 feladat)"},{"location":"gyakorlat/rest/","text":"REST API & ASP.NET Web API \u00b6 A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k gyakorolj\u00e1k a REST API-k tervez\u00e9s\u00e9t, \u00e9s megismerj\u00e9k a .NET Web API technol\u00f3gi\u00e1j\u00e1t. El\u0151felt\u00e9telek \u00b6 A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft Visual Studio 2019 ( nem VS Code) Microsoft SQL Server (LocalDB vagy Express edition) SQL Server Management Studio Postman: https://www.getpostman.com/downloads/ Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Kiindul\u00f3 alkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-rest-kiindulo Amit \u00e9rdemes \u00e1tn\u00e9zned: C# nyelv Entity Framework \u00e9s Linq REST API \u00e9s Web API el\u0151ad\u00e1s Gyakorlat menete \u00b6 A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot! Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se \u00b6 Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban .) Feladat 1: Projekt megnyit\u00e1sa \u00b6 T\u00f6lts\u00fck le a m\u00e9r\u00e9shez tartoz\u00f3 projekt v\u00e1zat! Nyissunk egy command prompt -ot Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN Adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone --depth 1 https://github.com/bmeviauac01/gyakorlat-rest-kiindulo.git Nyissuk meg a rest k\u00f6nyvt\u00e1r alatti sln f\u00e1jlt Visual Studio-val. Vizsg\u00e1ljuk meg a projektet. Ez egy ASP.NET Core Web API projekt. Kifejezetten REST API-k kiszolg\u00e1l\u00e1s\u00e1hoz k\u00e9sz\u00fclt. Ha F5-tel elind\u00edtjuk, akkor mag\u00e1ban tartalmaz egy webszervert a k\u00e9r\u00e9sek kiszolg\u00e1l\u00e1s\u00e1hoz. N\u00e9zz\u00fck meg a Program.cs tartalm\u00e1t. Nem kell \u00e9rten\u00fcnk, hogy mi t\u00f6rt\u00e9nik itt pontosan, csak l\u00e1ssuk, hogy ez olyan, mint egy konzol alkalmaz\u00e1s: a Main f\u00fcggv\u00e9nyben elind\u00edt egy webszervert. Az adatb\u00e1zisunk Entity Framework lek\u00e9pz\u00e9se ( Code First modellel) megtal\u00e1lhat\u00f3 a Dal mapp\u00e1ban. Az DataDrivenDbContext lesz az el\u00e9r\u00e9s k\u00f6zponti oszt\u00e1lya. A connection stringet jav\u00edtsuk ki sz\u00fcks\u00e9g eset\u00e9n ebben az oszt\u00e1lyban az OnConfiguring f\u00fcggv\u00e9nyben. A connection stringet term\u00e9szetesen nem c\u00e9lszer\u0171 be\u00e9getni a forr\u00e1sk\u00f3dba. Mi ezt csup\u00e1n egyszer\u0171s\u00edt\u00e9sk\u00e9nt alkalmazzuk. A Controllers mapp\u00e1ban m\u00e1r van egy teszt controller. Nyissuk meg \u00e9s vizsg\u00e1ljuk meg. Vegy\u00fck \u00e9szre az [ApiController] \u00e9s [Route] attrib\u00fatumokat, valamint a lesz\u00e1rmaz\u00e1st. Ett\u0151l lesz egy oszt\u00e1ly Web API controller . Minden tov\u00e1bbi automatikusan m\u0171k\u00f6dik, a controller met\u00f3dusai a megadott k\u00e9r\u00e9sekre (az \u00fatvonal \u00e9s http met\u00f3dus f\u00fcggv\u00e9ny\u00e9ben) meg fognak h\u00edv\u00f3dni (teh\u00e1t nincs tov\u00e1bbi konfigur\u00e1ci\u00f3ra sz\u00fcks\u00e9g). Ind\u00edtsuk el az alkalmaz\u00e1st. Ford\u00edt\u00e1s ut\u00e1n egy konzol alkalmaz\u00e1s indul el, ahol l\u00e1tjuk a logokat. Nyissunk egy b\u00f6ng\u00e9sz\u0151t, \u00e9s a http://localhost:5000/api/values c\u00edmet \u00edrjuk be. Kapnunk kell egy JSON v\u00e1laszt. \u00c1ll\u00edtsuk le az alkalmaz\u00e1st: vagy Ctrl-C a konzol alkalmaz\u00e1sban, vagy Visual Studio-ban \u00e1ll\u00edtsuk le. Feladat 2: Els\u0151 Controller \u00e9s met\u00f3dus, tesztel\u00e9s Postmannel \u00b6 K\u00e9sz\u00edts\u00fcnk egy \u00faj Web API controllert, ami visszaad egy \u00fcdv\u00f6zl\u0151 sz\u00f6veget. Pr\u00f3b\u00e1ljuk ki a m\u0171k\u00f6d\u00e9st Postman haszn\u00e1lat\u00e1val. T\u00f6r\u00f6lj\u00fck ki a ValuesController oszt\u00e1lyt. Adjuk hozz\u00e1 helyette egy \u00faj Api Controller -t \u00fcresen HelloController n\u00e9ven: a Solution Explorer -ben a Controllers mapp\u00e1ra jobb eg\u00e9rrel kattintva Add / Controller... / API Controller - Empty . A HelloController a /api/hello url alatt legyen el\u00e9rhet\u0151. K\u00e9sz\u00edts\u00fcnk egy GET k\u00e9r\u00e9sre v\u00e1laszol\u00f3 met\u00f3dust, ami egy sz\u00f6veggel t\u00e9r vissza. Pr\u00f3b\u00e1ljuk ki Postman-nel: a GET k\u00e9r\u00e9st http://localhost:5000/api/hello c\u00edmre kell k\u00fclden\u00fcnk. M\u00f3dos\u00edtsuk a REST k\u00e9r\u00e9st kiszolg\u00e1l\u00f3 met\u00f3dust \u00fagy, hogy opcion\u00e1lisan fogadjon el egy nevet query param\u00e9terben , azaz az urlben, \u00e9s ha kap ilyet, akkor a v\u00e1lasza legyen \"Hello\" + a kapott n\u00e9v. Pr\u00f3b\u00e1ljuk ki ezt is Postmannel: Ha adunk nevet, akkor azt a http://localhost:5000/api/hello?name=alma url-je k\u00fcldj\u00fck. V\u00e9g\u00fcl k\u00e9sz\u00edts\u00fcnk egy \u00faj REST Api v\u00e9gpontot (\u00faj f\u00fcggv\u00e9nyt), ami a http://localhost:5000/api/hello/alma url-en fog v\u00e1laszolni pont \u00fagy, ahogy az el\u0151z\u0151 is tette (csak most a n\u00e9v a path r\u00e9sze). Megold\u00e1s [Route(\"api/hello\")] [ApiController] public class HelloController : ControllerBase { // 2. alfeladat //[HttpGet] //public ActionResult<string> Hello() //{ // return \"Hello!\"; //} // 3. alfeladat [HttpGet] public ActionResult < string > Hello ([ FromQuery ] string name ) { if ( string . IsNullOrEmpty ( name )) return \"Hello noname!\" ; else return \"Hello \" + name ; } // 4. alfeladat [HttpGet] [Route(\"{personName}\")] // a route-ban a {} k\u00f6z\u00f6tti n\u00e9v meg kell egyezzen a param\u00e9ter nev\u00e9vel public ActionResult < string > HelloRoute ( string personName ) { return \"Hello route \" + personName ; } } Foglaljuk \u00f6ssze, mi kell ahhoz, hogy egy WebAPI v\u00e9gpontot k\u00e9sz\u00edts\u00fcnk: Lesz\u00e1rmazni a ControllerBase -b\u0151l \u00e9s az [ApiController] attrib\u00fatumot r\u00e1tenni az oszt\u00e1lyra. Megadni a route-ot, ak\u00e1r az oszt\u00e1lyon, ak\u00e1r a met\u00f3duson (vagy mindkett\u0151n) a [Route] attrib\u00fatummal. Megfelel\u0151 form\u00e1j\u00fa met\u00f3dust k\u00e9sz\u00edteni (pl. visszat\u00e9r\u00e9si \u00e9rt\u00e9k, param\u00e9terek). Megadni, milyen http k\u00e9r\u00e9sre v\u00e1laszol a v\u00e9gpont a megfelel\u0151 [Http*] attrib\u00fatummal. Feladat 3: Term\u00e9kek keres\u00e9se API \u00b6 Egy val\u00f3di API term\u00e9szetesen nem konstansokat ad vissza. K\u00e9sz\u00edts\u00fcnk API-t a webshopban \u00e1rult term\u00e9kek k\u00f6z\u00f6tti keres\u00e9shez. K\u00e9sz\u00edts\u00fcnk ehhez egy \u00faj controller-t. Lehessen list\u00e1zni a term\u00e9keket, de csak lapozva (max 5 elem minden lapon). Lehessen keresni term\u00e9k n\u00e9vre. A visszaadott term\u00e9k entit\u00e1s ne az adatb\u00e1zis lek\u00e9pz\u00e9sb\u0151l j\u00f6v\u0151 entit\u00e1s legyen, hanem k\u00e9sz\u00edts\u00fcnk egy \u00faj, un. DTO (data transfer object) oszt\u00e1lyt egy \u00faj, Models mapp\u00e1ban. Tesztelj\u00fck a megold\u00e1sunkat. Megold\u00e1s // ********************************* // Models/Product.cs namespace BME.DataDriven.REST.Models { public class Product { public Product ( int id , string name , double? price , int? stock ) { Id = id ; Name = name ; Price = price ; Stock = stock ; } // Csak a lenyeges tulajdonsagokat tartalmazza, pl. az adatbazis kulso kulcsokat nem. // Ertekadas csak a konstruktoron keresztul lehetseges, ezzel jelezve, hogy a peldany // egy pillanatkep alapjan jon letre, es nem modosithato. public int Id { get ; private set ; } public string Name { get ; private set ; } public double? Price { get ; private set ; } public int? Stock { get ; private set ; } } } // ********************************* // Controllers/ProductsController.cs using System.Linq ; using Microsoft.AspNetCore.Mvc ; namespace BME.DataDriven.REST.Controllers { [Route(\"api/products\")] // adjunk meg explicit urlt inkabb [ApiController] public class ProductsController : ControllerBase { private readonly Dal . DataDrivenDbContext dbContext ; // Az adatbazist igy kaphatjuk meg. A kornyezet adja a Dependency Injection szolgaltatast. // A DbContext automatikusan megszunik a keres veges (DI beallitas). public ProductsController ( Dal . DataDrivenDbContext dbContext ) { this . dbContext = dbContext ; } [HttpGet] public ActionResult < Models . Product []> List ([ FromQuery ] string search = null , [ FromQuery ] int from = 0 ) { IQueryable < Dal . Product > filteredList ; if ( string . IsNullOrEmpty ( search )) // ha nincs nev alapu kereses, az osszes termek filteredList = dbContext . Product ; else // nev alapjan kereses filteredList = dbContext . Product . Where ( p => p . Name . Contains ( search )); return filteredList . Skip ( from ) // lapozashoz: hanyadik termektol kezdve . Take ( 5 ) // egy lapon max 5 termek . Select ( p => new Models . Product ( p . Id , p . Name , p . Price , p . Stock )) // adatbazis entitas -> DTO . ToArray (); // a fenti IQueryable kiertekelesesen kieroltetese, kulonben hibara futnank } } } Vegy\u00fck \u00e9szre, hogy a JSON soros\u00edt\u00e1ssal nem kellett foglalkoznunk. Az API csak entit\u00e1st ad vissza. A soros\u00edt\u00e1sr\u00f3l automatikusan gondoskodik a keretrendszer. Lapoz\u00e1st az\u00e9rt \u00e9rdemes beiktatni, hogy korl\u00e1tozzuk a visszaadott v\u00e1laszt (ahogy a felhaszn\u00e1l\u00f3i fel\u00fcleteken is szok\u00e1s lapozni). Erre tipikus megold\u00e1s ez a \"-t\u00f3l\" jelleg\u0171 megold\u00e1s. A met\u00f3dus eredm\u00e9nye a ToArray -t megel\u0151z\u0151en egy IQueryable . Eml\u00e9kezz\u00fcnk arra, hogy az IQueryable nem tartalmazza az eredm\u00e9nyt, az csak egy le\u00edr\u00f3. Ha nem lenne a v\u00e9g\u00e9n ToArray , akkor hib\u00e1ra futna az alkalmaz\u00e1s, mert amikor a JSON soros\u00edt\u00e1s elkezden\u00e9 iter\u00e1lni a gy\u0171jtem\u00e9nyt, m\u00e1r egy megsz\u0171nt adatb\u00e1zis kapcsolaton pr\u00f3b\u00e1lna dolgozni. A WebAPI v\u00e9gpontokb\u00f3l soha ne adjunk emiatt IQueryable vagy IEnumerable visszat\u00e9r\u00e9si \u00e9rt\u00e9ket! Feladat 4: Term\u00e9kek adatainak szerkeszt\u00e9s API \u00b6 Eg\u00e9sz\u00edts\u00fck ki a term\u00e9kek keres\u00e9s\u00e9hez sz\u00fcletett API-t az al\u00e1bbi funkci\u00f3kkal: Lehessen egy adott term\u00e9k adatait lek\u00e9rdezni a term\u00e9k id-ja alapj\u00e1n a /api/products/id url-en. Tudjunk m\u00f3dos\u00edtani meglev\u0151 term\u00e9ket (nevet, \u00e1rat, rakt\u00e1rk\u00e9szletet). Lehessen felvenni \u00faj term\u00e9ket (ehhez k\u00e9sz\u00edts\u00fcnk egy \u00faj DTO oszt\u00e1lyt, amiben csak a n\u00e9v, rakt\u00e1rk\u00e9szlet \u00e9s \u00e1r van). Lehessen t\u00f6r\u00f6lni egy term\u00e9ket az id-ja alapj\u00e1n. Mindegyik v\u00e9gpontot tesztelj\u00fck! \u00daj term\u00e9k besz\u00far\u00e1s\u00e1hoz Postman-ben az al\u00e1bbi be\u00e1ll\u00edt\u00e1sokra lesz sz\u00fcks\u00e9g: POST k\u00e9r\u00e9s a helyes URL-re A Body f\u00fcl alatt a raw \u00e9s jobb oldalon a JSON kiv\u00e1laszt\u00e1sa Az al\u00e1bbi body json: { \"name\" : \"BME-s kardig\u00e1n\" , \"price\" : 8900 , \"stock\" : 100 } Megjegyz\u00e9s: Eset\u00fcnkben a JSON objektum egy Models.NewProduct objektumba deszerializ\u00e1l\u00f3dik. Mivel ebben az oszt\u00e1lyban a property setter-ek v\u00e9dettek, a JSON deszerializ\u00e1ci\u00f3 sor\u00e1n a JSON mez\u0151nevek lek\u00e9pez\u00e9se a konstruktor param\u00e9ter nevekre t\u00f6rt\u00e9nik (case insensitive m\u00f3don): \u00edgy l\u00e9nyeges, hogyan nevezz\u00fck el a konstruktor param\u00e9tereket! A m\u00f3dos\u00edt\u00e1s tesztel\u00e9s\u00e9hez pedig az al\u00e1bbi be\u00e1ll\u00edt\u00e1sokra lesz sz\u00fcks\u00e9g: PUT k\u00e9r\u00e9s a helyes URL-re A Body f\u00fcl alatt a raw \u00e9s jobb oldalon a JSON kiv\u00e1laszt\u00e1sa Az al\u00e1bbi body json: { \"id\" : 10 , \"name\" : \"Egy \u00f3ra csend\" , \"price\" : 440 , \"stock\" : 10 } Megjegyz\u00e9s: Eset\u00fcnkben a JSON objektum egy Models.Product objektumba deszerializ\u00e1l\u00f3dik. Mivel ebben az oszt\u00e1lyban a property setter-ek v\u00e9dettek, a JSON deszerializ\u00e1ci\u00f3 sor\u00e1n a JSON mez\u0151nevek lek\u00e9pez\u00e9se a konstruktor param\u00e9ter nevekre t\u00f6rt\u00e9nik (case insensitive m\u00f3don): \u00edgy l\u00e9nyeges, hogyan nevezz\u00fck el a konstruktor param\u00e9tereket! A tesztel\u00e9s sor\u00e1n n\u00e9zz\u00fck meg a kapott v\u00e1lasz Header -jeit is! A szerkeszt\u00e9s \u00e9s besz\u00far\u00e1s eset\u00e9n keress\u00fck meg benne a Location kulcsot. Itt adja vissza a rendszer, hol k\u00e9rdezhet\u0151 le az eredm\u00e9ny. Megold\u00e1s // ********************************* // Models/NewProduct.cs namespace BME.DataDriven.REST.Models { public class NewProduct { public NewProduct ( string name , double? price , int? stock ) { Name = name ; Price = price ; Stock = stock ; } public string Name { get ; private set ; } public double? Price { get ; private set ; } public int? Stock { get ; private set ; } } } // ********************************* // Controllers/ProductsController.cs namespace BME.DataDriven.REST.Controllers { public class ProductsController : ControllerBase { // ... // GET api/products/id [HttpGet] [Route(\"{id}\")] public ActionResult < Models . Product > Get ( int id ) { var dbProduct = dbContext . Product . SingleOrDefault ( p => p . Id == id ); if ( dbProduct == null ) return NotFound (); // helyes http valasz, ha nem talalhato a keresett elem else return new Models . Product ( dbProduct . Id , dbProduct . Name , dbProduct . Price , dbProduct . Stock ); // siker eseten visszaadjuk az adatot magat } // PUT api/products/id [HttpPut] [Route(\"{id}\")] public ActionResult Modify ([ FromRoute ] int id , [ FromBody ] Models . Product updated ) { if ( id != updated . Id ) return BadRequest (); var dbProduct = dbContext . Product . SingleOrDefault ( p => p . Id == id ); if ( dbProduct == null ) return NotFound (); // modositasok elvegzese dbProduct . Name = updated . Name ; dbProduct . Price = updated . Price ; dbProduct . Stock = updated . Stock ; // mentes az adatbazisban dbContext . SaveChanges (); return NoContent (); // 204 NoContent valasz } // POST api/products [HttpPost] public ActionResult Create ([ FromBody ] Models . NewProduct newProduct ) { var dbProduct = new Dal . Product () { Name = newProduct . Name , Price = newProduct . Price , Stock = newProduct . Stock , CategoryId = 1 , // nem szep, ideiglenes megoldas VatId = 1 // nem szep, ideiglenes megoldas }; // mentes az adatbazisba dbContext . Product . Add ( dbProduct ); dbContext . SaveChanges (); return CreatedAtAction ( nameof ( Get ), new { id = dbProduct . Id }, new Models . Product ( dbProduct . Id , dbProduct . Name , dbProduct . Price , dbProduct . Stock )); // igy mondjuk meg, hol kerdezheto le a beszurt elem } // DELETE api/products/id [HttpDelete] [Route(\"{id}\")] public ActionResult Delete ( int id ) { var dbProduct = dbContext . Product . SingleOrDefault ( p => p . Id == id ); if ( dbProduct == null ) return NotFound (); dbContext . Product . Remove ( dbProduct ); dbContext . SaveChanges (); return NoContent (); // a sikeres torlest 204 NoContent valasszal jelezzuk (lehetne meg 200 OK is, ha beletennenk an entitast) } } } Feladat 5: \u00daj term\u00e9k l\u00e9trehoz\u00e1sa: kateg\u00f3ria \u00e9s \u00e1fakulcs \u00b6 Az \u00faj term\u00e9k l\u00e9trehoz\u00e1sa sor\u00e1n meg kellene adnunk m\u00e9g a kateg\u00f3ri\u00e1t \u00e9s az \u00e1fakulcsot is. M\u00f3dos\u00edtsuk a fenti term\u00e9k besz\u00far\u00e1st \u00fagy, hogy a kateg\u00f3ria nev\u00e9t \u00e9s az \u00e1fakulcs sz\u00e1m\u00e9rt\u00e9k\u00e9t is meg lehessen adni. A kapott adatok alapj\u00e1n keresd ki a megfelel\u0151 VAT \u00e9s Category rekordokat az adatb\u00e1zisb\u00f3l, vagy hozz l\u00e9tre \u00fajat, ha nem l\u00e9teznek. Megold\u00e1s // ********************************* // Models/NewProduct.cs namespace BME.DataDriven.REST.Models { public class NewProduct { // ... // A konstruktort is ki kell egesziteni! // Lenyeges, hogyan nevezzuk el a konstruktor parametereket: // Mivel a property setter-ek vedettek, a JSON deszerializacio // soran a JSON mezonevek lekepezese a konstruktor parameter // nevekre tortenik (case insensitive modon). public int VATPercentage { get ; private set ; } public string CategoryName { get ; private set ; } } } // ********************************* // Controllers/ProductsController.cs namespace BME.DataDriven.REST.Controllers { // ... [HttpPost] public ActionResult Create ([ FromBody ] Models . NewProduct newProduct ) { var dbVat = dbContext . Vat . FirstOrDefault ( v => v . Percentage == newProduct . VATPercentage ); if ( dbVat == null ) dbVat = new Dal . VAT () { Percentage = newProduct . VATPercentage }; var dbCat = dbContext . Category . FirstOrDefault ( c => c . Name == newProduct . CategoryName ); if ( dbCat == null ) dbCat = new Dal . Category () { Name = newProduct . CategoryName }; var dbProduct = new Dal . Product () { Name = newProduct . Name , Price = newProduct . Price , Stock = newProduct . Stock , Category = dbCat , VAT = dbVat }; // mentes az adatbazisba dbContext . Product . Add ( dbProduct ); dbContext . SaveChanges (); return CreatedAtAction ( nameof ( Get ), new { id = dbProduct . Id }, new Models . Product ( dbProduct . Id , dbProduct . Name , dbProduct . Price , dbProduct . Stock )); // igy mondjuk meg, hol kerdezheto le a beszurt elem } }","title":"REST API & ASP.NET Web API"},{"location":"gyakorlat/rest/#rest-api-aspnet-web-api","text":"A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k gyakorolj\u00e1k a REST API-k tervez\u00e9s\u00e9t, \u00e9s megismerj\u00e9k a .NET Web API technol\u00f3gi\u00e1j\u00e1t.","title":"REST API &amp; ASP.NET Web API"},{"location":"gyakorlat/rest/#elofeltetelek","text":"A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft Visual Studio 2019 ( nem VS Code) Microsoft SQL Server (LocalDB vagy Express edition) SQL Server Management Studio Postman: https://www.getpostman.com/downloads/ Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Kiindul\u00f3 alkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-rest-kiindulo Amit \u00e9rdemes \u00e1tn\u00e9zned: C# nyelv Entity Framework \u00e9s Linq REST API \u00e9s Web API el\u0151ad\u00e1s","title":"El\u0151felt\u00e9telek"},{"location":"gyakorlat/rest/#gyakorlat-menete","text":"A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be. Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!","title":"Gyakorlat menete"},{"location":"gyakorlat/rest/#feladat-0-adatbazis-letrehozasa-ellenorzese","text":"Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban .)","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se"},{"location":"gyakorlat/rest/#feladat-1-projekt-megnyitasa","text":"T\u00f6lts\u00fck le a m\u00e9r\u00e9shez tartoz\u00f3 projekt v\u00e1zat! Nyissunk egy command prompt -ot Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul c:\\work\\NEPTUN Adjuk ki a k\u00f6vetkez\u0151 parancsot: git clone --depth 1 https://github.com/bmeviauac01/gyakorlat-rest-kiindulo.git Nyissuk meg a rest k\u00f6nyvt\u00e1r alatti sln f\u00e1jlt Visual Studio-val. Vizsg\u00e1ljuk meg a projektet. Ez egy ASP.NET Core Web API projekt. Kifejezetten REST API-k kiszolg\u00e1l\u00e1s\u00e1hoz k\u00e9sz\u00fclt. Ha F5-tel elind\u00edtjuk, akkor mag\u00e1ban tartalmaz egy webszervert a k\u00e9r\u00e9sek kiszolg\u00e1l\u00e1s\u00e1hoz. N\u00e9zz\u00fck meg a Program.cs tartalm\u00e1t. Nem kell \u00e9rten\u00fcnk, hogy mi t\u00f6rt\u00e9nik itt pontosan, csak l\u00e1ssuk, hogy ez olyan, mint egy konzol alkalmaz\u00e1s: a Main f\u00fcggv\u00e9nyben elind\u00edt egy webszervert. Az adatb\u00e1zisunk Entity Framework lek\u00e9pz\u00e9se ( Code First modellel) megtal\u00e1lhat\u00f3 a Dal mapp\u00e1ban. Az DataDrivenDbContext lesz az el\u00e9r\u00e9s k\u00f6zponti oszt\u00e1lya. A connection stringet jav\u00edtsuk ki sz\u00fcks\u00e9g eset\u00e9n ebben az oszt\u00e1lyban az OnConfiguring f\u00fcggv\u00e9nyben. A connection stringet term\u00e9szetesen nem c\u00e9lszer\u0171 be\u00e9getni a forr\u00e1sk\u00f3dba. Mi ezt csup\u00e1n egyszer\u0171s\u00edt\u00e9sk\u00e9nt alkalmazzuk. A Controllers mapp\u00e1ban m\u00e1r van egy teszt controller. Nyissuk meg \u00e9s vizsg\u00e1ljuk meg. Vegy\u00fck \u00e9szre az [ApiController] \u00e9s [Route] attrib\u00fatumokat, valamint a lesz\u00e1rmaz\u00e1st. Ett\u0151l lesz egy oszt\u00e1ly Web API controller . Minden tov\u00e1bbi automatikusan m\u0171k\u00f6dik, a controller met\u00f3dusai a megadott k\u00e9r\u00e9sekre (az \u00fatvonal \u00e9s http met\u00f3dus f\u00fcggv\u00e9ny\u00e9ben) meg fognak h\u00edv\u00f3dni (teh\u00e1t nincs tov\u00e1bbi konfigur\u00e1ci\u00f3ra sz\u00fcks\u00e9g). Ind\u00edtsuk el az alkalmaz\u00e1st. Ford\u00edt\u00e1s ut\u00e1n egy konzol alkalmaz\u00e1s indul el, ahol l\u00e1tjuk a logokat. Nyissunk egy b\u00f6ng\u00e9sz\u0151t, \u00e9s a http://localhost:5000/api/values c\u00edmet \u00edrjuk be. Kapnunk kell egy JSON v\u00e1laszt. \u00c1ll\u00edtsuk le az alkalmaz\u00e1st: vagy Ctrl-C a konzol alkalmaz\u00e1sban, vagy Visual Studio-ban \u00e1ll\u00edtsuk le.","title":"Feladat 1: Projekt megnyit\u00e1sa"},{"location":"gyakorlat/rest/#feladat-2-elso-controller-es-metodus-teszteles-postmannel","text":"K\u00e9sz\u00edts\u00fcnk egy \u00faj Web API controllert, ami visszaad egy \u00fcdv\u00f6zl\u0151 sz\u00f6veget. Pr\u00f3b\u00e1ljuk ki a m\u0171k\u00f6d\u00e9st Postman haszn\u00e1lat\u00e1val. T\u00f6r\u00f6lj\u00fck ki a ValuesController oszt\u00e1lyt. Adjuk hozz\u00e1 helyette egy \u00faj Api Controller -t \u00fcresen HelloController n\u00e9ven: a Solution Explorer -ben a Controllers mapp\u00e1ra jobb eg\u00e9rrel kattintva Add / Controller... / API Controller - Empty . A HelloController a /api/hello url alatt legyen el\u00e9rhet\u0151. K\u00e9sz\u00edts\u00fcnk egy GET k\u00e9r\u00e9sre v\u00e1laszol\u00f3 met\u00f3dust, ami egy sz\u00f6veggel t\u00e9r vissza. Pr\u00f3b\u00e1ljuk ki Postman-nel: a GET k\u00e9r\u00e9st http://localhost:5000/api/hello c\u00edmre kell k\u00fclden\u00fcnk. M\u00f3dos\u00edtsuk a REST k\u00e9r\u00e9st kiszolg\u00e1l\u00f3 met\u00f3dust \u00fagy, hogy opcion\u00e1lisan fogadjon el egy nevet query param\u00e9terben , azaz az urlben, \u00e9s ha kap ilyet, akkor a v\u00e1lasza legyen \"Hello\" + a kapott n\u00e9v. Pr\u00f3b\u00e1ljuk ki ezt is Postmannel: Ha adunk nevet, akkor azt a http://localhost:5000/api/hello?name=alma url-je k\u00fcldj\u00fck. V\u00e9g\u00fcl k\u00e9sz\u00edts\u00fcnk egy \u00faj REST Api v\u00e9gpontot (\u00faj f\u00fcggv\u00e9nyt), ami a http://localhost:5000/api/hello/alma url-en fog v\u00e1laszolni pont \u00fagy, ahogy az el\u0151z\u0151 is tette (csak most a n\u00e9v a path r\u00e9sze). Megold\u00e1s [Route(\"api/hello\")] [ApiController] public class HelloController : ControllerBase { // 2. alfeladat //[HttpGet] //public ActionResult<string> Hello() //{ // return \"Hello!\"; //} // 3. alfeladat [HttpGet] public ActionResult < string > Hello ([ FromQuery ] string name ) { if ( string . IsNullOrEmpty ( name )) return \"Hello noname!\" ; else return \"Hello \" + name ; } // 4. alfeladat [HttpGet] [Route(\"{personName}\")] // a route-ban a {} k\u00f6z\u00f6tti n\u00e9v meg kell egyezzen a param\u00e9ter nev\u00e9vel public ActionResult < string > HelloRoute ( string personName ) { return \"Hello route \" + personName ; } } Foglaljuk \u00f6ssze, mi kell ahhoz, hogy egy WebAPI v\u00e9gpontot k\u00e9sz\u00edts\u00fcnk: Lesz\u00e1rmazni a ControllerBase -b\u0151l \u00e9s az [ApiController] attrib\u00fatumot r\u00e1tenni az oszt\u00e1lyra. Megadni a route-ot, ak\u00e1r az oszt\u00e1lyon, ak\u00e1r a met\u00f3duson (vagy mindkett\u0151n) a [Route] attrib\u00fatummal. Megfelel\u0151 form\u00e1j\u00fa met\u00f3dust k\u00e9sz\u00edteni (pl. visszat\u00e9r\u00e9si \u00e9rt\u00e9k, param\u00e9terek). Megadni, milyen http k\u00e9r\u00e9sre v\u00e1laszol a v\u00e9gpont a megfelel\u0151 [Http*] attrib\u00fatummal.","title":"Feladat 2: Els\u0151 Controller \u00e9s met\u00f3dus, tesztel\u00e9s Postmannel"},{"location":"gyakorlat/rest/#feladat-3-termekek-keresese-api","text":"Egy val\u00f3di API term\u00e9szetesen nem konstansokat ad vissza. K\u00e9sz\u00edts\u00fcnk API-t a webshopban \u00e1rult term\u00e9kek k\u00f6z\u00f6tti keres\u00e9shez. K\u00e9sz\u00edts\u00fcnk ehhez egy \u00faj controller-t. Lehessen list\u00e1zni a term\u00e9keket, de csak lapozva (max 5 elem minden lapon). Lehessen keresni term\u00e9k n\u00e9vre. A visszaadott term\u00e9k entit\u00e1s ne az adatb\u00e1zis lek\u00e9pz\u00e9sb\u0151l j\u00f6v\u0151 entit\u00e1s legyen, hanem k\u00e9sz\u00edts\u00fcnk egy \u00faj, un. DTO (data transfer object) oszt\u00e1lyt egy \u00faj, Models mapp\u00e1ban. Tesztelj\u00fck a megold\u00e1sunkat. Megold\u00e1s // ********************************* // Models/Product.cs namespace BME.DataDriven.REST.Models { public class Product { public Product ( int id , string name , double? price , int? stock ) { Id = id ; Name = name ; Price = price ; Stock = stock ; } // Csak a lenyeges tulajdonsagokat tartalmazza, pl. az adatbazis kulso kulcsokat nem. // Ertekadas csak a konstruktoron keresztul lehetseges, ezzel jelezve, hogy a peldany // egy pillanatkep alapjan jon letre, es nem modosithato. public int Id { get ; private set ; } public string Name { get ; private set ; } public double? Price { get ; private set ; } public int? Stock { get ; private set ; } } } // ********************************* // Controllers/ProductsController.cs using System.Linq ; using Microsoft.AspNetCore.Mvc ; namespace BME.DataDriven.REST.Controllers { [Route(\"api/products\")] // adjunk meg explicit urlt inkabb [ApiController] public class ProductsController : ControllerBase { private readonly Dal . DataDrivenDbContext dbContext ; // Az adatbazist igy kaphatjuk meg. A kornyezet adja a Dependency Injection szolgaltatast. // A DbContext automatikusan megszunik a keres veges (DI beallitas). public ProductsController ( Dal . DataDrivenDbContext dbContext ) { this . dbContext = dbContext ; } [HttpGet] public ActionResult < Models . Product []> List ([ FromQuery ] string search = null , [ FromQuery ] int from = 0 ) { IQueryable < Dal . Product > filteredList ; if ( string . IsNullOrEmpty ( search )) // ha nincs nev alapu kereses, az osszes termek filteredList = dbContext . Product ; else // nev alapjan kereses filteredList = dbContext . Product . Where ( p => p . Name . Contains ( search )); return filteredList . Skip ( from ) // lapozashoz: hanyadik termektol kezdve . Take ( 5 ) // egy lapon max 5 termek . Select ( p => new Models . Product ( p . Id , p . Name , p . Price , p . Stock )) // adatbazis entitas -> DTO . ToArray (); // a fenti IQueryable kiertekelesesen kieroltetese, kulonben hibara futnank } } } Vegy\u00fck \u00e9szre, hogy a JSON soros\u00edt\u00e1ssal nem kellett foglalkoznunk. Az API csak entit\u00e1st ad vissza. A soros\u00edt\u00e1sr\u00f3l automatikusan gondoskodik a keretrendszer. Lapoz\u00e1st az\u00e9rt \u00e9rdemes beiktatni, hogy korl\u00e1tozzuk a visszaadott v\u00e1laszt (ahogy a felhaszn\u00e1l\u00f3i fel\u00fcleteken is szok\u00e1s lapozni). Erre tipikus megold\u00e1s ez a \"-t\u00f3l\" jelleg\u0171 megold\u00e1s. A met\u00f3dus eredm\u00e9nye a ToArray -t megel\u0151z\u0151en egy IQueryable . Eml\u00e9kezz\u00fcnk arra, hogy az IQueryable nem tartalmazza az eredm\u00e9nyt, az csak egy le\u00edr\u00f3. Ha nem lenne a v\u00e9g\u00e9n ToArray , akkor hib\u00e1ra futna az alkalmaz\u00e1s, mert amikor a JSON soros\u00edt\u00e1s elkezden\u00e9 iter\u00e1lni a gy\u0171jtem\u00e9nyt, m\u00e1r egy megsz\u0171nt adatb\u00e1zis kapcsolaton pr\u00f3b\u00e1lna dolgozni. A WebAPI v\u00e9gpontokb\u00f3l soha ne adjunk emiatt IQueryable vagy IEnumerable visszat\u00e9r\u00e9si \u00e9rt\u00e9ket!","title":"Feladat 3: Term\u00e9kek keres\u00e9se API"},{"location":"gyakorlat/rest/#feladat-4-termekek-adatainak-szerkesztes-api","text":"Eg\u00e9sz\u00edts\u00fck ki a term\u00e9kek keres\u00e9s\u00e9hez sz\u00fcletett API-t az al\u00e1bbi funkci\u00f3kkal: Lehessen egy adott term\u00e9k adatait lek\u00e9rdezni a term\u00e9k id-ja alapj\u00e1n a /api/products/id url-en. Tudjunk m\u00f3dos\u00edtani meglev\u0151 term\u00e9ket (nevet, \u00e1rat, rakt\u00e1rk\u00e9szletet). Lehessen felvenni \u00faj term\u00e9ket (ehhez k\u00e9sz\u00edts\u00fcnk egy \u00faj DTO oszt\u00e1lyt, amiben csak a n\u00e9v, rakt\u00e1rk\u00e9szlet \u00e9s \u00e1r van). Lehessen t\u00f6r\u00f6lni egy term\u00e9ket az id-ja alapj\u00e1n. Mindegyik v\u00e9gpontot tesztelj\u00fck! \u00daj term\u00e9k besz\u00far\u00e1s\u00e1hoz Postman-ben az al\u00e1bbi be\u00e1ll\u00edt\u00e1sokra lesz sz\u00fcks\u00e9g: POST k\u00e9r\u00e9s a helyes URL-re A Body f\u00fcl alatt a raw \u00e9s jobb oldalon a JSON kiv\u00e1laszt\u00e1sa Az al\u00e1bbi body json: { \"name\" : \"BME-s kardig\u00e1n\" , \"price\" : 8900 , \"stock\" : 100 } Megjegyz\u00e9s: Eset\u00fcnkben a JSON objektum egy Models.NewProduct objektumba deszerializ\u00e1l\u00f3dik. Mivel ebben az oszt\u00e1lyban a property setter-ek v\u00e9dettek, a JSON deszerializ\u00e1ci\u00f3 sor\u00e1n a JSON mez\u0151nevek lek\u00e9pez\u00e9se a konstruktor param\u00e9ter nevekre t\u00f6rt\u00e9nik (case insensitive m\u00f3don): \u00edgy l\u00e9nyeges, hogyan nevezz\u00fck el a konstruktor param\u00e9tereket! A m\u00f3dos\u00edt\u00e1s tesztel\u00e9s\u00e9hez pedig az al\u00e1bbi be\u00e1ll\u00edt\u00e1sokra lesz sz\u00fcks\u00e9g: PUT k\u00e9r\u00e9s a helyes URL-re A Body f\u00fcl alatt a raw \u00e9s jobb oldalon a JSON kiv\u00e1laszt\u00e1sa Az al\u00e1bbi body json: { \"id\" : 10 , \"name\" : \"Egy \u00f3ra csend\" , \"price\" : 440 , \"stock\" : 10 } Megjegyz\u00e9s: Eset\u00fcnkben a JSON objektum egy Models.Product objektumba deszerializ\u00e1l\u00f3dik. Mivel ebben az oszt\u00e1lyban a property setter-ek v\u00e9dettek, a JSON deszerializ\u00e1ci\u00f3 sor\u00e1n a JSON mez\u0151nevek lek\u00e9pez\u00e9se a konstruktor param\u00e9ter nevekre t\u00f6rt\u00e9nik (case insensitive m\u00f3don): \u00edgy l\u00e9nyeges, hogyan nevezz\u00fck el a konstruktor param\u00e9tereket! A tesztel\u00e9s sor\u00e1n n\u00e9zz\u00fck meg a kapott v\u00e1lasz Header -jeit is! A szerkeszt\u00e9s \u00e9s besz\u00far\u00e1s eset\u00e9n keress\u00fck meg benne a Location kulcsot. Itt adja vissza a rendszer, hol k\u00e9rdezhet\u0151 le az eredm\u00e9ny. Megold\u00e1s // ********************************* // Models/NewProduct.cs namespace BME.DataDriven.REST.Models { public class NewProduct { public NewProduct ( string name , double? price , int? stock ) { Name = name ; Price = price ; Stock = stock ; } public string Name { get ; private set ; } public double? Price { get ; private set ; } public int? Stock { get ; private set ; } } } // ********************************* // Controllers/ProductsController.cs namespace BME.DataDriven.REST.Controllers { public class ProductsController : ControllerBase { // ... // GET api/products/id [HttpGet] [Route(\"{id}\")] public ActionResult < Models . Product > Get ( int id ) { var dbProduct = dbContext . Product . SingleOrDefault ( p => p . Id == id ); if ( dbProduct == null ) return NotFound (); // helyes http valasz, ha nem talalhato a keresett elem else return new Models . Product ( dbProduct . Id , dbProduct . Name , dbProduct . Price , dbProduct . Stock ); // siker eseten visszaadjuk az adatot magat } // PUT api/products/id [HttpPut] [Route(\"{id}\")] public ActionResult Modify ([ FromRoute ] int id , [ FromBody ] Models . Product updated ) { if ( id != updated . Id ) return BadRequest (); var dbProduct = dbContext . Product . SingleOrDefault ( p => p . Id == id ); if ( dbProduct == null ) return NotFound (); // modositasok elvegzese dbProduct . Name = updated . Name ; dbProduct . Price = updated . Price ; dbProduct . Stock = updated . Stock ; // mentes az adatbazisban dbContext . SaveChanges (); return NoContent (); // 204 NoContent valasz } // POST api/products [HttpPost] public ActionResult Create ([ FromBody ] Models . NewProduct newProduct ) { var dbProduct = new Dal . Product () { Name = newProduct . Name , Price = newProduct . Price , Stock = newProduct . Stock , CategoryId = 1 , // nem szep, ideiglenes megoldas VatId = 1 // nem szep, ideiglenes megoldas }; // mentes az adatbazisba dbContext . Product . Add ( dbProduct ); dbContext . SaveChanges (); return CreatedAtAction ( nameof ( Get ), new { id = dbProduct . Id }, new Models . Product ( dbProduct . Id , dbProduct . Name , dbProduct . Price , dbProduct . Stock )); // igy mondjuk meg, hol kerdezheto le a beszurt elem } // DELETE api/products/id [HttpDelete] [Route(\"{id}\")] public ActionResult Delete ( int id ) { var dbProduct = dbContext . Product . SingleOrDefault ( p => p . Id == id ); if ( dbProduct == null ) return NotFound (); dbContext . Product . Remove ( dbProduct ); dbContext . SaveChanges (); return NoContent (); // a sikeres torlest 204 NoContent valasszal jelezzuk (lehetne meg 200 OK is, ha beletennenk an entitast) } } }","title":"Feladat 4: Term\u00e9kek adatainak szerkeszt\u00e9s API"},{"location":"gyakorlat/rest/#feladat-5-uj-termek-letrehozasa-kategoria-es-afakulcs","text":"Az \u00faj term\u00e9k l\u00e9trehoz\u00e1sa sor\u00e1n meg kellene adnunk m\u00e9g a kateg\u00f3ri\u00e1t \u00e9s az \u00e1fakulcsot is. M\u00f3dos\u00edtsuk a fenti term\u00e9k besz\u00far\u00e1st \u00fagy, hogy a kateg\u00f3ria nev\u00e9t \u00e9s az \u00e1fakulcs sz\u00e1m\u00e9rt\u00e9k\u00e9t is meg lehessen adni. A kapott adatok alapj\u00e1n keresd ki a megfelel\u0151 VAT \u00e9s Category rekordokat az adatb\u00e1zisb\u00f3l, vagy hozz l\u00e9tre \u00fajat, ha nem l\u00e9teznek. Megold\u00e1s // ********************************* // Models/NewProduct.cs namespace BME.DataDriven.REST.Models { public class NewProduct { // ... // A konstruktort is ki kell egesziteni! // Lenyeges, hogyan nevezzuk el a konstruktor parametereket: // Mivel a property setter-ek vedettek, a JSON deszerializacio // soran a JSON mezonevek lekepezese a konstruktor parameter // nevekre tortenik (case insensitive modon). public int VATPercentage { get ; private set ; } public string CategoryName { get ; private set ; } } } // ********************************* // Controllers/ProductsController.cs namespace BME.DataDriven.REST.Controllers { // ... [HttpPost] public ActionResult Create ([ FromBody ] Models . NewProduct newProduct ) { var dbVat = dbContext . Vat . FirstOrDefault ( v => v . Percentage == newProduct . VATPercentage ); if ( dbVat == null ) dbVat = new Dal . VAT () { Percentage = newProduct . VATPercentage }; var dbCat = dbContext . Category . FirstOrDefault ( c => c . Name == newProduct . CategoryName ); if ( dbCat == null ) dbCat = new Dal . Category () { Name = newProduct . CategoryName }; var dbProduct = new Dal . Product () { Name = newProduct . Name , Price = newProduct . Price , Stock = newProduct . Stock , Category = dbCat , VAT = dbVat }; // mentes az adatbazisba dbContext . Product . Add ( dbProduct ); dbContext . SaveChanges (); return CreatedAtAction ( nameof ( Get ), new { id = dbProduct . Id }, new Models . Product ( dbProduct . Id , dbProduct . Name , dbProduct . Price , dbProduct . Stock )); // igy mondjuk meg, hol kerdezheto le a beszurt elem } }","title":"Feladat 5: \u00daj term\u00e9k l\u00e9trehoz\u00e1sa: kateg\u00f3ria \u00e9s \u00e1fakulcs"},{"location":"gyakorlat/transactions/","text":"Tranzakci\u00f3kezel\u00e9s \u00b6 A gyakorlat c\u00e9lja a rel\u00e1ci\u00f3s adatb\u00e1zisok \u00e9s a Microsoft SQL Server tranzakci\u00f3kezel\u00e9s\u00e9nek megismer\u00e9se, a serializable izol\u00e1ci\u00f3s szint gyakorlati haszn\u00e1lhat\u00f3s\u00e1g\u00e1nak korl\u00e1tai, egyedi adat egym\u00e1sra hat\u00e1sok szab\u00e1lyoz\u00e1sa read committed izol\u00e1ci\u00f3s szinten. El\u0151felt\u00e9telek \u00b6 A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft SQL Server (LocalDB vagy Express edition) SQL Server Management Studio Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Amit \u00e9rdemes \u00e1tn\u00e9zned: Tranzakci\u00f3k tulajdons\u00e1gai, izol\u00e1ci\u00f3s szintek Microsoft SQL Server haszn\u00e1lata seg\u00e9dlet Gyakorlat menete \u00b6 A gyakorlat vezetett. A szoftverekkel t\u00f6rt\u00e9n\u0151 megismerked\u00e9s ut\u00e1n a gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok. A tapasztalt viselked\u00e9sekre magyar\u00e1zatot keres\u00fcnk, \u00e9s azt a csoport egy\u00fctt megbesz\u00e9li. A viselked\u00e9sek magyar\u00e1zat\u00e1t r\u00f6viden \u00f6sszefoglalja az \u00fatmutat\u00f3 is. El\u0151bb azonban gondolkodjunk el magunk a k\u00e9rd\u00e9seken! Feladat 1: Adatb\u00e1zis l\u00e9trehoz\u00e1sa MS SQL Serveren \u00b6 Els\u0151 l\u00e9p\u00e9sk\u00e9nt sz\u00fcks\u00e9g\u00fcnk lesz egy adatb\u00e1zisra. Az adatb\u00e1zis tipikusan egy k\u00f6zponti kiszolg\u00e1l\u00f3n helyezkedik el, de fejleszt\u00e9s k\u00f6zben sokszor a saj\u00e1t g\u00e9p\u00fcnk\u00f6n fut. Mi ez ut\u00f3bbi opci\u00f3t v\u00e1lasztjuk. Kapcsol\u00f3djon a Microsoft SQL Serverhez SQL Server Management Studio Seg\u00edts\u00e9g\u00e9vel. Ind\u00edtsa el az alkalmaz\u00e1st, \u00e9s az al\u00e1bbi adatokkal kapcsol\u00f3djon. Server name: (localdb)\\mssqllocaldb Authentication: Windows authentication Hozzon l\u00e9tre egy \u00faj adatb\u00e1zist (ha m\u00e9g nem l\u00e9tezik), az adatb\u00e1zis neve legyen a Neptun k\u00f3dja: Object Explorer -ben Databases-en jobb kattint\u00e1s, \u00e9s Create Database . Hozza l\u00e9tre a minta adatb\u00e1zist a gener\u00e1l\u00f3 script lefuttat\u00e1s\u00e1val. Nyisson egy \u00faj Query ablakot, m\u00e1solja be a script tartalm\u00e1t, \u00e9s futtassa le. \u00dcgyeljen az eszk\u00f6zt\u00e1ron lev\u0151 leg\u00f6rd\u00fcl\u0151 men\u00fcben a megfelel\u0151 adatb\u00e1zis kiv\u00e1laszt\u00e1s\u00e1ra. Ellen\u0151rizze, hogy l\u00e9trej\u00f6ttek-e a t\u00e1bl\u00e1k. Ha a Tables mappa ki volt m\u00e1r nyitva, akkor friss\u00edteni kell. . Feladat 2: P\u00e1rhuzamos tranzakci\u00f3k \u00b6 Nyisson k\u00e9t Query ablakot p\u00e1rhuzamos tranzakci\u00f3k szimul\u00e1l\u00e1s\u00e1hoz a New Query gomb k\u00e9tszeri megnyom\u00e1s\u00e1val. \u00c9rdemes az ablakokat egym\u00e1s mell\u00e9 tenni: a Query f\u00fcl fejl\u00e9c\u00e9re jobb eg\u00e9rrel kattintva v\u00e1lasszuk a New Vertical Tab Group opci\u00f3t: Haszn\u00e1lja az al\u00e1bbi \u00fctemez\u00e9st a parancsok v\u00e9grehajt\u00e1s\u00e1ra. A T1 tranzakci\u00f3 a 4-es megrendel\u00e9s st\u00e1tusz\u00e1t ellen\u0151rzi, m\u00edg a T2 tranzakci\u00f3 megv\u00e1ltoztatja a st\u00e1tuszt csomagolv\u00e1r\u00f3l sz\u00e1ll\u00edt\u00e1s alattira. T1 tranzakci\u00f3 -- List\u00e1zzuk ki a megrendel\u00e9s \u00e9s a hozz\u00e1 tartoz\u00f3 t\u00e9telek st\u00e1tusz\u00e1t select s1 . Name , p . Name , s2 . Name from [ Order ] o , OrderItem oi , Status s1 , status s2 , Product p where o . Id = oi . OrderID and o . ID = 4 and o . StatusID = s1 . ID and oi . StatusID = s2 . ID and p . ID = oi . ProductID [Order] Az [Order] t\u00e1bla nev\u00e9ben az\u00e9rt kell a sz\u00f6gletes z\u00e1r\u00f3jel, hogy jelezz\u00fck, t\u00e1bla n\u00e9vr\u0151l van sz\u00f3, \u00e9s nem az order by parancs kezdet\u00e9r\u0151l. T2 tranzakci\u00f3 -- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9s \u00e1llapot\u00e1t update [ Order ] set StatusID = 4 where ID = 4 T1 tranzakci\u00f3 : els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve T2 tranzakci\u00f3 -- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9shez tartoz\u00f3 t\u00e9telek \u00e1llapot\u00e1t update OrderItem set StatusID = 4 where OrderID = 4 T1 tranzakci\u00f3 : els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve Mit tapasztalt? Mi\u00e9rt? Kezdetben minden t\u00e9tel \"Packaged\" st\u00e1tuszban van, ami \u00edgy konzisztens (nem lehet egy darab t\u00e9tel \"in transit\", azaz post\u00e1z\u00e1s alatt, ha a megrendel\u00e9s nincs). Viszont, amint v\u00e1ltozatunk a megrendel\u00e9s \u00e1llapot\u00e1n, a csomag st\u00e1tusza ellentmond\u00e1sosnak l\u00e1tszik a t\u00e9telek st\u00e1tusz\u00e1val. Az adatb\u00e1zis nem inkonzisztens, mert a bels\u0151 szab\u00e1lyai (integrit\u00e1si krit\u00e9riumai) alapj\u00e1n nincs probl\u00e9ma. De \u00fczleti \u00e9rtelemben ellentmond\u00e1sos a tartalom. Az SQL Server alap\u00e9rtelmez\u00e9sben auto commit \u00fczemm\u00f3dban fut, azaz egy utas\u00edt\u00e1s az egy tranzakci\u00f3, amit automatikusan lez\u00e1r. Teh\u00e1t a probl\u00e9ma, hogy a m\u00f3dos\u00edt\u00e1saink nem egy tranzakci\u00f3t k\u00e9peznek. A helyes viselked\u00e9shez \u00f6ssze kellene fogni a k\u00e9t adatm\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st egy tranzakci\u00f3ba. Feladat 3: Tranzakci\u00f3 ind\u00edt\u00e1sa, read committed izol\u00e1ci\u00f3s szint \u00b6 Ism\u00e9telje meg az el\u0151z\u0151 feladatot \u00fagy, hogy a k\u00e9t adatm\u00f3dos\u00edt\u00e1s egy tranzakci\u00f3t k\u00e9pezzen: A T2 tranzakci\u00f3 kezdjen egy begin tran , \u00e9s v\u00e9gz\u0151dj\u00f6n egy commit utas\u00edt\u00e1ssal. Az adatm\u00f3dos\u00edt\u00e1sn\u00e1l a st\u00e1tuszt ez\u00fattal 3-asra \u00e1ll\u00edtsuk (hogy \u00e9rdemi v\u00e1ltoz\u00e1s legyen az adatokban). Mit tapasztalt? Mi\u00e9rt? Amint elkezdt\u00fck a st\u00e1tusz m\u00f3dos\u00edt\u00e1s\u00e1t T2 -ben, a lek\u00e9rdez\u0151 T1 -es utas\u00edt\u00e1s v\u00e1rni fog. Addig v\u00e1r, am\u00edg az adatm\u00f3dos\u00edt\u00f3 tranzakci\u00f3 be nem fejez\u0151dik. Ez az\u00e9rt van, mert a select utas\u00edt\u00e1s olvas\u00e1si z\u00e1rat akar elhelyezni, de m\u00e1sik tranzakci\u00f3 \u00e9ppen m\u00f3dos\u00edtja az adott rekordot, \u00edgy kiz\u00e1r\u00f3 z\u00e1rat helyezett el rajta. Jegyezz\u00fck meg, hogy az alap izol\u00e1ci\u00f3s szint, a read committed ezen a platformon azt jelenti, hogy m\u00f3dos\u00edt\u00e1s alatt lev\u0151 adat nem olvashat\u00f3. Ez egy implement\u00e1ci\u00f3s k\u00e9rd\u00e9s, az SQL szabv\u00e1ny ezt nem r\u00f6gz\u00edti. M\u00e1s adatb\u00e1zis platform viselkedhet m\u00e1shogy is (pl. az Oracle Server biztos\u00edtja, hogy a rekordok commit\u00e1lt k\u00e9pe mindenk\u00e9ppen olvashat\u00f3 marad). M\u00e1s izol\u00e1ci\u00f3s szinten az MSSQL szerver is m\u00e1shogy viselkedik, a snapshot izol\u00e1ci\u00f3s szint haszn\u00e1lata eset\u00e9n a m\u00f3dos\u00edt\u00e1s megkezd\u00e9se el\u0151tti v\u00e1ltozat olvashat\u00f3. Feladat 4: Tranzakci\u00f3 megszak\u00edt\u00e1sa ( rollback ) read committed izol\u00e1ci\u00f3s szinten \u00b6 Kezdj\u00fck el lefuttatni az el\u0151z\u0151 parancs sorozatot, a tranzakci\u00f3val egy\u00fctt, de a m\u00f3dos\u00edt\u00f3 tranzakci\u00f3t szak\u00edtsuk meg a k\u00f6zep\u00e9n. T1 tranzakci\u00f3 -- List\u00e1zzuk ki a megrendel\u00e9s \u00e9s a hozz\u00e1 tartoz\u00f3 t\u00e9telek st\u00e1tusz\u00e1t select s1 . Name , p . Name , s2 . Name from [ Order ] o , OrderItem oi , Status s1 , status s2 , Product p where o . Id = oi . OrderID and o . ID = 4 and o . StatusID = s1 . ID and oi . StatusID = s2 . ID and p . ID = oi . ProductID T2 tranzakci\u00f3 -- \u00daj tranzakci\u00f3t kezd\u00fcnk begin tran -- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9s \u00e1llapot\u00e1t update [ Order ] set StatusID = 4 where ID = 4 T1 tranzakci\u00f3 : els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve T2 tranzakci\u00f3 -- Szak\u00edtsuk meg a tranzakci\u00f3t rollback Mit tapasztalt? Mi\u00e9rt? Az el\u0151z\u0151ekben tapasztaltakhoz hasonl\u00f3an a m\u00f3dos\u00edt\u00e1s megkezdte ut\u00e1n az olvas\u00f3 utas\u00edt\u00e1s v\u00e1rakoz\u00e1sra k\u00e9nyszer\u00fclt. Amikor megszak\u00edtottuk a tranzakci\u00f3t, akkor \u00e9rkezett meg az eredm\u00e9ny. Mivel read committed izol\u00e1ci\u00f3s szinten vagyunk, nem l\u00e1tjuk a m\u00f3dos\u00edt\u00e1s alatt lev\u0151 tartalmat. Amint a m\u00f3dos\u00edt\u00f3 tranzakci\u00f3 befejez\u0151dik, ak\u00e1r sikeres commit , ak\u00e1r rollback miatt, el\u00e9rhet\u0151v\u00e9 v\u00e1lnak a rekordok. Vegy\u00fck \u00e9szre, hogy pont elker\u00fclt\u00fck a piszkos olvas\u00e1s probl\u00e9m\u00e1j\u00e1t. Ha a m\u00f3dos\u00edt\u00e1s fut\u00e1sa k\u00f6zben megjelent volna a f\u00e9lk\u00e9sz eredm\u00e9ny, a rollback miatt az a tranzakci\u00f3 \u00e9rv\u00e9nytelen adattal dolgozna tov\u00e1bb. Feladat 5: Megrendel\u00e9s r\u00f6gz\u00edt\u00e9se serializable izol\u00e1ci\u00f3s szinten \u00b6 A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r rollback utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz. Legyen k\u00e9t p\u00e1rhuzamos tranzakci\u00f3nk, melyek megrendel\u00e9st r\u00f6gz\u00edtenek. Egy term\u00e9kre nem vehet\u00fcnk fel t\u00f6bb megrendel\u00e9st, mint ami a rakt\u00e1rk\u00e9szlet. Az\u00e9rt, hogy a tranzakci\u00f3k egym\u00e1sra hat\u00e1s\u00e1t elk\u00fcl\u00f6n\u00edts\u00fck, kapcsoljunk \u00e1t serializable izol\u00e1ci\u00f3s szintre. T1 tranzakci\u00f3 set transaction isolation level serializable begin tran -- Ellen\u0151rizz\u00fck, hogy mennyi van rakt\u00e1ron egy term\u00e9kb\u0151l select * from Product where ID = 2 T2 tranzakci\u00f3 set transaction isolation level serializable begin tran select * from Product where ID = 2 T1 tranzakci\u00f3 -- Ellen\u0151rizz\u00fck, hogy h\u00e1ny, m\u00e9g fel nem dolgozott megrendel\u00e9s van erre a term\u00e9kre select sum ( Amount ) from OrderItem where ProductID = 2 and StatusID = 1 T2 tranzakci\u00f3 select sum ( Amount ) from OrderItem where ProductID = 2 and StatusID = 1 T1 tranzakci\u00f3 -- Mivel teljes\u00edthet\u0151 a megrendel\u00e9s, r\u00f6gz\u00edts\u00fck insert into OrderItem ( OrderID , ProductID , Amount , StatusID ) values ( 2 , 2 , 3 , 1 ) T2 tranzakci\u00f3 insert into OrderItem ( OrderID , ProductID , Amount , StatusID ) values ( 3 , 2 , 3 , 1 ) T1 tranzakci\u00f3 commit T2 tranzakci\u00f3 commit Mit tapasztalt? Mi\u00e9rt? Holtpont fog kialakulni, mivel a serializable izol\u00e1ci\u00f3s szint miatt mindk\u00e9t tranzakci\u00f3 megtiltja a megrendel\u00e9st\u00e9tel t\u00e1bla m\u00f3dos\u00edt\u00e1s\u00e1t. A select sum miatt, \u00e9s a megism\u00e9telhet\u0151 olvas\u00e1s elv\u00e1r\u00e1s miatt a rekordokat olvas\u00f3 z\u00e1rral l\u00e1tja el a rendszer. Viszont \u00edgy nem futhat le a m\u00e1sik tranzakci\u00f3ban az insert , amely kiz\u00e1r\u00f3lagos z\u00e1rat ig\u00e9nyelne. Ez mindk\u00e9t tranzakci\u00f3 eset\u00e9n azt jelenti, hogy a m\u00e1sik \u00e1ltal fogott z\u00e1rra v\u00e1r. A holtpont eredm\u00e9nye, hogy az egyik tranzakci\u00f3t le fogja \u00e1ll\u00edtani a szerver. Ez elv\u00e1rt \u00e9s helyes m\u0171k\u00f6d\u00e9st eredm\u00e9nyez, mivel megakad\u00e1lyozza, hogy a k\u00e9t tranzakci\u00f3 k\u00f6zt adat egym\u00e1srahat\u00e1s legyen (\u00edgy nem fordulhat el\u0151, hogy t\u00f6bb term\u00e9ket adunk el, mint amennyi van). Ism\u00e9telj\u00fck meg a fenti m\u0171veletsort, csak a megrendel\u00e9s r\u00f6gz\u00edt\u00e9sekor m\u00e1s-m\u00e1s term\u00e9k ID-t haszn\u00e1ljunk! Ezzel azt szimul\u00e1ljuk, hogy k\u00e9t megrendel\u0151 m\u00e1s-m\u00e1s term\u00e9ket rendel meg. A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r rollback utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz. Ahol utas\u00edt\u00e1sban ID vagy ProductID szerepel, ott egyik tranzakci\u00f3ban a 2-es, m\u00e1sikban a 3-as term\u00e9ket haszn\u00e1ljuk. Mit tapasztalt? Mi\u00e9rt? Ha k\u00fcl\u00f6nb\u00f6z\u0151 term\u00e9kre t\u00f6rt\u00e9nik a r\u00f6gz\u00edt\u00e9s, akkor is holtpont fog kialakulni. Olyan a z\u00e1rol\u00e1si rendszer, hogy a select sum az eg\u00e9sz t\u00e1bl\u00e1t z\u00e1rolja, mivel nem tudja megk\u00fcl\u00f6nb\u00f6ztetni ProductID szerint a rekordokat. Ez term\u00e9szetes is, mivel csak az \u00fczleti logik\u00e1b\u00f3l ad\u00f3dik, hogy ha k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 term\u00e9kre t\u00f6rt\u00e9nik a megrendel\u00e9s r\u00f6gz\u00edt\u00e9se, akkor azok t\u00f6rt\u00e9nhetn\u00e9nek egyszerre is. Az adatb\u00e1zis ezt nem tudhatja. Azaz a serializable izol\u00e1ci\u00f3s szint t\u00fal szigor\u00fa, \u00fczleti logik\u00e1t figyelembe v\u00e9ve nagyobb p\u00e1rhuzamos\u00edt\u00e1s engedhet\u0151 meg. Ez\u00e9rt is ritk\u00e1n haszn\u00e1ljuk a gyakorlatban. Feladat 6: Megrendel\u00e9s r\u00f6gz\u00edt\u00e9se read committed izol\u00e1ci\u00f3s szinten \u00b6 Gondoljuk v\u00e9gig, az el\u0151z\u0151 feladat eset\u00e9n mi t\u00f6rt\u00e9nne, ha a nem \u00e1ll\u00edtjuk \u00e1t a tranzakci\u00f3k izol\u00e1ci\u00f3s szintj\u00e9t? Lenne holtpont? \u00c9s helyes lenne a m\u0171k\u00f6d\u00e9s? Mit v\u00e1runk? Mi\u00e9rt? Ha nem v\u00e1ltoztatunk izol\u00e1ci\u00f3s szintet, akkor helytelen m\u0171k\u00f6d\u00e9s \u00e1llhatna el\u0151. Mivel a read committed izol\u00e1ci\u00f3s szint nem biztos\u00edtja sz\u00e1munkra azt, hogy am\u00edg fut a tranzakci\u00f3nk, addig egy m\u00e1sik tranzakci\u00f3 ber\u00f6gz\u00edtsen rekordokat. Teh\u00e1t lefuthatna az insert , ami miatt v\u00e9geredm\u00e9nyben t\u00f6bb \u00e1rut adn\u00e1nk el, mint ami a rakt\u00e1rban van. Ez a nem megism\u00e9telhet\u0151 olvas\u00e1s probl\u00e9m\u00e1ja. Err\u0151l az oldalr\u00f3l n\u00e9zve teh\u00e1t a serializable izol\u00e1ci\u00f3s szint nem volt feleslegesen szigor\u00fa. T\u00e9nyleg megv\u00e9dett minket egy probl\u00e9m\u00e1t\u00f3l. Feladat 7: Manu\u00e1lis z\u00e1rol\u00e1s \u00b6 A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r rollback utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz. Read committed izol\u00e1ci\u00f3s szintet haszn\u00e1lva dolgozzon ki megold\u00e1st, amely csak az azonos term\u00e9kekre t\u00f6rt\u00e9n\u0151 p\u00e1rhuzamos adatr\u00f6gz\u00edt\u00e9seket akad\u00e1lyozza meg. Term\u00e9szetesen felt\u00e9telezheti hogy mindegyik p\u00e1rhuzamos folyamat ugyanazt a programlogik\u00e1t k\u00f6veti. A megold\u00e1shoz kihaszn\u00e1ljuk, hogy lehets\u00e9ges manu\u00e1lisan z\u00e1rakat elhelyezni. Ezek a z\u00e1rak is, \u00fagy, mint a t\u00f6bbi z\u00e1r, a tranzakci\u00f3 v\u00e9g\u00e9ig \u00e9lnek. select * from tablename with ( XLOCK ) ... Hova kell ezt a z\u00e1rat elhelyezni? Hogyan n\u00e9z ki \u00edgy a megrendel\u00e9s folyamata? A megold\u00e1s kulcsa, hogy j\u00f3 helyre tegy\u00fck a z\u00e1rat. A k\u00e9rd\u00e9s, hogy mit is kellene z\u00e1rolni? A v\u00e1lasz, hogy a term\u00e9ket (Product) : azt akarjuk megg\u00e1tolni, hogy ugyanabb\u00f3l a term\u00e9kb\u0151l r\u00f6gz\u00edthet\u0151 legyen m\u00e9g egy elad\u00e1s. Teh\u00e1t a term\u00e9kre, konkr\u00e9tan a term\u00e9k t\u00e1bl\u00e1ban arra a sorra tessz\u00fck a z\u00e1rat, ami a term\u00e9ket reprezent\u00e1lja. Ennek a megold\u00e1snak a h\u00e1tr\u00e1nya, hogy nagyon alaposan \u00e1t kell gondolnunk, hogyan \u00e9s hol v\u00e9gezz\u00fck a z\u00e1rol\u00e1st. A l\u00e9p\u00e9seink teh\u00e1t a k\u00f6vetkez\u0151k. T1 tranzakci\u00f3 set transaction isolation level read committed begin tran select * from Product with ( xlock ) where ID = 2 T2 tranzakci\u00f3 set transaction isolation level read committed begin tran select * from Product with ( xlock ) where ID = 3 T1 tranzakci\u00f3 select sum ( Amount ) from OrderItem where ProductID = 2 and StatusID = 1 T2 tranzakci\u00f3 select sum ( Amount ) from OrderItem where ProductID = 3 and StatusID = 1 T1 tranzakci\u00f3 insert into OrderItem ( OrderID , ProductID , Amount , StatusID ) values ( 2 , 2 , 3 , 1 ) T2 tranzakci\u00f3 insert into OrderItem ( OrderID , ProductID , Amount , StatusID ) values ( 3 , 3 , 3 , 1 ) T1 tranzakci\u00f3 commit T2 tranzakci\u00f3 commit Feladat 8: T\u00e1bla szint\u0171 z\u00e1rol\u00e1s \u00b6 A sor szint\u0171 z\u00e1rol\u00e1s mellett lehet\u0151s\u00e9g\u00fcnk van t\u00e1bla szinten is z\u00e1rolni: select * from tablanev with ( TABLOCKX ) ... B\u00e1r ez egyszer\u0171 megold\u00e1snak t\u0171nik, gondoljuk v\u00e9gig, mi\u00e9rt nem \u00e9rdemes ezt haszn\u00e1lni? Jelen esetben a t\u00e1bla szint\u0171 z\u00e1rat a megrendel\u00e9sekre kellene tenn\u00fcnk, hiszen a konkurens megrendel\u00e9seket akarjuk megakad\u00e1lyozni. De ez ugyanazzal az eredm\u00e9nnyel j\u00e1rna, mint a serializable izol\u00e1ci\u00f3s szint haszn\u00e1lata. Ugyan holtpont nem lenne, de a p\u00e1rhuzamos v\u00e9grehajt\u00e1st lehetetlenn\u00e9 tenn\u00e9. Teh\u00e1t a t\u00e1bla szint\u0171 z\u00e1rol\u00e1sra ugyanaz igaz: az \u00fczleti logik\u00e1b\u00f3l nagyobb p\u00e1rhuzamoss\u00e1g ad\u00f3dik.","title":"Tranzakci\u00f3kezel\u00e9s"},{"location":"gyakorlat/transactions/#tranzakciokezeles","text":"A gyakorlat c\u00e9lja a rel\u00e1ci\u00f3s adatb\u00e1zisok \u00e9s a Microsoft SQL Server tranzakci\u00f3kezel\u00e9s\u00e9nek megismer\u00e9se, a serializable izol\u00e1ci\u00f3s szint gyakorlati haszn\u00e1lhat\u00f3s\u00e1g\u00e1nak korl\u00e1tai, egyedi adat egym\u00e1sra hat\u00e1sok szab\u00e1lyoz\u00e1sa read committed izol\u00e1ci\u00f3s szinten.","title":"Tranzakci\u00f3kezel\u00e9s"},{"location":"gyakorlat/transactions/#elofeltetelek","text":"A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k: Microsoft SQL Server (LocalDB vagy Express edition) SQL Server Management Studio Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Amit \u00e9rdemes \u00e1tn\u00e9zned: Tranzakci\u00f3k tulajdons\u00e1gai, izol\u00e1ci\u00f3s szintek Microsoft SQL Server haszn\u00e1lata seg\u00e9dlet","title":"El\u0151felt\u00e9telek"},{"location":"gyakorlat/transactions/#gyakorlat-menete","text":"A gyakorlat vezetett. A szoftverekkel t\u00f6rt\u00e9n\u0151 megismerked\u00e9s ut\u00e1n a gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok. A tapasztalt viselked\u00e9sekre magyar\u00e1zatot keres\u00fcnk, \u00e9s azt a csoport egy\u00fctt megbesz\u00e9li. A viselked\u00e9sek magyar\u00e1zat\u00e1t r\u00f6viden \u00f6sszefoglalja az \u00fatmutat\u00f3 is. El\u0151bb azonban gondolkodjunk el magunk a k\u00e9rd\u00e9seken!","title":"Gyakorlat menete"},{"location":"gyakorlat/transactions/#feladat-1-adatbazis-letrehozasa-ms-sql-serveren","text":"Els\u0151 l\u00e9p\u00e9sk\u00e9nt sz\u00fcks\u00e9g\u00fcnk lesz egy adatb\u00e1zisra. Az adatb\u00e1zis tipikusan egy k\u00f6zponti kiszolg\u00e1l\u00f3n helyezkedik el, de fejleszt\u00e9s k\u00f6zben sokszor a saj\u00e1t g\u00e9p\u00fcnk\u00f6n fut. Mi ez ut\u00f3bbi opci\u00f3t v\u00e1lasztjuk. Kapcsol\u00f3djon a Microsoft SQL Serverhez SQL Server Management Studio Seg\u00edts\u00e9g\u00e9vel. Ind\u00edtsa el az alkalmaz\u00e1st, \u00e9s az al\u00e1bbi adatokkal kapcsol\u00f3djon. Server name: (localdb)\\mssqllocaldb Authentication: Windows authentication Hozzon l\u00e9tre egy \u00faj adatb\u00e1zist (ha m\u00e9g nem l\u00e9tezik), az adatb\u00e1zis neve legyen a Neptun k\u00f3dja: Object Explorer -ben Databases-en jobb kattint\u00e1s, \u00e9s Create Database . Hozza l\u00e9tre a minta adatb\u00e1zist a gener\u00e1l\u00f3 script lefuttat\u00e1s\u00e1val. Nyisson egy \u00faj Query ablakot, m\u00e1solja be a script tartalm\u00e1t, \u00e9s futtassa le. \u00dcgyeljen az eszk\u00f6zt\u00e1ron lev\u0151 leg\u00f6rd\u00fcl\u0151 men\u00fcben a megfelel\u0151 adatb\u00e1zis kiv\u00e1laszt\u00e1s\u00e1ra. Ellen\u0151rizze, hogy l\u00e9trej\u00f6ttek-e a t\u00e1bl\u00e1k. Ha a Tables mappa ki volt m\u00e1r nyitva, akkor friss\u00edteni kell. .","title":"Feladat 1: Adatb\u00e1zis l\u00e9trehoz\u00e1sa MS SQL Serveren"},{"location":"gyakorlat/transactions/#feladat-2-parhuzamos-tranzakciok","text":"Nyisson k\u00e9t Query ablakot p\u00e1rhuzamos tranzakci\u00f3k szimul\u00e1l\u00e1s\u00e1hoz a New Query gomb k\u00e9tszeri megnyom\u00e1s\u00e1val. \u00c9rdemes az ablakokat egym\u00e1s mell\u00e9 tenni: a Query f\u00fcl fejl\u00e9c\u00e9re jobb eg\u00e9rrel kattintva v\u00e1lasszuk a New Vertical Tab Group opci\u00f3t: Haszn\u00e1lja az al\u00e1bbi \u00fctemez\u00e9st a parancsok v\u00e9grehajt\u00e1s\u00e1ra. A T1 tranzakci\u00f3 a 4-es megrendel\u00e9s st\u00e1tusz\u00e1t ellen\u0151rzi, m\u00edg a T2 tranzakci\u00f3 megv\u00e1ltoztatja a st\u00e1tuszt csomagolv\u00e1r\u00f3l sz\u00e1ll\u00edt\u00e1s alattira. T1 tranzakci\u00f3 -- List\u00e1zzuk ki a megrendel\u00e9s \u00e9s a hozz\u00e1 tartoz\u00f3 t\u00e9telek st\u00e1tusz\u00e1t select s1 . Name , p . Name , s2 . Name from [ Order ] o , OrderItem oi , Status s1 , status s2 , Product p where o . Id = oi . OrderID and o . ID = 4 and o . StatusID = s1 . ID and oi . StatusID = s2 . ID and p . ID = oi . ProductID [Order] Az [Order] t\u00e1bla nev\u00e9ben az\u00e9rt kell a sz\u00f6gletes z\u00e1r\u00f3jel, hogy jelezz\u00fck, t\u00e1bla n\u00e9vr\u0151l van sz\u00f3, \u00e9s nem az order by parancs kezdet\u00e9r\u0151l. T2 tranzakci\u00f3 -- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9s \u00e1llapot\u00e1t update [ Order ] set StatusID = 4 where ID = 4 T1 tranzakci\u00f3 : els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve T2 tranzakci\u00f3 -- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9shez tartoz\u00f3 t\u00e9telek \u00e1llapot\u00e1t update OrderItem set StatusID = 4 where OrderID = 4 T1 tranzakci\u00f3 : els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve Mit tapasztalt? Mi\u00e9rt? Kezdetben minden t\u00e9tel \"Packaged\" st\u00e1tuszban van, ami \u00edgy konzisztens (nem lehet egy darab t\u00e9tel \"in transit\", azaz post\u00e1z\u00e1s alatt, ha a megrendel\u00e9s nincs). Viszont, amint v\u00e1ltozatunk a megrendel\u00e9s \u00e1llapot\u00e1n, a csomag st\u00e1tusza ellentmond\u00e1sosnak l\u00e1tszik a t\u00e9telek st\u00e1tusz\u00e1val. Az adatb\u00e1zis nem inkonzisztens, mert a bels\u0151 szab\u00e1lyai (integrit\u00e1si krit\u00e9riumai) alapj\u00e1n nincs probl\u00e9ma. De \u00fczleti \u00e9rtelemben ellentmond\u00e1sos a tartalom. Az SQL Server alap\u00e9rtelmez\u00e9sben auto commit \u00fczemm\u00f3dban fut, azaz egy utas\u00edt\u00e1s az egy tranzakci\u00f3, amit automatikusan lez\u00e1r. Teh\u00e1t a probl\u00e9ma, hogy a m\u00f3dos\u00edt\u00e1saink nem egy tranzakci\u00f3t k\u00e9peznek. A helyes viselked\u00e9shez \u00f6ssze kellene fogni a k\u00e9t adatm\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st egy tranzakci\u00f3ba.","title":"Feladat 2: P\u00e1rhuzamos tranzakci\u00f3k"},{"location":"gyakorlat/transactions/#feladat-3-tranzakcio-inditasa-read-committed-izolacios-szint","text":"Ism\u00e9telje meg az el\u0151z\u0151 feladatot \u00fagy, hogy a k\u00e9t adatm\u00f3dos\u00edt\u00e1s egy tranzakci\u00f3t k\u00e9pezzen: A T2 tranzakci\u00f3 kezdjen egy begin tran , \u00e9s v\u00e9gz\u0151dj\u00f6n egy commit utas\u00edt\u00e1ssal. Az adatm\u00f3dos\u00edt\u00e1sn\u00e1l a st\u00e1tuszt ez\u00fattal 3-asra \u00e1ll\u00edtsuk (hogy \u00e9rdemi v\u00e1ltoz\u00e1s legyen az adatokban). Mit tapasztalt? Mi\u00e9rt? Amint elkezdt\u00fck a st\u00e1tusz m\u00f3dos\u00edt\u00e1s\u00e1t T2 -ben, a lek\u00e9rdez\u0151 T1 -es utas\u00edt\u00e1s v\u00e1rni fog. Addig v\u00e1r, am\u00edg az adatm\u00f3dos\u00edt\u00f3 tranzakci\u00f3 be nem fejez\u0151dik. Ez az\u00e9rt van, mert a select utas\u00edt\u00e1s olvas\u00e1si z\u00e1rat akar elhelyezni, de m\u00e1sik tranzakci\u00f3 \u00e9ppen m\u00f3dos\u00edtja az adott rekordot, \u00edgy kiz\u00e1r\u00f3 z\u00e1rat helyezett el rajta. Jegyezz\u00fck meg, hogy az alap izol\u00e1ci\u00f3s szint, a read committed ezen a platformon azt jelenti, hogy m\u00f3dos\u00edt\u00e1s alatt lev\u0151 adat nem olvashat\u00f3. Ez egy implement\u00e1ci\u00f3s k\u00e9rd\u00e9s, az SQL szabv\u00e1ny ezt nem r\u00f6gz\u00edti. M\u00e1s adatb\u00e1zis platform viselkedhet m\u00e1shogy is (pl. az Oracle Server biztos\u00edtja, hogy a rekordok commit\u00e1lt k\u00e9pe mindenk\u00e9ppen olvashat\u00f3 marad). M\u00e1s izol\u00e1ci\u00f3s szinten az MSSQL szerver is m\u00e1shogy viselkedik, a snapshot izol\u00e1ci\u00f3s szint haszn\u00e1lata eset\u00e9n a m\u00f3dos\u00edt\u00e1s megkezd\u00e9se el\u0151tti v\u00e1ltozat olvashat\u00f3.","title":"Feladat 3: Tranzakci\u00f3 ind\u00edt\u00e1sa, read committed izol\u00e1ci\u00f3s szint"},{"location":"gyakorlat/transactions/#feladat-4-tranzakcio-megszakitasa-rollback-read-committed-izolacios-szinten","text":"Kezdj\u00fck el lefuttatni az el\u0151z\u0151 parancs sorozatot, a tranzakci\u00f3val egy\u00fctt, de a m\u00f3dos\u00edt\u00f3 tranzakci\u00f3t szak\u00edtsuk meg a k\u00f6zep\u00e9n. T1 tranzakci\u00f3 -- List\u00e1zzuk ki a megrendel\u00e9s \u00e9s a hozz\u00e1 tartoz\u00f3 t\u00e9telek st\u00e1tusz\u00e1t select s1 . Name , p . Name , s2 . Name from [ Order ] o , OrderItem oi , Status s1 , status s2 , Product p where o . Id = oi . OrderID and o . ID = 4 and o . StatusID = s1 . ID and oi . StatusID = s2 . ID and p . ID = oi . ProductID T2 tranzakci\u00f3 -- \u00daj tranzakci\u00f3t kezd\u00fcnk begin tran -- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9s \u00e1llapot\u00e1t update [ Order ] set StatusID = 4 where ID = 4 T1 tranzakci\u00f3 : els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve T2 tranzakci\u00f3 -- Szak\u00edtsuk meg a tranzakci\u00f3t rollback Mit tapasztalt? Mi\u00e9rt? Az el\u0151z\u0151ekben tapasztaltakhoz hasonl\u00f3an a m\u00f3dos\u00edt\u00e1s megkezdte ut\u00e1n az olvas\u00f3 utas\u00edt\u00e1s v\u00e1rakoz\u00e1sra k\u00e9nyszer\u00fclt. Amikor megszak\u00edtottuk a tranzakci\u00f3t, akkor \u00e9rkezett meg az eredm\u00e9ny. Mivel read committed izol\u00e1ci\u00f3s szinten vagyunk, nem l\u00e1tjuk a m\u00f3dos\u00edt\u00e1s alatt lev\u0151 tartalmat. Amint a m\u00f3dos\u00edt\u00f3 tranzakci\u00f3 befejez\u0151dik, ak\u00e1r sikeres commit , ak\u00e1r rollback miatt, el\u00e9rhet\u0151v\u00e9 v\u00e1lnak a rekordok. Vegy\u00fck \u00e9szre, hogy pont elker\u00fclt\u00fck a piszkos olvas\u00e1s probl\u00e9m\u00e1j\u00e1t. Ha a m\u00f3dos\u00edt\u00e1s fut\u00e1sa k\u00f6zben megjelent volna a f\u00e9lk\u00e9sz eredm\u00e9ny, a rollback miatt az a tranzakci\u00f3 \u00e9rv\u00e9nytelen adattal dolgozna tov\u00e1bb.","title":"Feladat 4: Tranzakci\u00f3 megszak\u00edt\u00e1sa (rollback) read committed izol\u00e1ci\u00f3s szinten"},{"location":"gyakorlat/transactions/#feladat-5-megrendeles-rogzitese-serializable-izolacios-szinten","text":"A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r rollback utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz. Legyen k\u00e9t p\u00e1rhuzamos tranzakci\u00f3nk, melyek megrendel\u00e9st r\u00f6gz\u00edtenek. Egy term\u00e9kre nem vehet\u00fcnk fel t\u00f6bb megrendel\u00e9st, mint ami a rakt\u00e1rk\u00e9szlet. Az\u00e9rt, hogy a tranzakci\u00f3k egym\u00e1sra hat\u00e1s\u00e1t elk\u00fcl\u00f6n\u00edts\u00fck, kapcsoljunk \u00e1t serializable izol\u00e1ci\u00f3s szintre. T1 tranzakci\u00f3 set transaction isolation level serializable begin tran -- Ellen\u0151rizz\u00fck, hogy mennyi van rakt\u00e1ron egy term\u00e9kb\u0151l select * from Product where ID = 2 T2 tranzakci\u00f3 set transaction isolation level serializable begin tran select * from Product where ID = 2 T1 tranzakci\u00f3 -- Ellen\u0151rizz\u00fck, hogy h\u00e1ny, m\u00e9g fel nem dolgozott megrendel\u00e9s van erre a term\u00e9kre select sum ( Amount ) from OrderItem where ProductID = 2 and StatusID = 1 T2 tranzakci\u00f3 select sum ( Amount ) from OrderItem where ProductID = 2 and StatusID = 1 T1 tranzakci\u00f3 -- Mivel teljes\u00edthet\u0151 a megrendel\u00e9s, r\u00f6gz\u00edts\u00fck insert into OrderItem ( OrderID , ProductID , Amount , StatusID ) values ( 2 , 2 , 3 , 1 ) T2 tranzakci\u00f3 insert into OrderItem ( OrderID , ProductID , Amount , StatusID ) values ( 3 , 2 , 3 , 1 ) T1 tranzakci\u00f3 commit T2 tranzakci\u00f3 commit Mit tapasztalt? Mi\u00e9rt? Holtpont fog kialakulni, mivel a serializable izol\u00e1ci\u00f3s szint miatt mindk\u00e9t tranzakci\u00f3 megtiltja a megrendel\u00e9st\u00e9tel t\u00e1bla m\u00f3dos\u00edt\u00e1s\u00e1t. A select sum miatt, \u00e9s a megism\u00e9telhet\u0151 olvas\u00e1s elv\u00e1r\u00e1s miatt a rekordokat olvas\u00f3 z\u00e1rral l\u00e1tja el a rendszer. Viszont \u00edgy nem futhat le a m\u00e1sik tranzakci\u00f3ban az insert , amely kiz\u00e1r\u00f3lagos z\u00e1rat ig\u00e9nyelne. Ez mindk\u00e9t tranzakci\u00f3 eset\u00e9n azt jelenti, hogy a m\u00e1sik \u00e1ltal fogott z\u00e1rra v\u00e1r. A holtpont eredm\u00e9nye, hogy az egyik tranzakci\u00f3t le fogja \u00e1ll\u00edtani a szerver. Ez elv\u00e1rt \u00e9s helyes m\u0171k\u00f6d\u00e9st eredm\u00e9nyez, mivel megakad\u00e1lyozza, hogy a k\u00e9t tranzakci\u00f3 k\u00f6zt adat egym\u00e1srahat\u00e1s legyen (\u00edgy nem fordulhat el\u0151, hogy t\u00f6bb term\u00e9ket adunk el, mint amennyi van). Ism\u00e9telj\u00fck meg a fenti m\u0171veletsort, csak a megrendel\u00e9s r\u00f6gz\u00edt\u00e9sekor m\u00e1s-m\u00e1s term\u00e9k ID-t haszn\u00e1ljunk! Ezzel azt szimul\u00e1ljuk, hogy k\u00e9t megrendel\u0151 m\u00e1s-m\u00e1s term\u00e9ket rendel meg. A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r rollback utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz. Ahol utas\u00edt\u00e1sban ID vagy ProductID szerepel, ott egyik tranzakci\u00f3ban a 2-es, m\u00e1sikban a 3-as term\u00e9ket haszn\u00e1ljuk. Mit tapasztalt? Mi\u00e9rt? Ha k\u00fcl\u00f6nb\u00f6z\u0151 term\u00e9kre t\u00f6rt\u00e9nik a r\u00f6gz\u00edt\u00e9s, akkor is holtpont fog kialakulni. Olyan a z\u00e1rol\u00e1si rendszer, hogy a select sum az eg\u00e9sz t\u00e1bl\u00e1t z\u00e1rolja, mivel nem tudja megk\u00fcl\u00f6nb\u00f6ztetni ProductID szerint a rekordokat. Ez term\u00e9szetes is, mivel csak az \u00fczleti logik\u00e1b\u00f3l ad\u00f3dik, hogy ha k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 term\u00e9kre t\u00f6rt\u00e9nik a megrendel\u00e9s r\u00f6gz\u00edt\u00e9se, akkor azok t\u00f6rt\u00e9nhetn\u00e9nek egyszerre is. Az adatb\u00e1zis ezt nem tudhatja. Azaz a serializable izol\u00e1ci\u00f3s szint t\u00fal szigor\u00fa, \u00fczleti logik\u00e1t figyelembe v\u00e9ve nagyobb p\u00e1rhuzamos\u00edt\u00e1s engedhet\u0151 meg. Ez\u00e9rt is ritk\u00e1n haszn\u00e1ljuk a gyakorlatban.","title":"Feladat 5: Megrendel\u00e9s r\u00f6gz\u00edt\u00e9se serializable izol\u00e1ci\u00f3s szinten"},{"location":"gyakorlat/transactions/#feladat-6-megrendeles-rogzitese-read-committed-izolacios-szinten","text":"Gondoljuk v\u00e9gig, az el\u0151z\u0151 feladat eset\u00e9n mi t\u00f6rt\u00e9nne, ha a nem \u00e1ll\u00edtjuk \u00e1t a tranzakci\u00f3k izol\u00e1ci\u00f3s szintj\u00e9t? Lenne holtpont? \u00c9s helyes lenne a m\u0171k\u00f6d\u00e9s? Mit v\u00e1runk? Mi\u00e9rt? Ha nem v\u00e1ltoztatunk izol\u00e1ci\u00f3s szintet, akkor helytelen m\u0171k\u00f6d\u00e9s \u00e1llhatna el\u0151. Mivel a read committed izol\u00e1ci\u00f3s szint nem biztos\u00edtja sz\u00e1munkra azt, hogy am\u00edg fut a tranzakci\u00f3nk, addig egy m\u00e1sik tranzakci\u00f3 ber\u00f6gz\u00edtsen rekordokat. Teh\u00e1t lefuthatna az insert , ami miatt v\u00e9geredm\u00e9nyben t\u00f6bb \u00e1rut adn\u00e1nk el, mint ami a rakt\u00e1rban van. Ez a nem megism\u00e9telhet\u0151 olvas\u00e1s probl\u00e9m\u00e1ja. Err\u0151l az oldalr\u00f3l n\u00e9zve teh\u00e1t a serializable izol\u00e1ci\u00f3s szint nem volt feleslegesen szigor\u00fa. T\u00e9nyleg megv\u00e9dett minket egy probl\u00e9m\u00e1t\u00f3l.","title":"Feladat 6: Megrendel\u00e9s r\u00f6gz\u00edt\u00e9se read committed izol\u00e1ci\u00f3s szinten"},{"location":"gyakorlat/transactions/#feladat-7-manualis-zarolas","text":"A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r rollback utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz. Read committed izol\u00e1ci\u00f3s szintet haszn\u00e1lva dolgozzon ki megold\u00e1st, amely csak az azonos term\u00e9kekre t\u00f6rt\u00e9n\u0151 p\u00e1rhuzamos adatr\u00f6gz\u00edt\u00e9seket akad\u00e1lyozza meg. Term\u00e9szetesen felt\u00e9telezheti hogy mindegyik p\u00e1rhuzamos folyamat ugyanazt a programlogik\u00e1t k\u00f6veti. A megold\u00e1shoz kihaszn\u00e1ljuk, hogy lehets\u00e9ges manu\u00e1lisan z\u00e1rakat elhelyezni. Ezek a z\u00e1rak is, \u00fagy, mint a t\u00f6bbi z\u00e1r, a tranzakci\u00f3 v\u00e9g\u00e9ig \u00e9lnek. select * from tablename with ( XLOCK ) ... Hova kell ezt a z\u00e1rat elhelyezni? Hogyan n\u00e9z ki \u00edgy a megrendel\u00e9s folyamata? A megold\u00e1s kulcsa, hogy j\u00f3 helyre tegy\u00fck a z\u00e1rat. A k\u00e9rd\u00e9s, hogy mit is kellene z\u00e1rolni? A v\u00e1lasz, hogy a term\u00e9ket (Product) : azt akarjuk megg\u00e1tolni, hogy ugyanabb\u00f3l a term\u00e9kb\u0151l r\u00f6gz\u00edthet\u0151 legyen m\u00e9g egy elad\u00e1s. Teh\u00e1t a term\u00e9kre, konkr\u00e9tan a term\u00e9k t\u00e1bl\u00e1ban arra a sorra tessz\u00fck a z\u00e1rat, ami a term\u00e9ket reprezent\u00e1lja. Ennek a megold\u00e1snak a h\u00e1tr\u00e1nya, hogy nagyon alaposan \u00e1t kell gondolnunk, hogyan \u00e9s hol v\u00e9gezz\u00fck a z\u00e1rol\u00e1st. A l\u00e9p\u00e9seink teh\u00e1t a k\u00f6vetkez\u0151k. T1 tranzakci\u00f3 set transaction isolation level read committed begin tran select * from Product with ( xlock ) where ID = 2 T2 tranzakci\u00f3 set transaction isolation level read committed begin tran select * from Product with ( xlock ) where ID = 3 T1 tranzakci\u00f3 select sum ( Amount ) from OrderItem where ProductID = 2 and StatusID = 1 T2 tranzakci\u00f3 select sum ( Amount ) from OrderItem where ProductID = 3 and StatusID = 1 T1 tranzakci\u00f3 insert into OrderItem ( OrderID , ProductID , Amount , StatusID ) values ( 2 , 2 , 3 , 1 ) T2 tranzakci\u00f3 insert into OrderItem ( OrderID , ProductID , Amount , StatusID ) values ( 3 , 3 , 3 , 1 ) T1 tranzakci\u00f3 commit T2 tranzakci\u00f3 commit","title":"Feladat 7: Manu\u00e1lis z\u00e1rol\u00e1s"},{"location":"gyakorlat/transactions/#feladat-8-tabla-szintu-zarolas","text":"A sor szint\u0171 z\u00e1rol\u00e1s mellett lehet\u0151s\u00e9g\u00fcnk van t\u00e1bla szinten is z\u00e1rolni: select * from tablanev with ( TABLOCKX ) ... B\u00e1r ez egyszer\u0171 megold\u00e1snak t\u0171nik, gondoljuk v\u00e9gig, mi\u00e9rt nem \u00e9rdemes ezt haszn\u00e1lni? Jelen esetben a t\u00e1bla szint\u0171 z\u00e1rat a megrendel\u00e9sekre kellene tenn\u00fcnk, hiszen a konkurens megrendel\u00e9seket akarjuk megakad\u00e1lyozni. De ez ugyanazzal az eredm\u00e9nnyel j\u00e1rna, mint a serializable izol\u00e1ci\u00f3s szint haszn\u00e1lata. Ugyan holtpont nem lenne, de a p\u00e1rhuzamos v\u00e9grehajt\u00e1st lehetetlenn\u00e9 tenn\u00e9. Teh\u00e1t a t\u00e1bla szint\u0171 z\u00e1rol\u00e1sra ugyanaz igaz: az \u00fczleti logik\u00e1b\u00f3l nagyobb p\u00e1rhuzamoss\u00e1g ad\u00f3dik.","title":"Feladat 8: T\u00e1bla szint\u0171 z\u00e1rol\u00e1s"},{"location":"gyakorlatvezetoknek/","text":"Gyakorlatvezet\u0151knek \u00b6 Gyakorlatvezet\u0151/demonstr\u00e1tor lenn\u00e9l? Az al\u00e1bbiakat \u00e9rdemes tudnod. Gyakorlatvezet\u0151 feladatai \u00b6 A gyakorlatvezet\u0151 a t\u00e1rgy oktat\u00e1s\u00e1ban seg\u00edt a gyakorlatok megtart\u00e1sa \u00e9s a sz\u00e1monk\u00e9r\u00e9sek sor\u00e1n. A feladat az al\u00e1bbiakb\u00f3l \u00e1ll. F\u00e9l\u00e9v sor\u00e1n 12 gyakorlat megtart\u00e1sa. A gyakorlatok a 2. oktat\u00e1si h\u00e9ten kezd\u0151dnek \u00e9s a 13. oktat\u00e1si h\u00e9ten \u00e9rnek v\u00e9get. Egy gyakorlatvezet\u0151 \u00e1ltal\u00e1ban 2 gyakorlati csoport oktat\u00e1s\u00e1\u00e9rt felel \u00e9s mindk\u00e9t csoportnak 6-6 gyakorlatot tart meg. A gyakorlat fix \u00f3rarendi id\u0151ben van, 90 perces, \u00e9s sz\u00e1m\u00edt\u00f3g\u00e9p laborban tartjuk. Sz\u00fcnetek miatt elmarad\u00f3 laborokat nem p\u00f3tolunk, \u00edgy n\u00e9ha egy-kett\u0151vel kevesebb \u00f3ra lehet. Alkalmank\u00e9nt lehet\u0151s\u00e9get tudunk adni \"f\u00e9l\" gyakorlatvezet\u00e9sre is, azaz 12 helyett 6 alkalom, egy gyakorlati csoport minden m\u00e1sodik h\u00e9ten. Illet\u0151leg t\u00f6bbet is lehet v\u00e1llalni. A gyakorlat kiadott seg\u00e9dlet alapj\u00e1n ker\u00fcl megtart\u00e1sra. A gyakorlatvezet\u0151 feladata a gyakorlatra val\u00f3 felk\u00e9sz\u00fcl\u00e9s, a gyakorlat megtart\u00e1sa, ennek sor\u00e1n a sz\u00fcks\u00e9ges h\u00e1tt\u00e9rismeretek r\u00f6vid \u00e1tism\u00e9tl\u00e9se, a fontos r\u00e9szek kiemel\u00e9se, \u00e9s a hallgat\u00f3k seg\u00edt\u00e9se a gyakorlat sor\u00e1n. Egy gyakorlati \u00f3r\u00e1n 20 hallgat\u00f3 van a teremben. 2020 \u0151szi f\u00e9l\u00e9v sor\u00e1n a gyakorlatok \u00f3rarendi id\u0151pontjai: kedd 10-12 szerda 14-16 cs\u00fct\u00f6rt\u00f6k 8-10 cs\u00fct\u00f6rt\u00f6k 14-16 cs\u00fct\u00f6rt\u00f6k 16-18 p\u00e9ntek 12-14 Sz\u00e1monk\u00e9r\u00e9sek lebonyol\u00edt\u00e1s\u00e1ban seg\u00edts\u00e9g. A t\u00e1rgyban ZH, PZH, \u00e9s 4 vizsga van. Mindegyik sz\u00e1monk\u00e9r\u00e9s \u00edr\u00e1sban t\u00f6rt\u00e9nik. A gyakorlatvezet\u0151 feladata a sz\u00e1monk\u00e9r\u00e9sek fel\u00fcgyel\u00e9se majd a jav\u00edt\u00e1sban t\u00f6rt\u00e9n\u0151 r\u00e9szv\u00e9tel. A fel\u00fcgyel\u00e9s ideje alkalmank\u00e9nt k\u00f6r\u00fclbel\u00fcl 1 \u00f3ra, a jav\u00edt\u00e1s ideje l\u00e9tsz\u00e1m f\u00fcgg\u0151en 0.5-2 \u00f3ra alkalmank\u00e9nt. Gyakorlatvezet\u0151k\u00e9nt k\u00f6r\u00fclbel\u00fcl a sz\u00e1monk\u00e9r\u00e9sek fel\u00e9ben kell r\u00e9szt venni. H\u00e1zi feladatok \u00e9rt\u00e9kel\u00e9se. A f\u00e9l\u00e9v sor\u00e1n 5 opcion\u00e1lis kis h\u00e1zi feladatot hirdet\u00fcnk meg. Ezeket a hallgat\u00f3k otthon, \u00f6n\u00e1ll\u00f3an oldj\u00e1k meg \u00e9s adj\u00e1k be GitHub pull request-ek form\u00e1j\u00e1ban. A h\u00e1zi feladatok ki\u00e9rt\u00e9kel\u00e9se r\u00e9szben automatikusan t\u00f6rt\u00e9nik: egy szoftver lefuttatja \u00e9s ellen\u0151rzi a beadott munk\u00e1t. A gyakorlatvezet\u0151 feladata a beadott h\u00e1zi feladat formai ellen\u0151rz\u00e9se: k\u00e9rt k\u00e9perny\u0151k\u00e9pek megfelelnek-e az el\u0151\u00edr\u00e1soknak \u00e9s konzisztensek-e a beadott forr\u00e1sk\u00f3ddal. A h\u00e1zi feladat nem k\u00f6telez\u0151, nem minden hallgat\u00f3 szokta elk\u00e9sz\u00edteni, \u00edgy h\u00e1zi feladatonk\u00e9nt k\u00f6r\u00fclbel\u00fcl 1 \u00f3ra id\u0151 r\u00e1ford\u00edt\u00e1st jelent. Demonstr\u00e1tors\u00e1g \u00b6 Hallgat\u00f3 vagy de szeretn\u00e9l bekapcsol\u00f3dni az oktat\u00e1sba? Szeretn\u00e9d kipr\u00f3b\u00e1lni magad oktat\u00f3k\u00e9nt? Szeretsz magyar\u00e1zni? Elv\u00e9gezted ezt a t\u00e1rgyat \u00f6t\u00f6ssel? V\u00e1runk demonstr\u00e1tork\u00e9nt! A TVSZ p\u00e1r k\u00f6vetelm\u00e9nyt szab demonstr\u00e1toroknak: (l\u00e1sd aktu\u00e1lis TVSZ 165.\u00a7): (5) A demonstr\u00e1tori p\u00e1ly\u00e1zat beny\u00fajt\u00e1s\u00e1nak felt\u00e9tele, hogy a p\u00e1ly\u00e1z\u00f3 a) a demonstr\u00e1tori jogviszonnyal \u00e9rintett f\u00e9l\u00e9vben rendelkezzen akt\u00edv hallgat\u00f3i jogviszonnyal; b) rendelkezzen alapk\u00e9pz\u00e9sben vagy osztatlan k\u00e9pz\u00e9sben szerzett oklev\u00e9llel; c) alapk\u00e9pz\u00e9sben vagy osztatlan k\u00e9pz\u00e9sben szerzett oklev\u00e9l hi\u00e1ny\u00e1ban rendelkezzen legal\u00e1bb annyiszor huszon\u00f6t teljes\u00edtett kredittel, ah\u00e1ny lez\u00e1rt akt\u00edv f\u00e9l\u00e9ve van \u00e9s halmozott s\u00falyozott tanulm\u00e1nyi \u00e1tlageredm\u00e9nye haladja meg a 3,50 \u00e9rt\u00e9ket; \u00e9s d) ne \u00e1lljon fegyelmi b\u00fcntet\u00e9s hat\u00e1lya alatt. Ha \u00e9rdekel a lehet\u0151s\u00e9g, megfelelsz a fenti k\u00f6vetelm\u00e9nyeknek, \u00e9s az \u00f3rarendedbe belef\u00e9r a gyakorlat (l\u00e1sd az id\u0151pontokat fentebb), keresd a t\u00e1rgyfelel\u0151st . Tudnival\u00f3k a gyakorlatok megtart\u00e1s\u00e1hoz \u00b6 A t\u00e1rgy alapk\u00e9pz\u00e9s (BSc) 5. f\u00e9l\u00e9v\u00e9ben specializ\u00e1ci\u00f3s t\u00e1rgy. Ezt azt jelenti, hogy a hallgat\u00f3k szoftverfejleszt\u00e9si alapismeretekkel \u00e9s adatb\u00e1zis alapismeretekkel rendelkeznek. A t\u00e1rgyunk c\u00e9lja a tud\u00e1s elm\u00e9ly\u00edt\u00e9se \u00e9s \u00faj technol\u00f3gi\u00e1kba val\u00f3 \"belek\u00f3stol\u00e1s\". Az \u00faj ismeretek \u00e1tad\u00e1sa az el\u0151ad\u00e1sokon t\u00f6rt\u00e9nik, a gyakorlatokon a technol\u00f3gi\u00e1k els\u0151 k\u00e9zb\u0151l val\u00f3 kipr\u00f3b\u00e1l\u00e1sa a l\u00e9nyeg. A c\u00e9lunk, hogy mindenki maga is l\u00e1ssa \u00e9s kipr\u00f3b\u00e1lja az adott eszk\u00f6z\u00f6ket, technol\u00f3gi\u00e1kat, \u00e9s l\u00e1ssa a m\u0171k\u00f6d\u00e9s\u00fcket. A gyakorlatokon v\u00e1ltozatos technol\u00f3gi\u00e1kkal foglalkozunk, \u00e9s ennek megfelel\u0151en t\u00f6bb f\u00e9le szoftvert is haszn\u00e1lunk. Ezek egy r\u00e9sze \u00fajdons\u00e1g lesz a hallgat\u00f3knak, \u00edgy a gyakorlatokon a szoftverek alapvet\u0151 haszn\u00e1lat\u00e1t is megmutatjuk. Oktat\u00e1s m\u00f3dja \u00b6 A gyakorlatokon elv\u00e1rt a r\u00e9szv\u00e9tel, viszont nincs sz\u00e1monk\u00e9r\u00e9s (se beugr\u00f3, se egy\u00e9b). Az el\u0151ad\u00e1sokon minden sz\u00fcks\u00e9ges alapismeret elhangzik, de a gyakorlatokon c\u00e9lszer\u0171 sz\u00f3ban elism\u00e9telni mivel foglalkozunk az adott gyakorlaton \u00e9s az mi\u00e9rt fontos. Emellett \u00e9rdemes kiemelni a feladatok megold\u00e1sa sor\u00e1n az \u00e9rdekes, avagy felt\u00e9tlen\u00fcl megjegyzend\u0151 r\u00e9szeket. (Mindemellett a gyakorlat nem el\u0151ad\u00e1s, nem kell mindent \u00fajb\u00f3l elism\u00e9telni.) A gyakorlatokon \u00f6n\u00e1ll\u00f3 munk\u00e1t csak kis m\u00e9rt\u00e9kben v\u00e1runk el. A gyakorlatok anyaga jelzi, mit lehet \u00f6n\u00e1ll\u00f3 munk\u00e1nak feladni. A gyakorlat nagy r\u00e9sz\u00e9ben teh\u00e1t a gyakorlatvezet\u0151 projektoron csin\u00e1lja a feladatokat, a hallgat\u00f3k k\u00f6vetik \u00e9s maguk is v\u00e9gzik a feladatokat. A bemeleg\u00edt\u0151 feladatok ut\u00e1n (amikor a szoftver k\u00f6rnyezet m\u00e1r ismert), lehet adni gondolkod\u00e1si id\u0151t a hallgat\u00f3knak. A megold\u00e1st viszont mindig besz\u00e9lj\u00e9tek meg k\u00f6z\u00f6sen. A gyakorlati anyagban benne van a megold\u00e1s. Ha valaki lemarad, vagy otthon meg akarja n\u00e9zni, \u00edgy el\u00e9rheti a megold\u00e1sokat. A gyakorlatok sor\u00e1n ne csak \u00e1tm\u00e1soljuk az \u00f3r\u00e1n, hanem g\u00e9pelj\u00fck be a megold\u00e1st, a gondolatmenetet magyar\u00e1zva k\u00f6zben! Ha lehet, vegy\u00fck r\u00e1 a hallgat\u00f3kat is erre. Adminisztrat\u00edv tudnival\u00f3k \u00b6 A gyakorlatokat \u00f3ra 15-kor kezdj\u00fck pontosan \u00e9s 90 percet egyben, sz\u00fcnet n\u00e9lk\u00fcl tartjuk. A k\u00e9s\u0151 hallgat\u00f3kat els\u0151 alkalommal figyelmeztess\u00fck. Ha t\u00f6bbsz\u00f6r el\u0151fordul vagy zavar\u00f3an sokat k\u00e9sik (>5 perc), akkor k\u00fcldj\u00e9tek el (TVSZ erre jogot ad!). A gyakorlat teljes\u00edt\u00e9s\u00e9nek adminisztr\u00e1l\u00e1sa Moodle-ben t\u00f6rt\u00e9nik. A teljes\u00edt\u00e9s a gyakorlaton val\u00f3 megjelen\u00e9st, \u00e9s a munka veletek t\u00f6rt\u00e9n\u0151 elv\u00e9gz\u00e9s\u00e9t jelenti. (Teh\u00e1t a hallgat\u00f3 nem s\u00e9t\u00e1lhat ki a gyakorlat k\u00f6zep\u00e9n \u00e9s nem foglalkozhat m\u00e1ssal, csak a gyakorlattal. Eseti probl\u00e9m\u00e1kat az\u00e9rt kezelj\u00fcnk le, pl. ZH-ja van m\u00e1shol, stb. Egy-egy kiv\u00e9tel belef\u00e9r.) \u00c9rdemes a jelenl\u00e9tet a gyakorlat elej\u00e9n k\u00f6nyvelni. Ha az \u00f3r\u00e1n t\u00f6bb ember jelenne meg, mint ah\u00e1ny g\u00e9p van (hi\u00e1nyz\u00e1s p\u00f3tl\u00e1sa pl.), vagy egy g\u00e9p nem m\u0171k\u00f6dik, akkor akinek nem jut hely, le\u00fcl valaki mell\u00e9. A csoportok k\u00f6z\u00f6tt nincs ad-hoc \u00e1tj\u00e1r\u00e1s. Ha valaki jelzi, hogy nem tud r\u00e9szt venni egy gyakorlaton, akkor el\u0151re/ut\u00f3lag/ugyanazon a h\u00e9ten egy m\u00e1sik csoportban p\u00f3tolhat (ha van r\u00e1 m\u00f3d). Ennek a megszervez\u00e9s\u00e9t alapvet\u0151en a hallgat\u00f3 bonyol\u00edtsa (n\u00e9zze meg, mikor van m\u00e9g labor azonos anyagb\u00f3l, \u00e9s egyeztessen a t\u00e1rgyfelel\u0151ssel, vagy a gyakorlatvezet\u0151kkel), de seg\u00edts\u00fck, ha kell. Anyagok el\u00e9rhet\u0151s\u00e9ge \u00b6 A t\u00e1rgy el\u0151ad\u00e1s anyagai, az id\u0151pontok \u00e9s hat\u00e1rid\u0151k \u00e9s hivatalos k\u00f6vetelm\u00e9nyek Moodle-ben lesznek. (Ehhez a t\u00e1rgy indul\u00e1s\u00e1val kapsz hozz\u00e1f\u00e9r\u00e9st.) Gyakorlatok anyagai: l\u00e1sd a fenti men\u00fcben. A gyakorlati anyag minden r\u00e9sze teljesen publikus. A gyakorlatok anyaga GitHub repository-ban van. Ha hib\u00e1t, elg\u00e9pel\u00e9st tal\u00e1lsz benne, arra k\u00e9r\u00fcnk, hogy jav\u00edtsd: minden anyag jobb fels\u0151 sark\u00e1ban van egy kis ceruza ikon, jav\u00edtsd a hib\u00e1t, \u00e9s k\u00fcldj PR-t. Bel\u00e9p\u00e9sek \u00b6 A labor termekhez kulcsra \u00e9s/vagy k\u00e1rty\u00e1ra van sz\u00fcks\u00e9g. Ezeket a titk\u00e1rs\u00e1gon (QB207) kell k\u00e9rni. I \u00e9p\u00fclethez kell a teremkulcs, ill. a folyos\u00f3hoz sz\u00fcks\u00e9g van k\u00e1rty\u00e1ra is (kiv\u00e9ve, akinek van ilyenje). Q \u00e9p\u00fclet laborjaihoz hozz\u00e1f\u00e9r\u00e9st k\u00fcl\u00f6n szervezz\u00fck. Demonstr\u00e1torok: mindezt megmutatom els\u0151 alkalommal. G\u00e9pekre : emailben k\u00fcld\u00f6m f\u00e9l\u00e9v elej\u00e9n. Kis- \u00e9s nagybet\u0171 sz\u00e1m\u00edt! P\u00e1r elg\u00e9pel\u00e9s ut\u00e1n le lesz tiltva az account! MS SQL szerver : localdb: nincs jelsz\u00f3, Windows Authentication-t haszn\u00e1ljunk JPA laborn\u00e1l sqlexpress van, SQL Server Authentication kell: sa / sa MongoDB : nincs authentik\u00e1ci\u00f3 Tudnival\u00f3k a h\u00e1zi feladatokkal kapcsolatban \u00b6 A f\u00e9l\u00e9v sor\u00e1n a h\u00e1zi feladatok vannak meghirdetve, amiket adott hat\u00e1rid\u0151ig kell beadni GitHub-on. Ennek pontos menete a hallgat\u00f3 szemsz\u00f6g\u00e9b\u0151l itt elolvashat\u00f3. Ahhoz, hogy hozz\u00e1f\u00e9rj a GitHub-on a beadott megold\u00e1sokhoz (\u00e9s ahhoz, hogy a hallgat\u00f3k ezt hozz\u00e1d tudj\u00e1k rendelni), kell egy GitHub account. A GitHub nevedet \u00edrd meg a t\u00e1rgyfelel\u0151snek, \u00e9s felvesz GitHub-on a https://www.github.com/bmeviauac01 organization-be. Mikor kell \u00e9rt\u00e9kelni a h\u00e1zit? \u00b6 A h\u00e1zikat a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n kell \u00e9rt\u00e9kelni. A hat\u00e1rid\u0151 el\u0151tt a megold\u00e1sokra nem kell r\u00e1n\u00e9zni, kiv\u00e9ve, ha ezt a hallgat\u00f3 k\u00e9ri. K\u00e9rd\u00e9ssel a hallgat\u00f3 direktben kell megkeressen (pl. emailben vagy GitHub-on ). Hol kell \u00e9rt\u00e9kelni a h\u00e1zit? \u00b6 A hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a feladatod a hozz\u00e1d rendelt pull request-ek \u00e9rt\u00e9kel\u00e9se. A hallgat\u00f3 azzal adja be a h\u00e1zit, hogy a pull request-et a gyakorlatvezet\u0151j\u00e9hez rendeli. Ezeket a GitHub keres\u0151j\u00e9vel a legegyszer\u0171bb megtal\u00e1lni: https://github.com/pulls?q=is%3Aopen+is%3Apr+org%3Abmeviauac01+assignee%3A%40me+ . Alternat\u00edvak\u00e9nt a GitHub \u00e9rtes\u00edt\u0151 fel\u00fclet\u00e9t is lehet haszn\u00e1lni a https://github.com/notifications c\u00edmen, itt minden hozz\u00e1d rendelt, vagy review-ra v\u00e1r\u00f3 PR megjelenik. Hogyan kell \u00e9rt\u00e9kelni a h\u00e1zit? \u00b6 A PR-eket egyes\u00e9vel kell megnyitni, \u00e9s meg kell n\u00e9zni a PR komment fel\u00fclet\u00e9n az eredm\u00e9nyt. Itt l\u00e1that\u00f3 lesz a lefuttatott \u00e9rt\u00e9kel\u00e9s eredm\u00e9nye, valamint a k\u00e9perny\u0151k\u00e9pek. Emellett meg kell n\u00e9zni a forr\u00e1sk\u00f3dot is. A forr\u00e1sk\u00f3dot nem sz\u00fcks\u00e9ges bet\u0171r\u0151l bet\u0171re megn\u00e9zni - a r\u00e9szletes ellen\u0151rz\u00e9st elv\u00e9gzi az automata. A gyakorlatvezet\u0151 feladata a k\u00e9perny\u0151k\u00e9pek ellen\u0151rz\u00e9se, valamint annak eld\u00f6nt\u00e9se, hogy a forr\u00e1sk\u00f3d konzisztens-e a kapott eredm\u00e9nnyel. A feladatok minta megold\u00e1sa itt \u00e9rhet\u0151 el: https://github.com/bmeviauac01?q=hazi-megoldas . Ezek csak lehets\u00e9ges megold\u00e1sok, a hallgat\u00f3 megold\u00e1sa nem kell ezzel egyezzen. Az \u00e9rt\u00e9kel\u00e9s v\u00e9gezt\u00e9vel: R\u00f6gz\u00edteni kell a pontsz\u00e1mot Moodle-ben. Ha van iMsc pontsz\u00e1m, azt k\u00fcl\u00f6n sz\u00e1monk\u00e9r\u00e9sben kell r\u00f6gz\u00edteni. Opcion\u00e1lis, de javasolt: mergelni a PR-t. (Szoftverfejleszt\u00e9s sor\u00e1n ez a logikus lez\u00e1r\u00e1sa a PR-nek.) Ha nem mergeled a PR-t, akkor lez\u00e1rni a PR-t. Ha gond volt a megold\u00e1ssal, v\u00e1ltozott a pontsz\u00e1m, vagy valamit hozz\u00e1f\u0171zn\u00e9l, akkor azt is kommentbe be\u00edrni a PR-be. Probl\u00e9m\u00e1k \u00e9s megold\u00e1suk \u00b6 Nem futott le az automata \u00e9rt\u00e9kel\u00e9s. Lehet, hogy a hallgat\u00f3 draft m\u00f3dban hagyta a PR-t, ezt vissza kell \u00e1ll\u00edtani. A PR alj\u00e1n megjelenik ilyenkor egy Ready for review gomb. Ha sikertelen volt a ki\u00e9rt\u00e9kel\u00e9s, meg lehet ism\u00e9telni. Ez seg\u00edt a tranziens hib\u00e1kon (ritka eset). Ehhez tegy\u00e9l egy eval nev\u0171 labelt-t a PR-re (\u00faj label-k\u00e9nt kell l\u00e9trehozni). T\u00f6bb, mint 5-sz\u00f6r futott a ki\u00e9rt\u00e9kel\u00e9s. Ezt pontlevon\u00e1ssal szankcion\u00e1ljuk. Els\u0151 alkalommal eltekinthet\u00fcnk t\u0151le, de mindenk\u00e9ppen t\u00e1j\u00e9koztassuk a hallgat\u00f3t. Hiba van a ki\u00e9rt\u00e9kel\u0151 alkalmaz\u00e1sban. El\u0151fordulhat. Keresd a t\u00e1rgyfelel\u0151st, vagy jav\u00edtsd a hib\u00e1t (a ki\u00e9rt\u00e9kel\u0151 programok itt vannak: https://github.com/bmeviauac01/hazi-ahk/ ). Jelenl\u00e9t \u00e9s eredm\u00e9ny r\u00f6gz\u00edt\u00e9se Moodle-ben \u00b6 A gyakorlat csoportok Moodle-ban vannak. Neptunb\u00f3l automatikusan ker\u00fclnek \u00e1t. Az eredm\u00e9nyeket (gyakorlatokon jelenl\u00e9t \u00e9s h\u00e1zi feladat pontsz\u00e1ma) itt k\u00f6nyvelj\u00fck. Minden gyakorlati alkalom, ill. minden h\u00e1zi feladat k\u00fcl\u00f6n sz\u00e1monk\u00e9r\u00e9s (valamint a h\u00e1zi feladatokn\u00e1l az iMsc pontok is k\u00fcl\u00f6n sz\u00e1monk\u00e9r\u00e9sben vannak). A jelenl\u00e9t vagy pontsz\u00e1m r\u00f6gz\u00edt\u00e9s\u00e9nek menete: Be kell jelentkezni Moodle-re \u00e9s meg kell keresni a t\u00e1rgyat. A t\u00e1rgy kezd\u0151oldal\u00e1n meg kell keresni a sz\u00e1monk\u00e9r\u00e9st. Erre kattintva lehet sz\u0171rni a csoportra. A Grade gombbal egyes\u00e9vel j\u00f6nnek a hallgat\u00f3k, a View all t\u00e1bl\u00e1zatosan mutatja \u0151ket.","title":"Gyakorlatvezet\u0151knek"},{"location":"gyakorlatvezetoknek/#gyakorlatvezetoknek","text":"Gyakorlatvezet\u0151/demonstr\u00e1tor lenn\u00e9l? Az al\u00e1bbiakat \u00e9rdemes tudnod.","title":"Gyakorlatvezet\u0151knek"},{"location":"gyakorlatvezetoknek/#gyakorlatvezeto-feladatai","text":"A gyakorlatvezet\u0151 a t\u00e1rgy oktat\u00e1s\u00e1ban seg\u00edt a gyakorlatok megtart\u00e1sa \u00e9s a sz\u00e1monk\u00e9r\u00e9sek sor\u00e1n. A feladat az al\u00e1bbiakb\u00f3l \u00e1ll. F\u00e9l\u00e9v sor\u00e1n 12 gyakorlat megtart\u00e1sa. A gyakorlatok a 2. oktat\u00e1si h\u00e9ten kezd\u0151dnek \u00e9s a 13. oktat\u00e1si h\u00e9ten \u00e9rnek v\u00e9get. Egy gyakorlatvezet\u0151 \u00e1ltal\u00e1ban 2 gyakorlati csoport oktat\u00e1s\u00e1\u00e9rt felel \u00e9s mindk\u00e9t csoportnak 6-6 gyakorlatot tart meg. A gyakorlat fix \u00f3rarendi id\u0151ben van, 90 perces, \u00e9s sz\u00e1m\u00edt\u00f3g\u00e9p laborban tartjuk. Sz\u00fcnetek miatt elmarad\u00f3 laborokat nem p\u00f3tolunk, \u00edgy n\u00e9ha egy-kett\u0151vel kevesebb \u00f3ra lehet. Alkalmank\u00e9nt lehet\u0151s\u00e9get tudunk adni \"f\u00e9l\" gyakorlatvezet\u00e9sre is, azaz 12 helyett 6 alkalom, egy gyakorlati csoport minden m\u00e1sodik h\u00e9ten. Illet\u0151leg t\u00f6bbet is lehet v\u00e1llalni. A gyakorlat kiadott seg\u00e9dlet alapj\u00e1n ker\u00fcl megtart\u00e1sra. A gyakorlatvezet\u0151 feladata a gyakorlatra val\u00f3 felk\u00e9sz\u00fcl\u00e9s, a gyakorlat megtart\u00e1sa, ennek sor\u00e1n a sz\u00fcks\u00e9ges h\u00e1tt\u00e9rismeretek r\u00f6vid \u00e1tism\u00e9tl\u00e9se, a fontos r\u00e9szek kiemel\u00e9se, \u00e9s a hallgat\u00f3k seg\u00edt\u00e9se a gyakorlat sor\u00e1n. Egy gyakorlati \u00f3r\u00e1n 20 hallgat\u00f3 van a teremben. 2020 \u0151szi f\u00e9l\u00e9v sor\u00e1n a gyakorlatok \u00f3rarendi id\u0151pontjai: kedd 10-12 szerda 14-16 cs\u00fct\u00f6rt\u00f6k 8-10 cs\u00fct\u00f6rt\u00f6k 14-16 cs\u00fct\u00f6rt\u00f6k 16-18 p\u00e9ntek 12-14 Sz\u00e1monk\u00e9r\u00e9sek lebonyol\u00edt\u00e1s\u00e1ban seg\u00edts\u00e9g. A t\u00e1rgyban ZH, PZH, \u00e9s 4 vizsga van. Mindegyik sz\u00e1monk\u00e9r\u00e9s \u00edr\u00e1sban t\u00f6rt\u00e9nik. A gyakorlatvezet\u0151 feladata a sz\u00e1monk\u00e9r\u00e9sek fel\u00fcgyel\u00e9se majd a jav\u00edt\u00e1sban t\u00f6rt\u00e9n\u0151 r\u00e9szv\u00e9tel. A fel\u00fcgyel\u00e9s ideje alkalmank\u00e9nt k\u00f6r\u00fclbel\u00fcl 1 \u00f3ra, a jav\u00edt\u00e1s ideje l\u00e9tsz\u00e1m f\u00fcgg\u0151en 0.5-2 \u00f3ra alkalmank\u00e9nt. Gyakorlatvezet\u0151k\u00e9nt k\u00f6r\u00fclbel\u00fcl a sz\u00e1monk\u00e9r\u00e9sek fel\u00e9ben kell r\u00e9szt venni. H\u00e1zi feladatok \u00e9rt\u00e9kel\u00e9se. A f\u00e9l\u00e9v sor\u00e1n 5 opcion\u00e1lis kis h\u00e1zi feladatot hirdet\u00fcnk meg. Ezeket a hallgat\u00f3k otthon, \u00f6n\u00e1ll\u00f3an oldj\u00e1k meg \u00e9s adj\u00e1k be GitHub pull request-ek form\u00e1j\u00e1ban. A h\u00e1zi feladatok ki\u00e9rt\u00e9kel\u00e9se r\u00e9szben automatikusan t\u00f6rt\u00e9nik: egy szoftver lefuttatja \u00e9s ellen\u0151rzi a beadott munk\u00e1t. A gyakorlatvezet\u0151 feladata a beadott h\u00e1zi feladat formai ellen\u0151rz\u00e9se: k\u00e9rt k\u00e9perny\u0151k\u00e9pek megfelelnek-e az el\u0151\u00edr\u00e1soknak \u00e9s konzisztensek-e a beadott forr\u00e1sk\u00f3ddal. A h\u00e1zi feladat nem k\u00f6telez\u0151, nem minden hallgat\u00f3 szokta elk\u00e9sz\u00edteni, \u00edgy h\u00e1zi feladatonk\u00e9nt k\u00f6r\u00fclbel\u00fcl 1 \u00f3ra id\u0151 r\u00e1ford\u00edt\u00e1st jelent.","title":"Gyakorlatvezet\u0151 feladatai"},{"location":"gyakorlatvezetoknek/#demonstratorsag","text":"Hallgat\u00f3 vagy de szeretn\u00e9l bekapcsol\u00f3dni az oktat\u00e1sba? Szeretn\u00e9d kipr\u00f3b\u00e1lni magad oktat\u00f3k\u00e9nt? Szeretsz magyar\u00e1zni? Elv\u00e9gezted ezt a t\u00e1rgyat \u00f6t\u00f6ssel? V\u00e1runk demonstr\u00e1tork\u00e9nt! A TVSZ p\u00e1r k\u00f6vetelm\u00e9nyt szab demonstr\u00e1toroknak: (l\u00e1sd aktu\u00e1lis TVSZ 165.\u00a7): (5) A demonstr\u00e1tori p\u00e1ly\u00e1zat beny\u00fajt\u00e1s\u00e1nak felt\u00e9tele, hogy a p\u00e1ly\u00e1z\u00f3 a) a demonstr\u00e1tori jogviszonnyal \u00e9rintett f\u00e9l\u00e9vben rendelkezzen akt\u00edv hallgat\u00f3i jogviszonnyal; b) rendelkezzen alapk\u00e9pz\u00e9sben vagy osztatlan k\u00e9pz\u00e9sben szerzett oklev\u00e9llel; c) alapk\u00e9pz\u00e9sben vagy osztatlan k\u00e9pz\u00e9sben szerzett oklev\u00e9l hi\u00e1ny\u00e1ban rendelkezzen legal\u00e1bb annyiszor huszon\u00f6t teljes\u00edtett kredittel, ah\u00e1ny lez\u00e1rt akt\u00edv f\u00e9l\u00e9ve van \u00e9s halmozott s\u00falyozott tanulm\u00e1nyi \u00e1tlageredm\u00e9nye haladja meg a 3,50 \u00e9rt\u00e9ket; \u00e9s d) ne \u00e1lljon fegyelmi b\u00fcntet\u00e9s hat\u00e1lya alatt. Ha \u00e9rdekel a lehet\u0151s\u00e9g, megfelelsz a fenti k\u00f6vetelm\u00e9nyeknek, \u00e9s az \u00f3rarendedbe belef\u00e9r a gyakorlat (l\u00e1sd az id\u0151pontokat fentebb), keresd a t\u00e1rgyfelel\u0151st .","title":"Demonstr\u00e1tors\u00e1g"},{"location":"gyakorlatvezetoknek/#tudnivalok-a-gyakorlatok-megtartasahoz","text":"A t\u00e1rgy alapk\u00e9pz\u00e9s (BSc) 5. f\u00e9l\u00e9v\u00e9ben specializ\u00e1ci\u00f3s t\u00e1rgy. Ezt azt jelenti, hogy a hallgat\u00f3k szoftverfejleszt\u00e9si alapismeretekkel \u00e9s adatb\u00e1zis alapismeretekkel rendelkeznek. A t\u00e1rgyunk c\u00e9lja a tud\u00e1s elm\u00e9ly\u00edt\u00e9se \u00e9s \u00faj technol\u00f3gi\u00e1kba val\u00f3 \"belek\u00f3stol\u00e1s\". Az \u00faj ismeretek \u00e1tad\u00e1sa az el\u0151ad\u00e1sokon t\u00f6rt\u00e9nik, a gyakorlatokon a technol\u00f3gi\u00e1k els\u0151 k\u00e9zb\u0151l val\u00f3 kipr\u00f3b\u00e1l\u00e1sa a l\u00e9nyeg. A c\u00e9lunk, hogy mindenki maga is l\u00e1ssa \u00e9s kipr\u00f3b\u00e1lja az adott eszk\u00f6z\u00f6ket, technol\u00f3gi\u00e1kat, \u00e9s l\u00e1ssa a m\u0171k\u00f6d\u00e9s\u00fcket. A gyakorlatokon v\u00e1ltozatos technol\u00f3gi\u00e1kkal foglalkozunk, \u00e9s ennek megfelel\u0151en t\u00f6bb f\u00e9le szoftvert is haszn\u00e1lunk. Ezek egy r\u00e9sze \u00fajdons\u00e1g lesz a hallgat\u00f3knak, \u00edgy a gyakorlatokon a szoftverek alapvet\u0151 haszn\u00e1lat\u00e1t is megmutatjuk.","title":"Tudnival\u00f3k a gyakorlatok megtart\u00e1s\u00e1hoz"},{"location":"gyakorlatvezetoknek/#oktatas-modja","text":"A gyakorlatokon elv\u00e1rt a r\u00e9szv\u00e9tel, viszont nincs sz\u00e1monk\u00e9r\u00e9s (se beugr\u00f3, se egy\u00e9b). Az el\u0151ad\u00e1sokon minden sz\u00fcks\u00e9ges alapismeret elhangzik, de a gyakorlatokon c\u00e9lszer\u0171 sz\u00f3ban elism\u00e9telni mivel foglalkozunk az adott gyakorlaton \u00e9s az mi\u00e9rt fontos. Emellett \u00e9rdemes kiemelni a feladatok megold\u00e1sa sor\u00e1n az \u00e9rdekes, avagy felt\u00e9tlen\u00fcl megjegyzend\u0151 r\u00e9szeket. (Mindemellett a gyakorlat nem el\u0151ad\u00e1s, nem kell mindent \u00fajb\u00f3l elism\u00e9telni.) A gyakorlatokon \u00f6n\u00e1ll\u00f3 munk\u00e1t csak kis m\u00e9rt\u00e9kben v\u00e1runk el. A gyakorlatok anyaga jelzi, mit lehet \u00f6n\u00e1ll\u00f3 munk\u00e1nak feladni. A gyakorlat nagy r\u00e9sz\u00e9ben teh\u00e1t a gyakorlatvezet\u0151 projektoron csin\u00e1lja a feladatokat, a hallgat\u00f3k k\u00f6vetik \u00e9s maguk is v\u00e9gzik a feladatokat. A bemeleg\u00edt\u0151 feladatok ut\u00e1n (amikor a szoftver k\u00f6rnyezet m\u00e1r ismert), lehet adni gondolkod\u00e1si id\u0151t a hallgat\u00f3knak. A megold\u00e1st viszont mindig besz\u00e9lj\u00e9tek meg k\u00f6z\u00f6sen. A gyakorlati anyagban benne van a megold\u00e1s. Ha valaki lemarad, vagy otthon meg akarja n\u00e9zni, \u00edgy el\u00e9rheti a megold\u00e1sokat. A gyakorlatok sor\u00e1n ne csak \u00e1tm\u00e1soljuk az \u00f3r\u00e1n, hanem g\u00e9pelj\u00fck be a megold\u00e1st, a gondolatmenetet magyar\u00e1zva k\u00f6zben! Ha lehet, vegy\u00fck r\u00e1 a hallgat\u00f3kat is erre.","title":"Oktat\u00e1s m\u00f3dja"},{"location":"gyakorlatvezetoknek/#adminisztrativ-tudnivalok","text":"A gyakorlatokat \u00f3ra 15-kor kezdj\u00fck pontosan \u00e9s 90 percet egyben, sz\u00fcnet n\u00e9lk\u00fcl tartjuk. A k\u00e9s\u0151 hallgat\u00f3kat els\u0151 alkalommal figyelmeztess\u00fck. Ha t\u00f6bbsz\u00f6r el\u0151fordul vagy zavar\u00f3an sokat k\u00e9sik (>5 perc), akkor k\u00fcldj\u00e9tek el (TVSZ erre jogot ad!). A gyakorlat teljes\u00edt\u00e9s\u00e9nek adminisztr\u00e1l\u00e1sa Moodle-ben t\u00f6rt\u00e9nik. A teljes\u00edt\u00e9s a gyakorlaton val\u00f3 megjelen\u00e9st, \u00e9s a munka veletek t\u00f6rt\u00e9n\u0151 elv\u00e9gz\u00e9s\u00e9t jelenti. (Teh\u00e1t a hallgat\u00f3 nem s\u00e9t\u00e1lhat ki a gyakorlat k\u00f6zep\u00e9n \u00e9s nem foglalkozhat m\u00e1ssal, csak a gyakorlattal. Eseti probl\u00e9m\u00e1kat az\u00e9rt kezelj\u00fcnk le, pl. ZH-ja van m\u00e1shol, stb. Egy-egy kiv\u00e9tel belef\u00e9r.) \u00c9rdemes a jelenl\u00e9tet a gyakorlat elej\u00e9n k\u00f6nyvelni. Ha az \u00f3r\u00e1n t\u00f6bb ember jelenne meg, mint ah\u00e1ny g\u00e9p van (hi\u00e1nyz\u00e1s p\u00f3tl\u00e1sa pl.), vagy egy g\u00e9p nem m\u0171k\u00f6dik, akkor akinek nem jut hely, le\u00fcl valaki mell\u00e9. A csoportok k\u00f6z\u00f6tt nincs ad-hoc \u00e1tj\u00e1r\u00e1s. Ha valaki jelzi, hogy nem tud r\u00e9szt venni egy gyakorlaton, akkor el\u0151re/ut\u00f3lag/ugyanazon a h\u00e9ten egy m\u00e1sik csoportban p\u00f3tolhat (ha van r\u00e1 m\u00f3d). Ennek a megszervez\u00e9s\u00e9t alapvet\u0151en a hallgat\u00f3 bonyol\u00edtsa (n\u00e9zze meg, mikor van m\u00e9g labor azonos anyagb\u00f3l, \u00e9s egyeztessen a t\u00e1rgyfelel\u0151ssel, vagy a gyakorlatvezet\u0151kkel), de seg\u00edts\u00fck, ha kell.","title":"Adminisztrat\u00edv tudnival\u00f3k"},{"location":"gyakorlatvezetoknek/#anyagok-elerhetosege","text":"A t\u00e1rgy el\u0151ad\u00e1s anyagai, az id\u0151pontok \u00e9s hat\u00e1rid\u0151k \u00e9s hivatalos k\u00f6vetelm\u00e9nyek Moodle-ben lesznek. (Ehhez a t\u00e1rgy indul\u00e1s\u00e1val kapsz hozz\u00e1f\u00e9r\u00e9st.) Gyakorlatok anyagai: l\u00e1sd a fenti men\u00fcben. A gyakorlati anyag minden r\u00e9sze teljesen publikus. A gyakorlatok anyaga GitHub repository-ban van. Ha hib\u00e1t, elg\u00e9pel\u00e9st tal\u00e1lsz benne, arra k\u00e9r\u00fcnk, hogy jav\u00edtsd: minden anyag jobb fels\u0151 sark\u00e1ban van egy kis ceruza ikon, jav\u00edtsd a hib\u00e1t, \u00e9s k\u00fcldj PR-t.","title":"Anyagok el\u00e9rhet\u0151s\u00e9ge"},{"location":"gyakorlatvezetoknek/#belepesek","text":"A labor termekhez kulcsra \u00e9s/vagy k\u00e1rty\u00e1ra van sz\u00fcks\u00e9g. Ezeket a titk\u00e1rs\u00e1gon (QB207) kell k\u00e9rni. I \u00e9p\u00fclethez kell a teremkulcs, ill. a folyos\u00f3hoz sz\u00fcks\u00e9g van k\u00e1rty\u00e1ra is (kiv\u00e9ve, akinek van ilyenje). Q \u00e9p\u00fclet laborjaihoz hozz\u00e1f\u00e9r\u00e9st k\u00fcl\u00f6n szervezz\u00fck. Demonstr\u00e1torok: mindezt megmutatom els\u0151 alkalommal. G\u00e9pekre : emailben k\u00fcld\u00f6m f\u00e9l\u00e9v elej\u00e9n. Kis- \u00e9s nagybet\u0171 sz\u00e1m\u00edt! P\u00e1r elg\u00e9pel\u00e9s ut\u00e1n le lesz tiltva az account! MS SQL szerver : localdb: nincs jelsz\u00f3, Windows Authentication-t haszn\u00e1ljunk JPA laborn\u00e1l sqlexpress van, SQL Server Authentication kell: sa / sa MongoDB : nincs authentik\u00e1ci\u00f3","title":"Bel\u00e9p\u00e9sek"},{"location":"gyakorlatvezetoknek/#tudnivalok-a-hazi-feladatokkal-kapcsolatban","text":"A f\u00e9l\u00e9v sor\u00e1n a h\u00e1zi feladatok vannak meghirdetve, amiket adott hat\u00e1rid\u0151ig kell beadni GitHub-on. Ennek pontos menete a hallgat\u00f3 szemsz\u00f6g\u00e9b\u0151l itt elolvashat\u00f3. Ahhoz, hogy hozz\u00e1f\u00e9rj a GitHub-on a beadott megold\u00e1sokhoz (\u00e9s ahhoz, hogy a hallgat\u00f3k ezt hozz\u00e1d tudj\u00e1k rendelni), kell egy GitHub account. A GitHub nevedet \u00edrd meg a t\u00e1rgyfelel\u0151snek, \u00e9s felvesz GitHub-on a https://www.github.com/bmeviauac01 organization-be.","title":"Tudnival\u00f3k a h\u00e1zi feladatokkal kapcsolatban"},{"location":"gyakorlatvezetoknek/#mikor-kell-ertekelni-a-hazit","text":"A h\u00e1zikat a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n kell \u00e9rt\u00e9kelni. A hat\u00e1rid\u0151 el\u0151tt a megold\u00e1sokra nem kell r\u00e1n\u00e9zni, kiv\u00e9ve, ha ezt a hallgat\u00f3 k\u00e9ri. K\u00e9rd\u00e9ssel a hallgat\u00f3 direktben kell megkeressen (pl. emailben vagy GitHub-on ).","title":"Mikor kell \u00e9rt\u00e9kelni a h\u00e1zit?"},{"location":"gyakorlatvezetoknek/#hol-kell-ertekelni-a-hazit","text":"A hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a feladatod a hozz\u00e1d rendelt pull request-ek \u00e9rt\u00e9kel\u00e9se. A hallgat\u00f3 azzal adja be a h\u00e1zit, hogy a pull request-et a gyakorlatvezet\u0151j\u00e9hez rendeli. Ezeket a GitHub keres\u0151j\u00e9vel a legegyszer\u0171bb megtal\u00e1lni: https://github.com/pulls?q=is%3Aopen+is%3Apr+org%3Abmeviauac01+assignee%3A%40me+ . Alternat\u00edvak\u00e9nt a GitHub \u00e9rtes\u00edt\u0151 fel\u00fclet\u00e9t is lehet haszn\u00e1lni a https://github.com/notifications c\u00edmen, itt minden hozz\u00e1d rendelt, vagy review-ra v\u00e1r\u00f3 PR megjelenik.","title":"Hol kell \u00e9rt\u00e9kelni a h\u00e1zit?"},{"location":"gyakorlatvezetoknek/#hogyan-kell-ertekelni-a-hazit","text":"A PR-eket egyes\u00e9vel kell megnyitni, \u00e9s meg kell n\u00e9zni a PR komment fel\u00fclet\u00e9n az eredm\u00e9nyt. Itt l\u00e1that\u00f3 lesz a lefuttatott \u00e9rt\u00e9kel\u00e9s eredm\u00e9nye, valamint a k\u00e9perny\u0151k\u00e9pek. Emellett meg kell n\u00e9zni a forr\u00e1sk\u00f3dot is. A forr\u00e1sk\u00f3dot nem sz\u00fcks\u00e9ges bet\u0171r\u0151l bet\u0171re megn\u00e9zni - a r\u00e9szletes ellen\u0151rz\u00e9st elv\u00e9gzi az automata. A gyakorlatvezet\u0151 feladata a k\u00e9perny\u0151k\u00e9pek ellen\u0151rz\u00e9se, valamint annak eld\u00f6nt\u00e9se, hogy a forr\u00e1sk\u00f3d konzisztens-e a kapott eredm\u00e9nnyel. A feladatok minta megold\u00e1sa itt \u00e9rhet\u0151 el: https://github.com/bmeviauac01?q=hazi-megoldas . Ezek csak lehets\u00e9ges megold\u00e1sok, a hallgat\u00f3 megold\u00e1sa nem kell ezzel egyezzen. Az \u00e9rt\u00e9kel\u00e9s v\u00e9gezt\u00e9vel: R\u00f6gz\u00edteni kell a pontsz\u00e1mot Moodle-ben. Ha van iMsc pontsz\u00e1m, azt k\u00fcl\u00f6n sz\u00e1monk\u00e9r\u00e9sben kell r\u00f6gz\u00edteni. Opcion\u00e1lis, de javasolt: mergelni a PR-t. (Szoftverfejleszt\u00e9s sor\u00e1n ez a logikus lez\u00e1r\u00e1sa a PR-nek.) Ha nem mergeled a PR-t, akkor lez\u00e1rni a PR-t. Ha gond volt a megold\u00e1ssal, v\u00e1ltozott a pontsz\u00e1m, vagy valamit hozz\u00e1f\u0171zn\u00e9l, akkor azt is kommentbe be\u00edrni a PR-be.","title":"Hogyan kell \u00e9rt\u00e9kelni a h\u00e1zit?"},{"location":"gyakorlatvezetoknek/#problemak-es-megoldasuk","text":"Nem futott le az automata \u00e9rt\u00e9kel\u00e9s. Lehet, hogy a hallgat\u00f3 draft m\u00f3dban hagyta a PR-t, ezt vissza kell \u00e1ll\u00edtani. A PR alj\u00e1n megjelenik ilyenkor egy Ready for review gomb. Ha sikertelen volt a ki\u00e9rt\u00e9kel\u00e9s, meg lehet ism\u00e9telni. Ez seg\u00edt a tranziens hib\u00e1kon (ritka eset). Ehhez tegy\u00e9l egy eval nev\u0171 labelt-t a PR-re (\u00faj label-k\u00e9nt kell l\u00e9trehozni). T\u00f6bb, mint 5-sz\u00f6r futott a ki\u00e9rt\u00e9kel\u00e9s. Ezt pontlevon\u00e1ssal szankcion\u00e1ljuk. Els\u0151 alkalommal eltekinthet\u00fcnk t\u0151le, de mindenk\u00e9ppen t\u00e1j\u00e9koztassuk a hallgat\u00f3t. Hiba van a ki\u00e9rt\u00e9kel\u0151 alkalmaz\u00e1sban. El\u0151fordulhat. Keresd a t\u00e1rgyfelel\u0151st, vagy jav\u00edtsd a hib\u00e1t (a ki\u00e9rt\u00e9kel\u0151 programok itt vannak: https://github.com/bmeviauac01/hazi-ahk/ ).","title":"Probl\u00e9m\u00e1k \u00e9s megold\u00e1suk"},{"location":"gyakorlatvezetoknek/#jelenlet-es-eredmeny-rogzitese-moodle-ben","text":"A gyakorlat csoportok Moodle-ban vannak. Neptunb\u00f3l automatikusan ker\u00fclnek \u00e1t. Az eredm\u00e9nyeket (gyakorlatokon jelenl\u00e9t \u00e9s h\u00e1zi feladat pontsz\u00e1ma) itt k\u00f6nyvelj\u00fck. Minden gyakorlati alkalom, ill. minden h\u00e1zi feladat k\u00fcl\u00f6n sz\u00e1monk\u00e9r\u00e9s (valamint a h\u00e1zi feladatokn\u00e1l az iMsc pontok is k\u00fcl\u00f6n sz\u00e1monk\u00e9r\u00e9sben vannak). A jelenl\u00e9t vagy pontsz\u00e1m r\u00f6gz\u00edt\u00e9s\u00e9nek menete: Be kell jelentkezni Moodle-re \u00e9s meg kell keresni a t\u00e1rgyat. A t\u00e1rgy kezd\u0151oldal\u00e1n meg kell keresni a sz\u00e1monk\u00e9r\u00e9st. Erre kattintva lehet sz\u0171rni a csoportra. A Grade gombbal egyes\u00e9vel j\u00f6nnek a hallgat\u00f3k, a View all t\u00e1bl\u00e1zatosan mutatja \u0151ket.","title":"Jelenl\u00e9t \u00e9s eredm\u00e9ny r\u00f6gz\u00edt\u00e9se Moodle-ben"},{"location":"hazi/","text":"Szorgalmi h\u00e1zi feladatok \u00b6 A h\u00e1zi feladatok opcion\u00e1lisak, pluszpont \u00e9s iMsc pont szerezhet\u0151 vel\u00fck. A feladatok le\u00edr\u00e1sa tal\u00e1lhat\u00f3 itt; a megold\u00e1sok bead\u00e1sa GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik. M\u0171k\u00f6d\u0151 k\u00f3d A feladatok sor\u00e1n m\u0171k\u00f6d\u0151 k\u00f3dot, k\u00f3dr\u00e9szleteteket kell k\u00e9sz\u00edteni. A feladat l\u00e9nyege a val\u00f3s\u00e1gban m\u0171k\u00f6d\u0151 \u00e9s a k\u00edv\u00e1nt funkci\u00f3t ell\u00e1t\u00f3 k\u00f3d k\u00e9sz\u00edt\u00e9se. A feladatok \u00b6 MSSQL szerveroldali programoz\u00e1s ADO.NET adatel\u00e9r\u00e9s Entity Framework MongoDB REST API Web API technol\u00f3gi\u00e1val A feladatok bead\u00e1sa \u00b6 Minden h\u00e1zi feladat megold\u00e1s\u00e1t egy szem\u00e9lyre sz\u00f3l\u00f3 git repository-ban kell beadni. Ennek pontos folyamat\u00e1t l\u00e1sd itt . K\u00e9r\u00fcnk, hogy alaposan olvasd v\u00e9gig a le\u00edr\u00e1st! FONTOS A h\u00e1zik elk\u00e9sz\u00edt\u00e9se \u00e9s bead\u00e1s sor\u00e1n az itt le\u00edrtak szerint kell elj\u00e1rnod. A nem ilyen form\u00e1ban beadott h\u00e1zikat nem \u00e9rt\u00e9kelj\u00fck. A bead\u00e1s sor\u00e1n a munkafolyamati hib\u00e1k\u00e9rt (pl. nem megfelel\u0151 emberhez hozz\u00e1rendel\u00e9se, hozz\u00e1rendel\u00e9s elfelejt\u00e9se) pontot vonunk le. K\u00e9perny\u0151k\u00e9pek \u00b6 A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi . A k\u00e9perny\u0151k\u00e9p k\u00e9sz\u00fclhet a teljes desktopr\u00f3l is, de lehet csak a k\u00e9rt alkalmaz\u00e1sr\u00f3l k\u00e9sz\u00edteni. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, \u00edgy felker\u00fclnek a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l. A feladatok ki\u00e9rt\u00e9kel\u00e9se \u00b6 A feladatok ki\u00e9rt\u00e9kel\u00e9se r\u00e9szben automatikusan t\u00f6rt\u00e9nik. A futtathat\u00f3 k\u00f3dokat val\u00f3ban le fogjuk futtatni, ez\u00e9rt minden esetben fontos a feladatle\u00edr\u00e1sok pontos k\u00f6vet\u00e9se (kiindul\u00f3 k\u00f3d v\u00e1z haszn\u00e1lata, csak a megengedett f\u00e1jlok v\u00e1ltoztat\u00e1sa, stb.)! A ki\u00e9rt\u00e9kel\u00e9s eredm\u00e9ny\u00e9r\u0151l a GitHub-on kapsz sz\u00f6veges visszajelz\u00e9st (l\u00e1sd itt ). Ha enn\u00e9l t\u00f6bb inform\u00e1ci\u00f3ra van sz\u00fcks\u00e9ged, a GitHub Actions webes fel\u00fclete seg\u00edts\u00e9g\u00fcl szolg\u00e1lhat. Err\u0151l itt tal\u00e1lsz egy r\u00f6vid ismertet\u0151t. Ellen\u0151rz\u00e9s Egyes h\u00e1zikban (ahol a technol\u00f3gia ezt k\u00e9nyelmess\u00e9 teszi) tal\u00e1lsz unit teszteket. Ezen tesztek seg\u00edtenek ellen\u0151rizni a munk\u00e1dat, de nem helyettes\u00edtik saj\u00e1t ellen\u0151rz\u00e9sed . Amikor felt\u00f6lt\u00f6d a munk\u00e1dat, alaposabb tesztel\u00e9sen fog \u00e1tesni a k\u00f3dod.","title":"Szorgalmi h\u00e1zi feladatok"},{"location":"hazi/#szorgalmi-hazi-feladatok","text":"A h\u00e1zi feladatok opcion\u00e1lisak, pluszpont \u00e9s iMsc pont szerezhet\u0151 vel\u00fck. A feladatok le\u00edr\u00e1sa tal\u00e1lhat\u00f3 itt; a megold\u00e1sok bead\u00e1sa GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik. M\u0171k\u00f6d\u0151 k\u00f3d A feladatok sor\u00e1n m\u0171k\u00f6d\u0151 k\u00f3dot, k\u00f3dr\u00e9szleteteket kell k\u00e9sz\u00edteni. A feladat l\u00e9nyege a val\u00f3s\u00e1gban m\u0171k\u00f6d\u0151 \u00e9s a k\u00edv\u00e1nt funkci\u00f3t ell\u00e1t\u00f3 k\u00f3d k\u00e9sz\u00edt\u00e9se.","title":"Szorgalmi h\u00e1zi feladatok"},{"location":"hazi/#a-feladatok","text":"MSSQL szerveroldali programoz\u00e1s ADO.NET adatel\u00e9r\u00e9s Entity Framework MongoDB REST API Web API technol\u00f3gi\u00e1val","title":"A feladatok"},{"location":"hazi/#a-feladatok-beadasa","text":"Minden h\u00e1zi feladat megold\u00e1s\u00e1t egy szem\u00e9lyre sz\u00f3l\u00f3 git repository-ban kell beadni. Ennek pontos folyamat\u00e1t l\u00e1sd itt . K\u00e9r\u00fcnk, hogy alaposan olvasd v\u00e9gig a le\u00edr\u00e1st! FONTOS A h\u00e1zik elk\u00e9sz\u00edt\u00e9se \u00e9s bead\u00e1s sor\u00e1n az itt le\u00edrtak szerint kell elj\u00e1rnod. A nem ilyen form\u00e1ban beadott h\u00e1zikat nem \u00e9rt\u00e9kelj\u00fck. A bead\u00e1s sor\u00e1n a munkafolyamati hib\u00e1k\u00e9rt (pl. nem megfelel\u0151 emberhez hozz\u00e1rendel\u00e9se, hozz\u00e1rendel\u00e9s elfelejt\u00e9se) pontot vonunk le.","title":"A feladatok bead\u00e1sa"},{"location":"hazi/#kepernyokepek","text":"A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi . A k\u00e9perny\u0151k\u00e9p k\u00e9sz\u00fclhet a teljes desktopr\u00f3l is, de lehet csak a k\u00e9rt alkalmaz\u00e1sr\u00f3l k\u00e9sz\u00edteni. A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, \u00edgy felker\u00fclnek a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.","title":"K\u00e9perny\u0151k\u00e9pek"},{"location":"hazi/#a-feladatok-kiertekelese","text":"A feladatok ki\u00e9rt\u00e9kel\u00e9se r\u00e9szben automatikusan t\u00f6rt\u00e9nik. A futtathat\u00f3 k\u00f3dokat val\u00f3ban le fogjuk futtatni, ez\u00e9rt minden esetben fontos a feladatle\u00edr\u00e1sok pontos k\u00f6vet\u00e9se (kiindul\u00f3 k\u00f3d v\u00e1z haszn\u00e1lata, csak a megengedett f\u00e1jlok v\u00e1ltoztat\u00e1sa, stb.)! A ki\u00e9rt\u00e9kel\u00e9s eredm\u00e9ny\u00e9r\u0151l a GitHub-on kapsz sz\u00f6veges visszajelz\u00e9st (l\u00e1sd itt ). Ha enn\u00e9l t\u00f6bb inform\u00e1ci\u00f3ra van sz\u00fcks\u00e9ged, a GitHub Actions webes fel\u00fclete seg\u00edts\u00e9g\u00fcl szolg\u00e1lhat. Err\u0151l itt tal\u00e1lsz egy r\u00f6vid ismertet\u0151t. Ellen\u0151rz\u00e9s Egyes h\u00e1zikban (ahol a technol\u00f3gia ezt k\u00e9nyelmess\u00e9 teszi) tal\u00e1lsz unit teszteket. Ezen tesztek seg\u00edtenek ellen\u0151rizni a munk\u00e1dat, de nem helyettes\u00edtik saj\u00e1t ellen\u0151rz\u00e9sed . Amikor felt\u00f6lt\u00f6d a munk\u00e1dat, alaposabb tesztel\u00e9sen fog \u00e1tesni a k\u00f3dod.","title":"A feladatok ki\u00e9rt\u00e9kel\u00e9se"},{"location":"hazi/GitHub-Actions/","text":"GitHub Actions ismertet\u0151 \u00b6 A feladatok ki\u00e9rt\u00e9kel\u00e9s\u00e9ben a GitHub Actions -re t\u00e1maszkodunk. Seg\u00edts\u00e9g\u00e9vel a git repository-kon m\u0171veleteket \u00e9s programokat tudunk futtatni. Ilyen m\u0171velet p\u00e9ld\u00e1ul a C# k\u00f3d leford\u00edt\u00e1sa, vagy a beadott k\u00f3d tesztel\u00e9se. A lefutott ki\u00e9rt\u00e9kel\u00e9sr\u0151l a pull request-ben fogsz \u00e9rtes\u00edt\u00e9st kapni. Ha meg szeretn\u00e9d n\u00e9zni r\u00e9szletesebben a h\u00e1tt\u00e9rben t\u00f6rt\u00e9nteket, vagy p\u00e9ld\u00e1ul az alkalmaz\u00e1s napl\u00f3kat, a GitHub fel\u00fclet\u00e9n az Actions alatt indulhatsz el. Az Actions fel\u00fclet\u00e9n un. Workflow -kat l\u00e1tsz; minden egyes ki\u00e9rt\u00e9kel\u00e9s futtat\u00e1s egy-egy elem lesz itt (teh\u00e1t historikusan is visszakereshet\u0151ek). Ezek k\u00f6z\u00fcl egyet kiv\u00e1lasztva (pl. a legfels\u0151 mindig a legutols\u00f3) l\u00e1thatod a workflow fut\u00e1s\u00e1nak r\u00e9szleteit. A fut\u00e1s napl\u00f3j\u00e1hoz a bal oldali list\u00e1ban m\u00e9g kattintani kell egyet. Jobb oldalon l\u00e1that\u00f3 a folyamat teljes napl\u00f3ja. Minden z\u00f6ld pipa egy-egy sikeres l\u00e9p\u00e9st jelent. Ezen l\u00e9p\u00e9sek nem azonosak a feladatokokkal, hanem a ki\u00e9rt\u00e9kel\u00e9s folyamat\u00e1nak l\u00e9p\u00e9sei lesznek. Ilyen l\u00e9p\u00e9s p\u00e9ld\u00e1ul a k\u00f6rnyezet el\u0151k\u00e9sz\u00edt\u00e9se, pl. a .NET SDK telep\u00edt\u00e9se (minden ki\u00e9rt\u00e9kel\u00e9s egy vadi\u00faj k\u00f6rnyezetben indul, \u00edgy mindent el\u0151 kell k\u00e9sz\u00edteni). Alapvet\u0151en a l\u00e9p\u00e9sek mindig sikeresek, akkor is, ha a megold\u00e1sodban hiba van, mert a ki\u00e9rt\u00e9kel\u00e9s erre fel van k\u00e9sz\u00edtve. Kiv\u00e9telt ez al\u00f3l csak a neptun.txt hi\u00e1nya ill. a C# k\u00f3d leford\u00edt\u00e1sa jelent. El\u0151bbi felt\u00e9tlen\u00fcl sz\u00fcks\u00e9ges, ez\u00e9rt semmilyen folyamatot nem hajtunk v\u00e9gre n\u00e9lk\u00fcle. Ut\u00f3bbi eset\u00e9ben a C# k\u00f3d ford\u00edt\u00e1sa szint\u00e9n sz\u00fcks\u00e9ges a tov\u00e1bbl\u00e9p\u00e9shez, ez\u00e9rt sikertelens\u00e9g eset\u00e9n le\u00e1ll a folyamat. N\u00e9ha el\u0151fordulhat azonban tranziens, id\u0151szakos hiba is. P\u00e9ld\u00e1ul a .NET k\u00f6rnyezet let\u00f6lt\u00e9se nem siker\u00fcl h\u00e1l\u00f3zati hiba miatt. Ilyen esetben a futtat\u00e1st k\u00e9zzel meg lehet ism\u00e9telni. Ez persze csak akkor seg\u00edt, ha t\u00e9nyleg \u00e1tmeneti hib\u00e1r\u00f3l van sz\u00f3, teh\u00e1t pl. egy C# ford\u00edt\u00e1si hib\u00e1n nem fog seg\u00edteni. (Ezt a hiba\u00fczenetb\u0151l illetve a l\u00e9p\u00e9s nev\u00e9b\u0151l tudod kider\u00edteni, vagy legal\u00e1bb is megtippelni kell\u0151 bizonyoss\u00e1ggal.) A feladat f\u00fcggv\u00e9ny\u00e9ben ak\u00e1r az alkalmaz\u00e1s napl\u00f3kat is meg tudod n\u00e9zni itt. Pl. amikor .NET alkalmaz\u00e1st k\u00e9sz\u00edtesz, az alkalmaz\u00e1st elind\u00edtjuk, \u00e9s minden, amit napl\u00f3z, itt megtekinthet\u0151. Az al\u00e1bbi p\u00e9ld\u00e1ul egy Entity Framework-\u00f6t haszn\u00e1l\u00f3 alkalmaz\u00e1s inicializ\u00e1s\u00e1t mutatja, k\u00f6zt\u00fck p\u00e9ld\u00e1ul a kiadott SQL parancsokat is. Debuggol\u00e1s k\u00f6zben a Visual Studio Output ablak\u00e1ban is hasonl\u00f3kat l\u00e1thatsz. Ez term\u00e9szetesen nagyban f\u00fcgg a konkr\u00e9t feladatt\u00f3l.","title":"GitHub Actions ismertet\u0151"},{"location":"hazi/GitHub-Actions/#github-actions-ismerteto","text":"A feladatok ki\u00e9rt\u00e9kel\u00e9s\u00e9ben a GitHub Actions -re t\u00e1maszkodunk. Seg\u00edts\u00e9g\u00e9vel a git repository-kon m\u0171veleteket \u00e9s programokat tudunk futtatni. Ilyen m\u0171velet p\u00e9ld\u00e1ul a C# k\u00f3d leford\u00edt\u00e1sa, vagy a beadott k\u00f3d tesztel\u00e9se. A lefutott ki\u00e9rt\u00e9kel\u00e9sr\u0151l a pull request-ben fogsz \u00e9rtes\u00edt\u00e9st kapni. Ha meg szeretn\u00e9d n\u00e9zni r\u00e9szletesebben a h\u00e1tt\u00e9rben t\u00f6rt\u00e9nteket, vagy p\u00e9ld\u00e1ul az alkalmaz\u00e1s napl\u00f3kat, a GitHub fel\u00fclet\u00e9n az Actions alatt indulhatsz el. Az Actions fel\u00fclet\u00e9n un. Workflow -kat l\u00e1tsz; minden egyes ki\u00e9rt\u00e9kel\u00e9s futtat\u00e1s egy-egy elem lesz itt (teh\u00e1t historikusan is visszakereshet\u0151ek). Ezek k\u00f6z\u00fcl egyet kiv\u00e1lasztva (pl. a legfels\u0151 mindig a legutols\u00f3) l\u00e1thatod a workflow fut\u00e1s\u00e1nak r\u00e9szleteit. A fut\u00e1s napl\u00f3j\u00e1hoz a bal oldali list\u00e1ban m\u00e9g kattintani kell egyet. Jobb oldalon l\u00e1that\u00f3 a folyamat teljes napl\u00f3ja. Minden z\u00f6ld pipa egy-egy sikeres l\u00e9p\u00e9st jelent. Ezen l\u00e9p\u00e9sek nem azonosak a feladatokokkal, hanem a ki\u00e9rt\u00e9kel\u00e9s folyamat\u00e1nak l\u00e9p\u00e9sei lesznek. Ilyen l\u00e9p\u00e9s p\u00e9ld\u00e1ul a k\u00f6rnyezet el\u0151k\u00e9sz\u00edt\u00e9se, pl. a .NET SDK telep\u00edt\u00e9se (minden ki\u00e9rt\u00e9kel\u00e9s egy vadi\u00faj k\u00f6rnyezetben indul, \u00edgy mindent el\u0151 kell k\u00e9sz\u00edteni). Alapvet\u0151en a l\u00e9p\u00e9sek mindig sikeresek, akkor is, ha a megold\u00e1sodban hiba van, mert a ki\u00e9rt\u00e9kel\u00e9s erre fel van k\u00e9sz\u00edtve. Kiv\u00e9telt ez al\u00f3l csak a neptun.txt hi\u00e1nya ill. a C# k\u00f3d leford\u00edt\u00e1sa jelent. El\u0151bbi felt\u00e9tlen\u00fcl sz\u00fcks\u00e9ges, ez\u00e9rt semmilyen folyamatot nem hajtunk v\u00e9gre n\u00e9lk\u00fcle. Ut\u00f3bbi eset\u00e9ben a C# k\u00f3d ford\u00edt\u00e1sa szint\u00e9n sz\u00fcks\u00e9ges a tov\u00e1bbl\u00e9p\u00e9shez, ez\u00e9rt sikertelens\u00e9g eset\u00e9n le\u00e1ll a folyamat. N\u00e9ha el\u0151fordulhat azonban tranziens, id\u0151szakos hiba is. P\u00e9ld\u00e1ul a .NET k\u00f6rnyezet let\u00f6lt\u00e9se nem siker\u00fcl h\u00e1l\u00f3zati hiba miatt. Ilyen esetben a futtat\u00e1st k\u00e9zzel meg lehet ism\u00e9telni. Ez persze csak akkor seg\u00edt, ha t\u00e9nyleg \u00e1tmeneti hib\u00e1r\u00f3l van sz\u00f3, teh\u00e1t pl. egy C# ford\u00edt\u00e1si hib\u00e1n nem fog seg\u00edteni. (Ezt a hiba\u00fczenetb\u0151l illetve a l\u00e9p\u00e9s nev\u00e9b\u0151l tudod kider\u00edteni, vagy legal\u00e1bb is megtippelni kell\u0151 bizonyoss\u00e1ggal.) A feladat f\u00fcggv\u00e9ny\u00e9ben ak\u00e1r az alkalmaz\u00e1s napl\u00f3kat is meg tudod n\u00e9zni itt. Pl. amikor .NET alkalmaz\u00e1st k\u00e9sz\u00edtesz, az alkalmaz\u00e1st elind\u00edtjuk, \u00e9s minden, amit napl\u00f3z, itt megtekinthet\u0151. Az al\u00e1bbi p\u00e9ld\u00e1ul egy Entity Framework-\u00f6t haszn\u00e1l\u00f3 alkalmaz\u00e1s inicializ\u00e1s\u00e1t mutatja, k\u00f6zt\u00fck p\u00e9ld\u00e1ul a kiadott SQL parancsokat is. Debuggol\u00e1s k\u00f6zben a Visual Studio Output ablak\u00e1ban is hasonl\u00f3kat l\u00e1thatsz. Ez term\u00e9szetesen nagyban f\u00fcgg a konkr\u00e9t feladatt\u00f3l.","title":"GitHub Actions ismertet\u0151"},{"location":"hazi/GitHub/","text":"Feladatok bead\u00e1sa (GitHub) \u00b6 A feladatok bead\u00e1s\u00e1hoz a GitHub platformot haszn\u00e1ljuk. Minden h\u00e1zi bead\u00e1sa egy-egy GitHub repository-ban t\u00f6rt\u00e9nik, melyet a feladatle\u00edr\u00e1sban tal\u00e1lhat\u00f3 linken kereszt\u00fcl kapsz meg. A h\u00e1zi feladatainak megold\u00e1s\u00e1t ezen repository-ban kell elk\u00e9sz\u00edtened, \u00e9s ide kell felt\u00f6ltened. A k\u00e9sz megold\u00e1s bead\u00e1sa a repository-ba val\u00f3 felt\u00f6lt\u00e9s ut\u00e1n egy un. pull request form\u00e1j\u00e1ban t\u00f6rt\u00e9nik, amelyet a gyakorlatvezet\u0151dh\u00f6z rendelsz. FONTOS Az itt le\u00edrt formai el\u0151\u00edr\u00e1sok betart\u00e1sa elv\u00e1r\u00e1s. A nem ilyen form\u00e1ban beadott megold\u00e1sokat nem \u00e9rt\u00e9kelj\u00fck. R\u00f6vid\u00edtett verzi\u00f3 \u00b6 Al\u00e1bb r\u00e9szletesen bemutatjuk a bead\u00e1s menet\u00e9t. Itt egy r\u00f6vid \u00f6sszefoglal\u00f3 az \u00e1ttekint\u00e9shez, illetve a helyes bead\u00e1s ellen\u0151rz\u00e9s\u00e9hez. A munk\u00e1dat a h\u00e1zi le\u00edr\u00e1sban tal\u00e1lhat\u00f3 linken kereszt\u00fcl l\u00e9trehozott GitHub repository-ban kell elk\u00e9sz\u00edtsd. A megold\u00e1shoz k\u00e9sz\u00edts egy k\u00fcl\u00f6n \u00e1gat, ne a master -en dolgozz. Erre az \u00e1gra ak\u00e1rh\u00e1ny kommitot tehetsz. Mindenk\u00e9ppen pushold a megold\u00e1st. A bead\u00e1st egy pull request jelzi, amely pull request-et a gyakorlatvezet\u0151dh\u00f6z kell rendelned. Ha az eredm\u00e9nnyel vagy \u00e9rt\u00e9kel\u00e9ssel kapcsolatban k\u00e9rd\u00e9sed van, pull request kommentben k\u00e9rdezhetsz. A gyakorlatvezet\u0151 \u00e9rtes\u00edt\u00e9s\u00e9hez haszn\u00e1ld a @n\u00e9v c\u00edmz\u00e9st a komment sz\u00f6veg\u00e9ben. A munka elkezd\u00e9se: git checkout \u00b6 Regisztr\u00e1lj egy GitHub accountot, ha m\u00e9g nincs. A feladat bead\u00e1s\u00e1hoz tartoz\u00f3 linket nyisd meg. Ez minden feladathoz m\u00e1s lesz, a feladat le\u00edr\u00e1s\u00e1ban tal\u00e1lod. Ha k\u00e9ri, adj enged\u00e9lyt a GitHub Classroom alkalmaz\u00e1snak, hogy haszn\u00e1lja az account adataidat. L\u00e1tni fogsz egy oldalt, ahol elfogadhatod a feladatot (\"Accept the ... assignment\"). Kattints a gombra. V\u00e1rd meg, am\u00edg elk\u00e9sz\u00fcl a repository. A repository linkj\u00e9t itt kapod meg. Megjegyz\u00e9s A repository priv\u00e1t lesz, azaz az senki nem l\u00e1tja, csak te, \u00e9s az oktat\u00f3k. Nyisd meg a repository-t a webes fel\u00fcleten a linkre kattintva. Ezt az URL-t \u00edrd fel, vagy mentsd el. Kl\u00f3nozd le a repository-t. Ehhez sz\u00fcks\u00e9ges lesz a repository c\u00edm\u00e9re, amit a repository webes fel\u00fclet\u00e9n a Clone or download alatt tal\u00e1lsz. A git repository kezel\u00e9s\u00e9hez tetsz\u0151leges klienst haszn\u00e1lhatsz. Ha nincs kedvenced m\u00e9g, akkor legegyszer\u0171bb a GitHub Desktop . Ebben az alkalmaz\u00e1sban k\u00f6zvetlen\u00fcl tudod list\u00e1zni a repository-kat GitHub-r\u00f3l, vagy haszn\u00e1lhatod az URL-t is a kl\u00f3noz\u00e1shoz. Ha konzolt haszn\u00e1ln\u00e1l, az al\u00e1bbi parancs kl\u00f3nozza a repository-t (ha a git parancs el\u00e9rhet\u0151): git clone <repository link> Ha siker\u00fclt a kl\u00f3noz\u00e1s, M\u00c9G NE KEZDJ EL DOLGOZNI! A megold\u00e1st ne a repository master \u00e1g\u00e1n k\u00e9sz\u00edtsd el. Hozz l\u00e9tre egy \u00faj \u00e1gat (branch) megoldas n\u00e9ven. GitHub Desktop-ban a Branch men\u00fcben teheted ezt meg. Ha konzolt haszn\u00e1lsz, az \u00faj \u00e1g elk\u00e9sz\u00edthet\u0151 ezzel a paranccsal: git checkout -b megoldas Ezen a megold\u00e1s \u00e1gon dolgozva k\u00e9sz\u00edtsd el a beadand\u00f3kat. Ak\u00e1rh\u00e1nyszor kommitolhatsz \u00e9s pusholhatsz. Kommit n\u00e9v ellen\u0151rz\u00e9se Miel\u0151tt a git repository-val dolgozol, ellen\u0151r\u00edzd, hogy a megfelel\u0151 n\u00e9vvel \u00e9s email c\u00edmmel kommitolsz-e. Ezt a k\u00f6vetkez\u0151 command line paranccsal tudod megtenni. git config user.name git config user.email Ha ez nem megfelel\u0151 lenne, akkor add ki az al\u00e1bbi parancsokat a git repository mapp\u00e1j\u00e1ban. Ezzel az adott repository-ra fogod be\u00e1ll\u00edtani a k\u00edv\u00e1nt nevet \u00e9s email c\u00edmet. (\u00c9rdemes olyan email c\u00edmet, megadni ami a github useretekhez van rendelve) git config user.name \"John Doe\" git config user.email \"john@doe.org\" Ha nem akarod minden repository-re k\u00fcl\u00f6n \u00e1ll\u00edtani a fentieket, akkor \u00e9rdemes lehet a glob\u00e1lisan vizsg\u00e1lni \u00e9s fel\u00fcl\u00edrni a --global kapcsol\u00f3val. GitHub Desktop-ban \u00edgy tudsz kommitolni. Mindig ellen\u0151rizd, hogy j\u00f3 \u00e1gon vagy-e. Els\u0151 alkalommal a megoldas \u00e1g csak helyben l\u00e9tezik, ez\u00e9rt publik\u00e1lni kell: Publish this branch . A tov\u00e1bbi kommitokn\u00e1l is mindig ellen\u0151rizd a megfelel\u0151 \u00e1gat. Ha egy kommit m\u00e9g nincs fel\u00f6ltve, azt a Push origin gombbal teheted meg. A kis sz\u00e1m a gombon jelzi, hogy h\u00e1ny, m\u00e9g nem pusholt kommit van. Ha konzolt haszn\u00e1lsz, akkor az al\u00e1bbi parancsokat haszn\u00e1ld (felt\u00e9ve, hogy a j\u00f3 \u00e1gon vagy): # Ellen\u0151rizd az \u00e1gat, \u00e9s hogy milyen f\u00e1jlok m\u00f3dosultak git status # Minden v\u00e1ltoztat\u00e1st el\u0151k\u00e9sz\u00edt kommitol\u00e1sra git add . # Kommit git commit -m \"f1\" # Push els\u0151 alkalommal az \u00faj \u00e1g publik\u00e1l\u00e1s\u00e1hoz git push --set-upstream origin megoldas # Push a tov\u00e1bbiakban, amikor az \u00e1g m\u00e1r nem \u00faj git push A megold\u00e1s bead\u00e1sa \u00b6 Ha v\u00e9gezt\u00e9l a megold\u00e1ssal, ellen\u0151rizd a GitHub webes fel\u00fclet\u00e9n, hogy mindent felt\u00f6lt\u00f6tt\u00e9l-e. Ehhez a webes fel\u00fcleten v\u00e1ltanod kell az \u00e1gak k\u00f6z\u00f6tt. Felt\u00f6lt\u00e9s a webes fel\u00fcleten Azt javasoljuk, hogy ne haszn\u00e1ld a GitHub f\u00e1jl felt\u00f6lt\u00e9s funkci\u00f3j\u00e1t. Ha valami hi\u00e1nyzik, a helyi git repository-ban p\u00f3told, \u00e9s kommitold majd pushold. Ha t\u00e9nyleg k\u00e9sz vagy, akkor nyiss egy pull request -et. Minek a pull request? Ez a pull request fogja \u00f6ssze a megold\u00e1sodat, \u00e9s annak \"v\u00e9geredm\u00e9ny\u00e9t\" mutatja. \u00cdgy a gyakorlatvezet\u0151nek nem az egyes kommitjaidat vagy f\u00e1jljaidat kell n\u00e9znie, hanem csak a relev\u00e1ns, v\u00e1ltozott r\u00e9szeket l\u00e1tja egyben. A pull request jelenti a feladatod bead\u00e1s\u00e1t is, \u00edgy ez a l\u00e9p\u00e9s nem hagyhat\u00f3 ki . A pull request nyit\u00e1s\u00e1hoz a GitHub webes fel\u00fclet\u00e9re kell menj. Itt, ha nem r\u00e9g pusholt\u00e1l, a GitHub fel is aj\u00e1nlja a pull request l\u00e9trehoz\u00e1s\u00e1t. A pull request -et a fenti men\u00fcben is l\u00e9trehozhatod. Fontos, hogy a megfelel\u0151 brancheket v\u00e1laszd ki: master -be megy a megoldas \u00e1g. Ha minden rendben siker\u00fclt, a men\u00fcben fent l\u00e1tod a kis \"1\" sz\u00e1mot a Pull request elem mellett, jelezve, hogy van egy nyitott pull request. DE M\u00c9G NEM V\u00c9GEZT\u00c9L! A pull request hat\u00e1s\u00e1ra le fog futni egy \u00e9rt\u00e9kel\u00e9s. Ennek eredm\u00e9ny\u00e9t a pull request alatt kommentben fogod l\u00e1tni. Ez az \u00e9rt\u00e9kel\u00e9s minden h\u00e1zi eset\u00e9ben m\u00e1s lesz. A programodat minden esetben lefuttatjuk, \u00e9s el\u0151zetes pontsz\u00e1mot is kapsz. Ha a ki\u00e9rt\u00e9kel\u00e9s eredm\u00e9ny\u00e9vel kapcsolatban t\u00f6bb inform\u00e1ci\u00f3ra van sz\u00fcks\u00e9ged, mint amit itt l\u00e1tsz, a GitHub Actions webes fel\u00fclete seg\u00edts\u00e9g\u00fcl szolg\u00e1lhat. Err\u0151l itt tal\u00e1lsz egy r\u00f6vid ismertet\u0151t. Ha nem vagy megel\u00e9gedve a munk\u00e1ddal, akkor m\u00e9g jav\u00edthatsz rajta. Ehhez kommitolj \u00e9s pusholj \u00fajra. Ha tov\u00e1bbra is a megfelel\u0151 \u00e1gon dolgozol, akkor a pull request \u00fajb\u00f3l le fogja futtatni a ki\u00e9rt\u00e9kel\u00e9st. Arra k\u00e9r\u00fcnk, hogy MAXIMUM 5 alkalommal futtasd le a ki\u00e9rt\u00e9kel\u00e9st! Megold\u00e1s jav\u00edt\u00e1sa ki\u00e9rt\u00e9kel\u00e9s n\u00e9lk\u00fcl Ha \u00fagy l\u00e1tod, hogy a megold\u00e1sodat m\u00e9g jav\u00edtani akarod, \u00e9s nem szeretn\u00e9d, hogy mindig lefusson az \u00e9rt\u00e9kel\u00e9s, akkor \u00e1ll\u00edtsd \u00e1t a pull request-et a webes fel\u00fcleten draft \u00e1llapotra. Ezzel az \u00e1llapottal jelzed, hogy m\u00e9g dolgozol. Kommitolj \u00e9s pusholj. Ilyenkor nem fog futni ki\u00e9rt\u00e9kel\u00e9s. Ha v\u00e9gezt\u00e9l, akkor vissza kell \u00e1ll\u00edtanod a pull request-et: menj a PR alj\u00e1ra \u00e9s kattints a \"Ready for review\" gombra. Ennek hat\u00e1s\u00e1ra vissza\u00e1ll a PR \u00e9s le fog futni az automata \u00e9rt\u00e9kel\u00e9s. Maximum 5 A maximum 5 alkalomba nem sz\u00e1moljuk bele az esetlegesen megszakadt, vagy tranziens hiba miatt sikertelen futtat\u00e1sokat. Ha viszont figyelmetlens\u00e9gb\u0151l, vagy sz\u00e1nd\u00e9kosan t\u00fall\u00e9ped az \u00f6t\u00f6t, akkor pontlevon\u00e1ssal szankcion\u00e1lunk. Arra k\u00e9r\u00fcnk, hogy bead\u00e1s el\u0151tt teszteld a megold\u00e1sod , ne a GitHub platformot \"dolgoztasd\" magad helyett! V\u00c9GEZET\u00dcL , ha k\u00e9sz vagy, a pull request -et rendeld a gyakorlatvezet\u0151dh\u00f6z . Ez a l\u00e9p\u00e9s felt\u00e9tlen\u00fcl fontos, ez jelzi a bead\u00e1st. Pull request n\u00e9lk\u00fcl Ha nincs pull request-ed, vagy nincs a gyakorlatvezet\u0151h\u00f6z rendelve, akkor \u00fagy tekintj\u00fck, hogy m\u00e9g nem vagy k\u00e9szen, \u00e9s nem adtad be a megold\u00e1st. V\u00e9gezt\u00e9l Miut\u00e1n a gyakorlatvezet\u0151h\u00f6z rendelted a pull request-et, m\u00e1r ne m\u00f3dos\u00edts semmin. A gyakorlatvezet\u0151 \u00e9rt\u00e9kelni fogja a munk\u00e1dat, \u00e9s a pull request lez\u00e1r\u00e1s\u00e1val kommentben jelzi a v\u00e9geredm\u00e9nyt. Kapott eredm\u00e9nnyel kapcsolatban k\u00e9rd\u00e9s vagy reklam\u00e1ci\u00f3 \u00b6 Ha a feladatok \u00e9rt\u00e9kel\u00e9s\u00e9vel vagy az eredm\u00e9nnyel kapcsolatban k\u00e9rd\u00e9st tenn\u00e9l fel, vagy reklam\u00e1ln\u00e1l, haszn\u00e1ld a Pull Request kommentel\u00e9si lehet\u0151s\u00e9g\u00e9t erre. Annak \u00e9rdek\u00e9ben, hogy a gyakorlatvezet\u0151 biztosan \u00e9rtes\u00fclj\u00f6n a k\u00e9rd\u00e9sr\u0151l haszn\u00e1ld a @n\u00e9v mention funkci\u00f3t a gyakorlatvezet\u0151d megnevez\u00e9s\u00e9hez. Err\u0151l automatikusan kapni fog egy email \u00e9rtes\u00edt\u00e9st. Reklam\u00e1ci\u00f3 csak indokl\u00e1ssal Ha nem \u00e9rtesz egyet az \u00e9rt\u00e9kel\u00e9ssel, a bizony\u00edt\u00e1s t\u00e9ged terhel, azaz al\u00e1 kell t\u00e1masztanod a reklam\u00e1ci\u00f3d (pl. annak le\u00edr\u00e1s\u00e1val, hogyan tesztelted a megold\u00e1sod, \u00e9s mi bizony\u00edtja a helyess\u00e9g\u00e9t).","title":"Feladatok bead\u00e1sa (GitHub)"},{"location":"hazi/GitHub/#feladatok-beadasa-github","text":"A feladatok bead\u00e1s\u00e1hoz a GitHub platformot haszn\u00e1ljuk. Minden h\u00e1zi bead\u00e1sa egy-egy GitHub repository-ban t\u00f6rt\u00e9nik, melyet a feladatle\u00edr\u00e1sban tal\u00e1lhat\u00f3 linken kereszt\u00fcl kapsz meg. A h\u00e1zi feladatainak megold\u00e1s\u00e1t ezen repository-ban kell elk\u00e9sz\u00edtened, \u00e9s ide kell felt\u00f6ltened. A k\u00e9sz megold\u00e1s bead\u00e1sa a repository-ba val\u00f3 felt\u00f6lt\u00e9s ut\u00e1n egy un. pull request form\u00e1j\u00e1ban t\u00f6rt\u00e9nik, amelyet a gyakorlatvezet\u0151dh\u00f6z rendelsz. FONTOS Az itt le\u00edrt formai el\u0151\u00edr\u00e1sok betart\u00e1sa elv\u00e1r\u00e1s. A nem ilyen form\u00e1ban beadott megold\u00e1sokat nem \u00e9rt\u00e9kelj\u00fck.","title":"Feladatok bead\u00e1sa (GitHub)"},{"location":"hazi/GitHub/#roviditett-verzio","text":"Al\u00e1bb r\u00e9szletesen bemutatjuk a bead\u00e1s menet\u00e9t. Itt egy r\u00f6vid \u00f6sszefoglal\u00f3 az \u00e1ttekint\u00e9shez, illetve a helyes bead\u00e1s ellen\u0151rz\u00e9s\u00e9hez. A munk\u00e1dat a h\u00e1zi le\u00edr\u00e1sban tal\u00e1lhat\u00f3 linken kereszt\u00fcl l\u00e9trehozott GitHub repository-ban kell elk\u00e9sz\u00edtsd. A megold\u00e1shoz k\u00e9sz\u00edts egy k\u00fcl\u00f6n \u00e1gat, ne a master -en dolgozz. Erre az \u00e1gra ak\u00e1rh\u00e1ny kommitot tehetsz. Mindenk\u00e9ppen pushold a megold\u00e1st. A bead\u00e1st egy pull request jelzi, amely pull request-et a gyakorlatvezet\u0151dh\u00f6z kell rendelned. Ha az eredm\u00e9nnyel vagy \u00e9rt\u00e9kel\u00e9ssel kapcsolatban k\u00e9rd\u00e9sed van, pull request kommentben k\u00e9rdezhetsz. A gyakorlatvezet\u0151 \u00e9rtes\u00edt\u00e9s\u00e9hez haszn\u00e1ld a @n\u00e9v c\u00edmz\u00e9st a komment sz\u00f6veg\u00e9ben.","title":"R\u00f6vid\u00edtett verzi\u00f3"},{"location":"hazi/GitHub/#a-munka-elkezdese-git-checkout","text":"Regisztr\u00e1lj egy GitHub accountot, ha m\u00e9g nincs. A feladat bead\u00e1s\u00e1hoz tartoz\u00f3 linket nyisd meg. Ez minden feladathoz m\u00e1s lesz, a feladat le\u00edr\u00e1s\u00e1ban tal\u00e1lod. Ha k\u00e9ri, adj enged\u00e9lyt a GitHub Classroom alkalmaz\u00e1snak, hogy haszn\u00e1lja az account adataidat. L\u00e1tni fogsz egy oldalt, ahol elfogadhatod a feladatot (\"Accept the ... assignment\"). Kattints a gombra. V\u00e1rd meg, am\u00edg elk\u00e9sz\u00fcl a repository. A repository linkj\u00e9t itt kapod meg. Megjegyz\u00e9s A repository priv\u00e1t lesz, azaz az senki nem l\u00e1tja, csak te, \u00e9s az oktat\u00f3k. Nyisd meg a repository-t a webes fel\u00fcleten a linkre kattintva. Ezt az URL-t \u00edrd fel, vagy mentsd el. Kl\u00f3nozd le a repository-t. Ehhez sz\u00fcks\u00e9ges lesz a repository c\u00edm\u00e9re, amit a repository webes fel\u00fclet\u00e9n a Clone or download alatt tal\u00e1lsz. A git repository kezel\u00e9s\u00e9hez tetsz\u0151leges klienst haszn\u00e1lhatsz. Ha nincs kedvenced m\u00e9g, akkor legegyszer\u0171bb a GitHub Desktop . Ebben az alkalmaz\u00e1sban k\u00f6zvetlen\u00fcl tudod list\u00e1zni a repository-kat GitHub-r\u00f3l, vagy haszn\u00e1lhatod az URL-t is a kl\u00f3noz\u00e1shoz. Ha konzolt haszn\u00e1ln\u00e1l, az al\u00e1bbi parancs kl\u00f3nozza a repository-t (ha a git parancs el\u00e9rhet\u0151): git clone <repository link> Ha siker\u00fclt a kl\u00f3noz\u00e1s, M\u00c9G NE KEZDJ EL DOLGOZNI! A megold\u00e1st ne a repository master \u00e1g\u00e1n k\u00e9sz\u00edtsd el. Hozz l\u00e9tre egy \u00faj \u00e1gat (branch) megoldas n\u00e9ven. GitHub Desktop-ban a Branch men\u00fcben teheted ezt meg. Ha konzolt haszn\u00e1lsz, az \u00faj \u00e1g elk\u00e9sz\u00edthet\u0151 ezzel a paranccsal: git checkout -b megoldas Ezen a megold\u00e1s \u00e1gon dolgozva k\u00e9sz\u00edtsd el a beadand\u00f3kat. Ak\u00e1rh\u00e1nyszor kommitolhatsz \u00e9s pusholhatsz. Kommit n\u00e9v ellen\u0151rz\u00e9se Miel\u0151tt a git repository-val dolgozol, ellen\u0151r\u00edzd, hogy a megfelel\u0151 n\u00e9vvel \u00e9s email c\u00edmmel kommitolsz-e. Ezt a k\u00f6vetkez\u0151 command line paranccsal tudod megtenni. git config user.name git config user.email Ha ez nem megfelel\u0151 lenne, akkor add ki az al\u00e1bbi parancsokat a git repository mapp\u00e1j\u00e1ban. Ezzel az adott repository-ra fogod be\u00e1ll\u00edtani a k\u00edv\u00e1nt nevet \u00e9s email c\u00edmet. (\u00c9rdemes olyan email c\u00edmet, megadni ami a github useretekhez van rendelve) git config user.name \"John Doe\" git config user.email \"john@doe.org\" Ha nem akarod minden repository-re k\u00fcl\u00f6n \u00e1ll\u00edtani a fentieket, akkor \u00e9rdemes lehet a glob\u00e1lisan vizsg\u00e1lni \u00e9s fel\u00fcl\u00edrni a --global kapcsol\u00f3val. GitHub Desktop-ban \u00edgy tudsz kommitolni. Mindig ellen\u0151rizd, hogy j\u00f3 \u00e1gon vagy-e. Els\u0151 alkalommal a megoldas \u00e1g csak helyben l\u00e9tezik, ez\u00e9rt publik\u00e1lni kell: Publish this branch . A tov\u00e1bbi kommitokn\u00e1l is mindig ellen\u0151rizd a megfelel\u0151 \u00e1gat. Ha egy kommit m\u00e9g nincs fel\u00f6ltve, azt a Push origin gombbal teheted meg. A kis sz\u00e1m a gombon jelzi, hogy h\u00e1ny, m\u00e9g nem pusholt kommit van. Ha konzolt haszn\u00e1lsz, akkor az al\u00e1bbi parancsokat haszn\u00e1ld (felt\u00e9ve, hogy a j\u00f3 \u00e1gon vagy): # Ellen\u0151rizd az \u00e1gat, \u00e9s hogy milyen f\u00e1jlok m\u00f3dosultak git status # Minden v\u00e1ltoztat\u00e1st el\u0151k\u00e9sz\u00edt kommitol\u00e1sra git add . # Kommit git commit -m \"f1\" # Push els\u0151 alkalommal az \u00faj \u00e1g publik\u00e1l\u00e1s\u00e1hoz git push --set-upstream origin megoldas # Push a tov\u00e1bbiakban, amikor az \u00e1g m\u00e1r nem \u00faj git push","title":"A munka elkezd\u00e9se: git checkout"},{"location":"hazi/GitHub/#a-megoldas-beadasa","text":"Ha v\u00e9gezt\u00e9l a megold\u00e1ssal, ellen\u0151rizd a GitHub webes fel\u00fclet\u00e9n, hogy mindent felt\u00f6lt\u00f6tt\u00e9l-e. Ehhez a webes fel\u00fcleten v\u00e1ltanod kell az \u00e1gak k\u00f6z\u00f6tt. Felt\u00f6lt\u00e9s a webes fel\u00fcleten Azt javasoljuk, hogy ne haszn\u00e1ld a GitHub f\u00e1jl felt\u00f6lt\u00e9s funkci\u00f3j\u00e1t. Ha valami hi\u00e1nyzik, a helyi git repository-ban p\u00f3told, \u00e9s kommitold majd pushold. Ha t\u00e9nyleg k\u00e9sz vagy, akkor nyiss egy pull request -et. Minek a pull request? Ez a pull request fogja \u00f6ssze a megold\u00e1sodat, \u00e9s annak \"v\u00e9geredm\u00e9ny\u00e9t\" mutatja. \u00cdgy a gyakorlatvezet\u0151nek nem az egyes kommitjaidat vagy f\u00e1jljaidat kell n\u00e9znie, hanem csak a relev\u00e1ns, v\u00e1ltozott r\u00e9szeket l\u00e1tja egyben. A pull request jelenti a feladatod bead\u00e1s\u00e1t is, \u00edgy ez a l\u00e9p\u00e9s nem hagyhat\u00f3 ki . A pull request nyit\u00e1s\u00e1hoz a GitHub webes fel\u00fclet\u00e9re kell menj. Itt, ha nem r\u00e9g pusholt\u00e1l, a GitHub fel is aj\u00e1nlja a pull request l\u00e9trehoz\u00e1s\u00e1t. A pull request -et a fenti men\u00fcben is l\u00e9trehozhatod. Fontos, hogy a megfelel\u0151 brancheket v\u00e1laszd ki: master -be megy a megoldas \u00e1g. Ha minden rendben siker\u00fclt, a men\u00fcben fent l\u00e1tod a kis \"1\" sz\u00e1mot a Pull request elem mellett, jelezve, hogy van egy nyitott pull request. DE M\u00c9G NEM V\u00c9GEZT\u00c9L! A pull request hat\u00e1s\u00e1ra le fog futni egy \u00e9rt\u00e9kel\u00e9s. Ennek eredm\u00e9ny\u00e9t a pull request alatt kommentben fogod l\u00e1tni. Ez az \u00e9rt\u00e9kel\u00e9s minden h\u00e1zi eset\u00e9ben m\u00e1s lesz. A programodat minden esetben lefuttatjuk, \u00e9s el\u0151zetes pontsz\u00e1mot is kapsz. Ha a ki\u00e9rt\u00e9kel\u00e9s eredm\u00e9ny\u00e9vel kapcsolatban t\u00f6bb inform\u00e1ci\u00f3ra van sz\u00fcks\u00e9ged, mint amit itt l\u00e1tsz, a GitHub Actions webes fel\u00fclete seg\u00edts\u00e9g\u00fcl szolg\u00e1lhat. Err\u0151l itt tal\u00e1lsz egy r\u00f6vid ismertet\u0151t. Ha nem vagy megel\u00e9gedve a munk\u00e1ddal, akkor m\u00e9g jav\u00edthatsz rajta. Ehhez kommitolj \u00e9s pusholj \u00fajra. Ha tov\u00e1bbra is a megfelel\u0151 \u00e1gon dolgozol, akkor a pull request \u00fajb\u00f3l le fogja futtatni a ki\u00e9rt\u00e9kel\u00e9st. Arra k\u00e9r\u00fcnk, hogy MAXIMUM 5 alkalommal futtasd le a ki\u00e9rt\u00e9kel\u00e9st! Megold\u00e1s jav\u00edt\u00e1sa ki\u00e9rt\u00e9kel\u00e9s n\u00e9lk\u00fcl Ha \u00fagy l\u00e1tod, hogy a megold\u00e1sodat m\u00e9g jav\u00edtani akarod, \u00e9s nem szeretn\u00e9d, hogy mindig lefusson az \u00e9rt\u00e9kel\u00e9s, akkor \u00e1ll\u00edtsd \u00e1t a pull request-et a webes fel\u00fcleten draft \u00e1llapotra. Ezzel az \u00e1llapottal jelzed, hogy m\u00e9g dolgozol. Kommitolj \u00e9s pusholj. Ilyenkor nem fog futni ki\u00e9rt\u00e9kel\u00e9s. Ha v\u00e9gezt\u00e9l, akkor vissza kell \u00e1ll\u00edtanod a pull request-et: menj a PR alj\u00e1ra \u00e9s kattints a \"Ready for review\" gombra. Ennek hat\u00e1s\u00e1ra vissza\u00e1ll a PR \u00e9s le fog futni az automata \u00e9rt\u00e9kel\u00e9s. Maximum 5 A maximum 5 alkalomba nem sz\u00e1moljuk bele az esetlegesen megszakadt, vagy tranziens hiba miatt sikertelen futtat\u00e1sokat. Ha viszont figyelmetlens\u00e9gb\u0151l, vagy sz\u00e1nd\u00e9kosan t\u00fall\u00e9ped az \u00f6t\u00f6t, akkor pontlevon\u00e1ssal szankcion\u00e1lunk. Arra k\u00e9r\u00fcnk, hogy bead\u00e1s el\u0151tt teszteld a megold\u00e1sod , ne a GitHub platformot \"dolgoztasd\" magad helyett! V\u00c9GEZET\u00dcL , ha k\u00e9sz vagy, a pull request -et rendeld a gyakorlatvezet\u0151dh\u00f6z . Ez a l\u00e9p\u00e9s felt\u00e9tlen\u00fcl fontos, ez jelzi a bead\u00e1st. Pull request n\u00e9lk\u00fcl Ha nincs pull request-ed, vagy nincs a gyakorlatvezet\u0151h\u00f6z rendelve, akkor \u00fagy tekintj\u00fck, hogy m\u00e9g nem vagy k\u00e9szen, \u00e9s nem adtad be a megold\u00e1st. V\u00e9gezt\u00e9l Miut\u00e1n a gyakorlatvezet\u0151h\u00f6z rendelted a pull request-et, m\u00e1r ne m\u00f3dos\u00edts semmin. A gyakorlatvezet\u0151 \u00e9rt\u00e9kelni fogja a munk\u00e1dat, \u00e9s a pull request lez\u00e1r\u00e1s\u00e1val kommentben jelzi a v\u00e9geredm\u00e9nyt.","title":"A megold\u00e1s bead\u00e1sa"},{"location":"hazi/GitHub/#kapott-eredmennyel-kapcsolatban-kerdes-vagy-reklamacio","text":"Ha a feladatok \u00e9rt\u00e9kel\u00e9s\u00e9vel vagy az eredm\u00e9nnyel kapcsolatban k\u00e9rd\u00e9st tenn\u00e9l fel, vagy reklam\u00e1ln\u00e1l, haszn\u00e1ld a Pull Request kommentel\u00e9si lehet\u0151s\u00e9g\u00e9t erre. Annak \u00e9rdek\u00e9ben, hogy a gyakorlatvezet\u0151 biztosan \u00e9rtes\u00fclj\u00f6n a k\u00e9rd\u00e9sr\u0151l haszn\u00e1ld a @n\u00e9v mention funkci\u00f3t a gyakorlatvezet\u0151d megnevez\u00e9s\u00e9hez. Err\u0151l automatikusan kapni fog egy email \u00e9rtes\u00edt\u00e9st. Reklam\u00e1ci\u00f3 csak indokl\u00e1ssal Ha nem \u00e9rtesz egyet az \u00e9rt\u00e9kel\u00e9ssel, a bizony\u00edt\u00e1s t\u00e9ged terhel, azaz al\u00e1 kell t\u00e1masztanod a reklam\u00e1ci\u00f3d (pl. annak le\u00edr\u00e1s\u00e1val, hogyan tesztelted a megold\u00e1sod, \u00e9s mi bizony\u00edtja a helyess\u00e9g\u00e9t).","title":"Kapott eredm\u00e9nnyel kapcsolatban k\u00e9rd\u00e9s vagy reklam\u00e1ci\u00f3"},{"location":"hazi/VisualStudio/","text":"Visual Studio telep\u00edt\u00e9se \u00b6 Egyes feladatokhoz a Microsoft Visual Studio 2019 16.6 vagy \u00fajabb verzi\u00f3ja sz\u00fcks\u00e9ges. Az ingyenes, Community v\u00e1ltozata is elegend\u0151 a feladatok megold\u00e1s\u00e1hoz. VS Code A feladatok Visual Studio n\u00e9lk\u00fcl, Visual Studio Code -dal is megoldhat\u00f3ak. A kiadott k\u00f3d v\u00e1z azonban Visual Studio-hoz k\u00e9sz\u00fclt, annak konfigur\u00e1ci\u00f3it tartalmazza. Ha VS Code-dal dolgozol, magadnak kell konfigur\u00e1lni a k\u00f6rnyezetet. A Visual Studio telep\u00edt\u00e9sekor ki kell pip\u00e1lni az al\u00e1bbi workload-okat : ASP.NET and web development .NET Core cross-platform development Meglev\u0151 telep\u00edt\u00e9s a Visual Studio Installer -ben a Modify gombbal m\u00f3dos\u00edthat\u00f3, ill. ellen\u0151rizhet\u0151.","title":"Visual Studio telep\u00edt\u00e9se"},{"location":"hazi/VisualStudio/#visual-studio-telepitese","text":"Egyes feladatokhoz a Microsoft Visual Studio 2019 16.6 vagy \u00fajabb verzi\u00f3ja sz\u00fcks\u00e9ges. Az ingyenes, Community v\u00e1ltozata is elegend\u0151 a feladatok megold\u00e1s\u00e1hoz. VS Code A feladatok Visual Studio n\u00e9lk\u00fcl, Visual Studio Code -dal is megoldhat\u00f3ak. A kiadott k\u00f3d v\u00e1z azonban Visual Studio-hoz k\u00e9sz\u00fclt, annak konfigur\u00e1ci\u00f3it tartalmazza. Ha VS Code-dal dolgozol, magadnak kell konfigur\u00e1lni a k\u00f6rnyezetet. A Visual Studio telep\u00edt\u00e9sekor ki kell pip\u00e1lni az al\u00e1bbi workload-okat : ASP.NET and web development .NET Core cross-platform development Meglev\u0151 telep\u00edt\u00e9s a Visual Studio Installer -ben a Modify gombbal m\u00f3dos\u00edthat\u00f3, ill. ellen\u0151rizhet\u0151.","title":"Visual Studio telep\u00edt\u00e9se"},{"location":"hazi/adonet/","text":"Feladat: ADO.NET adatel\u00e9r\u00e9s \u00b6 A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/92X9gQ8k linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod. Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k \u00b6 Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. Microsoft SQL Server Express v\u00e1ltozat ingyenesen haszn\u00e1lhat\u00f3, avagy Visual Studio mellett feltelep\u00fcl\u0151 localdb v\u00e1ltozat is megfelel\u0151 Van Linux v\u00e1ltozata is. MacOS-en Docker-rel futtathat\u00f3. SQL Server Management Studio , vagy kipr\u00f3b\u00e1lhat\u00f3 a platformf\u00fcggetlen Azure Data Studio is Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Microsoft Visual Studio 2019 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET Core SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3. .NET Core 3.1 SDK Visual Studio eset\u00e9n telep\u00fcl, de ha m\u00e9gse, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges. GitHub account \u00e9s egy git kliens Feladat 0: Neptun k\u00f3d \u00b6 Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat! Feladat 1: Term\u00e9k repository (2 pluszpont) \u00b6 K\u00e9sz\u00edts a term\u00e9kek ( Product ) kezel\u00e9s\u00e9hez egy repository oszt\u00e1lyt ADO.NET Connection technol\u00f3gi\u00e1t haszn\u00e1lva. Nyisd meg a kiindul\u00f3 k\u00f3dban az sln f\u00e1jlt Visual Studio-val. Keresd meg a Repository.ProductRepository \u00e9s Model.Product oszt\u00e1lyokat. Implement\u00e1ld a ProductRepository oszt\u00e1lyt al\u00e1bbi funkci\u00f3it: A Search(string name) f\u00fcggv\u00e9ny keresse meg az adatb\u00e1zisban a param\u00e9terben kapott term\u00e9kn\u00e9vre illeszked\u0151 tal\u00e1latokat, \u00e9s adja \u0151ket vissza C# oszt\u00e1ly p\u00e9ld\u00e1nyak\u00e9nt. Ha a kapott sz\u0171r\u00e9si param\u00e9ter null , akkor minden term\u00e9ket adjon vissza, ellenkez\u0151 esetben case-insensitive m\u00f3don a n\u00e9vben b\u00e1rhol keressen! A FindById(int id) adja vissza az ID alapj\u00e1n megtal\u00e1lt term\u00e9ket, vagy null \u00e9rt\u00e9ket, ha nem tal\u00e1lhat\u00f3 ilyen. Az Update(Product p) egy l\u00e9tez\u0151 term\u00e9k adatait friss\u00edtse az adatb\u00e1zisban a kapott param\u00e9ter alapj\u00e1n. Csak a Name , Price \u00e9s Stock v\u00e1ltozhat, a t\u00f6bbi tulajdons\u00e1got itt nem kell figyelembe venni. \u00dcgyelj az al\u00e1bbiakra: Csak a ProductRepository oszt\u00e1ly k\u00f3dj\u00e1t m\u00f3dos\u00edtsd! A repository k\u00f3dj\u00e1ban az ADO.NET kapcsolat megnyit\u00e1s\u00e1hoz a connectionString v\u00e1ltoz\u00f3t haszn\u00e1ld (\u00e9s ne a TestConnectionStringHelper -t). A term\u00e9k \u00e1fakulcs\u00e1t is ki kell keresni, teh\u00e1t nem a kapcsol\u00f3d\u00f3 rekord id-j\u00e1t kell a Model.Product oszt\u00e1lynak \u00e1tadni, hanem az \u00e1fakulcs sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t! A term\u00e9k kateg\u00f3ri\u00e1j\u00e1nak nev\u00e9t hasonl\u00f3an ki kell keresni. Csak ADO.NET technol\u00f3gi\u00e1t haszn\u00e1lhatsz! V\u00e9dekezz SQL injectionnel szemben! A Model.Product oszt\u00e1ly k\u00f3dj\u00e1t ezen feladathoz ne m\u00f3dos\u00edtsd! A ProductRepository oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9nyek t\u00f6rzs\u00e9t \u00edrd meg. A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. Ezeket a teszteket Visual Studio-ban egyszer\u0171en tudod futtatni , de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy dotnet cli ), akkor is tudsz teszteket futtatni . Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a TestConnectionStringHelper seg\u00e9doszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet. Tesztek A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz. A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod. BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel. Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Visual Studio-b\u00f3l (vagy a fejleszt\u00e9shez haszn\u00e1lt eszk\u00f6zb\u00f3l, ak\u00e1r dotnet cli is lehet), amelyben a vonatkoz\u00f3 teszteket lefuttattad. L\u00e1tsz\u00f3djon a repository k\u00f3dja (a relev\u00e1ns r\u00e9sze, amennyi kif\u00e9r) \u00e9s a tesztek fut\u00e1s\u00e1nak eredm\u00e9nye ! A k\u00e9pet f1.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt! Ha dotnet test -et haszn\u00e1lsz a teszt futtat\u00e1s\u00e1hoz, a k\u00e9perny\u0151k\u00e9pen l\u00e1tsz\u00f3djon az \u00f6sszes teszt neve. Ehhez haszn\u00e1ld a -v n kapcsol\u00f3d a r\u00e9szletesebb napl\u00f3z\u00e1shoz. A k\u00e9perny\u0151k\u00e9pen lev\u0151 forr\u00e1sk\u00f3d tekintet\u00e9ben nem sz\u00fcks\u00e9ges, hogy a v\u00e9gs\u0151 megold\u00e1sban szerepl\u0151 k\u00f3d bet\u0171r\u0151l bet\u0171re megegyezen a k\u00e9pen \u00e9s a felt\u00f6lt\u00f6tt v\u00e1ltozatban. Teh\u00e1t a tesztek sikeres lefut\u00e1sa ut\u00e1n elk\u00e9sz\u00edtett k\u00e9perny\u0151k\u00e9pet nem sz\u00fcks\u00e9ges friss\u00edteni, ha a forr\u00e1sk\u00f3dban kisebb v\u00e1ltoztat\u00e1st eszk\u00f6z\u00f6lsz. Feladat 2: Optimista konkurenciakezel\u00e9s (2 iMsc pont) \u00b6 Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g. A term\u00e9kek adatb\u00e1zisban t\u00f6rt\u00e9n\u0151 friss\u00edt\u00e9se eset\u00e9n vegy\u00fck \u00e9szre, \u00e9s ne engedj\u00fck a m\u00f3dos\u00edt\u00e1st, ha a friss\u00edt\u00e9ssel fel\u00fcl\u00edrn\u00e1nk egy nem l\u00e1tott m\u00f3dos\u00edt\u00e1st. A ProductRepository.UpdateWithConcurrencyCheck f\u00fcggv\u00e9nye legyen felel\u0151s a helyes viselked\u00e9s\u00e9rt, \u00e9s ne v\u00e9gezze el a k\u00e9rt m\u00f3dos\u00edt\u00e1st, ha elveszett m\u00f3dos\u00edt\u00e1s jelleg\u0171 konkurenciaprobl\u00e9m\u00e1t \u00e9szlel. A konkr\u00e9t eset, amit el szeretn\u00e9nk ker\u00fclni: A felhaszn\u00e1l\u00f3 lek\u00e9rdez egy term\u00e9ket. B felhaszn\u00e1l\u00f3 lek\u00e9rdezi ugyanazt a term\u00e9ket. A felhaszn\u00e1l\u00f3 m\u00f3dos\u00edtja a term\u00e9k \u00e1r\u00e1t (vagy m\u00e1s tulajdons\u00e1g\u00e1t), visszamenti az adatb\u00e1zisba. B felhaszn\u00e1l\u00f3 is m\u00f3dos\u00edtja a term\u00e9k \u00e1r\u00e1t (vagy m\u00e1s tulajdons\u00e1g\u00e1t), \u00e9s fel\u00fcl\u00edrja ezzel A m\u00f3dos\u00edt\u00e1s\u00e1t figyelmeztet\u00e9s n\u00e9lk\u00fcl. Optimista konkurenciakezel\u00e9s A megold\u00e1shoz az optimista konkurenciakezel\u00e9s koncepci\u00f3j\u00e1t alkalmazd. Ne haszn\u00e1lj tranzakci\u00f3t , mert a lek\u00e9rdez\u00e9s \u00e9s m\u00f3dos\u00edt\u00e1s id\u0151ben eltolva t\u00f6rt\u00e9nik, k\u00f6zben az adatb\u00e1zis kapcsolat megsz\u0171nik. Ne haszn\u00e1lj t\u00f6bb SQL utas\u00edt\u00e1st se, mert a lefut\u00e1suk k\u00f6z\u00f6tt m\u00e1s adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9sek t\u00f6rt\u00e9nhetnek elrontva a v\u00e1rt viselked\u00e9st. A megold\u00e1st a ProductRepository.UpdateWithConcurrencyCheck f\u00fcggv\u00e9nyben \u00edrd meg, valamint adapt\u00e1ld a Model.Product oszt\u00e1lyt is. Az adatb\u00e1zisba nem vehetsz fel \u00faj oszlopot. \u00dcgyelj az al\u00e1bbiakra: Csak a ProductRepository.UpdateWithConcurrencyCheck f\u00fcggv\u00e9ny \u00e9s a Model.Product oszt\u00e1lyok k\u00f3dj\u00e1t m\u00f3dos\u00edtsd! A f\u00fcggv\u00e9ny visszat\u00e9r\u00e9si \u00e9rt\u00e9kben jelezze, hogy sikeres volt-e a m\u00f3dos\u00edt\u00e1s (vagyis, hogy nem volt konkurencia probl\u00e9ma). Magyar\u00e1zd el a viselked\u00e9st az UpdateWithConcurrencyCheck f\u00fcggv\u00e9nyben egy kommentben (2-3 mondatban). Egyetlen SQL parancs haszn\u00e1lat\u00e1val oldd meg a feladatot! Csak ADO.NET technol\u00f3gi\u00e1t haszn\u00e1lhatsz! V\u00e9dekezz SQL injectionnel szemben! A ProductRepository oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t \u00edrd meg. A Model.Product oszt\u00e1lyban konstruktor\u00e1nak defin\u00edci\u00f3j\u00e1t (param\u00e9terek darabsz\u00e1ma, sorrendje, nevei) ne v\u00e1ltoztasd meg, de a k\u00f3dj\u00e1t \u00e1t\u00edrhatod. A meglev\u0151 property-ket ne v\u00e1ltoztasd meg, de \u00fajakat felvehetsz. BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel. Ne felejtsd a magyar\u00e1zatot a C# k\u00f3dban!","title":"Feladat: ADO.NET adatel\u00e9r\u00e9s"},{"location":"hazi/adonet/#feladat-adonet-adateleres","text":"A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/92X9gQ8k linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.","title":"Feladat: ADO.NET adatel\u00e9r\u00e9s"},{"location":"hazi/adonet/#szukseges-eszkozok","text":"Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. Microsoft SQL Server Express v\u00e1ltozat ingyenesen haszn\u00e1lhat\u00f3, avagy Visual Studio mellett feltelep\u00fcl\u0151 localdb v\u00e1ltozat is megfelel\u0151 Van Linux v\u00e1ltozata is. MacOS-en Docker-rel futtathat\u00f3. SQL Server Management Studio , vagy kipr\u00f3b\u00e1lhat\u00f3 a platformf\u00fcggetlen Azure Data Studio is Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Microsoft Visual Studio 2019 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET Core SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3. .NET Core 3.1 SDK Visual Studio eset\u00e9n telep\u00fcl, de ha m\u00e9gse, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges. GitHub account \u00e9s egy git kliens","title":"Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k"},{"location":"hazi/adonet/#feladat-0-neptun-kod","text":"Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!","title":"Feladat 0: Neptun k\u00f3d"},{"location":"hazi/adonet/#feladat-1-termek-repository-2-pluszpont","text":"K\u00e9sz\u00edts a term\u00e9kek ( Product ) kezel\u00e9s\u00e9hez egy repository oszt\u00e1lyt ADO.NET Connection technol\u00f3gi\u00e1t haszn\u00e1lva. Nyisd meg a kiindul\u00f3 k\u00f3dban az sln f\u00e1jlt Visual Studio-val. Keresd meg a Repository.ProductRepository \u00e9s Model.Product oszt\u00e1lyokat. Implement\u00e1ld a ProductRepository oszt\u00e1lyt al\u00e1bbi funkci\u00f3it: A Search(string name) f\u00fcggv\u00e9ny keresse meg az adatb\u00e1zisban a param\u00e9terben kapott term\u00e9kn\u00e9vre illeszked\u0151 tal\u00e1latokat, \u00e9s adja \u0151ket vissza C# oszt\u00e1ly p\u00e9ld\u00e1nyak\u00e9nt. Ha a kapott sz\u0171r\u00e9si param\u00e9ter null , akkor minden term\u00e9ket adjon vissza, ellenkez\u0151 esetben case-insensitive m\u00f3don a n\u00e9vben b\u00e1rhol keressen! A FindById(int id) adja vissza az ID alapj\u00e1n megtal\u00e1lt term\u00e9ket, vagy null \u00e9rt\u00e9ket, ha nem tal\u00e1lhat\u00f3 ilyen. Az Update(Product p) egy l\u00e9tez\u0151 term\u00e9k adatait friss\u00edtse az adatb\u00e1zisban a kapott param\u00e9ter alapj\u00e1n. Csak a Name , Price \u00e9s Stock v\u00e1ltozhat, a t\u00f6bbi tulajdons\u00e1got itt nem kell figyelembe venni. \u00dcgyelj az al\u00e1bbiakra: Csak a ProductRepository oszt\u00e1ly k\u00f3dj\u00e1t m\u00f3dos\u00edtsd! A repository k\u00f3dj\u00e1ban az ADO.NET kapcsolat megnyit\u00e1s\u00e1hoz a connectionString v\u00e1ltoz\u00f3t haszn\u00e1ld (\u00e9s ne a TestConnectionStringHelper -t). A term\u00e9k \u00e1fakulcs\u00e1t is ki kell keresni, teh\u00e1t nem a kapcsol\u00f3d\u00f3 rekord id-j\u00e1t kell a Model.Product oszt\u00e1lynak \u00e1tadni, hanem az \u00e1fakulcs sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t! A term\u00e9k kateg\u00f3ri\u00e1j\u00e1nak nev\u00e9t hasonl\u00f3an ki kell keresni. Csak ADO.NET technol\u00f3gi\u00e1t haszn\u00e1lhatsz! V\u00e9dekezz SQL injectionnel szemben! A Model.Product oszt\u00e1ly k\u00f3dj\u00e1t ezen feladathoz ne m\u00f3dos\u00edtsd! A ProductRepository oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9nyek t\u00f6rzs\u00e9t \u00edrd meg. A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. Ezeket a teszteket Visual Studio-ban egyszer\u0171en tudod futtatni , de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy dotnet cli ), akkor is tudsz teszteket futtatni . Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a TestConnectionStringHelper seg\u00e9doszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet. Tesztek A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz. A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod. BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel. Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Visual Studio-b\u00f3l (vagy a fejleszt\u00e9shez haszn\u00e1lt eszk\u00f6zb\u00f3l, ak\u00e1r dotnet cli is lehet), amelyben a vonatkoz\u00f3 teszteket lefuttattad. L\u00e1tsz\u00f3djon a repository k\u00f3dja (a relev\u00e1ns r\u00e9sze, amennyi kif\u00e9r) \u00e9s a tesztek fut\u00e1s\u00e1nak eredm\u00e9nye ! A k\u00e9pet f1.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt! Ha dotnet test -et haszn\u00e1lsz a teszt futtat\u00e1s\u00e1hoz, a k\u00e9perny\u0151k\u00e9pen l\u00e1tsz\u00f3djon az \u00f6sszes teszt neve. Ehhez haszn\u00e1ld a -v n kapcsol\u00f3d a r\u00e9szletesebb napl\u00f3z\u00e1shoz. A k\u00e9perny\u0151k\u00e9pen lev\u0151 forr\u00e1sk\u00f3d tekintet\u00e9ben nem sz\u00fcks\u00e9ges, hogy a v\u00e9gs\u0151 megold\u00e1sban szerepl\u0151 k\u00f3d bet\u0171r\u0151l bet\u0171re megegyezen a k\u00e9pen \u00e9s a felt\u00f6lt\u00f6tt v\u00e1ltozatban. Teh\u00e1t a tesztek sikeres lefut\u00e1sa ut\u00e1n elk\u00e9sz\u00edtett k\u00e9perny\u0151k\u00e9pet nem sz\u00fcks\u00e9ges friss\u00edteni, ha a forr\u00e1sk\u00f3dban kisebb v\u00e1ltoztat\u00e1st eszk\u00f6z\u00f6lsz.","title":"Feladat 1: Term\u00e9k repository (2 pluszpont)"},{"location":"hazi/adonet/#feladat-2-optimista-konkurenciakezeles-2-imsc-pont","text":"Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g. A term\u00e9kek adatb\u00e1zisban t\u00f6rt\u00e9n\u0151 friss\u00edt\u00e9se eset\u00e9n vegy\u00fck \u00e9szre, \u00e9s ne engedj\u00fck a m\u00f3dos\u00edt\u00e1st, ha a friss\u00edt\u00e9ssel fel\u00fcl\u00edrn\u00e1nk egy nem l\u00e1tott m\u00f3dos\u00edt\u00e1st. A ProductRepository.UpdateWithConcurrencyCheck f\u00fcggv\u00e9nye legyen felel\u0151s a helyes viselked\u00e9s\u00e9rt, \u00e9s ne v\u00e9gezze el a k\u00e9rt m\u00f3dos\u00edt\u00e1st, ha elveszett m\u00f3dos\u00edt\u00e1s jelleg\u0171 konkurenciaprobl\u00e9m\u00e1t \u00e9szlel. A konkr\u00e9t eset, amit el szeretn\u00e9nk ker\u00fclni: A felhaszn\u00e1l\u00f3 lek\u00e9rdez egy term\u00e9ket. B felhaszn\u00e1l\u00f3 lek\u00e9rdezi ugyanazt a term\u00e9ket. A felhaszn\u00e1l\u00f3 m\u00f3dos\u00edtja a term\u00e9k \u00e1r\u00e1t (vagy m\u00e1s tulajdons\u00e1g\u00e1t), visszamenti az adatb\u00e1zisba. B felhaszn\u00e1l\u00f3 is m\u00f3dos\u00edtja a term\u00e9k \u00e1r\u00e1t (vagy m\u00e1s tulajdons\u00e1g\u00e1t), \u00e9s fel\u00fcl\u00edrja ezzel A m\u00f3dos\u00edt\u00e1s\u00e1t figyelmeztet\u00e9s n\u00e9lk\u00fcl. Optimista konkurenciakezel\u00e9s A megold\u00e1shoz az optimista konkurenciakezel\u00e9s koncepci\u00f3j\u00e1t alkalmazd. Ne haszn\u00e1lj tranzakci\u00f3t , mert a lek\u00e9rdez\u00e9s \u00e9s m\u00f3dos\u00edt\u00e1s id\u0151ben eltolva t\u00f6rt\u00e9nik, k\u00f6zben az adatb\u00e1zis kapcsolat megsz\u0171nik. Ne haszn\u00e1lj t\u00f6bb SQL utas\u00edt\u00e1st se, mert a lefut\u00e1suk k\u00f6z\u00f6tt m\u00e1s adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9sek t\u00f6rt\u00e9nhetnek elrontva a v\u00e1rt viselked\u00e9st. A megold\u00e1st a ProductRepository.UpdateWithConcurrencyCheck f\u00fcggv\u00e9nyben \u00edrd meg, valamint adapt\u00e1ld a Model.Product oszt\u00e1lyt is. Az adatb\u00e1zisba nem vehetsz fel \u00faj oszlopot. \u00dcgyelj az al\u00e1bbiakra: Csak a ProductRepository.UpdateWithConcurrencyCheck f\u00fcggv\u00e9ny \u00e9s a Model.Product oszt\u00e1lyok k\u00f3dj\u00e1t m\u00f3dos\u00edtsd! A f\u00fcggv\u00e9ny visszat\u00e9r\u00e9si \u00e9rt\u00e9kben jelezze, hogy sikeres volt-e a m\u00f3dos\u00edt\u00e1s (vagyis, hogy nem volt konkurencia probl\u00e9ma). Magyar\u00e1zd el a viselked\u00e9st az UpdateWithConcurrencyCheck f\u00fcggv\u00e9nyben egy kommentben (2-3 mondatban). Egyetlen SQL parancs haszn\u00e1lat\u00e1val oldd meg a feladatot! Csak ADO.NET technol\u00f3gi\u00e1t haszn\u00e1lhatsz! V\u00e9dekezz SQL injectionnel szemben! A ProductRepository oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t \u00edrd meg. A Model.Product oszt\u00e1lyban konstruktor\u00e1nak defin\u00edci\u00f3j\u00e1t (param\u00e9terek darabsz\u00e1ma, sorrendje, nevei) ne v\u00e1ltoztasd meg, de a k\u00f3dj\u00e1t \u00e1t\u00edrhatod. A meglev\u0151 property-ket ne v\u00e1ltoztasd meg, de \u00fajakat felvehetsz. BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel. Ne felejtsd a magyar\u00e1zatot a C# k\u00f3dban!","title":"Feladat 2: Optimista konkurenciakezel\u00e9s (2 iMsc pont)"},{"location":"hazi/ef/","text":"Feladat: Entity Framework \u00b6 A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/vu7F1SHB linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod. Entity Framework Core A feladatban Entity Framework Core -t haszn\u00e1lunk. A gyakorlaton haszn\u00e1lt Entity Framework-t\u0151l elt\u00e9r\u0151en ez egy platformf\u00fcggetlen technol\u00f3gia. Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k \u00b6 Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. Microsoft SQL Server Express v\u00e1ltozat ingyenesen haszn\u00e1lhat\u00f3, avagy Visual Studio mellett feltelep\u00fcl\u0151 localdb v\u00e1ltozat is megfelel\u0151 Van Linux v\u00e1ltozata is. MacOS-en Docker-rel futtathat\u00f3. SQL Server Management Studio , vagy kipr\u00f3b\u00e1lhat\u00f3 a platformf\u00fcggetlen Azure Data Studio is Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Microsoft Visual Studio 2019 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET Core SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3. .NET Core 3.1 SDK Visual Studio eset\u00e9n telep\u00fcl, de ha m\u00e9gse, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges. GitHub account \u00e9s egy git kliens Feladat 0: Neptun k\u00f3d \u00b6 Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat! Feladat 1: Adatb\u00e1zis lek\u00e9pz\u00e9s Code First modellel \u00e9s lek\u00e9rdez\u00e9sek (2 pluszpont) \u00b6 K\u00e9sz\u00edtsd el az adatb\u00e1zisunk (egy r\u00e9sz\u00e9nek) Entity Framework lek\u00e9pz\u00e9s\u00e9t Code First megold\u00e1ssal. Az Entity Framework Core csomag m\u00e1r r\u00e9sze a kiindul\u00f3 projekt\u00fcnknek, \u00edgy r\u00f6gt\u00f6n k\u00f3dolhatunk is. Az adatel\u00e9r\u00e9s k\u00f6zponti eleme a DbContext. Ez az oszt\u00e1ly m\u00e1r l\u00e9tezik ProductDbContext n\u00e9ven. K\u00e9pezd le a term\u00e9keket. Hozz l\u00e9tre egy \u00faj oszt\u00e1lyt DbProduct n\u00e9ven az al\u00e1bbi k\u00f3ddal. (A Db prefix egy\u00e9rtelm\u0171v\u00e9 teszi, hogy az oszt\u00e1ly az adatb\u00e1zis kontextus\u00e1ban \u00e9rtelmezett. Ez a k\u00e9s\u0151bbi feladatn\u00e1l lesz \u00e9rdekes.) A lek\u00e9pz\u00e9sn\u00e9l t\u00f6bbnyire hagyatkozzunk a konvenci\u00f3kra, azaz a property-k nev\u00e9n\u00e9l haszn\u00e1ljuk az adatb\u00e1zis oszlopok nev\u00e9t, \u00edgy automatikus lesz a lek\u00e9pz\u00e9s. using System.ComponentModel.DataAnnotations.Schema ; namespace ef { [Table(\"Product\")] public class DbProduct { [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int ID { get ; set ; } public string Name { get ; set ; } public double Price { get ; set ; } public int Stock { get ; set ; } } } Menj a ProductDbContext oszt\u00e1lyhoz \u00e9s t\u00f6r\u00f6ld a kommentet a Products property el\u0151l. K\u00e9sz\u00edts egy DbVat oszt\u00e1lyt a VAT t\u00e1bla lek\u00e9pz\u00e9s\u00e9re a DbProduct -hoz hasonl\u00f3an. Ne felejtsd el felvenni a DbSet property-t az ProductDbContext -be Vat n\u00e9ven. K\u00e9pezd le a Product - VAT kapcsolatot. A DbProduct oszt\u00e1lyba vegy\u00e9l fel egy DbVat t\u00edpus\u00fa Vat nev\u0171 get-set property-t, ez lesz a navigation property. Haszn\u00e1ld a ForeignKey attrib\u00fatumot a property felett , ami meghat\u00e1rozza a k\u00fcls\u0151 kulcs adatb\u00e1zis mez\u0151j\u00e9t (\"VatID\"). Vedd fel ennek az egy-t\u00f6bb kapcsolatnak a m\u00e1sik oldal\u00e1t a DbVat oszt\u00e1lyba. Ez a Products nev\u0171 property System.Collections.Generic.List t\u00edpus\u00fa legyen. (L\u00e1sd a p\u00e9ld\u00e1ban is az el\u0151bbi linken.) A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. A tesztek k\u00f3dja ki van kommentezve, mert nem fordul, am\u00edg nem \u00edrod meg a fentieket. Jel\u00f6ld ki a teljes k\u00f3dot, \u00e9s haszn\u00e1ld az Edit / Advanced / Uncomment Selection parancsot. Ezut\u00e1n a teszteket Visual Studio-ban egyszer\u0171en tudod futtatni , de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy dotnet cli ), akkor is tudsz teszteket futtatni . Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a TestConnectionStringHelper seg\u00e9doszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet. Tesztek A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz. A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod. Ha a teszt nem fordul Ha nem fordulna le a teszt k\u00f3d, lehet, hogy egy-egy property n\u00e9vnek m\u00e1st haszn\u00e1lt\u00e1l. A saj\u00e1t k\u00f3dodban jav\u00edtsd a nevet, ne a tesztekben ! OnConfiguring A DbContext k\u00f3dj\u00e1ban nincs sz\u00fcks\u00e9ged connection stringre. A konstruktor int\u00e9zi a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9t. Ne \u00edrj OnConfiguring f\u00fcggv\u00e9ny az oszt\u00e1lyba! BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6lts fel. Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Visual Studio-b\u00f3l (vagy a fejleszt\u00e9shez haszn\u00e1lt eszk\u00f6zb\u00f3l, ak\u00e1r dotnet cli is lehet), amelyben a vonatkoz\u00f3 teszteket lefuttattad. L\u00e1tsz\u00f3djon a DbContext k\u00f3dja \u00e9s a tesztek fut\u00e1s\u00e1nak eredm\u00e9nye ! A k\u00e9pet f1.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt! Ha dotnet test -et haszn\u00e1lsz a teszt futtat\u00e1s\u00e1hoz, a k\u00e9perny\u0151k\u00e9pen l\u00e1tsz\u00f3djon az \u00f6sszes teszt neve. Ehhez haszn\u00e1ld a -v n kapcsol\u00f3d a r\u00e9szletesebb napl\u00f3z\u00e1shoz. A k\u00e9perny\u0151k\u00e9pen lev\u0151 forr\u00e1sk\u00f3d tekintet\u00e9ben nem sz\u00fcks\u00e9ges, hogy a v\u00e9gs\u0151 megold\u00e1sban szerepl\u0151 k\u00f3d bet\u0171r\u0151l bet\u0171re megegyezen a k\u00e9pen \u00e9s a felt\u00f6lt\u00f6tt v\u00e1ltozatban. Teh\u00e1t a tesztek sikeres lefut\u00e1sa ut\u00e1n elk\u00e9sz\u00edtett k\u00e9perny\u0151k\u00e9pet nem sz\u00fcks\u00e9ges friss\u00edteni, ha a forr\u00e1sk\u00f3dban kisebb v\u00e1ltoztat\u00e1st eszk\u00f6z\u00f6lsz. Feladat 2: Repository megval\u00f3s\u00edt\u00e1s Entity Framework-kel (2 iMsc pont) \u00b6 Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g. Az Entity Framework DbContext-je az el\u0151z\u0151ekben meg\u00edrt m\u00f3don nem haszn\u00e1lhat\u00f3 k\u00e9nyelmesen. P\u00e9ld\u00e1ul a kapcsolatok bet\u00f6lt\u00e9s\u00e9t ( Include ) k\u00e9zzel kell kezdem\u00e9nyezni, \u00e9s a lek\u00e9pzett entit\u00e1sok t\u00fals\u00e1gosan k\u00f6t\u0151dnek az adatb\u00e1zis s\u00e9m\u00e1j\u00e1hoz. Egy komplex alkalmaz\u00e1s eset\u00e9ben ez\u00e9rt c\u00e9lszer\u0171 a DbContext-et a repository minta szerint becsomagolni, \u00e9s ily m\u00f3don ny\u00fajtani az adatel\u00e9r\u00e9si r\u00e9teget. Implement\u00e1ld a ProductRepository oszt\u00e1lyt, amely megval\u00f3s\u00edtja a term\u00e9kek list\u00e1z\u00e1s\u00e1t \u00e9s besz\u00far\u00e1s\u00e1t. Ehhez m\u00e1r rendelkez\u00e9sre \u00e1ll egy \u00faj, un. modell oszt\u00e1lyt, ami a term\u00e9ket reprezent\u00e1lja, de k\u00f6zvetlen\u00fcl tartalmazza az \u00e1fa kulcs sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t is. Ez az oszt\u00e1ly az adatb\u00e1zis adataib\u00f3l \u00e9p\u00edtkezik, de egys\u00e9gbe z\u00e1rja az adatokat an\u00e9lk\u00fcl, hogy az adatb\u00e1zishoz kellene fordulni a kapcsol\u00f3d\u00f3 \u00e1fa rekord lek\u00e9rdez\u00e9s\u00e9hez. Ez a Model.Product nev\u0171 oszt\u00e1ly, ami tartalmazza a DbProduct lek\u00e9pzett tulajdons\u00e1gait, de a DbVat -ra mutat\u00f3 navigation property helyett az int t\u00edpus\u00fa \u00e1fakulcs ( VAT.Percentage ) sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t tartalmazza. Implement\u00e1ld a ProductRepository oszt\u00e1ly f\u00fcggv\u00e9nyeit. A List az \u00f6sszes term\u00e9ket adja vissza Model.Product t\u00edpusra lek\u00e9pezve. Az Insert sz\u00farjon be egy \u00faj term\u00e9ket. A kapott \u00c1FA kulcs \u00e9rt\u00e9knek megfelel\u0151en keresse ki az adatb\u00e1zisb\u00f3l a kapcsol\u00f3d\u00f3 VAT rekordot, vagy ha nem l\u00e9tezik ilyen kulcs m\u00e9g, akkor sz\u00farjon be egy \u00faj VAT rekordot is! A ProductRepository oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9nyek t\u00f6rzs\u00e9t \u00edrd meg. A k\u00f3dban a ProductRepository.createDbContext() -et haszn\u00e1ld a DbContext l\u00e9trehoz\u00e1s\u00e1hoz (\u00e9s ne a TestConnectionStringHelper -t). BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6lts fel.","title":"Feladat: Entity Framework"},{"location":"hazi/ef/#feladat-entity-framework","text":"A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/vu7F1SHB linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod. Entity Framework Core A feladatban Entity Framework Core -t haszn\u00e1lunk. A gyakorlaton haszn\u00e1lt Entity Framework-t\u0151l elt\u00e9r\u0151en ez egy platformf\u00fcggetlen technol\u00f3gia.","title":"Feladat: Entity Framework"},{"location":"hazi/ef/#szukseges-eszkozok","text":"Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. Microsoft SQL Server Express v\u00e1ltozat ingyenesen haszn\u00e1lhat\u00f3, avagy Visual Studio mellett feltelep\u00fcl\u0151 localdb v\u00e1ltozat is megfelel\u0151 Van Linux v\u00e1ltozata is. MacOS-en Docker-rel futtathat\u00f3. SQL Server Management Studio , vagy kipr\u00f3b\u00e1lhat\u00f3 a platformf\u00fcggetlen Azure Data Studio is Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql Microsoft Visual Studio 2019 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET Core SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3. .NET Core 3.1 SDK Visual Studio eset\u00e9n telep\u00fcl, de ha m\u00e9gse, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges. GitHub account \u00e9s egy git kliens","title":"Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k"},{"location":"hazi/ef/#feladat-0-neptun-kod","text":"Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!","title":"Feladat 0: Neptun k\u00f3d"},{"location":"hazi/ef/#feladat-1-adatbazis-lekepzes-code-first-modellel-es-lekerdezesek-2-pluszpont","text":"K\u00e9sz\u00edtsd el az adatb\u00e1zisunk (egy r\u00e9sz\u00e9nek) Entity Framework lek\u00e9pz\u00e9s\u00e9t Code First megold\u00e1ssal. Az Entity Framework Core csomag m\u00e1r r\u00e9sze a kiindul\u00f3 projekt\u00fcnknek, \u00edgy r\u00f6gt\u00f6n k\u00f3dolhatunk is. Az adatel\u00e9r\u00e9s k\u00f6zponti eleme a DbContext. Ez az oszt\u00e1ly m\u00e1r l\u00e9tezik ProductDbContext n\u00e9ven. K\u00e9pezd le a term\u00e9keket. Hozz l\u00e9tre egy \u00faj oszt\u00e1lyt DbProduct n\u00e9ven az al\u00e1bbi k\u00f3ddal. (A Db prefix egy\u00e9rtelm\u0171v\u00e9 teszi, hogy az oszt\u00e1ly az adatb\u00e1zis kontextus\u00e1ban \u00e9rtelmezett. Ez a k\u00e9s\u0151bbi feladatn\u00e1l lesz \u00e9rdekes.) A lek\u00e9pz\u00e9sn\u00e9l t\u00f6bbnyire hagyatkozzunk a konvenci\u00f3kra, azaz a property-k nev\u00e9n\u00e9l haszn\u00e1ljuk az adatb\u00e1zis oszlopok nev\u00e9t, \u00edgy automatikus lesz a lek\u00e9pz\u00e9s. using System.ComponentModel.DataAnnotations.Schema ; namespace ef { [Table(\"Product\")] public class DbProduct { [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int ID { get ; set ; } public string Name { get ; set ; } public double Price { get ; set ; } public int Stock { get ; set ; } } } Menj a ProductDbContext oszt\u00e1lyhoz \u00e9s t\u00f6r\u00f6ld a kommentet a Products property el\u0151l. K\u00e9sz\u00edts egy DbVat oszt\u00e1lyt a VAT t\u00e1bla lek\u00e9pz\u00e9s\u00e9re a DbProduct -hoz hasonl\u00f3an. Ne felejtsd el felvenni a DbSet property-t az ProductDbContext -be Vat n\u00e9ven. K\u00e9pezd le a Product - VAT kapcsolatot. A DbProduct oszt\u00e1lyba vegy\u00e9l fel egy DbVat t\u00edpus\u00fa Vat nev\u0171 get-set property-t, ez lesz a navigation property. Haszn\u00e1ld a ForeignKey attrib\u00fatumot a property felett , ami meghat\u00e1rozza a k\u00fcls\u0151 kulcs adatb\u00e1zis mez\u0151j\u00e9t (\"VatID\"). Vedd fel ennek az egy-t\u00f6bb kapcsolatnak a m\u00e1sik oldal\u00e1t a DbVat oszt\u00e1lyba. Ez a Products nev\u0171 property System.Collections.Generic.List t\u00edpus\u00fa legyen. (L\u00e1sd a p\u00e9ld\u00e1ban is az el\u0151bbi linken.) A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. A tesztek k\u00f3dja ki van kommentezve, mert nem fordul, am\u00edg nem \u00edrod meg a fentieket. Jel\u00f6ld ki a teljes k\u00f3dot, \u00e9s haszn\u00e1ld az Edit / Advanced / Uncomment Selection parancsot. Ezut\u00e1n a teszteket Visual Studio-ban egyszer\u0171en tudod futtatni , de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy dotnet cli ), akkor is tudsz teszteket futtatni . Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a TestConnectionStringHelper seg\u00e9doszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet. Tesztek A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz. A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod. Ha a teszt nem fordul Ha nem fordulna le a teszt k\u00f3d, lehet, hogy egy-egy property n\u00e9vnek m\u00e1st haszn\u00e1lt\u00e1l. A saj\u00e1t k\u00f3dodban jav\u00edtsd a nevet, ne a tesztekben ! OnConfiguring A DbContext k\u00f3dj\u00e1ban nincs sz\u00fcks\u00e9ged connection stringre. A konstruktor int\u00e9zi a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9t. Ne \u00edrj OnConfiguring f\u00fcggv\u00e9ny az oszt\u00e1lyba! BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6lts fel. Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Visual Studio-b\u00f3l (vagy a fejleszt\u00e9shez haszn\u00e1lt eszk\u00f6zb\u00f3l, ak\u00e1r dotnet cli is lehet), amelyben a vonatkoz\u00f3 teszteket lefuttattad. L\u00e1tsz\u00f3djon a DbContext k\u00f3dja \u00e9s a tesztek fut\u00e1s\u00e1nak eredm\u00e9nye ! A k\u00e9pet f1.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt! Ha dotnet test -et haszn\u00e1lsz a teszt futtat\u00e1s\u00e1hoz, a k\u00e9perny\u0151k\u00e9pen l\u00e1tsz\u00f3djon az \u00f6sszes teszt neve. Ehhez haszn\u00e1ld a -v n kapcsol\u00f3d a r\u00e9szletesebb napl\u00f3z\u00e1shoz. A k\u00e9perny\u0151k\u00e9pen lev\u0151 forr\u00e1sk\u00f3d tekintet\u00e9ben nem sz\u00fcks\u00e9ges, hogy a v\u00e9gs\u0151 megold\u00e1sban szerepl\u0151 k\u00f3d bet\u0171r\u0151l bet\u0171re megegyezen a k\u00e9pen \u00e9s a felt\u00f6lt\u00f6tt v\u00e1ltozatban. Teh\u00e1t a tesztek sikeres lefut\u00e1sa ut\u00e1n elk\u00e9sz\u00edtett k\u00e9perny\u0151k\u00e9pet nem sz\u00fcks\u00e9ges friss\u00edteni, ha a forr\u00e1sk\u00f3dban kisebb v\u00e1ltoztat\u00e1st eszk\u00f6z\u00f6lsz.","title":"Feladat 1: Adatb\u00e1zis lek\u00e9pz\u00e9s Code First modellel \u00e9s lek\u00e9rdez\u00e9sek (2 pluszpont)"},{"location":"hazi/ef/#feladat-2-repository-megvalositas-entity-framework-kel-2-imsc-pont","text":"Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g. Az Entity Framework DbContext-je az el\u0151z\u0151ekben meg\u00edrt m\u00f3don nem haszn\u00e1lhat\u00f3 k\u00e9nyelmesen. P\u00e9ld\u00e1ul a kapcsolatok bet\u00f6lt\u00e9s\u00e9t ( Include ) k\u00e9zzel kell kezdem\u00e9nyezni, \u00e9s a lek\u00e9pzett entit\u00e1sok t\u00fals\u00e1gosan k\u00f6t\u0151dnek az adatb\u00e1zis s\u00e9m\u00e1j\u00e1hoz. Egy komplex alkalmaz\u00e1s eset\u00e9ben ez\u00e9rt c\u00e9lszer\u0171 a DbContext-et a repository minta szerint becsomagolni, \u00e9s ily m\u00f3don ny\u00fajtani az adatel\u00e9r\u00e9si r\u00e9teget. Implement\u00e1ld a ProductRepository oszt\u00e1lyt, amely megval\u00f3s\u00edtja a term\u00e9kek list\u00e1z\u00e1s\u00e1t \u00e9s besz\u00far\u00e1s\u00e1t. Ehhez m\u00e1r rendelkez\u00e9sre \u00e1ll egy \u00faj, un. modell oszt\u00e1lyt, ami a term\u00e9ket reprezent\u00e1lja, de k\u00f6zvetlen\u00fcl tartalmazza az \u00e1fa kulcs sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t is. Ez az oszt\u00e1ly az adatb\u00e1zis adataib\u00f3l \u00e9p\u00edtkezik, de egys\u00e9gbe z\u00e1rja az adatokat an\u00e9lk\u00fcl, hogy az adatb\u00e1zishoz kellene fordulni a kapcsol\u00f3d\u00f3 \u00e1fa rekord lek\u00e9rdez\u00e9s\u00e9hez. Ez a Model.Product nev\u0171 oszt\u00e1ly, ami tartalmazza a DbProduct lek\u00e9pzett tulajdons\u00e1gait, de a DbVat -ra mutat\u00f3 navigation property helyett az int t\u00edpus\u00fa \u00e1fakulcs ( VAT.Percentage ) sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t tartalmazza. Implement\u00e1ld a ProductRepository oszt\u00e1ly f\u00fcggv\u00e9nyeit. A List az \u00f6sszes term\u00e9ket adja vissza Model.Product t\u00edpusra lek\u00e9pezve. Az Insert sz\u00farjon be egy \u00faj term\u00e9ket. A kapott \u00c1FA kulcs \u00e9rt\u00e9knek megfelel\u0151en keresse ki az adatb\u00e1zisb\u00f3l a kapcsol\u00f3d\u00f3 VAT rekordot, vagy ha nem l\u00e9tezik ilyen kulcs m\u00e9g, akkor sz\u00farjon be egy \u00faj VAT rekordot is! A ProductRepository oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9nyek t\u00f6rzs\u00e9t \u00edrd meg. A k\u00f3dban a ProductRepository.createDbContext() -et haszn\u00e1ld a DbContext l\u00e9trehoz\u00e1s\u00e1hoz (\u00e9s ne a TestConnectionStringHelper -t). BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6lts fel.","title":"Feladat 2: Repository megval\u00f3s\u00edt\u00e1s Entity Framework-kel (2 iMsc pont)"},{"location":"hazi/mongodb/","text":"Feladat: MongoDB \u00b6 A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/ePdcRbph linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod. Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k \u00b6 Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. MongoDB Community Server ( let\u00f6lt\u00e9s ) Robo 3T ( let\u00f6lt\u00e9s ) Microsoft Visual Studio 2019 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET Core SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3. .NET Core 3.1 SDK Visual Studio eset\u00e9n telep\u00fcl, de ha m\u00e9gse, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges. Gyakorlatokon is haszn\u00e1lt minta adatb\u00e1zis k\u00f3dja: mongo.js El\u0151k\u00e9sz\u00fcletk\u00e9nt hozz l\u00e9tre egy \u00faj adatb\u00e1zist, a gyakorlatanyagban le\u00edrt m\u00f3don. GitHub account \u00e9s egy git kliens Feladat 0: Neptun k\u00f3d \u00b6 Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat! Feladat 1: \u00c1fa kulcs m\u00f3dos\u00edt\u00e1sa (2 pluszpont) \u00b6 Ebben a feladatban egy m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1s ( Update ) seg\u00edts\u00e9g\u00e9vel kell megv\u00e1ltoztatni egy \u00e1fat\u00edpus kulcs\u00e1t. Az implement\u00e1land\u00f3 met\u00f3dus a ProductRepository oszt\u00e1lyban a k\u00f6vetkez\u0151. public void ChangeVatPercentage ( string name , int newPercentage ) El\u0151sz\u00f6r is vizsg\u00e1ljuk meg, hogy hogy tal\u00e1lhat\u00f3k meg az \u00c1FA \u00e9rt\u00e9kek az adatb\u00e1zisunkban. Az SQL adatb\u00e1zisban megszokott normaliz\u00e1lt t\u00e1bl\u00e1val ellent\u00e9tben itt denormaliz\u00e1lt m\u00f3don, a products kollekci\u00f3ban be\u00e1gyazott dokumentumk\u00e9nt szerepel. Ezt t\u00fckr\u00f6zi a Product entit\u00e1s oszt\u00e1ly is. public class Product { [BsonId] public ObjectId ID { get ; set ; } public ObjectId CategoryID { get ; set ; } public string Name { get ; set ; } public double? Price { get ; set ; } public int? Stock { get ; set ; } public VAT VAT { get ; set ; } } Ez az adatb\u00e1zis olvas\u00e1s\u00e1t igen hat\u00e9konny\u00e1 teszi: ha egy term\u00e9k brutt\u00f3 \u00e1r\u00e1ra vagyunk k\u00edv\u00e1ncsiak, egyetlen dokumentumban rendelkez\u00e9s\u00fcnkre \u00e1ll minden sz\u00fcks\u00e9ges \u00e9rt\u00e9k \u2014 szemben az SQL adatb\u00e1zissal, ahol ehhez JOIN -ra lenne sz\u00fcks\u00e9g. H\u00e1tr\u00e1nya viszont, hogy m\u00f3dos\u00edt\u00e1s eset\u00e9n minden dokumentumban m\u00f3dos\u00edtanunk kell az \u00e1fakulcsot, ahol megjelenik. Az el\u0151z\u0151ekb\u0151l k\u00f6vetkezik, hogy a t\u00f6meges v\u00e1ltoztat\u00e1shoz UpdateMany utas\u00edt\u00e1sra lesz sz\u00fcks\u00e9g\u00fcnk \u2014 ugyanis mindenhol szeretn\u00e9nk m\u00f3dos\u00edtani az \u00e1fakulcsot ahol a n\u00e9v megegyezik. A f\u00fcggv\u00e9ny haszn\u00e1lat\u00e1nak m\u00f3dj\u00e1t \u00e9rdemes felid\u00e9zni. Az UpdateMany f\u00fcggv\u00e9ny filter param\u00e9ter\u00e9ben sz\u0171rj\u00fcnk r\u00e1 azokra a term\u00e9kekre melyekben az VAT.Name megegyezik a f\u00fcggv\u00e9ny name param\u00e9ter\u00e9vel. A f\u00fcggv\u00e9ny update param\u00e9ter\u00e9ben a m\u00f3dos\u00edt\u00f3 l\u00e9p\u00e9st mondjuk meg, itt az VAT.Percentage \u00e9rt\u00e9ket szeretn\u00e9nk be\u00e1ll\u00edtani az newPercentage param\u00e9ter \u00e9rt\u00e9k\u00e9re. Ehhez a $set ( Set ) oper\u00e1tor haszn\u00e1lhat\u00f3. K\u00e9sz\u00edtsd el a f\u00fcggv\u00e9ny implement\u00e1ci\u00f3j\u00e1t. A repository oszt\u00e1ly konstruktorban megkapja az adatb\u00e1zist \u00e9s elmenti mag\u00e1nak a haszn\u00e1land\u00f3 gy\u0171jtem\u00e9nyt, ezen kereszt\u00fcl \u00e9rheted el az adatb\u00e1zist. A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. A teszteket Visual Studio-ban egyszer\u0171en tudod futtatni , de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy dotnet cli ), akkor is tudsz teszteket futtatni . Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a TestDbFactory oszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet. Tesztek A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz. A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod. BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6lts fel. Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a products gy\u0171jtem\u00e9ny tartalm\u00e1r\u00f3l a v\u00e1ltoztat\u00e1s ut\u00e1n . A teszt lefuttat\u00e1s\u00e1val a Standard Rate nev\u0171 \u00e1fakulcs sz\u00e1zal\u00e9ka megv\u00e1ltozik. Robo3T-b\u0151l (vagy m\u00e1s eszk\u00f6zb\u0151l) mutasd meg, hogy val\u00f3ban friss\u00fclnek a gy\u0171jtem\u00e9nyben az \u00e9rt\u00e9kek. Egy-k\u00e9t \u00e9rintett dokumentumot bonts ki, hogy l\u00e1that\u00f3 legyen a v\u00e1ltoz\u00e1s (mint a k\u00e9pen fent). Feladat 2: Legnagyobb \u00f6ssz\u00e9rt\u00e9k\u0171 term\u00e9k a rakt\u00e1rban (2 iMsc pont) \u00b6 A feladat meghat\u00e1rozni, hogy a rakt\u00e1runkban egy adott kateg\u00f3ri\u00e1ba tartoz\u00f3 term\u00e9kek k\u00f6z\u00fcl melyik k\u00e9pviseli a legnagyobb \u00f6ssz\u00e9rt\u00e9ket \u2014 teh\u00e1t melyik term\u00e9k az, amelyiknek az \u00e1ra szorozva a rakt\u00e1rban l\u00e9v\u0151 mennyis\u00e9g\u00e9vel a legnagyobb . Ehhez a ProductRepository oszt\u00e1lyban a k\u00f6vetkez\u0151 met\u00f3dust kell implement\u00e1lnunk. ( string , double? ) ProductWithLargestTotalValue ( ObjectId categoryId ) A pontos specifik\u00e1ci\u00f3 meg\u00e9rt\u00e9s\u00e9hez vizsg\u00e1ljuk meg el\u0151sz\u00f6r a feladathoz tartoz\u00f3 teszteket a TestExercise2.cs f\u00e1jlban. A f\u00fcggv\u00e9ny bemeneti param\u00e9tere a kateg\u00f3ria ID-ja, amelyhez tartoz\u00f3 term\u00e9kekre \u00e9ppen k\u00edv\u00e1ncsiak vagyunk. Amennyiben tartozik term\u00e9k a megadott kateg\u00f3ri\u00e1hoz, akkor a legnagyobb \u00f6ssz\u00e9rt\u00e9k\u0171 term\u00e9k nev\u00e9t \u00e9s az \u00f6ssz\u00e9rt\u00e9ket kell visszaadnunk. Amennyiben nem tartozik term\u00e9k a kateg\u00f3ri\u00e1hoz, mind a k\u00e9t \u00e9rt\u00e9kre null -t kell visszaadnunk. A lek\u00e9rdez\u00e9s elv\u00e9gz\u00e9s\u00e9hez a MongoDB aggreg\u00e1ci\u00f3s pipeline-j\u00e1t \u00e9rdemes haszn\u00e1lni. Ennek m\u0171k\u00f6d\u00e9s\u00e9nek feleleven\u00edt\u00e9s\u00e9hez n\u00e9zd meg a gyakorlatfeladatok megold\u00e1s\u00e1t. A lek\u00e9rdez\u00e9shez a k\u00f6vetkez\u0151 pipeline l\u00e9p\u00e9sek sz\u00fcks\u00e9gesek: Sz\u0171rj\u00fck le a term\u00e9keket a megadott kateg\u00f3ri\u00e1hoz tartoz\u00f3kra. Ehhez egy $match ( Match ) l\u00e9p\u00e9sre lesz sz\u00fcks\u00e9g\u00fcnk, ahol megadhatjuk a megfelel\u0151 filter kifejez\u00e9st. Sz\u00e1moljuk ki minden megmaradt term\u00e9k eset\u00e9n az \u00f6ssz\u00e9rt\u00e9ket egy $project ( Project ) l\u00e9p\u00e9s seg\u00edts\u00e9g\u00e9vel. Ne felejtsd el, hogy az \u00f6ssz\u00e9rt\u00e9k mellett a term\u00e9k nev\u00e9re is sz\u00fcks\u00e9g\u00fcnk lesz! Rendezz\u00fck az \u00edgy kapott dokumentumokat cs\u00f6kken\u0151 sorrendbe az \u00f6ssz\u00e9rt\u00e9k alapj\u00e1n. Ehhez a $sort ( SortByDescending ) l\u00e9p\u00e9st tudjuk alkalmazni. A legnagyobb \u00e9rt\u00e9kre vagyunk k\u00edv\u00e1ncsiak, azaz az eredm\u00e9nyek k\u00f6z\u00fcl csup\u00e1n az els\u0151 \u00e9rdekel minket. Azonban akkor sem szeretn\u00e9nk hib\u00e1t kapni, ha egy\u00e1ltal\u00e1n nem tartozott term\u00e9k ehhez a kateg\u00f3ri\u00e1hoz. Ez\u00e9rt a FirstOrDefault ki\u00e9rt\u00e9kel\u0151 utas\u00edt\u00e1st \u00e9rdemes haszn\u00e1lni. Ha esetleg ismeretlen lenne a (string, double?) szintaktika: return ( \"test\" , 0.0 ); utas\u00edt\u00e1s seg\u00edts\u00e9g\u00e9vel egyszerre k\u00e9t visszat\u00e9r\u00e9si \u00e9rt\u00e9ket tudunk adni a f\u00fcggv\u00e9nynek. Ha siker\u00fclt implement\u00e1lni a met\u00f3dust, akkor a kor\u00e1bban m\u00e1r l\u00e1tott m\u00f3don a TestExercise2 oszt\u00e1lyban tal\u00e1lhat\u00f3 teszt met\u00f3dusokkal ellen\u0151rizni tudod a m\u0171k\u00f6d\u00e9st. BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6lts fel.","title":"Feladat: MongoDB"},{"location":"hazi/mongodb/#feladat-mongodb","text":"A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/ePdcRbph linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.","title":"Feladat: MongoDB"},{"location":"hazi/mongodb/#szukseges-eszkozok","text":"Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. MongoDB Community Server ( let\u00f6lt\u00e9s ) Robo 3T ( let\u00f6lt\u00e9s ) Microsoft Visual Studio 2019 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET Core SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3. .NET Core 3.1 SDK Visual Studio eset\u00e9n telep\u00fcl, de ha m\u00e9gse, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges. Gyakorlatokon is haszn\u00e1lt minta adatb\u00e1zis k\u00f3dja: mongo.js El\u0151k\u00e9sz\u00fcletk\u00e9nt hozz l\u00e9tre egy \u00faj adatb\u00e1zist, a gyakorlatanyagban le\u00edrt m\u00f3don. GitHub account \u00e9s egy git kliens","title":"Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k"},{"location":"hazi/mongodb/#feladat-0-neptun-kod","text":"Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!","title":"Feladat 0: Neptun k\u00f3d"},{"location":"hazi/mongodb/#feladat-1-afa-kulcs-modositasa-2-pluszpont","text":"Ebben a feladatban egy m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1s ( Update ) seg\u00edts\u00e9g\u00e9vel kell megv\u00e1ltoztatni egy \u00e1fat\u00edpus kulcs\u00e1t. Az implement\u00e1land\u00f3 met\u00f3dus a ProductRepository oszt\u00e1lyban a k\u00f6vetkez\u0151. public void ChangeVatPercentage ( string name , int newPercentage ) El\u0151sz\u00f6r is vizsg\u00e1ljuk meg, hogy hogy tal\u00e1lhat\u00f3k meg az \u00c1FA \u00e9rt\u00e9kek az adatb\u00e1zisunkban. Az SQL adatb\u00e1zisban megszokott normaliz\u00e1lt t\u00e1bl\u00e1val ellent\u00e9tben itt denormaliz\u00e1lt m\u00f3don, a products kollekci\u00f3ban be\u00e1gyazott dokumentumk\u00e9nt szerepel. Ezt t\u00fckr\u00f6zi a Product entit\u00e1s oszt\u00e1ly is. public class Product { [BsonId] public ObjectId ID { get ; set ; } public ObjectId CategoryID { get ; set ; } public string Name { get ; set ; } public double? Price { get ; set ; } public int? Stock { get ; set ; } public VAT VAT { get ; set ; } } Ez az adatb\u00e1zis olvas\u00e1s\u00e1t igen hat\u00e9konny\u00e1 teszi: ha egy term\u00e9k brutt\u00f3 \u00e1r\u00e1ra vagyunk k\u00edv\u00e1ncsiak, egyetlen dokumentumban rendelkez\u00e9s\u00fcnkre \u00e1ll minden sz\u00fcks\u00e9ges \u00e9rt\u00e9k \u2014 szemben az SQL adatb\u00e1zissal, ahol ehhez JOIN -ra lenne sz\u00fcks\u00e9g. H\u00e1tr\u00e1nya viszont, hogy m\u00f3dos\u00edt\u00e1s eset\u00e9n minden dokumentumban m\u00f3dos\u00edtanunk kell az \u00e1fakulcsot, ahol megjelenik. Az el\u0151z\u0151ekb\u0151l k\u00f6vetkezik, hogy a t\u00f6meges v\u00e1ltoztat\u00e1shoz UpdateMany utas\u00edt\u00e1sra lesz sz\u00fcks\u00e9g\u00fcnk \u2014 ugyanis mindenhol szeretn\u00e9nk m\u00f3dos\u00edtani az \u00e1fakulcsot ahol a n\u00e9v megegyezik. A f\u00fcggv\u00e9ny haszn\u00e1lat\u00e1nak m\u00f3dj\u00e1t \u00e9rdemes felid\u00e9zni. Az UpdateMany f\u00fcggv\u00e9ny filter param\u00e9ter\u00e9ben sz\u0171rj\u00fcnk r\u00e1 azokra a term\u00e9kekre melyekben az VAT.Name megegyezik a f\u00fcggv\u00e9ny name param\u00e9ter\u00e9vel. A f\u00fcggv\u00e9ny update param\u00e9ter\u00e9ben a m\u00f3dos\u00edt\u00f3 l\u00e9p\u00e9st mondjuk meg, itt az VAT.Percentage \u00e9rt\u00e9ket szeretn\u00e9nk be\u00e1ll\u00edtani az newPercentage param\u00e9ter \u00e9rt\u00e9k\u00e9re. Ehhez a $set ( Set ) oper\u00e1tor haszn\u00e1lhat\u00f3. K\u00e9sz\u00edtsd el a f\u00fcggv\u00e9ny implement\u00e1ci\u00f3j\u00e1t. A repository oszt\u00e1ly konstruktorban megkapja az adatb\u00e1zist \u00e9s elmenti mag\u00e1nak a haszn\u00e1land\u00f3 gy\u0171jtem\u00e9nyt, ezen kereszt\u00fcl \u00e9rheted el az adatb\u00e1zist. A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. A teszteket Visual Studio-ban egyszer\u0171en tudod futtatni , de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy dotnet cli ), akkor is tudsz teszteket futtatni . Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a TestDbFactory oszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet. Tesztek A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz. A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod. BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6lts fel. Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a products gy\u0171jtem\u00e9ny tartalm\u00e1r\u00f3l a v\u00e1ltoztat\u00e1s ut\u00e1n . A teszt lefuttat\u00e1s\u00e1val a Standard Rate nev\u0171 \u00e1fakulcs sz\u00e1zal\u00e9ka megv\u00e1ltozik. Robo3T-b\u0151l (vagy m\u00e1s eszk\u00f6zb\u0151l) mutasd meg, hogy val\u00f3ban friss\u00fclnek a gy\u0171jtem\u00e9nyben az \u00e9rt\u00e9kek. Egy-k\u00e9t \u00e9rintett dokumentumot bonts ki, hogy l\u00e1that\u00f3 legyen a v\u00e1ltoz\u00e1s (mint a k\u00e9pen fent).","title":"Feladat 1: \u00c1fa kulcs m\u00f3dos\u00edt\u00e1sa (2 pluszpont)"},{"location":"hazi/mongodb/#feladat-2-legnagyobb-osszerteku-termek-a-raktarban-2-imsc-pont","text":"A feladat meghat\u00e1rozni, hogy a rakt\u00e1runkban egy adott kateg\u00f3ri\u00e1ba tartoz\u00f3 term\u00e9kek k\u00f6z\u00fcl melyik k\u00e9pviseli a legnagyobb \u00f6ssz\u00e9rt\u00e9ket \u2014 teh\u00e1t melyik term\u00e9k az, amelyiknek az \u00e1ra szorozva a rakt\u00e1rban l\u00e9v\u0151 mennyis\u00e9g\u00e9vel a legnagyobb . Ehhez a ProductRepository oszt\u00e1lyban a k\u00f6vetkez\u0151 met\u00f3dust kell implement\u00e1lnunk. ( string , double? ) ProductWithLargestTotalValue ( ObjectId categoryId ) A pontos specifik\u00e1ci\u00f3 meg\u00e9rt\u00e9s\u00e9hez vizsg\u00e1ljuk meg el\u0151sz\u00f6r a feladathoz tartoz\u00f3 teszteket a TestExercise2.cs f\u00e1jlban. A f\u00fcggv\u00e9ny bemeneti param\u00e9tere a kateg\u00f3ria ID-ja, amelyhez tartoz\u00f3 term\u00e9kekre \u00e9ppen k\u00edv\u00e1ncsiak vagyunk. Amennyiben tartozik term\u00e9k a megadott kateg\u00f3ri\u00e1hoz, akkor a legnagyobb \u00f6ssz\u00e9rt\u00e9k\u0171 term\u00e9k nev\u00e9t \u00e9s az \u00f6ssz\u00e9rt\u00e9ket kell visszaadnunk. Amennyiben nem tartozik term\u00e9k a kateg\u00f3ri\u00e1hoz, mind a k\u00e9t \u00e9rt\u00e9kre null -t kell visszaadnunk. A lek\u00e9rdez\u00e9s elv\u00e9gz\u00e9s\u00e9hez a MongoDB aggreg\u00e1ci\u00f3s pipeline-j\u00e1t \u00e9rdemes haszn\u00e1lni. Ennek m\u0171k\u00f6d\u00e9s\u00e9nek feleleven\u00edt\u00e9s\u00e9hez n\u00e9zd meg a gyakorlatfeladatok megold\u00e1s\u00e1t. A lek\u00e9rdez\u00e9shez a k\u00f6vetkez\u0151 pipeline l\u00e9p\u00e9sek sz\u00fcks\u00e9gesek: Sz\u0171rj\u00fck le a term\u00e9keket a megadott kateg\u00f3ri\u00e1hoz tartoz\u00f3kra. Ehhez egy $match ( Match ) l\u00e9p\u00e9sre lesz sz\u00fcks\u00e9g\u00fcnk, ahol megadhatjuk a megfelel\u0151 filter kifejez\u00e9st. Sz\u00e1moljuk ki minden megmaradt term\u00e9k eset\u00e9n az \u00f6ssz\u00e9rt\u00e9ket egy $project ( Project ) l\u00e9p\u00e9s seg\u00edts\u00e9g\u00e9vel. Ne felejtsd el, hogy az \u00f6ssz\u00e9rt\u00e9k mellett a term\u00e9k nev\u00e9re is sz\u00fcks\u00e9g\u00fcnk lesz! Rendezz\u00fck az \u00edgy kapott dokumentumokat cs\u00f6kken\u0151 sorrendbe az \u00f6ssz\u00e9rt\u00e9k alapj\u00e1n. Ehhez a $sort ( SortByDescending ) l\u00e9p\u00e9st tudjuk alkalmazni. A legnagyobb \u00e9rt\u00e9kre vagyunk k\u00edv\u00e1ncsiak, azaz az eredm\u00e9nyek k\u00f6z\u00fcl csup\u00e1n az els\u0151 \u00e9rdekel minket. Azonban akkor sem szeretn\u00e9nk hib\u00e1t kapni, ha egy\u00e1ltal\u00e1n nem tartozott term\u00e9k ehhez a kateg\u00f3ri\u00e1hoz. Ez\u00e9rt a FirstOrDefault ki\u00e9rt\u00e9kel\u0151 utas\u00edt\u00e1st \u00e9rdemes haszn\u00e1lni. Ha esetleg ismeretlen lenne a (string, double?) szintaktika: return ( \"test\" , 0.0 ); utas\u00edt\u00e1s seg\u00edts\u00e9g\u00e9vel egyszerre k\u00e9t visszat\u00e9r\u00e9si \u00e9rt\u00e9ket tudunk adni a f\u00fcggv\u00e9nynek. Ha siker\u00fclt implement\u00e1lni a met\u00f3dust, akkor a kor\u00e1bban m\u00e1r l\u00e1tott m\u00f3don a TestExercise2 oszt\u00e1lyban tal\u00e1lhat\u00f3 teszt met\u00f3dusokkal ellen\u0151rizni tudod a m\u0171k\u00f6d\u00e9st. BEADAND\u00d3 A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6lts fel.","title":"Feladat 2: Legnagyobb \u00f6ssz\u00e9rt\u00e9k\u0171 term\u00e9k a rakt\u00e1rban (2 iMsc pont)"},{"location":"hazi/mssql/","text":"Feladat: MSSQL szerveroldali programoz\u00e1s \u00b6 A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/CEXFRiAu linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod. Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k \u00b6 Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. Microsoft SQL Server Express v\u00e1ltozat ingyenesen haszn\u00e1lhat\u00f3, avagy Visual Studio mellett feltelep\u00fcl\u0151 localdb v\u00e1ltozat is megfelel\u0151 Van Linux v\u00e1ltozata is. MacOS-en Docker-rel futtathat\u00f3. SQL Server Management Studio , vagy kipr\u00f3b\u00e1lhat\u00f3 a platformf\u00fcggetlen Azure Data Studio is Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql GitHub account \u00e9s egy git kliens Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se \u00b6 Hozz l\u00e9tre egy \u00faj adatb\u00e1zist, amelynek neve megegyezik a Neptun k\u00f3doddal . Ebben az adatb\u00e1zisban futtasd le a t\u00e1bl\u00e1kat l\u00e9trehoz\u00f3 szkriptet. Neptun k\u00f3d fontos A feladatok al\u00e1bb k\u00e9rnek k\u00e9perny\u0151k\u00e9pet, amelyen szerepelnie kell az adatb\u00e1zis nev\u00e9nek, amely megegyezik a Neptun k\u00f3doddal! Feladat 0: Neptun k\u00f3d \u00b6 Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat! Feladat 1: Jelsz\u00f3 lej\u00e1rat \u00e9s karbantart\u00e1sa (2 pluszpont) \u00b6 Biztons\u00e1gi megfontol\u00e1sb\u00f3l szeretn\u00e9nk k\u00f6telez\u0151v\u00e9 tenni a jelsz\u00f3 id\u0151nk\u00e9nti meg\u00faj\u00edt\u00e1s\u00e1t. Ehhez r\u00f6gz\u00edteni fogjuk, \u00e9s karbantartjuk a jelsz\u00f3 utols\u00f3 m\u00f3dos\u00edt\u00e1s\u00e1nak idej\u00e9t. Adj hozz\u00e1 egy \u00faj oszlopot a Customer t\u00e1bl\u00e1hoz PasswordExpiry n\u00e9ven, ami egy d\u00e1tumot tartalmaz: alter table [Customer] add [PasswordExpiry] datetime . K\u00e9sz\u00edts egy triggert, amellyel jelsz\u00f3 v\u00e1ltoztat\u00e1s eset\u00e9n automatikusan kit\u00f6lt\u00e9sre ker\u00fcl a PasswordExpiry mez\u0151 \u00e9rt\u00e9ke. Az \u00faj \u00e9rt\u00e9ke a mai d\u00e1tum plusz egy \u00e9v legyen. Az \u00e9rt\u00e9ket a szerver sz\u00e1m\u00edtsa ki. \u00dcgyelj arra, hogy \u00faj vev\u0151 regisztr\u00e1l\u00e1sakor ( insert ) mindig kit\u00f6lt\u00e9sre ker\u00fclj\u00f6n a mez\u0151, viszont a vev\u0151 adatainak szerkeszt\u00e9sekor ( update ) csak akkor v\u00e1ltozzon a lej\u00e1rat d\u00e1tuma, ha v\u00e1ltozott a jelsz\u00f3. (Teh\u00e1t pl. ha az email c\u00edmet v\u00e1ltoztatt\u00e1k csak, akkor a lej\u00e1rat ne v\u00e1ltozzon.) A trigger csak a besz\u00fart/friss\u00edtett rekorddal t\u00f6r\u0151dj\u00f6n (teh\u00e1t nem a t\u00e1bla teljes tartalm\u00e1ra kell friss\u00edteni a d\u00e1tum oszlopot)! A feladatban felt\u00e9telezheted, hogy egyszerre csak egyetlen rekord m\u00f3dosul. Ellen\u0151rizd a trigger viselked\u00e9s\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 esetekre is. BEADAND\u00d3 A trigger k\u00f3dj\u00e1t az f1.sql f\u00e1jlban add be. Az sql f\u00e1jl egyetlen utas\u00edt\u00e1st tartalmazzon csak (egyetlen create trigger ), ne legyen benne se use se go parancs! K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a Customer t\u00e1bla tartalm\u00e1r\u00f3l, amiben l\u00e1that\u00f3 az \u00faj oszlop \u00e9s annak kit\u00f6lt\u00f6tt \u00e9rt\u00e9kei (a tesztel\u00e9s ut\u00e1ni \u00e1llapottal). A k\u00e9pen legyen l\u00e1that\u00f3 az adatb\u00e1zisod neve (a Neptun k\u00f3dod). A k\u00e9pet f1.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt! Feladat 2: Term\u00e9k aj\u00e1nlott korhat\u00e1ra (2 iMsc pont) \u00b6 Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g. A minta adatb\u00e1zisban a term\u00e9kek ( Product ) rekordjaiban van egy xml t\u00edpus\u00fa Description nev\u0171 oszlop. Ez n\u00e9h\u00e1ny term\u00e9kn\u00e9l van csak kit\u00f6ltve. Egy p\u00e9lda a tartalm\u00e1ra: <product> <product_size> <unit> cm </unit> <width> 150 </width> <height> 50 </height> <depth> 150 </depth> </product_size> <description> Requires battery (not part of the package). </description> <recommended_age> 0-18 m </recommended_age> </product> Szeretn\u00e9nk a recommended_age tag tartalm\u00e1t k\u00f6nnyebb el\u00e9rhet\u0151s\u00e9g v\u00e9gett egy saj\u00e1t oszlopba helyezni. Adj hozz\u00e1 egy \u00faj oszlopot a Product t\u00e1bl\u00e1hoz RecommendedAge n\u00e9ven, ami egy sz\u00f6veget tartalmaz tartalmaz: alter table [Product] add [RecommendedAge] nvarchar(200) . (Ezt a k\u00f3dot nem kell beadni a megold\u00e1sban.) \u00cdrj T-SQL szkriptet, amely minden term\u00e9k eset\u00e9n az xml le\u00edr\u00e1sb\u00f3l az <recommended_age> elemet kiemelve felt\u00f6lti az el\u0151bb l\u00e9trehozott RecommendedAge oszlopot. Ha az xml le\u00edr\u00e1s \u00fcres, vagy nincs benne a keresett elem, akkor maradjon NULL az \u00faj oszlop tartalma. Ellenkez\u0151 esetben az xml tag sz\u00f6veges tartalma ker\u00fclj\u00f6n \u00e1tm\u00e1sol\u00e1sra, \u00e9s az xml dokumentumb\u00f3l t\u00f6r\u00f6ld ezt az elemet. Felt\u00e9telezheted, hogy csak egyetlen <recommended_age> elem van az xml-ben. BEADAND\u00d3 A scriptet az f2.sql f\u00e1jlban add be. Ne haszn\u00e1lj se t\u00e1rolt elj\u00e1r\u00e1st, se triggert, csak egy T-SQL k\u00f3d blokkot k\u00e9sz\u00edts. Az sql f\u00e1jl \u00f6nmag\u00e1ban futtathat\u00f3 legyen, ne legyen benne se use se go parancs! K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a Product t\u00e1bla tartalm\u00e1r\u00f3l a kit\u00f6lt\u00e9s ut\u00e1n. Legyen l\u00e1that\u00f3 az \u00faj oszlop \u00e9s annak tartalma. A k\u00e9pen legyen l\u00e1that\u00f3 az adatb\u00e1zisod neve (a Neptun k\u00f3dod). A k\u00e9pet f2.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!","title":"Feladat: MSSQL szerveroldali programoz\u00e1s"},{"location":"hazi/mssql/#feladat-mssql-szerveroldali-programozas","text":"A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/CEXFRiAu linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.","title":"Feladat: MSSQL szerveroldali programoz\u00e1s"},{"location":"hazi/mssql/#szukseges-eszkozok","text":"Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. Microsoft SQL Server Express v\u00e1ltozat ingyenesen haszn\u00e1lhat\u00f3, avagy Visual Studio mellett feltelep\u00fcl\u0151 localdb v\u00e1ltozat is megfelel\u0151 Van Linux v\u00e1ltozata is. MacOS-en Docker-rel futtathat\u00f3. SQL Server Management Studio , vagy kipr\u00f3b\u00e1lhat\u00f3 a platformf\u00fcggetlen Azure Data Studio is Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql GitHub account \u00e9s egy git kliens","title":"Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k"},{"location":"hazi/mssql/#adatbazis-elokeszitese","text":"Hozz l\u00e9tre egy \u00faj adatb\u00e1zist, amelynek neve megegyezik a Neptun k\u00f3doddal . Ebben az adatb\u00e1zisban futtasd le a t\u00e1bl\u00e1kat l\u00e9trehoz\u00f3 szkriptet. Neptun k\u00f3d fontos A feladatok al\u00e1bb k\u00e9rnek k\u00e9perny\u0151k\u00e9pet, amelyen szerepelnie kell az adatb\u00e1zis nev\u00e9nek, amely megegyezik a Neptun k\u00f3doddal!","title":"Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se"},{"location":"hazi/mssql/#feladat-0-neptun-kod","text":"Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!","title":"Feladat 0: Neptun k\u00f3d"},{"location":"hazi/mssql/#feladat-1-jelszo-lejarat-es-karbantartasa-2-pluszpont","text":"Biztons\u00e1gi megfontol\u00e1sb\u00f3l szeretn\u00e9nk k\u00f6telez\u0151v\u00e9 tenni a jelsz\u00f3 id\u0151nk\u00e9nti meg\u00faj\u00edt\u00e1s\u00e1t. Ehhez r\u00f6gz\u00edteni fogjuk, \u00e9s karbantartjuk a jelsz\u00f3 utols\u00f3 m\u00f3dos\u00edt\u00e1s\u00e1nak idej\u00e9t. Adj hozz\u00e1 egy \u00faj oszlopot a Customer t\u00e1bl\u00e1hoz PasswordExpiry n\u00e9ven, ami egy d\u00e1tumot tartalmaz: alter table [Customer] add [PasswordExpiry] datetime . K\u00e9sz\u00edts egy triggert, amellyel jelsz\u00f3 v\u00e1ltoztat\u00e1s eset\u00e9n automatikusan kit\u00f6lt\u00e9sre ker\u00fcl a PasswordExpiry mez\u0151 \u00e9rt\u00e9ke. Az \u00faj \u00e9rt\u00e9ke a mai d\u00e1tum plusz egy \u00e9v legyen. Az \u00e9rt\u00e9ket a szerver sz\u00e1m\u00edtsa ki. \u00dcgyelj arra, hogy \u00faj vev\u0151 regisztr\u00e1l\u00e1sakor ( insert ) mindig kit\u00f6lt\u00e9sre ker\u00fclj\u00f6n a mez\u0151, viszont a vev\u0151 adatainak szerkeszt\u00e9sekor ( update ) csak akkor v\u00e1ltozzon a lej\u00e1rat d\u00e1tuma, ha v\u00e1ltozott a jelsz\u00f3. (Teh\u00e1t pl. ha az email c\u00edmet v\u00e1ltoztatt\u00e1k csak, akkor a lej\u00e1rat ne v\u00e1ltozzon.) A trigger csak a besz\u00fart/friss\u00edtett rekorddal t\u00f6r\u0151dj\u00f6n (teh\u00e1t nem a t\u00e1bla teljes tartalm\u00e1ra kell friss\u00edteni a d\u00e1tum oszlopot)! A feladatban felt\u00e9telezheted, hogy egyszerre csak egyetlen rekord m\u00f3dosul. Ellen\u0151rizd a trigger viselked\u00e9s\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 esetekre is. BEADAND\u00d3 A trigger k\u00f3dj\u00e1t az f1.sql f\u00e1jlban add be. Az sql f\u00e1jl egyetlen utas\u00edt\u00e1st tartalmazzon csak (egyetlen create trigger ), ne legyen benne se use se go parancs! K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a Customer t\u00e1bla tartalm\u00e1r\u00f3l, amiben l\u00e1that\u00f3 az \u00faj oszlop \u00e9s annak kit\u00f6lt\u00f6tt \u00e9rt\u00e9kei (a tesztel\u00e9s ut\u00e1ni \u00e1llapottal). A k\u00e9pen legyen l\u00e1that\u00f3 az adatb\u00e1zisod neve (a Neptun k\u00f3dod). A k\u00e9pet f1.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!","title":"Feladat 1: Jelsz\u00f3 lej\u00e1rat \u00e9s karbantart\u00e1sa (2 pluszpont)"},{"location":"hazi/mssql/#feladat-2-termek-ajanlott-korhatara-2-imsc-pont","text":"Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g. A minta adatb\u00e1zisban a term\u00e9kek ( Product ) rekordjaiban van egy xml t\u00edpus\u00fa Description nev\u0171 oszlop. Ez n\u00e9h\u00e1ny term\u00e9kn\u00e9l van csak kit\u00f6ltve. Egy p\u00e9lda a tartalm\u00e1ra: <product> <product_size> <unit> cm </unit> <width> 150 </width> <height> 50 </height> <depth> 150 </depth> </product_size> <description> Requires battery (not part of the package). </description> <recommended_age> 0-18 m </recommended_age> </product> Szeretn\u00e9nk a recommended_age tag tartalm\u00e1t k\u00f6nnyebb el\u00e9rhet\u0151s\u00e9g v\u00e9gett egy saj\u00e1t oszlopba helyezni. Adj hozz\u00e1 egy \u00faj oszlopot a Product t\u00e1bl\u00e1hoz RecommendedAge n\u00e9ven, ami egy sz\u00f6veget tartalmaz tartalmaz: alter table [Product] add [RecommendedAge] nvarchar(200) . (Ezt a k\u00f3dot nem kell beadni a megold\u00e1sban.) \u00cdrj T-SQL szkriptet, amely minden term\u00e9k eset\u00e9n az xml le\u00edr\u00e1sb\u00f3l az <recommended_age> elemet kiemelve felt\u00f6lti az el\u0151bb l\u00e9trehozott RecommendedAge oszlopot. Ha az xml le\u00edr\u00e1s \u00fcres, vagy nincs benne a keresett elem, akkor maradjon NULL az \u00faj oszlop tartalma. Ellenkez\u0151 esetben az xml tag sz\u00f6veges tartalma ker\u00fclj\u00f6n \u00e1tm\u00e1sol\u00e1sra, \u00e9s az xml dokumentumb\u00f3l t\u00f6r\u00f6ld ezt az elemet. Felt\u00e9telezheted, hogy csak egyetlen <recommended_age> elem van az xml-ben. BEADAND\u00d3 A scriptet az f2.sql f\u00e1jlban add be. Ne haszn\u00e1lj se t\u00e1rolt elj\u00e1r\u00e1st, se triggert, csak egy T-SQL k\u00f3d blokkot k\u00e9sz\u00edts. Az sql f\u00e1jl \u00f6nmag\u00e1ban futtathat\u00f3 legyen, ne legyen benne se use se go parancs! K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a Product t\u00e1bla tartalm\u00e1r\u00f3l a kit\u00f6lt\u00e9s ut\u00e1n. Legyen l\u00e1that\u00f3 az \u00faj oszlop \u00e9s annak tartalma. A k\u00e9pen legyen l\u00e1that\u00f3 az adatb\u00e1zisod neve (a Neptun k\u00f3dod). A k\u00e9pet f2.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!","title":"Feladat 2: Term\u00e9k aj\u00e1nlott korhat\u00e1ra (2 iMsc pont)"},{"location":"hazi/rest/","text":"Feladat: REST API Web API technol\u00f3gi\u00e1val \u00b6 A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/h3EDX6Bu linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod. Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k \u00b6 Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. Microsoft Visual Studio 2019 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET Core SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3. .NET Core 3.1 SDK Visual Studio eset\u00e9n telep\u00fcl, de ha m\u00e9gse, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges. Postman GitHub account \u00e9s egy git kliens Feladat 0: Neptun k\u00f3d \u00b6 Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat! Feladat 1: Term\u00e9k m\u0171veletek (2 pluszpont) \u00b6 A l\u00e9trehozott \u00e9s kl\u00f3nozott repository-ban megtal\u00e1lhat\u00f3 a kiindul\u00f3 k\u00f3d v\u00e1z. Nyitsd meg Visual Studio-val \u00e9s ind\u00edtsd el. Egy konzol alkalmaz\u00e1snak kell elindulnia, amely hosztolja a web alkalmaz\u00e1st. Pr\u00f3b\u00e1ld ki (mik\u00f6zben fut a program): b\u00f6ng\u00e9sz\u0151ben nyitsd meg a http://localhost:5000/api/product oldalt, ahol a term\u00e9kek list\u00e1j\u00e1t kell l\u00e1sd JSON form\u00e1ban. N\u00e9zd meg a rendelkez\u00e9sre \u00e1ll\u00f3 k\u00f3dot. A Startup.cs inicializ\u00e1lja az alkalmaz\u00e1st. Ez egy ASP.NET Core webalkalmaz\u00e1s. Az alkalmaz\u00e1sban nincs adatb\u00e1zis el\u00e9r\u00e9s az egyszer\u0171s\u00e9g v\u00e9gett. A ProductRepository oszt\u00e1ly tesztel\u00e9shez haszn\u00e1land\u00f3 adatokat ad. A ProductsController dependency injection seg\u00edts\u00e9g\u00e9vel p\u00e9ld\u00e1nyos\u00edtja az IProductRepository -t. Feladatok: A DAL.ProductRepository oszt\u00e1lyban a Neptun nev\u0171 mez\u0151 \u00e9rt\u00e9k\u00e9ben cser\u00e9ld le a Neptun k\u00f3dod. A string \u00e9rt\u00e9ke a Neptun k\u00f3dod 6 karaktere legyen. FONTOS Az \u00edgy m\u00f3dos\u00edtott adatokr\u00f3l kell k\u00e9perny\u0151k\u00e9pet k\u00e9sz\u00edteni, \u00edgy ez a l\u00e9p\u00e9s fontos. K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, amivel ellen\u0151rizhet\u0151, hogy l\u00e9tezik-e egy adott id-j\u00fa term\u00e9k. A lek\u00e9rdez\u00e9shez egy HEAD t\u00edpus\u00fa HTTP k\u00e9r\u00e9st fogunk k\u00fcldeni a /api/product/{id} URL-re. A v\u00e1lasz HTTP 200 vagy 404 legyen (extra tartalom/body n\u00e9lk\u00fcl, csak a v\u00e1laszk\u00f3d sz\u00fcks\u00e9ges). K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, ami egy term\u00e9ket ( Product ) ad vissza az id-ja alapj\u00e1n; a k\u00e9r\u00e9s GET t\u00edpus\u00fa legyen a /api/product/{id} c\u00edmre, \u00e9s a v\u00e1lasz vagy 200 legyen az adattal, vagy 404, ha nincs ilyen elem. K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, amivel lek\u00e9rdezhet\u0151, h\u00e1ny f\u00e9le term\u00e9k van \u00f6sszesen. (P\u00e9ld\u00e1ul a lapoz\u00e1st el\u0151seg\u00edtend\u0151 kisz\u00e1molhatja a frontend, hogy h\u00e1ny lap lesz.) Ez is egy GET t\u00edpus\u00fa k\u00e9r\u00e9s legyen a /api/product/-/count c\u00edmre. A visszaadott adat a CountResult oszt\u00e1ly p\u00e9ld\u00e1nya legyen kit\u00f6ltve a darabsz\u00e1mmal (term\u00e9szetesen JSON form\u00e1ban). Mi\u00e9rt van a /- r\u00e9sz az URL-ben? Ahhoz, hogy ezt meg\u00e9rts\u00fck, gondoljuk \u00e1t, mi lehene az URL: term\u00e9kek darabsz\u00e1m\u00e1ra vagyunk k\u00edv\u00e1ncsiak, teh\u00e1t /api/product/ , de ut\u00e1na mi? Lehetne /api/product/count . Viszont ez \"\u00f6sszekeveredik\" a /api/product/123 jelleg\u0171 URL-lel, ami egy konkr\u00e9t term\u00e9k lek\u00e9rdez\u00e9s\u00e9re szolg\u00e1l. A gyakorlatban a k\u00e9t URL egy\u00fctt tudna m\u0171k\u00f6dni, mert a term\u00e9k azonos\u00edt\u00f3 most sz\u00e1m, \u00edgy a keretrendszer felismeri, hogy ha /123 az URL v\u00e9ge, akkor a term\u00e9k ID-t v\u00e1r\u00f3 v\u00e9gpontot kell v\u00e9grehajtani, ha pedig /count az URL v\u00e9ge, akkor a sz\u00e1moss\u00e1got megad\u00f3t. De ez csak akkor m\u0171k\u00f6dik, ha az ID int. Ha sz\u00f6veg lenne a term\u00e9k azonos\u00edt\u00f3ja, probl\u00e9ma lenne. Ilyen esetekben olyan URL-t kell \"kital\u00e1lni\", ami nem \u00fctk\u00f6zik. A /- r\u00e9sz azt jelzi, hogy ott nem term\u00e9k azonos\u00edt\u00f3 utazik. Megjegyz\u00e9s: az URL - controller met\u00f3dus azonos\u00edt\u00e1s a fent le\u00edrtakn\u00e1l bonyolultabb a val\u00f3s\u00e1gban. Az ASP.NET Core keretrendszer priorit\u00e1s sorrendben illeszti a controller met\u00f3dusokat a be\u00e9rkez\u0151 k\u00e9r\u00e9sek URL-jeire. Ezt a priorit\u00e1st lehet\u0151s\u00e9g\u00fcnk van befoly\u00e1solni a [Http*] attrib\u00fatumok Order tulajdons\u00e1g\u00e1val . BEADAND\u00d3 A m\u00f3dos\u00edtott forr\u00e1sk\u00f3dot t\u00f6ltsd fel. Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Postman-b\u0151l (vagy m\u00e1s tesztel\u00e9shez haszn\u00e1lt eszk\u00f6zb\u0151l), amely egy sikeres term\u00e9k lek\u00e9r\u00e9s eredm\u00e9ny\u00e9t mutatja. A k\u00e9pen legyen l\u00e1that\u00f3 a k\u00e9r\u00e9s \u00e9s a v\u00e1lasz minden r\u00e9szlete (k\u00e9r\u00e9s t\u00edpusa, URL, v\u00e1lasz k\u00f3dja, v\u00e1lasz tartalma). A v\u00e1laszban a n\u00e9vben szerepelnie kell a Neptun k\u00f3dodnak . A k\u00e9pet f1.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt! Feladat 2: OpenAPI dokument\u00e1ci\u00f3 (2 iMsc pont) \u00b6 Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g. Az OpenAPI (kor\u00e1bbi nev\u00e9n Swagger) egy REST API dokument\u00e1ci\u00f3s eszk\u00f6z. C\u00e9lja hasonl\u00f3 a Web Service-ek eset\u00e9ben haszn\u00e1lt WSDL-hez: le\u00edrni az API szolg\u00e1ltat\u00e1sait egy standardiz\u00e1lt form\u00e1ban. A kor\u00e1bbi feladatok megold\u00e1sa ut\u00e1n k\u00e9sz\u00edts OpenAPI specifik\u00e1ci\u00f3t \u00e9s dokument\u00e1ci\u00f3t a REST API le\u00edr\u00e1s\u00e1hoz. A megold\u00e1shoz k\u00f6vesd a Microsoft hivatalos dokument\u00e1ci\u00f3j\u00e1t: https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-3.1&tabs=visual-studio Mindenk\u00e9ppen a Swashbuckle opci\u00f3t haszn\u00e1ld. A swagger.json -t az alkalmaz\u00e1s maga gener\u00e1lja (nem k\u00e9zzel kell meg\u00edrnod), \u00e9s a /swagger/v1/swagger.json c\u00edmen legyen el\u00e9rhet\u0151. \u00c1ll\u00edtsd be a Swagger UI -t is, ez a /neptun c\u00edmen legyen el\u00e9rhet\u0151. Ezt a UseSwaggerUI be\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l a RoutePrefix konfigur\u00e1l\u00e1s\u00e1val fogod tudni el\u00e9rni. A saj\u00e1t Neptun k\u00f3dod legyen a prefix csupa kisbet\u0171vel . (A \"Customize and extend\" r\u00e9sszel \u00e9s egy\u00e9b testreszab\u00e1ssal nem kell foglalkoznod.) Ind\u00edtsd el a webalkalmaz\u00e1st, \u00e9s n\u00e9zd meg a swagger.json -t http://localhost:5000/swagger/v1/swagger.json c\u00edmen, \u00e9s pr\u00f3b\u00e1ld ki a SwaggerUI-t a http://localhost:5000/neptun c\u00edmen. Pr\u00f3b\u00e1ld ki a SwaggerUI \"Try it out\" szolg\u00e1ltat\u00e1s\u00e1t: t\u00e9nyleg kik\u00fcldi a k\u00e9r\u00e9st a webalkalmaz\u00e1snak, \u00e9s l\u00e1tod a val\u00f3di v\u00e1laszt. BEADAND\u00d3 A m\u00f3dos\u00edtott forr\u00e1sk\u00f3dot t\u00f6ltsd fel. \u00dcgyelj r\u00e1, hogy a csproj f\u00e1jl is m\u00f3dosult a hozz\u00e1adott NuGet csomaggal! K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a b\u00f6ng\u00e9sz\u0151ben megjelen\u0151 Swagger UI-r\u00f3l. \u00dcgyelj r\u00e1, hogy az URL-ben l\u00e1that\u00f3 legyen, hogy a SwaggerUI-t a /neptun c\u00edmen szolg\u00e1lja ki a rendszer a saj\u00e1t Neptun k\u00f3doddal. A k\u00e9pet f2.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!","title":"Feladat: REST API Web API technol\u00f3gi\u00e1val"},{"location":"hazi/rest/#feladat-rest-api-web-api-technologiaval","text":"A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151. GitHub Classroom seg\u00edts\u00e9g\u00e9vel a https://classroom.github.com/a/h3EDX6Bu linken kereszt\u00fcl hozz l\u00e9tre egy repository-t. Kl\u00f3nozd le a repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.","title":"Feladat: REST API Web API technol\u00f3gi\u00e1val"},{"location":"hazi/rest/#szukseges-eszkozok","text":"Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja. Microsoft Visual Studio 2019 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET Core SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3. .NET Core 3.1 SDK Visual Studio eset\u00e9n telep\u00fcl, de ha m\u00e9gse, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges. Postman GitHub account \u00e9s egy git kliens","title":"Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k"},{"location":"hazi/rest/#feladat-0-neptun-kod","text":"Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 neptun.txt f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!","title":"Feladat 0: Neptun k\u00f3d"},{"location":"hazi/rest/#feladat-1-termek-muveletek-2-pluszpont","text":"A l\u00e9trehozott \u00e9s kl\u00f3nozott repository-ban megtal\u00e1lhat\u00f3 a kiindul\u00f3 k\u00f3d v\u00e1z. Nyitsd meg Visual Studio-val \u00e9s ind\u00edtsd el. Egy konzol alkalmaz\u00e1snak kell elindulnia, amely hosztolja a web alkalmaz\u00e1st. Pr\u00f3b\u00e1ld ki (mik\u00f6zben fut a program): b\u00f6ng\u00e9sz\u0151ben nyitsd meg a http://localhost:5000/api/product oldalt, ahol a term\u00e9kek list\u00e1j\u00e1t kell l\u00e1sd JSON form\u00e1ban. N\u00e9zd meg a rendelkez\u00e9sre \u00e1ll\u00f3 k\u00f3dot. A Startup.cs inicializ\u00e1lja az alkalmaz\u00e1st. Ez egy ASP.NET Core webalkalmaz\u00e1s. Az alkalmaz\u00e1sban nincs adatb\u00e1zis el\u00e9r\u00e9s az egyszer\u0171s\u00e9g v\u00e9gett. A ProductRepository oszt\u00e1ly tesztel\u00e9shez haszn\u00e1land\u00f3 adatokat ad. A ProductsController dependency injection seg\u00edts\u00e9g\u00e9vel p\u00e9ld\u00e1nyos\u00edtja az IProductRepository -t. Feladatok: A DAL.ProductRepository oszt\u00e1lyban a Neptun nev\u0171 mez\u0151 \u00e9rt\u00e9k\u00e9ben cser\u00e9ld le a Neptun k\u00f3dod. A string \u00e9rt\u00e9ke a Neptun k\u00f3dod 6 karaktere legyen. FONTOS Az \u00edgy m\u00f3dos\u00edtott adatokr\u00f3l kell k\u00e9perny\u0151k\u00e9pet k\u00e9sz\u00edteni, \u00edgy ez a l\u00e9p\u00e9s fontos. K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, amivel ellen\u0151rizhet\u0151, hogy l\u00e9tezik-e egy adott id-j\u00fa term\u00e9k. A lek\u00e9rdez\u00e9shez egy HEAD t\u00edpus\u00fa HTTP k\u00e9r\u00e9st fogunk k\u00fcldeni a /api/product/{id} URL-re. A v\u00e1lasz HTTP 200 vagy 404 legyen (extra tartalom/body n\u00e9lk\u00fcl, csak a v\u00e1laszk\u00f3d sz\u00fcks\u00e9ges). K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, ami egy term\u00e9ket ( Product ) ad vissza az id-ja alapj\u00e1n; a k\u00e9r\u00e9s GET t\u00edpus\u00fa legyen a /api/product/{id} c\u00edmre, \u00e9s a v\u00e1lasz vagy 200 legyen az adattal, vagy 404, ha nincs ilyen elem. K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, amivel lek\u00e9rdezhet\u0151, h\u00e1ny f\u00e9le term\u00e9k van \u00f6sszesen. (P\u00e9ld\u00e1ul a lapoz\u00e1st el\u0151seg\u00edtend\u0151 kisz\u00e1molhatja a frontend, hogy h\u00e1ny lap lesz.) Ez is egy GET t\u00edpus\u00fa k\u00e9r\u00e9s legyen a /api/product/-/count c\u00edmre. A visszaadott adat a CountResult oszt\u00e1ly p\u00e9ld\u00e1nya legyen kit\u00f6ltve a darabsz\u00e1mmal (term\u00e9szetesen JSON form\u00e1ban). Mi\u00e9rt van a /- r\u00e9sz az URL-ben? Ahhoz, hogy ezt meg\u00e9rts\u00fck, gondoljuk \u00e1t, mi lehene az URL: term\u00e9kek darabsz\u00e1m\u00e1ra vagyunk k\u00edv\u00e1ncsiak, teh\u00e1t /api/product/ , de ut\u00e1na mi? Lehetne /api/product/count . Viszont ez \"\u00f6sszekeveredik\" a /api/product/123 jelleg\u0171 URL-lel, ami egy konkr\u00e9t term\u00e9k lek\u00e9rdez\u00e9s\u00e9re szolg\u00e1l. A gyakorlatban a k\u00e9t URL egy\u00fctt tudna m\u0171k\u00f6dni, mert a term\u00e9k azonos\u00edt\u00f3 most sz\u00e1m, \u00edgy a keretrendszer felismeri, hogy ha /123 az URL v\u00e9ge, akkor a term\u00e9k ID-t v\u00e1r\u00f3 v\u00e9gpontot kell v\u00e9grehajtani, ha pedig /count az URL v\u00e9ge, akkor a sz\u00e1moss\u00e1got megad\u00f3t. De ez csak akkor m\u0171k\u00f6dik, ha az ID int. Ha sz\u00f6veg lenne a term\u00e9k azonos\u00edt\u00f3ja, probl\u00e9ma lenne. Ilyen esetekben olyan URL-t kell \"kital\u00e1lni\", ami nem \u00fctk\u00f6zik. A /- r\u00e9sz azt jelzi, hogy ott nem term\u00e9k azonos\u00edt\u00f3 utazik. Megjegyz\u00e9s: az URL - controller met\u00f3dus azonos\u00edt\u00e1s a fent le\u00edrtakn\u00e1l bonyolultabb a val\u00f3s\u00e1gban. Az ASP.NET Core keretrendszer priorit\u00e1s sorrendben illeszti a controller met\u00f3dusokat a be\u00e9rkez\u0151 k\u00e9r\u00e9sek URL-jeire. Ezt a priorit\u00e1st lehet\u0151s\u00e9g\u00fcnk van befoly\u00e1solni a [Http*] attrib\u00fatumok Order tulajdons\u00e1g\u00e1val . BEADAND\u00d3 A m\u00f3dos\u00edtott forr\u00e1sk\u00f3dot t\u00f6ltsd fel. Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Postman-b\u0151l (vagy m\u00e1s tesztel\u00e9shez haszn\u00e1lt eszk\u00f6zb\u0151l), amely egy sikeres term\u00e9k lek\u00e9r\u00e9s eredm\u00e9ny\u00e9t mutatja. A k\u00e9pen legyen l\u00e1that\u00f3 a k\u00e9r\u00e9s \u00e9s a v\u00e1lasz minden r\u00e9szlete (k\u00e9r\u00e9s t\u00edpusa, URL, v\u00e1lasz k\u00f3dja, v\u00e1lasz tartalma). A v\u00e1laszban a n\u00e9vben szerepelnie kell a Neptun k\u00f3dodnak . A k\u00e9pet f1.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!","title":"Feladat 1: Term\u00e9k m\u0171veletek (2 pluszpont)"},{"location":"hazi/rest/#feladat-2-openapi-dokumentacio-2-imsc-pont","text":"Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g. Az OpenAPI (kor\u00e1bbi nev\u00e9n Swagger) egy REST API dokument\u00e1ci\u00f3s eszk\u00f6z. C\u00e9lja hasonl\u00f3 a Web Service-ek eset\u00e9ben haszn\u00e1lt WSDL-hez: le\u00edrni az API szolg\u00e1ltat\u00e1sait egy standardiz\u00e1lt form\u00e1ban. A kor\u00e1bbi feladatok megold\u00e1sa ut\u00e1n k\u00e9sz\u00edts OpenAPI specifik\u00e1ci\u00f3t \u00e9s dokument\u00e1ci\u00f3t a REST API le\u00edr\u00e1s\u00e1hoz. A megold\u00e1shoz k\u00f6vesd a Microsoft hivatalos dokument\u00e1ci\u00f3j\u00e1t: https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-3.1&tabs=visual-studio Mindenk\u00e9ppen a Swashbuckle opci\u00f3t haszn\u00e1ld. A swagger.json -t az alkalmaz\u00e1s maga gener\u00e1lja (nem k\u00e9zzel kell meg\u00edrnod), \u00e9s a /swagger/v1/swagger.json c\u00edmen legyen el\u00e9rhet\u0151. \u00c1ll\u00edtsd be a Swagger UI -t is, ez a /neptun c\u00edmen legyen el\u00e9rhet\u0151. Ezt a UseSwaggerUI be\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l a RoutePrefix konfigur\u00e1l\u00e1s\u00e1val fogod tudni el\u00e9rni. A saj\u00e1t Neptun k\u00f3dod legyen a prefix csupa kisbet\u0171vel . (A \"Customize and extend\" r\u00e9sszel \u00e9s egy\u00e9b testreszab\u00e1ssal nem kell foglalkoznod.) Ind\u00edtsd el a webalkalmaz\u00e1st, \u00e9s n\u00e9zd meg a swagger.json -t http://localhost:5000/swagger/v1/swagger.json c\u00edmen, \u00e9s pr\u00f3b\u00e1ld ki a SwaggerUI-t a http://localhost:5000/neptun c\u00edmen. Pr\u00f3b\u00e1ld ki a SwaggerUI \"Try it out\" szolg\u00e1ltat\u00e1s\u00e1t: t\u00e9nyleg kik\u00fcldi a k\u00e9r\u00e9st a webalkalmaz\u00e1snak, \u00e9s l\u00e1tod a val\u00f3di v\u00e1laszt. BEADAND\u00d3 A m\u00f3dos\u00edtott forr\u00e1sk\u00f3dot t\u00f6ltsd fel. \u00dcgyelj r\u00e1, hogy a csproj f\u00e1jl is m\u00f3dosult a hozz\u00e1adott NuGet csomaggal! K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a b\u00f6ng\u00e9sz\u0151ben megjelen\u0151 Swagger UI-r\u00f3l. \u00dcgyelj r\u00e1, hogy az URL-ben l\u00e1that\u00f3 legyen, hogy a SwaggerUI-t a /neptun c\u00edmen szolg\u00e1lja ki a rendszer a saj\u00e1t Neptun k\u00f3doddal. A k\u00e9pet f2.png n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!","title":"Feladat 2: OpenAPI dokument\u00e1ci\u00f3 (2 iMsc pont)"},{"location":"jegyzet/architektura/","text":"Adatvez\u00e9relt rendszerek \u00e9s a t\u00f6bbr\u00e9teg\u0171 (h\u00e1romr\u00e9teg\u0171) architekt\u00fara \u00b6 Mit nevez\u00fcnk adatvez\u00e9relt alkalmaz\u00e1snak? \u00b6 Minden alkalmaz\u00e1s valamilyen m\u00f3don adatokat kezel, hiszen a sz\u00e1m\u00edt\u00f3g\u00e9p mem\u00f3ri\u00e1j\u00e1ban adatok vannak, \u00e9s a program ezeket manipul\u00e1lja. De m\u00e9gse minden alkalmaz\u00e1s adatvez\u00e9relt. Akkor h\u00edvunk egy alkalmaz\u00e1st adatvez\u00e9reltnek, ha a szoftver els\u0151dleges c\u00e9lja a tartalmazott adatok kezel\u00e9se. M\u00e1s sz\u00f3val, az adatvez\u00e9relt alkalmaz\u00e1s az\u00e9rt j\u00f6n l\u00e9tre, hogy adatokat t\u00e1roljon, megjelen\u00edtsen, manipul\u00e1ljon. A felhaszn\u00e1l\u00f3 az\u00e9rt l\u00e9p interakci\u00f3ba az alkalmaz\u00e1ssal, hogy az adatokhoz hozz\u00e1f\u00e9rjen. Egy sakkprogram eset\u00e9ben a t\u00e1bla \u00e1ll\u00e1sa mem\u00f3ri\u00e1ban tal\u00e1lhat\u00f3 adat. De a sakkprogram nem az\u00e9rt j\u00f6n l\u00e9tre, hogy ezt a mem\u00f3riabeli t\u00e1bl\u00e1t manipul\u00e1lja, hanem az\u00e9rt, hogy a j\u00e1t\u00e9kos sakkozzon. Egy adatvez\u00e9relt alkalmaz\u00e1sban az adat hat\u00e1rozza meg, hogy mik\u00e9nt m\u0171k\u00f6dik a szoftver. P\u00e9ld\u00e1ul az adat rekordok egyes attrib\u00fatumainak f\u00fcggv\u00e9ny\u00e9ben \u00e9rtelmezhet\u0151 egy t\u00f6rl\u00e9s m\u0171velet a rekordra, vagy sem. Egy hasonl\u00f3 p\u00e9lda, ahol az adat maga hat\u00e1rozza meg a rajta v\u00e9grehajthat\u00f3 m\u0171veleteket, a Neptun rendszerben a vizsgajelentkez\u00e9s. A f\u00e9l\u00e9vhez tartoz\u00f3 id\u0151szakok, bele\u00e9rtve, hogy mikor kezd\u0151dik a vizsgaid\u0151szak, maga is a Neptun rendszer adatai k\u00f6z\u00f6tt tal\u00e1lhat\u00f3. Ezen adat hat\u00e1rozza meg, hogy a felhaszn\u00e1l\u00f3 (hallgat\u00f3) tud-e egy vizsg\u00e1ra jelentkezni. Att\u00f3l, hogy egyik \u00e9vben m\u00e1skor kezd\u0151dik a vizsgaid\u0151szak, a program logik\u00e1ja (k\u00f3dja) nem v\u00e1ltozik meg, a szoftver m\u00e9gis k\u00e9pes m\u00e1shogyan viselkedni. P\u00e9lda adatvez\u00e9relt alkalmaz\u00e1sra \u00b6 A m\u00e1r eml\u00edtett Neptun rendszer egy tipikus adatvez\u00e9relt alkalmaz\u00e1s. C\u00e9lja az oktat\u00e1shoz kapcsol\u00f3d\u00f3 adatok, a kurzusok, jegyek, vizsg\u00e1k, stb. kezel\u00e9se. Egy m\u00e1sik p\u00e9lda a Gmail : az\u00e9rt l\u00e9tezik, hogy adatokat (itt: emailek, csatolm\u00e1nyok, kontaktok) kezeljen. Az alkalmaz\u00e1s minden funkci\u00f3ja ezen adatok kezel\u00e9s\u00e9r\u0151l, megjelen\u00edt\u00e9s\u00e9r\u0151l, manipul\u00e1l\u00e1s\u00e1r\u00f3l sz\u00f3l. Mindemellett, az adatokat hossz\u00fa t\u00e1von meg\u0151rzi, azaz minden m\u00f3dos\u00edt\u00e1s a rendszerben megmarad. Adatvez\u00e9relt rendszer fel\u00e9p\u00edt\u00e9se \u00b6 Vegy\u00fck a Gmail p\u00e9ld\u00e1j\u00e1t. Szeretn\u00e9nk egy olyan modern email rendszert \u00e9p\u00edteni, ahol lehet: emaileket k\u00fcldeni \u00e9s fogadni, van webes \u00e9s mobil fel\u00fclete is, a felhaszn\u00e1l\u00f3i fel\u00fclet t\u00f6bb nyelvet is t\u00e1mogat, tudunk f\u00e1jlokat csatolni a csatolm\u00e1nyokat ak\u00e1r Google Drive-r\u00f3l is tudjuk hivatkozni, tudjuk k\u00e9sleltetni egy email elk\u00fcld\u00e9s\u00e9t, stb. Gondoljuk v\u00e9gig Hogyan kezden\u00e9nk neki egy ilyen alkalmaz\u00e1s fejleszt\u00e9s\u00e9nek? Ez tal\u00e1n t\u00fal neh\u00e9z k\u00e9rd\u00e9s. Kezdj\u00fck egy egyszer\u0171bb k\u00e9rd\u00e9ssel: tegy\u00fck fel, hogy m\u00e1r majdnem minden r\u00e9sze m\u0171k\u00f6dik az alkalmaz\u00e1snak, csak \u00e9ppen a k\u00e9sleltetett email k\u00fcld\u00e9s hi\u00e1nyzik; ezt hogyan implement\u00e1ln\u00e1nk? P\u00e9ld\u00e1ul lehetne \u00fagy, hogy az email k\u00fcld\u00e9se gombra kattint\u00e1sn\u00e1l elind\u00edtunk egy id\u0151z\u00edt\u0151t, ami 1 perc m\u00falva ind\u00edtja csak az email k\u00fcld\u00e9st. Ez az\u00e9rt nem lesz j\u00f3 megold\u00e1s, mert ha k\u00f6zben bez\u00e1rjuk a web b\u00f6ng\u00e9sz\u0151t, akkor nem fog az id\u0151z\u00edt\u0151 lej\u00e1rni, \u00e9s nem lesz elk\u00fcldve az email. Helyette csin\u00e1lhatjuk \u00fagy, hogy r\u00f6gz\u00edtj\u00fck az email mellett, hogy mikor kell elk\u00fcldeni, \u00edgy ez az inform\u00e1ci\u00f3 is az email, mint kezelt adat r\u00e9sze lesz. Ezzel eld\u00f6nt\u00f6tt\u00fck, hogy nem a felhaszn\u00e1l\u00f3i fel\u00fclet feladata lesz a k\u00e9sleltetett email k\u00fcld\u00e9s. M\u00e9g nem tudjuk, hogy milyen alkalmaz\u00e1s komponensre b\u00edzzuk a feladatot, de nem a felhaszn\u00e1l\u00f3 fel\u00fcletre. Miel\u0151tt meg tudjuk v\u00e1laszolni a k\u00e9rd\u00e9st, hogy m\u00e9gis milyen komponensnek lesz a dolga az email j\u00f6v\u0151beli kik\u00fcld\u00e9se, n\u00e9zz\u00fcnk egy hasonl\u00f3 k\u00e9rd\u00e9st. A Gmail az email \u00e9rkez\u00e9s\u00e9nek idej\u00e9t magyar felhaszn\u00e1l\u00f3knak magyar szok\u00e1s szerint (pl. \"15:23\"), m\u00e1s nyelv\u0171 felhaszn\u00e1l\u00f3knak a saj\u00e1t preferenci\u00e1ik szerint jelen\u00edti meg (pl. \"3:23 PM\"). Ez azt jelenti, hogy az email, mint adat rekord t\u00f6bbf\u00e9le \u00e9rkez\u00e9si id\u0151vel rendelkezik? Nyilv\u00e1n nem. Az email \u00e9rkez\u00e9si ideje egyetlen d\u00e1tum, egy univerz\u00e1lis reprezent\u00e1ci\u00f3ban, \u00e9s csak akkor ker\u00fcl \u00e1talak\u00edt\u00e1sra, amikor megjelen\u00edti a felhaszn\u00e1l\u00f3 fel\u00fclet. Meg\u00e1llap\u00edtottuk teh\u00e1t, hogy vannak feladatok, amelyek a felhaszn\u00e1l\u00f3i fel\u00fclet felel\u0151ss\u00e9gi k\u00f6r\u00e9be tartoznak, \u00e9s vannak olyanok, amelyek nem. \u00cdgy \u00e9rkez\u00fcnk meg a t\u00f6bbr\u00e9get\u0171-, avagy h\u00e1romr\u00e9teg\u0171 architekt\u00far\u00e1hoz. A t\u00f6bbr\u00e9teg\u0171 (h\u00e1romr\u00e9teg\u0171) architekt\u00fara \u00b6 Adatvez\u00e9relt rendszereket tipikusan a t\u00f6bbr\u00e9teg\u0171-, avagy h\u00e1romr\u00e9teg\u0171 architekt\u00fara ( three-layered / three-tiered architecture ) szerint \u00e9p\u00edt\u00fcnk fel. Jelen kontextusban a k\u00e9t elnevez\u00e9st szinonimak\u00e9nt kezelj\u00fck. Ez az architekt\u00fara megk\u00fcl\u00f6nb\u00f6zteti az alkalmaz\u00e1s h\u00e1rom f\u0151 komponenscsal\u00e1dj\u00e1t, avagy r\u00e9teg\u00e9t: a megjelen\u00edt\u00e9si r\u00e9teget, az \u00fczleti logikai r\u00e9teget, \u00e9s az adatel\u00e9r\u00e9si r\u00e9teget. Ezen k\u00edv\u00fcl az architekt\u00far\u00e1hoz kapcsol\u00f3dik m\u00e9g: az adatb\u00e1zis, ill. k\u00fcls\u0151 adatforr\u00e1sok; \u00e9s az un. r\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok (l\u00e1sd k\u00e9s\u0151bb). Az alkalmaz\u00e1sunkat \u00fagy szervezz\u00fck meg, hogy az egyes komponensek (szoftver elemek) r\u00e9tegekbe szervez\u0151dnek, \u00e9s minden egyes r\u00e9teg m\u00e1s-m\u00e1s funkcionalit\u00e1s\u00e9rt felel. Ez a logikai szervez\u00e9s megk\u00f6nny\u00edti a szoftverfejleszt\u0151k munk\u00e1j\u00e1t az\u00e1ltal, hogy egy\u00e9rtelm\u0171 felel\u0151ss\u00e9gi k\u00f6r\u00f6ket \u00e9s hat\u00e1rokat jel\u00f6l ki a r\u00e9tegekben. Mi\u00e9rt t\u00f6bbr\u00e9teg\u0171, hiszen csak h\u00e1rom r\u00e9tege van Az elnevez\u00e9s arra utal, hogy mindegyik r\u00e9teg maga is tov\u00e1bb bonthat\u00f3 tov\u00e1bbi r\u00e9tegekre az alkalmaz\u00e1s komplexit\u00e1s\u00e1nak f\u00fcggv\u00e9ny\u00e9ben. Att\u00f3l t\u00f6bbr\u00e9teg\u0171 az architekt\u00fara, hogy kett\u0151n\u00e9l t\u00f6bb r\u00e9tege van. (\u00cdgy szembe\u00e1ll\u00edtva a k\u00e9tr\u00e9teg\u0171 architekt\u00far\u00e1val , ahol a felhaszn\u00e1l\u00f3i fel\u00fclet \u00e9s az \u00fczleti logikai r\u00e9teg nem v\u00e1lik el.) Az egyes r\u00e9tegek nem csak saj\u00e1t felel\u0151ss\u00e9gi k\u00f6rrel rendelkeznek, hanem egyben meghat\u00e1rozz\u00e1k azt az interf\u00e9szt , amit a r\u00e1\u00e9p\u00fcl\u0151 r\u00e9tegek haszn\u00e1lhatnak. Az adatel\u00e9r\u00e9si r\u00e9teg defini\u00e1lja, milyen m\u0171veleteken kereszt\u00fcl \u00e9rhet\u0151 el az \u00fczleti logikai r\u00e9teg sz\u00e1m\u00e1ra; az \u00fczleti logikai r\u00e9teg hasonl\u00f3an defini\u00e1lja az interf\u00e9sz\u00e9t a megjelen\u00edt\u00e9si r\u00e9teg fel\u00e9. Ennek megfelel\u0151en minden r\u00e9teg csak az alatta lev\u0151vel kommunik\u00e1l (\u00edgy teh\u00e1t a prezent\u00e1ci\u00f3s r\u00e9teg nem ad ki pl. SQL lek\u00e9rdez\u00e9st az adatb\u00e1zis fel\u00e9), valamint a r\u00e9tegek \u00e1ltal defini\u00e1lt interf\u00e9sz m\u00f6g\u00f6tt az implement\u00e1ci\u00f3 cser\u00e9lhet\u0151v\u00e9 v\u00e1lik, \u00edgy el\u0151seg\u00edtve az alkalmaz\u00e1s hossz\u00fa karbantarthat\u00f3s\u00e1g\u00e1t. A r\u00e9tegek sz\u00e9tv\u00e1laszt\u00e1s\u00e1nak k\u00f6sz\u00f6nhet\u0151en az is gyakori, hogy az alkalmaz\u00e1sunk nem egy helyen, hanem a r\u00e9tegek ment\u00e9n t\u00f6bb kiszolg\u00e1l\u00f3n fut. Leggyakoribb esete ennek a megjelen\u00edt\u00e9si r\u00e9teg lev\u00e1laszt\u00e1sa, amely p\u00e9ld\u00e1ul egy webalkalmaz\u00e1s eset\u00e9n a felhaszn\u00e1l\u00f3 sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n a b\u00f6ng\u00e9sz\u0151ben fut, m\u00edg a t\u00f6bbi komponens a t\u00e1voli kiszolg\u00e1l\u00f3n tal\u00e1lhat\u00f3. Hasonl\u00f3an gyakori, hogy az adatr\u00e9teg (pl. adatb\u00e1zis) egy saj\u00e1t kiszolg\u00e1l\u00f3t kap teljes\u00edt\u00e9ny okokb\u00f3l. Am\u00edg a r\u00e9tegek k\u00f6z\u00f6tti interf\u00e9szek v\u00e1ltozatlanok maradnak, a r\u00e9tegek ak\u00e1r kiszolg\u00e1l\u00f3k k\u00f6z\u00f6tt is mozgathat\u00f3ak. Ennek tipikus oka a teljes\u00edtm\u00e9ny-optimaliz\u00e1l\u00e1s \u00e9s a nagy terhel\u00e9sek kiszolg\u00e1l\u00e1s\u00e1nak el\u0151seg\u00edt\u00e9se (pl. forgalmas webhelyek eset\u00e9ben). Layer / tier Az architekt\u00fara angol elnevez\u00e9se megk\u00fcl\u00f6nb\u00f6zteti a logikai \u00e9s fizikai elv\u00e1laszt\u00e1st. A three-layered elnevez\u00e9sben a r\u00e9tegek logikailag k\u00fcl\u00f6nv\u00e1lnak, de azonos kiszolg\u00e1l\u00f3n futnak. A three-tiered azonban a r\u00e9tegek ( tier ) ment\u00e9n fizikai elv\u00e1laszt\u00e1s\u00e1ra, k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon val\u00f3 fut\u00e1sra is utal. Egy j\u00f3 architekt\u00far\u00e1val rendelkez\u0151 alkalmaz\u00e1s hossz\u00fa \u00e9letciklusa sor\u00e1n is karbantarthat\u00f3 marad. A r\u00e9tegez\u00e9s nem plusz teherk\u00e9nt, betartand\u00f3 szab\u00e1lyok halmazak\u00e9nt, hanem mank\u00f3k\u00e9nt seg\u00edti a fejleszt\u0151ket a k\u00f3d fejleszt\u00e9s\u00e9ben. Ez\u00e9rt egy t\u00f6bbr\u00e9teg\u0171 alkalmaz\u00e1s fejleszt\u00e9se sor\u00e1n fontos, hogy pontosan \u00e9rts\u00fck, mely r\u00e9tegek milyen felel\u0151ss\u00e9gekkel rendelkeznek, \u00e9s milyen feladok tartoznak hozz\u00e1juk. A r\u00e9teges fel\u00e9p\u00edt\u00e9s nem azt jelenti, hogy a felhaszn\u00e1l\u00f3k \u00e1ltal haszn\u00e1lt funkci\u00f3k csak egy-egy r\u00e9tegben jelennek meg. A legt\u00f6bb funkci\u00f3 valamilyen m\u00f3don az \u00f6sszes r\u00e9tegben megjelenik: a funkci\u00f3hoz tartozik felhaszn\u00e1l\u00f3i fel\u00fclet, valamilyen adatkezel\u00e9s az \u00fczleti logik\u00e1ban, \u00e9s az eredm\u00e9ny ment\u00e9sre ker\u00fcl az adatb\u00e1zisba. A t\u00f6bbr\u00e9teg\u0171 architekt\u00far\u00e1val k\u00e9sz\u00fcl\u0151 alkalmaz\u00e1sok k\u00f3d szervez\u00e9se is t\u00fckr\u00f6zi a r\u00e9tegek fel\u00e9p\u00edt\u00e9s\u00e9t. Az adott programoz\u00e1si k\u00f6rnyezet lehet\u0151s\u00e9geit \u00e9s szok\u00e1sait figyelembe v\u00e9ve az egyes r\u00e9tegeket k\u00fcl\u00f6n projektekbe, csomagokba szok\u00e1s elhelyezni. Ez egy\u00e9rtelm\u0171v\u00e9 teszi az egym\u00e1sra \u00e9p\u00fcl\u00e9st is, hiszen a projektek \u00e9s csomagok k\u00f6z\u00f6tt \u00e1ltal\u00e1ban csak egyir\u00e1ny\u00fa hivatkoz\u00e1s lehets\u00e9ges (teh\u00e1t ha az \u00fczleti logikai csomag haszn\u00e1lja az adatel\u00e9r\u00e9si r\u00e9teget, akkor ford\u00edtva ez m\u00e1r nem t\u00f6rt\u00e9nhet meg). A t\u00f6bbr\u00e9teg\u0171 architekt\u00fara nem az egyetlen lehet\u0151s\u00e9g adatvez\u00e9relt alkalmaz\u00e1s megval\u00f3s\u00edt\u00e1sa eset\u00e9n. Kis, egyszer\u0171 alkalmaz\u00e1sokra c\u00e9lszer\u0171 lehet a k\u00e9tr\u00e9teg\u0171 architekt\u00fara, m\u00edg sokkal komplexebb rendszerek eset\u00e9n az alkalmaz\u00e1s tov\u00e1bbi darabol\u00e1sa is sz\u00fcks\u00e9ges lehet p\u00e9ld\u00e1ul un. mikroszolg\u00e1ltat\u00e1sok architekt\u00fara ir\u00e1ny\u00e1ba l\u00e9pve. A t\u00f6bbr\u00e9teg\u0171 architekt\u00fara r\u00e9tegeinek felel\u0151ss\u00e9ge \u00b6 Vizsg\u00e1ljuk meg alaposabban a r\u00e9tegeket, \u00e9s feladataikat, felel\u0151ss\u00e9geiket. Az architekt\u00fara r\u00e9szletesebben kifejtve az al\u00e1bbi elemeket tartalmazza. (A k\u00e9p forr\u00e1sa: Microsoft Application Architecture Guide, 2 nd Edition, https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ee658109%28v%3dpandp.10%29 ) A r\u00e9tegeken \"lentr\u0151l felfel\u00e9\" haladunk v\u00e9gig. Az adatforr\u00e1sok \u00b6 A leggyakoribb adatforr\u00e1s az adatb\u00e1zis . Ez lehet rel\u00e1ci\u00f3s, vagy ak\u00e1r NoSQL adatb\u00e1zis is. Feladata az adataink hossz\u00fa t\u00e1von megmarad\u00f3 \u00e9s megb\u00edzhat\u00f3 (un. \"perzisztens\") t\u00e1rol\u00e1sa. Tipikusan ez az adatb\u00e1zis egy megb\u00edzhat\u00f3 gy\u00e1rt\u00f3t\u00f3l sz\u00e1rmaz\u00f3 szoftver, amely egy k\u00fcl\u00f6n erre a c\u00e9lra \u00fczemeltetett kiszolg\u00e1l\u00f3n fut, \u00edgy az adatel\u00e9r\u00e9si r\u00e9teg h\u00e1l\u00f3zaton kereszt\u00fcl \u00e9ri el. El\u0151fordulhat az is, hogy a rendszer \u00e1ltal kezelt adatok nem mind a saj\u00e1t adatb\u00e1zisunkban tal\u00e1lhat\u00f3ak, hanem olyan m\u00e1s k\u00fcls\u0151 szolg\u00e1ltat\u00e1sokban , amelyeket \"adatb\u00e1zisk\u00e9nt\" haszn\u00e1lunk. P\u00e9ld\u00e1ul a Gmail eset\u00e9n f\u00e1jl csatolm\u00e1nyok t\u00e1rolhat\u00f3ak az emailekkel egy\u00fctt egy adatb\u00e1zisban, de lehet\u0151s\u00e9g\u00fcnk van Google Drive-r\u00f3l is csatolni f\u00e1jlokat. A Gmail ilyenkor a Google Drive-r\u00f3l let\u00f6lti az el\u00e9rhet\u0151 f\u00e1jlok list\u00e1j\u00e1t, hogy a felhaszn\u00e1l\u00f3 kiv\u00e1lassza a csatoland\u00f3 mell\u00e9kletet. A Google Drive nem adatb\u00e1zis, m\u00e9gis, a haszn\u00e1lat szempontj\u00e1b\u00f3l adatforr\u00e1sk\u00e9nt m\u0171k\u00f6dik. Az ilyen jelleg\u0171 k\u00fcls\u0151 szolg\u00e1ltat\u00e1sokat az\u00e9rt az adatb\u00e1zisok mellett helyezz\u00fck el k\u00e9pzeletben, mert a mi alkalmaz\u00e1sunk sz\u00e1m\u00e1ra csak adatokat szolg\u00e1ltatnak (pl. list\u00e1zd az el\u00e9rhet\u0151 f\u00e1jlokat). A bels\u0151 m\u0171k\u00f6d\u00e9s\u00fckbe nem l\u00e1tunk bele, \u00e9s nem is c\u00e9lunk azt meg\u00e9rteni. Ilyen szempontb\u00f3l nem nagy a k\u00fcl\u00f6nbs\u00e9g egy rel\u00e1ci\u00f3s adatb\u00e1zis \u00e9s egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1s k\u00f6z\u00f6tt. Ma m\u00e1r t\u00f6bb modern adatb\u00e1zis-kezel\u0151 rendszer is gyakran rendelkeznek a k\u00fcls\u0151 szolg\u00e1ltat\u00e1sok el\u00e9r\u00e9s\u00e9hez haszn\u00e1lt HTTP/REST-jelleg\u0171 interf\u00e9sszel, \u00e9s nem SQL nyelven kell vel\u00fck kommunik\u00e1lni. \u00cdgy egyre kevesebb a k\u00fcl\u00f6nbs\u00e9g egy adatb\u00e1zis \u00e9s egy k\u00fcls\u0151 adatforr\u00e1s k\u00f6z\u00f6tt. Adatel\u00e9r\u00e9si r\u00e9teg \u00b6 Az adatel\u00e9r\u00e9si r\u00e9teg ( data access layer , r\u00f6viden DAL ) feladata az adatforr\u00e1sok k\u00e9nyelmes el\u00e9r\u00e9s\u00e9nek biztos\u00edt\u00e1sa. F\u0151 funkci\u00f3ja az elemi adatszolg\u00e1ltat\u00e1si m\u0171veletek biztos\u00edt\u00e1sa, mint egy \u00faj rekord t\u00e1rol\u00e1sa, meglev\u0151 m\u00f3dos\u00edt\u00e1sa vagy t\u00f6rl\u00e9se. Az adatforr\u00e1sokat \u00e9s az adatel\u00e9r\u00e9si r\u00e9teget szok\u00e1s m\u00e9g egyben adatr\u00e9tegnek ( data layer ) is nevezni. Az adatb\u00e1zisok el\u00e9r\u00e9s\u00e9hez sz\u00fcks\u00e9ges funkcionalit\u00e1sokat az \u00fan. data access components -ek val\u00f3s\u00edtj\u00e1k meg. C\u00e9ljuk, hogy elrejts\u00e9k a komplexit\u00e1st, ami az adatb\u00e1zis kezel\u00e9s\u00e9b\u0151l ad\u00f3dik, \u00e9s k\u00f6zpontilag k\u00e9nyelmes, a fels\u0151bb r\u00e9teg sz\u00e1m\u00e1ra egyszer\u0171en haszn\u00e1lhat\u00f3 szolg\u00e1ltat\u00e1sk\u00e9nt ny\u00fajts\u00e1k az adatt\u00e1rol\u00e1st . Ide tartozik p\u00e9ld\u00e1ul az SQL parancsok kezel\u00e9se, valamint az adatb\u00e1zis t\u00e1rol\u00e1si modellj\u00e9nek lek\u00e9pz\u00e9se az \u00fczleti logika sz\u00e1m\u00e1ra is k\u00e9nyelmesen haszn\u00e1lhat\u00f3 m\u00f3don. Amennyiben az adatok nem egy adatb\u00e1zisban, hanem egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1sban tal\u00e1lhat\u00f3ak, a service agent -ek feladata a k\u00fcls\u0151 rendszerrel val\u00f3 kommunik\u00e1ci\u00f3 kezel\u00e9se. Ebben a r\u00e9tegben tal\u00e1lhat\u00f3 komponensek \u00e1ltal\u00e1ban egy konkr\u00e9t technol\u00f3gia k\u00f6r\u00e9 csoportosulnak, p\u00e9ld\u00e1ul a v\u00e1lasztott adatb\u00e1zis-kezel\u0151 rendszer el\u00e9r\u00e9s\u00e9hez haszn\u00e1lt technol\u00f3gia (mint az ADO.NET, Entity Framework, vagy JDBC, JPA, stb.). Az itt megval\u00f3s\u00edtott logik\u00e1k gyakran szorosan csatol\u00f3dnak az adatkezel\u00e9si technol\u00f3gi\u00e1kkal. Fontos azonban, hogy ez a platform specifikuss\u00e1g ne sziv\u00e1rogjon ki ebb\u0151l a r\u00e9tegb\u0151l. Fontos Egy j\u00f3l megtervezett rendszerben SQL lek\u00e9rdez\u00e9sek csak az adatel\u00e9r\u00e9si r\u00e9tegben jelennek meg, a t\u00f6bbi r\u00e9teg semmilyen k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt nem \u00e1ll\u00edt \u00f6ssze SQL lek\u00e9rdez\u00e9st. Mivel az adatb\u00e1zisban val\u00f3 t\u00e1rol\u00e1s gondolkod\u00e1sm\u00f3dja (tipikusan a rel\u00e1ci\u00f3s s\u00e9ma), valamint az objektumorient\u00e1lt modellez\u00e9s nem egy az egyben fedik egym\u00e1st, ez\u00e9rt ennek a r\u00e9tegnek a feladata a k\u00e9t vil\u00e1g k\u00f6z\u00f6tti lek\u00e9pez\u00e9s \u00e9s megfeleltet\u00e9s megval\u00f3s\u00edt\u00e1sa. A rel\u00e1ci\u00f3s adatb\u00e1zisokban haszn\u00e1lt k\u00fcls\u0151 kulcsokat ( foreign key ) objektumorient\u00e1lt asszoci\u00e1ci\u00f3kra, kompoz\u00edci\u00f3kra alak\u00edtjuk, valamint ha sz\u00fcks\u00e9ges, konvert\u00e1l\u00e1st v\u00e9gz\u00fcnk a k\u00fcl\u00f6nb\u00f6z\u0151 rendszerek \u00e1ltal t\u00e1mogatott adatt\u00edpusok k\u00f6z\u00f6tt. Err\u0151l a feladatr\u00f3l a k\u00e9s\u0151bbeikben m\u00e9g r\u00e9szletesebben ejt\u00fcnk sz\u00f3t. A k\u00fcls\u0151 rendszerekkel val\u00f3 kommunik\u00e1ci\u00f3, ak\u00e1r egy adatb\u00e1zis-kezel\u0151 rendszerr\u0151l, ak\u00e1r egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1sr\u00f3l van sz\u00f3, saj\u00e1tos kezel\u00e9stechnik\u00e1t ig\u00e9nyel. Teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l nem mindegy, hogy a t\u00e1voli kiszolg\u00e1l\u00f3 megsz\u00f3l\u00edt\u00e1sa, a kapcsolat fel\u00e9p\u00edt\u00e9se mikor \u00e9s milyen gyakran t\u00f6rt\u00e9nik. Egyes kapcsolatfelv\u00e9teli m\u00f3dok, mint p\u00e9ld\u00e1ul a HTTP (\u00e9s alatta a TCP) kapcsolat fel\u00e9p\u00edt\u00e9se tipikusan egyszer\u0171 \u00e9s gyors; m\u00edg egy rel\u00e1ci\u00f3s adatb\u00e1zis szerverhez t\u00f6rt\u00e9n\u0151 csatlakoz\u00e1s hosszabb folyamat. \u00cdgy az adatel\u00e9r\u00e9si r\u00e9teg felel az\u00e9rt is, hogy megfelel\u0151 m\u00f3don kezelje a kapcsolatokat , \u00e9s ha lehets\u00e9ges, \u00fajra haszn\u00e1lja a kapcsolatokat ( connection pooling ). Ezt a m\u0171k\u00f6d\u00e9st \u00e1ltal\u00e1ban a j\u00f3l megv\u00e1lasztott kliens k\u00f6nyvt\u00e1rak automatikusan biztos\u00edtj\u00e1k is. Hasonl\u00f3an r\u00e9teg specifikus feladat az adatok konkurens el\u00e9r\u00e9s\u00e9nek \u00e9s m\u00f3dos\u00edt\u00e1s\u00e1nak kezel\u00e9se. Ezzel r\u00e9szletesen foglalkozunk k\u00e9s\u0151bb. Egyel\u0151re annyit \u00e9rdemes megjegyezni err\u0151l, hogy a t\u00f6bbr\u00e9teg\u0171 alkalmaz\u00e1st tipikusan egyszerre t\u00f6bb felhaszn\u00e1l\u00f3 haszn\u00e1lja (gondoljunk csak bele a Neptun rendszerbe, vagy egy webshop m\u0171k\u00f6d\u00e9s\u00e9be), \u00edgy el\u0151fordulhat, hogy egyszerre t\u00f6bben m\u00f3dos\u00edtan\u00e1nak a rendszerben. Ennek szab\u00e1lyait, hogy milyen m\u00f3dos\u00edt\u00e1sok enged\u00e9lyezettek, \u00e9s mik nem, a konkurenciakezel\u00e9s t\u00e9mak\u00f6r\u00e9ben fogjuk t\u00e1rgyalni. \u00dczleti logikai r\u00e9teg \u00b6 Az \u00fczleti logikai r\u00e9teg adja az alkalmaz\u00e1sunk lelk\u00e9t. Az adatt\u00e1rol\u00e1s, az adatel\u00e9r\u00e9s, \u00e9s a megjelen\u00edt\u00e9s is mind az\u00e9rt sz\u00fcletik, hogy az \u00fczleti logikai r\u00e9tegben lefektetett funkcionalit\u00e1sokat ny\u00fajtani tudjuk. Hogy pontosan milyen funkci\u00f3kat ny\u00fajt ez a r\u00e9teg, annak f\u00fcggv\u00e9ny\u00e9ben alak\u00edtjuk ki, hogy milyen alkalmaz\u00e1sr\u00f3l van sz\u00f3. Ha a Neptun rendszert tervezz\u00fck, akkor vizsgajelentkez\u00e9sr\u0151l, t\u00e1rgyfelv\u00e9telr\u0151l, tanulm\u00e1nyi id\u0151szakokr\u00f3l fog sz\u00f3lni a r\u00e9teg; ha egy webshopot tervez\u00fcnk, akkor term\u00e9kek, keres\u00e9s, \u00e9rt\u00e9kel\u00e9s, v\u00e1s\u00e1rl\u00e1s lesz a k\u00f6z\u00e9ppontban. \u00c1ltal\u00e1nosan ebben a r\u00e9tegben \u00fczleti entit\u00e1sok ( business entities ), \u00fczleti komponensek ( business components ), \u00e9s \u00fczleti folyamatok ( business workflows ) tal\u00e1lhat\u00f3ak. Az entit\u00e1sok hordozz\u00e1k a kezelt inform\u00e1ci\u00f3kat. A probl\u00e9mater\u00fclet f\u00fcggv\u00e9ny\u00e9ben olyan entit\u00e1sokat defini\u00e1lunk, mint a term\u00e9k \u00e9s \u00e9rt\u00e9kel\u00e9s (egy webshopban), vagy a kurzus \u00e9s a vizsga (a Neptunban). Az entit\u00e1sok manipul\u00e1l\u00e1s\u00e1\u00e9rt felelnek a komponensek. Ezek olyan alapszolg\u00e1ltat\u00e1sokat implement\u00e1lnak, amelyek az alkalmaz\u00e1sunk \u00e1ltal megval\u00f3s\u00edtott bonyolult funkci\u00f3k alap \u00e9p\u00edt\u0151k\u00f6veit adj\u00e1k. Ilyen funkci\u00f3 lehet p\u00e9ld\u00e1ul a term\u00e9kek list\u00e1z\u00e1sa, vagy a n\u00e9v alapj\u00e1n t\u00f6rt\u00e9n\u0151 keres\u00e9s. Ezen alap funkci\u00f3kb\u00f3l \u00e9p\u00edtj\u00fck fel a folyamatokat. A folyamatok a v\u00e9gfelhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra fontos m\u0171veleteket fogj\u00e1k \u00f6ssze. Egy folyamat \u00e1ltal\u00e1ban t\u00f6bb komponens t\u00f6bb m\u0171velet\u00e9t haszn\u00e1lja. Ilyen folyamat p\u00e9ld\u00e1ul a rendel\u00e9s v\u00e9gleges\u00edt\u00e9se ( checkout ) egy webshopban, amely ellen\u0151rzi a term\u00e9keket, ki\u00e1ll\u00edtja a sz\u00e1ml\u00e1t, elk\u00fcldi a meger\u0151s\u00edt\u00e9st emailben, stb. Szolg\u00e1ltat\u00e1si interf\u00e9sz alr\u00e9teg \u00b6 A fenti \u00e1br\u00e1n megk\u00fcl\u00f6nb\u00f6ztet\u00e9sre ker\u00fclt a services alr\u00e9teg. Ezt az \u00fczleti logikai r\u00e9teg r\u00e9sz\u00e9nek tekintj\u00fck, annak legfels\u0151 alr\u00e9tege. Feladata a k\u00fcls\u0151 h\u00edv\u00f3 sz\u00e1m\u00e1ra interf\u00e9szt biztos\u00edtani az \u00fczleti logikai r\u00e9teg funkcionalit\u00e1s\u00e1nak el\u00e9r\u00e9s\u00e9hez. Minden eddig t\u00e1rgyalt r\u00e9teg ugyan\u00edgy biztos\u00edt egy interf\u00e9szt a fels\u0151bb r\u00e9tegek sz\u00e1m\u00e1ra. Az \u00fczleti logikai r\u00e9teg az\u00e9rt speci\u00e1lis, \u00e9s az\u00e9rt szok\u00e1s ezt a szolg\u00e1ltat\u00e1si interf\u00e9sz alr\u00e9teget k\u00fcl\u00f6n megeml\u00edteni, mert manaps\u00e1g gyakran nem is egyetlen ilyen interf\u00e9szt publik\u00e1lnak az alkalmaz\u00e1sok. Gyakori, hogy egy alkalmaz\u00e1s t\u00f6bb megjelen\u00edt\u00e9si r\u00e9teggel is rendelkezik, gondolunk csak bele a Gmail eset\u00e9be: webalkalmaz\u00e1s, \u00e9s sok f\u00e9le mobil platform. Mindegyik felhaszn\u00e1l\u00f3i fel\u00fclet hasonl\u00f3, de nem teljesen azonos szolg\u00e1ltat\u00e1st ny\u00fajt, \u00edgy gyakran elk\u00fcl\u00f6n\u00fclnek a k\u00fcl\u00f6nb\u00f6z\u0151 megjelen\u00edt\u00e9si r\u00e9tegek sz\u00e1m\u00e1ra ny\u00fajtott interf\u00e9szek. Tov\u00e1bbi gyakori eset, hogy az alkalmaz\u00e1sunk nem csak egy saj\u00e1t megjelen\u00edt\u00e9si r\u00e9teggel rendelkezik, hanem un. API-t ( application programming interface ) is el\u00e9rhet\u0151v\u00e9 tesz. Az API harmadik f\u00e9l sz\u00e1m\u00e1ra teszi el\u00e9rhet\u0151v\u00e9 az alkalmaz\u00e1sunk funkci\u00f3it. A saj\u00e1t felhaszn\u00e1l\u00f3i fel\u00fclet\u00fcnk, \u00e9s a harmadik f\u00e9l sz\u00e1m\u00e1ra ny\u00fajtott API funkcionalit\u00e1sa \u00e9s el\u00e9r\u00e9se gyakran elt\u00e9r\u0151, \u00e9s k\u00fcl\u00f6n technol\u00f3gi\u00e1t, \u00edgy k\u00fcl\u00f6n szolg\u00e1ltat\u00e1si interf\u00e9szeket is ig\u00e9nyel. Az API publik\u00e1l\u00e1ssal v\u00e1lhat a mi alkalmaz\u00e1sunk maga is k\u00fcls\u0151 adatforr\u00e1ss\u00e1 m\u00e1s alkalmaz\u00e1sok sz\u00e1m\u00e1ra. Az \u00fczleti logikai funkci\u00f3ink publik\u00e1l\u00e1s\u00e1val r\u00e9szletesebben foglalkozunk a f\u00e9l\u00e9v sor\u00e1n. Meg fogjuk ismerni a web services \u00e9s a REST modelleket. Megjelen\u00edt\u00e9si r\u00e9teg \u00b6 A megjelen\u00edt\u00e9si r\u00e9teg ( presentation layer , UI , vagy felhaszn\u00e1l\u00f3i fel\u00fclet) feladata az adatok felhaszn\u00e1l\u00f3bar\u00e1t megjelen\u00edt\u00e9se, \u00e9s a lehets\u00e9ges m\u0171veletek kezdem\u00e9nyez\u00e9s\u00e9nek lehet\u0151v\u00e9 t\u00e9tele. Az adatok prezent\u00e1l\u00e1sa olyan m\u00f3don kell t\u00f6rt\u00e9njen, ahogy az a felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra hasznos. P\u00e9ld\u00e1ul egy list\u00e1s megjelen\u00edt\u00e9s eset\u00e9n gyakran a felhaszn\u00e1l\u00f3i fel\u00fclet feladata a rendez\u00e9s, csoportos\u00edt\u00e1s, kereshet\u0151s\u00e9g. Rendez\u00e9s \u00e9s keres\u00e9s A v\u00e1lasztott technol\u00f3gia f\u00fcggv\u00e9ny\u00e9ben a rendez\u00e9s, keres\u00e9s tipikusan ig\u00e9nybe veszi a t\u00f6bbi r\u00e9teget is. Nagy mennyis\u00e9g\u0171 adat, t\u00f6bb sz\u00e1z, vagy t\u00f6bb ezer rekordot nem c\u00e9lszer\u0171 egyben eljuttatni a megjelen\u00edt\u00e9si r\u00e9teg sz\u00e1m\u00e1ra, hogy ott legyen a keres\u00e9s megval\u00f3s\u00edtva. Ez egyr\u00e9szt terheli a h\u00e1l\u00f3zatot is, m\u00e1sr\u00e9szt a UI technol\u00f3gi\u00e1k limit\u00e1ci\u00f3i miatt nem hat\u00e9kony sok adatot itt mem\u00f3ri\u00e1ban tartani. Viszont, ha nem nagy mennyis\u00e9g\u0171 adatr\u00f3l van sz\u00f3, sokkal eleg\u00e1nsabb a megjelen\u00edt\u00e9si r\u00e9tegre b\u00edzni mindezt, mert sokkal gyorsabb lesz a visszajelz\u00e9s a felhaszn\u00e1l\u00f3nak (hiszen ha mindezt a UI v\u00e9gzi, nem sz\u00fcks\u00e9ges minden alkalommal a h\u00e1tt\u00e9rrendszerhez fordulni). Az adatok megjelen\u00edt\u00e9se sor\u00e1n a UI felel\u0151s olyan egyszer\u0171 transzform\u00e1ci\u00f3k\u00e9rt is, mint p\u00e9ld\u00e1ul a d\u00e1tum felhaszn\u00e1l\u00f3bar\u00e1t megjelen\u00edt\u00e9se. A kor\u00e1bban eml\u00edtett p\u00e9lda alapj\u00e1n teh\u00e1t egy d\u00e1tumot a felhaszn\u00e1l\u00f3i fel\u00fclet feladata a \"15:23\", 3:23 AM\", vagy ak\u00e1r a \"15 perccel ezel\u0151tt\" sz\u00f6veges megjelen\u00edt\u00e9sre \u00e1talak\u00edtani. Tov\u00e1bb\u00e1, a felhaszn\u00e1l\u00f3i fel\u00fclet feladata az un. lokaliz\u00e1ci\u00f3 is. A lokaliz\u00e1ci\u00f3 a UI felhaszn\u00e1l\u00f3 \u00e1ltal v\u00e1lasztott nyelven val\u00f3 megjelen\u00edt\u00e9se, amely kiterjed a statikus sz\u00f6vegekre, feliratokra is, de egyben a kult\u00fara f\u00fcgg\u0151 adat transzform\u00e1ci\u00f3kra is (mint a d\u00e1tumok, sz\u00e1mok, p\u00e9nznemek megjelen\u00edt\u00e9se is). A felhaszn\u00e1l\u00f3i fel\u00fclet felel m\u00e9g a v\u00e9gfelhaszn\u00e1l\u00f3 interakci\u00f3inak kezel\u00e9s\u00e9\u00e9rt. Ha egy gombra kattintottak, akkor a UI kezdem\u00e9nyezi a k\u00e9rt funkci\u00f3 v\u00e9grehajt\u00e1s\u00e1t, \u00e9s t\u00e1j\u00e9koztatja a v\u00e9geredm\u00e9nyr\u0151l a felhaszn\u00e1l\u00f3t. Amikor a felhaszn\u00e1l\u00f3 adatot visz be a rendszerbe, azt is a felhaszn\u00e1l\u00f3i fel\u00fclet biztos\u00edtja, \u00e9s ez a r\u00e9teg felel az adatok valid\u00e1ci\u00f3j\u00e1\u00e9rt (ellen\u0151rz\u00e9s\u00e9\u00e9rt) is. A valid\u00e1ci\u00f3 sor\u00e1n egyszer\u0171bb ellen\u0151rz\u00e9sek hajthat\u00f3k v\u00e9gre, mint p\u00e9ld\u00e1ul, hogy a sz\u00fcks\u00e9ges mez\u0151k nem maradhatnak \u00fcresen, az email c\u00edmben kell legyen @ karakter, a megadott percnek 0 \u00e9s 59 k\u00f6z\u00e9 kell esnie, stb. Valid\u00e1ci\u00f3 A valid\u00e1ci\u00f3t nem el\u00e9g, ha kiz\u00e1r\u00f3lag a felhaszn\u00e1l\u00f3i fel\u00fclet v\u00e9gzi. A v\u00e1lasztott technol\u00f3gi\u00e1t\u00f3l f\u00fcgg\u0151en a UI k\u00f6nnyen \"kiker\u00fclhet\u0151\", \u00e9s lehet\u0151s\u00e9g van az adatokat k\u00f6zvetlen\u00fcl a h\u00e1tt\u00e9rrendszernek k\u00fcldeni. Ilyen esetben, ha a valid\u00e1ci\u00f3t csak a felhaszn\u00e1l\u00f3 fel\u00fclet val\u00f3s\u00edtan\u00e1 meg, \u00e9rv\u00e9nytelen adat ker\u00fclhetne a rendszerbe. Ez\u00e9rt a valid\u00e1ci\u00f3kat tipikusan megism\u00e9tli a h\u00e1tt\u00e9rrendszer is. Ennek ellen\u00e9re praktikus ezeket a felhaszn\u00e1l\u00f3i fel\u00fcleten is elv\u00e9gezni, mert azonnali visszajelz\u00e9st tudunk \u00edgy adni a felhaszn\u00e1l\u00f3nak. A r\u00e9teggel enn\u00e9l r\u00e9szleteseben nem foglalkozunk ezen t\u00e1rgy keretei k\u00f6z\u00f6tt. R\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok \u00b6 R\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok ( crosscutting concerns ) n\u00e9ven szoktuk hivatkozni az alkalmaz\u00e1s olyan szolg\u00e1ltat\u00e1sait, amelyek nem csak egy r\u00e9tegben jelennek meg. Az ilyen szolg\u00e1ltat\u00e1sok implement\u00e1l\u00e1sakor igyeksz\u00fcnk el\u00e9rni, hogy b\u00e1r t\u00f6bb r\u00e9tegben is jelen van az adott szolg\u00e1ltat\u00e1s, m\u00e9gis, egy k\u00f6z\u00f6s implement\u00e1ci\u00f3t, k\u00f3dot, megold\u00e1st haszn\u00e1ljunk. Biztons\u00e1g \u00b6 A biztons\u00e1gi szolg\u00e1ltat\u00e1sok lefedik a felhaszn\u00e1l\u00f3k bel\u00e9ptet\u00e9s\u00e9t ( authentik\u00e1ci\u00f3 ) \u00e9s a hozz\u00e1f\u00e9r\u00e9s ellen\u0151rz\u00e9s\u00e9t ( authoriz\u00e1ci\u00f3 ), valamint a nyomk\u00f6vet\u00e9st \u00e9s audit\u00e1l\u00e1st. Az authentik\u00e1ci\u00f3 a \"ki vagy\" k\u00e9rd\u00e9st, m\u00edg az authoriz\u00e1ci\u00f3 a \"mihez van jogod\" k\u00e9rd\u00e9st kezeli. Az authentik\u00e1ci\u00f3 nem csak a felhaszn\u00e1l\u00f3i fel\u00fcleten t\u00f6rt\u00e9n\u0151 bejelentkez\u00e9st jelenti. Az adatb\u00e1zis szerverek fel\u00e9 is tipikusan sz\u00fcks\u00e9g\u00fcnk van bejelentkez\u00e9sre, vagy ha k\u00fcls\u0151 szolg\u00e1ltat\u00e1s fel\u00e9 fordulunk, oda is be kell jelentkezn\u00fcnk. Ez\u00e9rt teh\u00e1t ez az aspektus t\u00f6bb r\u00e9tegben is jelen van. Bejelentkez\u00e9sre t\u00f6bbf\u00e9le megk\u00f6zel\u00edt\u00e9st v\u00e1laszthatunk. K\u00e9sz\u00edthet\u00fcnk saj\u00e1t bejelentkez\u00e9st, haszn\u00e1lhatunk valamilyen c\u00edmt\u00e1ras megold\u00e1st, vagy OAuth bejelentkez\u00e9st. Ha a mi alkalmaz\u00e1sunk bejelentkeztetett egy felhaszn\u00e1l\u00f3t, akkor eld\u00f6nthetj\u00fck, hogy a k\u00fcls\u0151 szolg\u00e1ltat\u00e1s fel\u00e9 ennek a felhaszn\u00e1l\u00f3nak a nev\u00e9ben fordulunk (pl. ahogy a Gmail a Google Drive-r\u00f3l sz\u00e1rmaz\u00f3 f\u00e1jlokat a bejelentkezett felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra list\u00e1zza), avagy egy k\u00f6zponti felhaszn\u00e1l\u00f3 nev\u00e9ben j\u00e1runk el (pl. ha a rendszer emailt k\u00fcld, akkor azt tipikusan egy k\u00f6zpontilag konfigur\u00e1lt fi\u00f3k nev\u00e9ben k\u00fcldi el). A hozz\u00e1f\u00e9r\u00e9s szab\u00e1lyoz\u00e1s megszabja, hogy milyen funkci\u00f3khoz ki f\u00e9rhet hozz\u00e1. Ennek ellen\u0151rz\u00e9se t\u00f6rt\u00e9nhet a felhaszn\u00e1l\u00f3i fel\u00fcleten is (ne is jelenjen meg a a nem el\u00e9rhet\u0151 funkci\u00f3), de ahogy a bemenetek valid\u00e1ci\u00f3j\u00e1n\u00e1l is eml\u00edt\u00e9sre ker\u00fclt, az \u00fczleti logik\u00e1nak meg kell ism\u00e9telnie az ellen\u0151rz\u00e9st. Fontos, hogy ez a k\u00e9t valid\u00e1ci\u00f3 azonos szab\u00e1lyrendszer szerint dolgozzon. A nyomk\u00f6vet\u00e9s, audit\u00e1l\u00e1s feladata, hogy visszakereshet\u0151v\u00e9 v\u00e1ljon a rendszerben, hogy ki, mikor, mit csin\u00e1lt. C\u00e9lja, hogy egy ember ne tudja \"elt\u00fcntetni a nyomokat\". Ez a fajta napl\u00f3z\u00e1s t\u00f6bb ponton is megt\u00f6rt\u00e9nhet, tipikusan az \u00fczleti logik\u00e1ban \u00e9s az adatb\u00e1zisban. \u00dczemeltet\u00e9s \u00b6 Az \u00fczemeltet\u00e9si szempontok figyelembe v\u00e9tele el\u0151seg\u00edti, hogy a szoftver fejleszt\u00e9s ut\u00e1ni \u00e9letciklusa sor\u00e1n is kiel\u00e9g\u00edtse a felhaszn\u00e1l\u00f3k ig\u00e9nyeit. Ide olyan feladatok megold\u00e1sa tartozik, mint az egys\u00e9ges kiv\u00e9telkezel\u00e9s, a megfelel\u0151 napl\u00f3z\u00e1s \u00e9s monitoroz\u00e1s, valamint a konfigur\u00e1l\u00e1s \u00e9s konfigur\u00e1ci\u00f3-kezel\u00e9s. A kiv\u00e9telkezel\u00e9s sor\u00e1n egy olyan egys\u00e9ges m\u00f3dszert kell kialak\u00edtani, ami az alkalmaz\u00e1s fut\u00e1sa sor\u00e1n keletkez\u0151 minden kiv\u00e9telt megfog. Mindenk\u00e9ppen r\u00f6gz\u00edteni kell a hib\u00e1kat (pl. napl\u00f3z\u00e1ssal), \u00e9s emellett a felhaszn\u00e1l\u00f3t is valamilyen m\u00f3don t\u00e1j\u00e9koztatni a hiba jelleg\u00e9r\u0151l (pl. hogy pr\u00f3b\u00e1lja-e \u00fajra a m\u0171veletet, vagy v\u00e1rjon a jav\u00edt\u00e1sig). Az egys\u00e9ges kiv\u00e9telkezel\u00e9s az\u00e9rt nagyon fontos, mert az architekt\u00fara als\u00f3bb r\u00e9tegeiben el\u0151fordul\u00f3 hib\u00e1kat az \u00fczemeltet\u00e9s \u00e9s fejleszt\u00e9s nem l\u00e1tja, csak ha azok megfelel\u0151en kezelve \u00e9s r\u00f6gz\u00edtve lesznek. A napl\u00f3z\u00e1s \u00e9s monitoroz\u00e1s az \u00fczemszer\u0171 \u00e9s nem rendeltet\u00e9sszer\u0171 viselked\u00e9s k\u00f6vet\u00e9s\u00e9hez is fontos. A napl\u00f3z\u00e1s \u00e1ltal\u00e1ban sz\u00f6veges form\u00e1tum\u00fa rendszer \u00fczenetek r\u00f6gz\u00edt\u00e9s\u00e9t jelenti. A monitoroz\u00e1s a rendszer \u00e1llapot\u00e1t meghat\u00e1rozott jellemz\u0151k (un. KPI -k, key performance indicator ) k\u00f6vet\u00e9s\u00e9t jelenti. Ilyen KPI lehet a mem\u00f3ria fogyaszt\u00e1s, a hib\u00e1s k\u00e9r\u00e9sek sz\u00e1ma, a kiszolg\u00e1lt felhaszn\u00e1l\u00f3k sz\u00e1ma, stb. A konfigur\u00e1ci\u00f3 kezel\u00e9s pedig arr\u00f3l sz\u00f3l, hogy az alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9t befoly\u00e1sol\u00f3 be\u00e1ll\u00edt\u00e1sokat hol t\u00e1roljuk, \u00e9s hogyan k\u00f6tj\u00fck be \u0151ket az alkalmaz\u00e1sba. Konfigur\u00e1ci\u00f3nak min\u0151s\u00fclnek kiszolg\u00e1l\u00f3k el\u00e9r\u00e9si \u00fatvonalai (pl. az adatb\u00e1zis szerver c\u00edme), de ak\u00e1r a megjelen\u00edt\u00e9si r\u00e9tegben haszn\u00e1lt h\u00e1tt\u00e9rsz\u00edn is. Alapelv, hogy a be\u00e1ll\u00edt\u00e1sokat min\u00e9l kev\u00e9sb\u00e9 \"\u00e9gess\u00fck be\" a forr\u00e1sk\u00f3dba, hogy alkalmazkodni tudjunk az \u00fczemeltet\u00e9s sor\u00e1n el\u0151fordul\u00f3 k\u00fcl\u00f6nb\u00f6z\u0151 k\u00f6rnyezetekhez. A konfigur\u00e1ci\u00f3 t\u00f6rt\u00e9nhet tipikusan konfigur\u00e1ci\u00f3s f\u00e1jlokkal, vagy kifejezetten konfigur\u00e1ci\u00f3-menedzsment c\u00e9lra szolg\u00e1l\u00f3 eszk\u00f6z\u00f6kkel is. Az \u00fczemeltet\u00e9si aspektusokkal nem fogunk r\u00e9szletesebben foglalkozni. Tipikusan a v\u00e1lasztott platform k\u00e9pess\u00e9geit \u00e9s lehet\u0151s\u00e9geit haszn\u00e1ljuk a megval\u00f3s\u00edt\u00e1shoz. Kommunik\u00e1ci\u00f3 \u00b6 A kommunik\u00e1ci\u00f3s szolg\u00e1ltat\u00e1s az egyes r\u00e9tegek k\u00f6z\u00f6tti kommunik\u00e1ci\u00f3s forma megv\u00e1laszt\u00e1s\u00e1\u00e9rt \u00e9s kezel\u00e9s\u00e9\u00e9rt felel. Ennek helyes megv\u00e1laszt\u00e1sa nem csak architektur\u00e1lis k\u00e9rd\u00e9s, mert nagyban f\u00fcgg a telep\u00edt\u00e9s mik\u00e9ntj\u00e9t\u0151l is. Amennyiben az egyes r\u00e9tegek elt\u00e9r\u0151 kiszolg\u00e1l\u00f3n ker\u00fclnek elhelyez\u00e9sre, h\u00e1l\u00f3zati alap\u00fa kommunik\u00e1ci\u00f3ra van sz\u00fcks\u00e9g; m\u00edg azonos kiszolg\u00e1l\u00f3n \u00fczemeltetett komponensek k\u00f6z\u00f6tt egyszer\u0171bb megold\u00e1sokat haszn\u00e1lhatunk. Manaps\u00e1g szinte minden alkalmaz\u00e1sban valahol megjelenik a h\u00e1l\u00f3zati kommunik\u00e1ci\u00f3: tipikusan az adatb\u00e1zis \u00e9s adatforr\u00e1sok ir\u00e1ny\u00e1ba, illetve a megjelen\u00edt\u00e9si r\u00e9teg \u00e9s a szolg\u00e1ltat\u00e1si interf\u00e9szek k\u00f6z\u00f6tt. Itt tipikusan HTTP vagy arra \u00e9p\u00fcl\u0151 kommunik\u00e1ci\u00f3t szoktak alkalmazni, b\u00e1r nagyobb teljes\u00edtm\u00e9nyt ig\u00e9nyl\u0151 alkalmaz\u00e1sok eset\u00e9n \u00e9rdemes lehet TCP alap\u00fa bin\u00e1ris kommunik\u00e1ci\u00f3t v\u00e1lasztani. Nagy rendszerek eset\u00e9n, ahol az egyes r\u00e9tegek maguk is elosztva, t\u00f6bb kiszolg\u00e1l\u00f3n tal\u00e1lhat\u00f3ak, pedig gyakori az \u00fczenetsorok ( message queue ) haszn\u00e1lata. A kommunik\u00e1ci\u00f3 r\u00e9sz\u00e9nek tekintj\u00fck \u00e1ltal\u00e1ban a titkos\u00edt\u00e1st is. Amennyiben az egyes r\u00e9tegek k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon futnak, fontos, hogy megfelel\u0151en titkos\u00edtsuk a kommunik\u00e1ci\u00f3t. A felhaszn\u00e1l\u00f3i fel\u00fclet \u00e9s a szolg\u00e1ltat\u00e1si interf\u00e9szek k\u00f6z\u00f6tt ez \u00e1ltal\u00e1ban HTTPS/TLS kommunik\u00e1ci\u00f3t jelent. Backend \u00e9s frontend \u00b6 Ha az alkalmaz\u00e1sra egy kicsit m\u00e1s szemsz\u00f6gb\u0151l n\u00e9z\u00fcnk, akkor meg szoktuk k\u00fcl\u00f6nb\u00f6ztetni a backend \u00e9s a frontend r\u00e9szt. A frontend nagyr\u00e9szt a felhaszn\u00e1l\u00f3i fel\u00fclet, vagyis a prezent\u00e1ci\u00f3s r\u00e9teg, ill. annak v\u00e1ltozatos megjelen\u00e9si form\u00e1i (b\u00f6ng\u00e9sz\u0151ben fut\u00f3 webalkalmaz\u00e1s UI, nat\u00edv mobil alkalmaz\u00e1s, vastag kliens UI, stb). A felhaszn\u00e1l\u00f3 ezzel l\u00e9p kapcsolatba. A backend pedig a \"h\u00e1tt\u00e9rben\" fut\u00f3 rendszer, a szolg\u00e1ltat\u00e1si API-k, az \u00fczleti logikai r\u00e9teg, az adatel\u00e9r\u00e9s, adatb\u00e1zisok. A frontend nem csak felhaszn\u00e1l\u00f3 sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n jelenik meg. Frontend technol\u00f3gia f\u00fcggv\u00e9ny\u00e9ben gyakran el\u0151fordul, hogy a felhaszn\u00e1l\u00f3i fel\u00fclet egy r\u00e9sz\u00e9t a backend k\u00e9sz\u00edti el. Ezt szokt\u00e1k szerver oldali renderel\u00e9snek h\u00edvni. Ha \u00f6sszefoglal\u00f3an akarjuk hivatkozni, akkor a t\u00e1rgy keret\u00e9ben a backend technol\u00f3gi\u00e1kkal foglalkozunk. Ellen\u0151rz\u0151 k\u00e9rd\u00e9sek \u00b6 Mik a h\u00e1romr\u00e9teg\u0171 architekt\u00fara r\u00e9tegei? Mik a felel\u0151ss\u00e9geik? Ismertesse a r\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sokat! D\u00f6ntse el, hogy igaz vagy hamis az al\u00e1bbi \u00e1ll\u00edt\u00e1s: Az adatbevitel valid\u00e1ci\u00f3j\u00e1\u00e9rt csak a megjelen\u00edt\u00e9si r\u00e9teg felel. Az architekt\u00fara szempontj\u00e1b\u00f3l helytelen, ha SQL parancsok ker\u00fclnek az \u00fczleti logikai r\u00e9tegbe. A h\u00e1romr\u00e9teg\u0171 architekt\u00fara r\u00e9tegei mindig k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon futnak. A h\u00e1romr\u00e9teg\u0171 architekt\u00fara akkor lesz t\u00f6bbr\u00e9teg\u0171, pl. n\u00e9gyr\u00e9teg\u0171, ha teljes\u00edtm\u00e9ny okokb\u00f3l az \u00fczleti logikai r\u00e9teget m\u00e1s kiszolg\u00e1l\u00f3ra vissz\u00fck, mint az adatel\u00e9r\u00e9si r\u00e9teget. A r\u00e9teges fel\u00e9p\u00edt\u00e9s garant\u00e1lja, hogy a r\u00e9tegek \u00e1ltal biztos\u00edtott szolg\u00e1ltat\u00e1sokat tetsz\u0151legesen megv\u00e1ltoztathatjuk, ez nem \u00e9rinti a t\u00f6bbi r\u00e9teget. A frontend \u00e9s a megjelen\u00edt\u00e9si r\u00e9teg egy \u00e9s ugyanaz. Kiv\u00e9telkezel\u00e9sre csak az \u00fczleti logikai r\u00e9tegben van sz\u00fcks\u00e9g.","title":"Adatvez\u00e9relt rendszerek \u00e9s a t\u00f6bbr\u00e9teg\u0171 (h\u00e1romr\u00e9teg\u0171) architekt\u00fara"},{"location":"jegyzet/architektura/#adatvezerelt-rendszerek-es-a-tobbretegu-haromretegu-architektura","text":"","title":"Adatvez\u00e9relt rendszerek \u00e9s a t\u00f6bbr\u00e9teg\u0171 (h\u00e1romr\u00e9teg\u0171) architekt\u00fara"},{"location":"jegyzet/architektura/#mit-nevezunk-adatvezerelt-alkalmazasnak","text":"Minden alkalmaz\u00e1s valamilyen m\u00f3don adatokat kezel, hiszen a sz\u00e1m\u00edt\u00f3g\u00e9p mem\u00f3ri\u00e1j\u00e1ban adatok vannak, \u00e9s a program ezeket manipul\u00e1lja. De m\u00e9gse minden alkalmaz\u00e1s adatvez\u00e9relt. Akkor h\u00edvunk egy alkalmaz\u00e1st adatvez\u00e9reltnek, ha a szoftver els\u0151dleges c\u00e9lja a tartalmazott adatok kezel\u00e9se. M\u00e1s sz\u00f3val, az adatvez\u00e9relt alkalmaz\u00e1s az\u00e9rt j\u00f6n l\u00e9tre, hogy adatokat t\u00e1roljon, megjelen\u00edtsen, manipul\u00e1ljon. A felhaszn\u00e1l\u00f3 az\u00e9rt l\u00e9p interakci\u00f3ba az alkalmaz\u00e1ssal, hogy az adatokhoz hozz\u00e1f\u00e9rjen. Egy sakkprogram eset\u00e9ben a t\u00e1bla \u00e1ll\u00e1sa mem\u00f3ri\u00e1ban tal\u00e1lhat\u00f3 adat. De a sakkprogram nem az\u00e9rt j\u00f6n l\u00e9tre, hogy ezt a mem\u00f3riabeli t\u00e1bl\u00e1t manipul\u00e1lja, hanem az\u00e9rt, hogy a j\u00e1t\u00e9kos sakkozzon. Egy adatvez\u00e9relt alkalmaz\u00e1sban az adat hat\u00e1rozza meg, hogy mik\u00e9nt m\u0171k\u00f6dik a szoftver. P\u00e9ld\u00e1ul az adat rekordok egyes attrib\u00fatumainak f\u00fcggv\u00e9ny\u00e9ben \u00e9rtelmezhet\u0151 egy t\u00f6rl\u00e9s m\u0171velet a rekordra, vagy sem. Egy hasonl\u00f3 p\u00e9lda, ahol az adat maga hat\u00e1rozza meg a rajta v\u00e9grehajthat\u00f3 m\u0171veleteket, a Neptun rendszerben a vizsgajelentkez\u00e9s. A f\u00e9l\u00e9vhez tartoz\u00f3 id\u0151szakok, bele\u00e9rtve, hogy mikor kezd\u0151dik a vizsgaid\u0151szak, maga is a Neptun rendszer adatai k\u00f6z\u00f6tt tal\u00e1lhat\u00f3. Ezen adat hat\u00e1rozza meg, hogy a felhaszn\u00e1l\u00f3 (hallgat\u00f3) tud-e egy vizsg\u00e1ra jelentkezni. Att\u00f3l, hogy egyik \u00e9vben m\u00e1skor kezd\u0151dik a vizsgaid\u0151szak, a program logik\u00e1ja (k\u00f3dja) nem v\u00e1ltozik meg, a szoftver m\u00e9gis k\u00e9pes m\u00e1shogyan viselkedni.","title":"Mit nevez\u00fcnk adatvez\u00e9relt alkalmaz\u00e1snak?"},{"location":"jegyzet/architektura/#pelda-adatvezerelt-alkalmazasra","text":"A m\u00e1r eml\u00edtett Neptun rendszer egy tipikus adatvez\u00e9relt alkalmaz\u00e1s. C\u00e9lja az oktat\u00e1shoz kapcsol\u00f3d\u00f3 adatok, a kurzusok, jegyek, vizsg\u00e1k, stb. kezel\u00e9se. Egy m\u00e1sik p\u00e9lda a Gmail : az\u00e9rt l\u00e9tezik, hogy adatokat (itt: emailek, csatolm\u00e1nyok, kontaktok) kezeljen. Az alkalmaz\u00e1s minden funkci\u00f3ja ezen adatok kezel\u00e9s\u00e9r\u0151l, megjelen\u00edt\u00e9s\u00e9r\u0151l, manipul\u00e1l\u00e1s\u00e1r\u00f3l sz\u00f3l. Mindemellett, az adatokat hossz\u00fa t\u00e1von meg\u0151rzi, azaz minden m\u00f3dos\u00edt\u00e1s a rendszerben megmarad.","title":"P\u00e9lda adatvez\u00e9relt alkalmaz\u00e1sra"},{"location":"jegyzet/architektura/#adatvezerelt-rendszer-felepitese","text":"Vegy\u00fck a Gmail p\u00e9ld\u00e1j\u00e1t. Szeretn\u00e9nk egy olyan modern email rendszert \u00e9p\u00edteni, ahol lehet: emaileket k\u00fcldeni \u00e9s fogadni, van webes \u00e9s mobil fel\u00fclete is, a felhaszn\u00e1l\u00f3i fel\u00fclet t\u00f6bb nyelvet is t\u00e1mogat, tudunk f\u00e1jlokat csatolni a csatolm\u00e1nyokat ak\u00e1r Google Drive-r\u00f3l is tudjuk hivatkozni, tudjuk k\u00e9sleltetni egy email elk\u00fcld\u00e9s\u00e9t, stb. Gondoljuk v\u00e9gig Hogyan kezden\u00e9nk neki egy ilyen alkalmaz\u00e1s fejleszt\u00e9s\u00e9nek? Ez tal\u00e1n t\u00fal neh\u00e9z k\u00e9rd\u00e9s. Kezdj\u00fck egy egyszer\u0171bb k\u00e9rd\u00e9ssel: tegy\u00fck fel, hogy m\u00e1r majdnem minden r\u00e9sze m\u0171k\u00f6dik az alkalmaz\u00e1snak, csak \u00e9ppen a k\u00e9sleltetett email k\u00fcld\u00e9s hi\u00e1nyzik; ezt hogyan implement\u00e1ln\u00e1nk? P\u00e9ld\u00e1ul lehetne \u00fagy, hogy az email k\u00fcld\u00e9se gombra kattint\u00e1sn\u00e1l elind\u00edtunk egy id\u0151z\u00edt\u0151t, ami 1 perc m\u00falva ind\u00edtja csak az email k\u00fcld\u00e9st. Ez az\u00e9rt nem lesz j\u00f3 megold\u00e1s, mert ha k\u00f6zben bez\u00e1rjuk a web b\u00f6ng\u00e9sz\u0151t, akkor nem fog az id\u0151z\u00edt\u0151 lej\u00e1rni, \u00e9s nem lesz elk\u00fcldve az email. Helyette csin\u00e1lhatjuk \u00fagy, hogy r\u00f6gz\u00edtj\u00fck az email mellett, hogy mikor kell elk\u00fcldeni, \u00edgy ez az inform\u00e1ci\u00f3 is az email, mint kezelt adat r\u00e9sze lesz. Ezzel eld\u00f6nt\u00f6tt\u00fck, hogy nem a felhaszn\u00e1l\u00f3i fel\u00fclet feladata lesz a k\u00e9sleltetett email k\u00fcld\u00e9s. M\u00e9g nem tudjuk, hogy milyen alkalmaz\u00e1s komponensre b\u00edzzuk a feladatot, de nem a felhaszn\u00e1l\u00f3 fel\u00fcletre. Miel\u0151tt meg tudjuk v\u00e1laszolni a k\u00e9rd\u00e9st, hogy m\u00e9gis milyen komponensnek lesz a dolga az email j\u00f6v\u0151beli kik\u00fcld\u00e9se, n\u00e9zz\u00fcnk egy hasonl\u00f3 k\u00e9rd\u00e9st. A Gmail az email \u00e9rkez\u00e9s\u00e9nek idej\u00e9t magyar felhaszn\u00e1l\u00f3knak magyar szok\u00e1s szerint (pl. \"15:23\"), m\u00e1s nyelv\u0171 felhaszn\u00e1l\u00f3knak a saj\u00e1t preferenci\u00e1ik szerint jelen\u00edti meg (pl. \"3:23 PM\"). Ez azt jelenti, hogy az email, mint adat rekord t\u00f6bbf\u00e9le \u00e9rkez\u00e9si id\u0151vel rendelkezik? Nyilv\u00e1n nem. Az email \u00e9rkez\u00e9si ideje egyetlen d\u00e1tum, egy univerz\u00e1lis reprezent\u00e1ci\u00f3ban, \u00e9s csak akkor ker\u00fcl \u00e1talak\u00edt\u00e1sra, amikor megjelen\u00edti a felhaszn\u00e1l\u00f3 fel\u00fclet. Meg\u00e1llap\u00edtottuk teh\u00e1t, hogy vannak feladatok, amelyek a felhaszn\u00e1l\u00f3i fel\u00fclet felel\u0151ss\u00e9gi k\u00f6r\u00e9be tartoznak, \u00e9s vannak olyanok, amelyek nem. \u00cdgy \u00e9rkez\u00fcnk meg a t\u00f6bbr\u00e9get\u0171-, avagy h\u00e1romr\u00e9teg\u0171 architekt\u00far\u00e1hoz.","title":"Adatvez\u00e9relt rendszer fel\u00e9p\u00edt\u00e9se"},{"location":"jegyzet/architektura/#a-tobbretegu-haromretegu-architektura","text":"Adatvez\u00e9relt rendszereket tipikusan a t\u00f6bbr\u00e9teg\u0171-, avagy h\u00e1romr\u00e9teg\u0171 architekt\u00fara ( three-layered / three-tiered architecture ) szerint \u00e9p\u00edt\u00fcnk fel. Jelen kontextusban a k\u00e9t elnevez\u00e9st szinonimak\u00e9nt kezelj\u00fck. Ez az architekt\u00fara megk\u00fcl\u00f6nb\u00f6zteti az alkalmaz\u00e1s h\u00e1rom f\u0151 komponenscsal\u00e1dj\u00e1t, avagy r\u00e9teg\u00e9t: a megjelen\u00edt\u00e9si r\u00e9teget, az \u00fczleti logikai r\u00e9teget, \u00e9s az adatel\u00e9r\u00e9si r\u00e9teget. Ezen k\u00edv\u00fcl az architekt\u00far\u00e1hoz kapcsol\u00f3dik m\u00e9g: az adatb\u00e1zis, ill. k\u00fcls\u0151 adatforr\u00e1sok; \u00e9s az un. r\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok (l\u00e1sd k\u00e9s\u0151bb). Az alkalmaz\u00e1sunkat \u00fagy szervezz\u00fck meg, hogy az egyes komponensek (szoftver elemek) r\u00e9tegekbe szervez\u0151dnek, \u00e9s minden egyes r\u00e9teg m\u00e1s-m\u00e1s funkcionalit\u00e1s\u00e9rt felel. Ez a logikai szervez\u00e9s megk\u00f6nny\u00edti a szoftverfejleszt\u0151k munk\u00e1j\u00e1t az\u00e1ltal, hogy egy\u00e9rtelm\u0171 felel\u0151ss\u00e9gi k\u00f6r\u00f6ket \u00e9s hat\u00e1rokat jel\u00f6l ki a r\u00e9tegekben. Mi\u00e9rt t\u00f6bbr\u00e9teg\u0171, hiszen csak h\u00e1rom r\u00e9tege van Az elnevez\u00e9s arra utal, hogy mindegyik r\u00e9teg maga is tov\u00e1bb bonthat\u00f3 tov\u00e1bbi r\u00e9tegekre az alkalmaz\u00e1s komplexit\u00e1s\u00e1nak f\u00fcggv\u00e9ny\u00e9ben. Att\u00f3l t\u00f6bbr\u00e9teg\u0171 az architekt\u00fara, hogy kett\u0151n\u00e9l t\u00f6bb r\u00e9tege van. (\u00cdgy szembe\u00e1ll\u00edtva a k\u00e9tr\u00e9teg\u0171 architekt\u00far\u00e1val , ahol a felhaszn\u00e1l\u00f3i fel\u00fclet \u00e9s az \u00fczleti logikai r\u00e9teg nem v\u00e1lik el.) Az egyes r\u00e9tegek nem csak saj\u00e1t felel\u0151ss\u00e9gi k\u00f6rrel rendelkeznek, hanem egyben meghat\u00e1rozz\u00e1k azt az interf\u00e9szt , amit a r\u00e1\u00e9p\u00fcl\u0151 r\u00e9tegek haszn\u00e1lhatnak. Az adatel\u00e9r\u00e9si r\u00e9teg defini\u00e1lja, milyen m\u0171veleteken kereszt\u00fcl \u00e9rhet\u0151 el az \u00fczleti logikai r\u00e9teg sz\u00e1m\u00e1ra; az \u00fczleti logikai r\u00e9teg hasonl\u00f3an defini\u00e1lja az interf\u00e9sz\u00e9t a megjelen\u00edt\u00e9si r\u00e9teg fel\u00e9. Ennek megfelel\u0151en minden r\u00e9teg csak az alatta lev\u0151vel kommunik\u00e1l (\u00edgy teh\u00e1t a prezent\u00e1ci\u00f3s r\u00e9teg nem ad ki pl. SQL lek\u00e9rdez\u00e9st az adatb\u00e1zis fel\u00e9), valamint a r\u00e9tegek \u00e1ltal defini\u00e1lt interf\u00e9sz m\u00f6g\u00f6tt az implement\u00e1ci\u00f3 cser\u00e9lhet\u0151v\u00e9 v\u00e1lik, \u00edgy el\u0151seg\u00edtve az alkalmaz\u00e1s hossz\u00fa karbantarthat\u00f3s\u00e1g\u00e1t. A r\u00e9tegek sz\u00e9tv\u00e1laszt\u00e1s\u00e1nak k\u00f6sz\u00f6nhet\u0151en az is gyakori, hogy az alkalmaz\u00e1sunk nem egy helyen, hanem a r\u00e9tegek ment\u00e9n t\u00f6bb kiszolg\u00e1l\u00f3n fut. Leggyakoribb esete ennek a megjelen\u00edt\u00e9si r\u00e9teg lev\u00e1laszt\u00e1sa, amely p\u00e9ld\u00e1ul egy webalkalmaz\u00e1s eset\u00e9n a felhaszn\u00e1l\u00f3 sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n a b\u00f6ng\u00e9sz\u0151ben fut, m\u00edg a t\u00f6bbi komponens a t\u00e1voli kiszolg\u00e1l\u00f3n tal\u00e1lhat\u00f3. Hasonl\u00f3an gyakori, hogy az adatr\u00e9teg (pl. adatb\u00e1zis) egy saj\u00e1t kiszolg\u00e1l\u00f3t kap teljes\u00edt\u00e9ny okokb\u00f3l. Am\u00edg a r\u00e9tegek k\u00f6z\u00f6tti interf\u00e9szek v\u00e1ltozatlanok maradnak, a r\u00e9tegek ak\u00e1r kiszolg\u00e1l\u00f3k k\u00f6z\u00f6tt is mozgathat\u00f3ak. Ennek tipikus oka a teljes\u00edtm\u00e9ny-optimaliz\u00e1l\u00e1s \u00e9s a nagy terhel\u00e9sek kiszolg\u00e1l\u00e1s\u00e1nak el\u0151seg\u00edt\u00e9se (pl. forgalmas webhelyek eset\u00e9ben). Layer / tier Az architekt\u00fara angol elnevez\u00e9se megk\u00fcl\u00f6nb\u00f6zteti a logikai \u00e9s fizikai elv\u00e1laszt\u00e1st. A three-layered elnevez\u00e9sben a r\u00e9tegek logikailag k\u00fcl\u00f6nv\u00e1lnak, de azonos kiszolg\u00e1l\u00f3n futnak. A three-tiered azonban a r\u00e9tegek ( tier ) ment\u00e9n fizikai elv\u00e1laszt\u00e1s\u00e1ra, k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon val\u00f3 fut\u00e1sra is utal. Egy j\u00f3 architekt\u00far\u00e1val rendelkez\u0151 alkalmaz\u00e1s hossz\u00fa \u00e9letciklusa sor\u00e1n is karbantarthat\u00f3 marad. A r\u00e9tegez\u00e9s nem plusz teherk\u00e9nt, betartand\u00f3 szab\u00e1lyok halmazak\u00e9nt, hanem mank\u00f3k\u00e9nt seg\u00edti a fejleszt\u0151ket a k\u00f3d fejleszt\u00e9s\u00e9ben. Ez\u00e9rt egy t\u00f6bbr\u00e9teg\u0171 alkalmaz\u00e1s fejleszt\u00e9se sor\u00e1n fontos, hogy pontosan \u00e9rts\u00fck, mely r\u00e9tegek milyen felel\u0151ss\u00e9gekkel rendelkeznek, \u00e9s milyen feladok tartoznak hozz\u00e1juk. A r\u00e9teges fel\u00e9p\u00edt\u00e9s nem azt jelenti, hogy a felhaszn\u00e1l\u00f3k \u00e1ltal haszn\u00e1lt funkci\u00f3k csak egy-egy r\u00e9tegben jelennek meg. A legt\u00f6bb funkci\u00f3 valamilyen m\u00f3don az \u00f6sszes r\u00e9tegben megjelenik: a funkci\u00f3hoz tartozik felhaszn\u00e1l\u00f3i fel\u00fclet, valamilyen adatkezel\u00e9s az \u00fczleti logik\u00e1ban, \u00e9s az eredm\u00e9ny ment\u00e9sre ker\u00fcl az adatb\u00e1zisba. A t\u00f6bbr\u00e9teg\u0171 architekt\u00far\u00e1val k\u00e9sz\u00fcl\u0151 alkalmaz\u00e1sok k\u00f3d szervez\u00e9se is t\u00fckr\u00f6zi a r\u00e9tegek fel\u00e9p\u00edt\u00e9s\u00e9t. Az adott programoz\u00e1si k\u00f6rnyezet lehet\u0151s\u00e9geit \u00e9s szok\u00e1sait figyelembe v\u00e9ve az egyes r\u00e9tegeket k\u00fcl\u00f6n projektekbe, csomagokba szok\u00e1s elhelyezni. Ez egy\u00e9rtelm\u0171v\u00e9 teszi az egym\u00e1sra \u00e9p\u00fcl\u00e9st is, hiszen a projektek \u00e9s csomagok k\u00f6z\u00f6tt \u00e1ltal\u00e1ban csak egyir\u00e1ny\u00fa hivatkoz\u00e1s lehets\u00e9ges (teh\u00e1t ha az \u00fczleti logikai csomag haszn\u00e1lja az adatel\u00e9r\u00e9si r\u00e9teget, akkor ford\u00edtva ez m\u00e1r nem t\u00f6rt\u00e9nhet meg). A t\u00f6bbr\u00e9teg\u0171 architekt\u00fara nem az egyetlen lehet\u0151s\u00e9g adatvez\u00e9relt alkalmaz\u00e1s megval\u00f3s\u00edt\u00e1sa eset\u00e9n. Kis, egyszer\u0171 alkalmaz\u00e1sokra c\u00e9lszer\u0171 lehet a k\u00e9tr\u00e9teg\u0171 architekt\u00fara, m\u00edg sokkal komplexebb rendszerek eset\u00e9n az alkalmaz\u00e1s tov\u00e1bbi darabol\u00e1sa is sz\u00fcks\u00e9ges lehet p\u00e9ld\u00e1ul un. mikroszolg\u00e1ltat\u00e1sok architekt\u00fara ir\u00e1ny\u00e1ba l\u00e9pve.","title":"A t\u00f6bbr\u00e9teg\u0171 (h\u00e1romr\u00e9teg\u0171) architekt\u00fara"},{"location":"jegyzet/architektura/#a-tobbretegu-architektura-retegeinek-felelossege","text":"Vizsg\u00e1ljuk meg alaposabban a r\u00e9tegeket, \u00e9s feladataikat, felel\u0151ss\u00e9geiket. Az architekt\u00fara r\u00e9szletesebben kifejtve az al\u00e1bbi elemeket tartalmazza. (A k\u00e9p forr\u00e1sa: Microsoft Application Architecture Guide, 2 nd Edition, https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ee658109%28v%3dpandp.10%29 ) A r\u00e9tegeken \"lentr\u0151l felfel\u00e9\" haladunk v\u00e9gig.","title":"A t\u00f6bbr\u00e9teg\u0171 architekt\u00fara r\u00e9tegeinek felel\u0151ss\u00e9ge"},{"location":"jegyzet/architektura/#az-adatforrasok","text":"A leggyakoribb adatforr\u00e1s az adatb\u00e1zis . Ez lehet rel\u00e1ci\u00f3s, vagy ak\u00e1r NoSQL adatb\u00e1zis is. Feladata az adataink hossz\u00fa t\u00e1von megmarad\u00f3 \u00e9s megb\u00edzhat\u00f3 (un. \"perzisztens\") t\u00e1rol\u00e1sa. Tipikusan ez az adatb\u00e1zis egy megb\u00edzhat\u00f3 gy\u00e1rt\u00f3t\u00f3l sz\u00e1rmaz\u00f3 szoftver, amely egy k\u00fcl\u00f6n erre a c\u00e9lra \u00fczemeltetett kiszolg\u00e1l\u00f3n fut, \u00edgy az adatel\u00e9r\u00e9si r\u00e9teg h\u00e1l\u00f3zaton kereszt\u00fcl \u00e9ri el. El\u0151fordulhat az is, hogy a rendszer \u00e1ltal kezelt adatok nem mind a saj\u00e1t adatb\u00e1zisunkban tal\u00e1lhat\u00f3ak, hanem olyan m\u00e1s k\u00fcls\u0151 szolg\u00e1ltat\u00e1sokban , amelyeket \"adatb\u00e1zisk\u00e9nt\" haszn\u00e1lunk. P\u00e9ld\u00e1ul a Gmail eset\u00e9n f\u00e1jl csatolm\u00e1nyok t\u00e1rolhat\u00f3ak az emailekkel egy\u00fctt egy adatb\u00e1zisban, de lehet\u0151s\u00e9g\u00fcnk van Google Drive-r\u00f3l is csatolni f\u00e1jlokat. A Gmail ilyenkor a Google Drive-r\u00f3l let\u00f6lti az el\u00e9rhet\u0151 f\u00e1jlok list\u00e1j\u00e1t, hogy a felhaszn\u00e1l\u00f3 kiv\u00e1lassza a csatoland\u00f3 mell\u00e9kletet. A Google Drive nem adatb\u00e1zis, m\u00e9gis, a haszn\u00e1lat szempontj\u00e1b\u00f3l adatforr\u00e1sk\u00e9nt m\u0171k\u00f6dik. Az ilyen jelleg\u0171 k\u00fcls\u0151 szolg\u00e1ltat\u00e1sokat az\u00e9rt az adatb\u00e1zisok mellett helyezz\u00fck el k\u00e9pzeletben, mert a mi alkalmaz\u00e1sunk sz\u00e1m\u00e1ra csak adatokat szolg\u00e1ltatnak (pl. list\u00e1zd az el\u00e9rhet\u0151 f\u00e1jlokat). A bels\u0151 m\u0171k\u00f6d\u00e9s\u00fckbe nem l\u00e1tunk bele, \u00e9s nem is c\u00e9lunk azt meg\u00e9rteni. Ilyen szempontb\u00f3l nem nagy a k\u00fcl\u00f6nbs\u00e9g egy rel\u00e1ci\u00f3s adatb\u00e1zis \u00e9s egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1s k\u00f6z\u00f6tt. Ma m\u00e1r t\u00f6bb modern adatb\u00e1zis-kezel\u0151 rendszer is gyakran rendelkeznek a k\u00fcls\u0151 szolg\u00e1ltat\u00e1sok el\u00e9r\u00e9s\u00e9hez haszn\u00e1lt HTTP/REST-jelleg\u0171 interf\u00e9sszel, \u00e9s nem SQL nyelven kell vel\u00fck kommunik\u00e1lni. \u00cdgy egyre kevesebb a k\u00fcl\u00f6nbs\u00e9g egy adatb\u00e1zis \u00e9s egy k\u00fcls\u0151 adatforr\u00e1s k\u00f6z\u00f6tt.","title":"Az adatforr\u00e1sok"},{"location":"jegyzet/architektura/#adateleresi-reteg","text":"Az adatel\u00e9r\u00e9si r\u00e9teg ( data access layer , r\u00f6viden DAL ) feladata az adatforr\u00e1sok k\u00e9nyelmes el\u00e9r\u00e9s\u00e9nek biztos\u00edt\u00e1sa. F\u0151 funkci\u00f3ja az elemi adatszolg\u00e1ltat\u00e1si m\u0171veletek biztos\u00edt\u00e1sa, mint egy \u00faj rekord t\u00e1rol\u00e1sa, meglev\u0151 m\u00f3dos\u00edt\u00e1sa vagy t\u00f6rl\u00e9se. Az adatforr\u00e1sokat \u00e9s az adatel\u00e9r\u00e9si r\u00e9teget szok\u00e1s m\u00e9g egyben adatr\u00e9tegnek ( data layer ) is nevezni. Az adatb\u00e1zisok el\u00e9r\u00e9s\u00e9hez sz\u00fcks\u00e9ges funkcionalit\u00e1sokat az \u00fan. data access components -ek val\u00f3s\u00edtj\u00e1k meg. C\u00e9ljuk, hogy elrejts\u00e9k a komplexit\u00e1st, ami az adatb\u00e1zis kezel\u00e9s\u00e9b\u0151l ad\u00f3dik, \u00e9s k\u00f6zpontilag k\u00e9nyelmes, a fels\u0151bb r\u00e9teg sz\u00e1m\u00e1ra egyszer\u0171en haszn\u00e1lhat\u00f3 szolg\u00e1ltat\u00e1sk\u00e9nt ny\u00fajts\u00e1k az adatt\u00e1rol\u00e1st . Ide tartozik p\u00e9ld\u00e1ul az SQL parancsok kezel\u00e9se, valamint az adatb\u00e1zis t\u00e1rol\u00e1si modellj\u00e9nek lek\u00e9pz\u00e9se az \u00fczleti logika sz\u00e1m\u00e1ra is k\u00e9nyelmesen haszn\u00e1lhat\u00f3 m\u00f3don. Amennyiben az adatok nem egy adatb\u00e1zisban, hanem egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1sban tal\u00e1lhat\u00f3ak, a service agent -ek feladata a k\u00fcls\u0151 rendszerrel val\u00f3 kommunik\u00e1ci\u00f3 kezel\u00e9se. Ebben a r\u00e9tegben tal\u00e1lhat\u00f3 komponensek \u00e1ltal\u00e1ban egy konkr\u00e9t technol\u00f3gia k\u00f6r\u00e9 csoportosulnak, p\u00e9ld\u00e1ul a v\u00e1lasztott adatb\u00e1zis-kezel\u0151 rendszer el\u00e9r\u00e9s\u00e9hez haszn\u00e1lt technol\u00f3gia (mint az ADO.NET, Entity Framework, vagy JDBC, JPA, stb.). Az itt megval\u00f3s\u00edtott logik\u00e1k gyakran szorosan csatol\u00f3dnak az adatkezel\u00e9si technol\u00f3gi\u00e1kkal. Fontos azonban, hogy ez a platform specifikuss\u00e1g ne sziv\u00e1rogjon ki ebb\u0151l a r\u00e9tegb\u0151l. Fontos Egy j\u00f3l megtervezett rendszerben SQL lek\u00e9rdez\u00e9sek csak az adatel\u00e9r\u00e9si r\u00e9tegben jelennek meg, a t\u00f6bbi r\u00e9teg semmilyen k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt nem \u00e1ll\u00edt \u00f6ssze SQL lek\u00e9rdez\u00e9st. Mivel az adatb\u00e1zisban val\u00f3 t\u00e1rol\u00e1s gondolkod\u00e1sm\u00f3dja (tipikusan a rel\u00e1ci\u00f3s s\u00e9ma), valamint az objektumorient\u00e1lt modellez\u00e9s nem egy az egyben fedik egym\u00e1st, ez\u00e9rt ennek a r\u00e9tegnek a feladata a k\u00e9t vil\u00e1g k\u00f6z\u00f6tti lek\u00e9pez\u00e9s \u00e9s megfeleltet\u00e9s megval\u00f3s\u00edt\u00e1sa. A rel\u00e1ci\u00f3s adatb\u00e1zisokban haszn\u00e1lt k\u00fcls\u0151 kulcsokat ( foreign key ) objektumorient\u00e1lt asszoci\u00e1ci\u00f3kra, kompoz\u00edci\u00f3kra alak\u00edtjuk, valamint ha sz\u00fcks\u00e9ges, konvert\u00e1l\u00e1st v\u00e9gz\u00fcnk a k\u00fcl\u00f6nb\u00f6z\u0151 rendszerek \u00e1ltal t\u00e1mogatott adatt\u00edpusok k\u00f6z\u00f6tt. Err\u0151l a feladatr\u00f3l a k\u00e9s\u0151bbeikben m\u00e9g r\u00e9szletesebben ejt\u00fcnk sz\u00f3t. A k\u00fcls\u0151 rendszerekkel val\u00f3 kommunik\u00e1ci\u00f3, ak\u00e1r egy adatb\u00e1zis-kezel\u0151 rendszerr\u0151l, ak\u00e1r egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1sr\u00f3l van sz\u00f3, saj\u00e1tos kezel\u00e9stechnik\u00e1t ig\u00e9nyel. Teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l nem mindegy, hogy a t\u00e1voli kiszolg\u00e1l\u00f3 megsz\u00f3l\u00edt\u00e1sa, a kapcsolat fel\u00e9p\u00edt\u00e9se mikor \u00e9s milyen gyakran t\u00f6rt\u00e9nik. Egyes kapcsolatfelv\u00e9teli m\u00f3dok, mint p\u00e9ld\u00e1ul a HTTP (\u00e9s alatta a TCP) kapcsolat fel\u00e9p\u00edt\u00e9se tipikusan egyszer\u0171 \u00e9s gyors; m\u00edg egy rel\u00e1ci\u00f3s adatb\u00e1zis szerverhez t\u00f6rt\u00e9n\u0151 csatlakoz\u00e1s hosszabb folyamat. \u00cdgy az adatel\u00e9r\u00e9si r\u00e9teg felel az\u00e9rt is, hogy megfelel\u0151 m\u00f3don kezelje a kapcsolatokat , \u00e9s ha lehets\u00e9ges, \u00fajra haszn\u00e1lja a kapcsolatokat ( connection pooling ). Ezt a m\u0171k\u00f6d\u00e9st \u00e1ltal\u00e1ban a j\u00f3l megv\u00e1lasztott kliens k\u00f6nyvt\u00e1rak automatikusan biztos\u00edtj\u00e1k is. Hasonl\u00f3an r\u00e9teg specifikus feladat az adatok konkurens el\u00e9r\u00e9s\u00e9nek \u00e9s m\u00f3dos\u00edt\u00e1s\u00e1nak kezel\u00e9se. Ezzel r\u00e9szletesen foglalkozunk k\u00e9s\u0151bb. Egyel\u0151re annyit \u00e9rdemes megjegyezni err\u0151l, hogy a t\u00f6bbr\u00e9teg\u0171 alkalmaz\u00e1st tipikusan egyszerre t\u00f6bb felhaszn\u00e1l\u00f3 haszn\u00e1lja (gondoljunk csak bele a Neptun rendszerbe, vagy egy webshop m\u0171k\u00f6d\u00e9s\u00e9be), \u00edgy el\u0151fordulhat, hogy egyszerre t\u00f6bben m\u00f3dos\u00edtan\u00e1nak a rendszerben. Ennek szab\u00e1lyait, hogy milyen m\u00f3dos\u00edt\u00e1sok enged\u00e9lyezettek, \u00e9s mik nem, a konkurenciakezel\u00e9s t\u00e9mak\u00f6r\u00e9ben fogjuk t\u00e1rgyalni.","title":"Adatel\u00e9r\u00e9si r\u00e9teg"},{"location":"jegyzet/architektura/#uzleti-logikai-reteg","text":"Az \u00fczleti logikai r\u00e9teg adja az alkalmaz\u00e1sunk lelk\u00e9t. Az adatt\u00e1rol\u00e1s, az adatel\u00e9r\u00e9s, \u00e9s a megjelen\u00edt\u00e9s is mind az\u00e9rt sz\u00fcletik, hogy az \u00fczleti logikai r\u00e9tegben lefektetett funkcionalit\u00e1sokat ny\u00fajtani tudjuk. Hogy pontosan milyen funkci\u00f3kat ny\u00fajt ez a r\u00e9teg, annak f\u00fcggv\u00e9ny\u00e9ben alak\u00edtjuk ki, hogy milyen alkalmaz\u00e1sr\u00f3l van sz\u00f3. Ha a Neptun rendszert tervezz\u00fck, akkor vizsgajelentkez\u00e9sr\u0151l, t\u00e1rgyfelv\u00e9telr\u0151l, tanulm\u00e1nyi id\u0151szakokr\u00f3l fog sz\u00f3lni a r\u00e9teg; ha egy webshopot tervez\u00fcnk, akkor term\u00e9kek, keres\u00e9s, \u00e9rt\u00e9kel\u00e9s, v\u00e1s\u00e1rl\u00e1s lesz a k\u00f6z\u00e9ppontban. \u00c1ltal\u00e1nosan ebben a r\u00e9tegben \u00fczleti entit\u00e1sok ( business entities ), \u00fczleti komponensek ( business components ), \u00e9s \u00fczleti folyamatok ( business workflows ) tal\u00e1lhat\u00f3ak. Az entit\u00e1sok hordozz\u00e1k a kezelt inform\u00e1ci\u00f3kat. A probl\u00e9mater\u00fclet f\u00fcggv\u00e9ny\u00e9ben olyan entit\u00e1sokat defini\u00e1lunk, mint a term\u00e9k \u00e9s \u00e9rt\u00e9kel\u00e9s (egy webshopban), vagy a kurzus \u00e9s a vizsga (a Neptunban). Az entit\u00e1sok manipul\u00e1l\u00e1s\u00e1\u00e9rt felelnek a komponensek. Ezek olyan alapszolg\u00e1ltat\u00e1sokat implement\u00e1lnak, amelyek az alkalmaz\u00e1sunk \u00e1ltal megval\u00f3s\u00edtott bonyolult funkci\u00f3k alap \u00e9p\u00edt\u0151k\u00f6veit adj\u00e1k. Ilyen funkci\u00f3 lehet p\u00e9ld\u00e1ul a term\u00e9kek list\u00e1z\u00e1sa, vagy a n\u00e9v alapj\u00e1n t\u00f6rt\u00e9n\u0151 keres\u00e9s. Ezen alap funkci\u00f3kb\u00f3l \u00e9p\u00edtj\u00fck fel a folyamatokat. A folyamatok a v\u00e9gfelhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra fontos m\u0171veleteket fogj\u00e1k \u00f6ssze. Egy folyamat \u00e1ltal\u00e1ban t\u00f6bb komponens t\u00f6bb m\u0171velet\u00e9t haszn\u00e1lja. Ilyen folyamat p\u00e9ld\u00e1ul a rendel\u00e9s v\u00e9gleges\u00edt\u00e9se ( checkout ) egy webshopban, amely ellen\u0151rzi a term\u00e9keket, ki\u00e1ll\u00edtja a sz\u00e1ml\u00e1t, elk\u00fcldi a meger\u0151s\u00edt\u00e9st emailben, stb.","title":"\u00dczleti logikai r\u00e9teg"},{"location":"jegyzet/architektura/#szolgaltatasi-interfesz-alreteg","text":"A fenti \u00e1br\u00e1n megk\u00fcl\u00f6nb\u00f6ztet\u00e9sre ker\u00fclt a services alr\u00e9teg. Ezt az \u00fczleti logikai r\u00e9teg r\u00e9sz\u00e9nek tekintj\u00fck, annak legfels\u0151 alr\u00e9tege. Feladata a k\u00fcls\u0151 h\u00edv\u00f3 sz\u00e1m\u00e1ra interf\u00e9szt biztos\u00edtani az \u00fczleti logikai r\u00e9teg funkcionalit\u00e1s\u00e1nak el\u00e9r\u00e9s\u00e9hez. Minden eddig t\u00e1rgyalt r\u00e9teg ugyan\u00edgy biztos\u00edt egy interf\u00e9szt a fels\u0151bb r\u00e9tegek sz\u00e1m\u00e1ra. Az \u00fczleti logikai r\u00e9teg az\u00e9rt speci\u00e1lis, \u00e9s az\u00e9rt szok\u00e1s ezt a szolg\u00e1ltat\u00e1si interf\u00e9sz alr\u00e9teget k\u00fcl\u00f6n megeml\u00edteni, mert manaps\u00e1g gyakran nem is egyetlen ilyen interf\u00e9szt publik\u00e1lnak az alkalmaz\u00e1sok. Gyakori, hogy egy alkalmaz\u00e1s t\u00f6bb megjelen\u00edt\u00e9si r\u00e9teggel is rendelkezik, gondolunk csak bele a Gmail eset\u00e9be: webalkalmaz\u00e1s, \u00e9s sok f\u00e9le mobil platform. Mindegyik felhaszn\u00e1l\u00f3i fel\u00fclet hasonl\u00f3, de nem teljesen azonos szolg\u00e1ltat\u00e1st ny\u00fajt, \u00edgy gyakran elk\u00fcl\u00f6n\u00fclnek a k\u00fcl\u00f6nb\u00f6z\u0151 megjelen\u00edt\u00e9si r\u00e9tegek sz\u00e1m\u00e1ra ny\u00fajtott interf\u00e9szek. Tov\u00e1bbi gyakori eset, hogy az alkalmaz\u00e1sunk nem csak egy saj\u00e1t megjelen\u00edt\u00e9si r\u00e9teggel rendelkezik, hanem un. API-t ( application programming interface ) is el\u00e9rhet\u0151v\u00e9 tesz. Az API harmadik f\u00e9l sz\u00e1m\u00e1ra teszi el\u00e9rhet\u0151v\u00e9 az alkalmaz\u00e1sunk funkci\u00f3it. A saj\u00e1t felhaszn\u00e1l\u00f3i fel\u00fclet\u00fcnk, \u00e9s a harmadik f\u00e9l sz\u00e1m\u00e1ra ny\u00fajtott API funkcionalit\u00e1sa \u00e9s el\u00e9r\u00e9se gyakran elt\u00e9r\u0151, \u00e9s k\u00fcl\u00f6n technol\u00f3gi\u00e1t, \u00edgy k\u00fcl\u00f6n szolg\u00e1ltat\u00e1si interf\u00e9szeket is ig\u00e9nyel. Az API publik\u00e1l\u00e1ssal v\u00e1lhat a mi alkalmaz\u00e1sunk maga is k\u00fcls\u0151 adatforr\u00e1ss\u00e1 m\u00e1s alkalmaz\u00e1sok sz\u00e1m\u00e1ra. Az \u00fczleti logikai funkci\u00f3ink publik\u00e1l\u00e1s\u00e1val r\u00e9szletesebben foglalkozunk a f\u00e9l\u00e9v sor\u00e1n. Meg fogjuk ismerni a web services \u00e9s a REST modelleket.","title":"Szolg\u00e1ltat\u00e1si interf\u00e9sz alr\u00e9teg"},{"location":"jegyzet/architektura/#megjelenitesi-reteg","text":"A megjelen\u00edt\u00e9si r\u00e9teg ( presentation layer , UI , vagy felhaszn\u00e1l\u00f3i fel\u00fclet) feladata az adatok felhaszn\u00e1l\u00f3bar\u00e1t megjelen\u00edt\u00e9se, \u00e9s a lehets\u00e9ges m\u0171veletek kezdem\u00e9nyez\u00e9s\u00e9nek lehet\u0151v\u00e9 t\u00e9tele. Az adatok prezent\u00e1l\u00e1sa olyan m\u00f3don kell t\u00f6rt\u00e9njen, ahogy az a felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra hasznos. P\u00e9ld\u00e1ul egy list\u00e1s megjelen\u00edt\u00e9s eset\u00e9n gyakran a felhaszn\u00e1l\u00f3i fel\u00fclet feladata a rendez\u00e9s, csoportos\u00edt\u00e1s, kereshet\u0151s\u00e9g. Rendez\u00e9s \u00e9s keres\u00e9s A v\u00e1lasztott technol\u00f3gia f\u00fcggv\u00e9ny\u00e9ben a rendez\u00e9s, keres\u00e9s tipikusan ig\u00e9nybe veszi a t\u00f6bbi r\u00e9teget is. Nagy mennyis\u00e9g\u0171 adat, t\u00f6bb sz\u00e1z, vagy t\u00f6bb ezer rekordot nem c\u00e9lszer\u0171 egyben eljuttatni a megjelen\u00edt\u00e9si r\u00e9teg sz\u00e1m\u00e1ra, hogy ott legyen a keres\u00e9s megval\u00f3s\u00edtva. Ez egyr\u00e9szt terheli a h\u00e1l\u00f3zatot is, m\u00e1sr\u00e9szt a UI technol\u00f3gi\u00e1k limit\u00e1ci\u00f3i miatt nem hat\u00e9kony sok adatot itt mem\u00f3ri\u00e1ban tartani. Viszont, ha nem nagy mennyis\u00e9g\u0171 adatr\u00f3l van sz\u00f3, sokkal eleg\u00e1nsabb a megjelen\u00edt\u00e9si r\u00e9tegre b\u00edzni mindezt, mert sokkal gyorsabb lesz a visszajelz\u00e9s a felhaszn\u00e1l\u00f3nak (hiszen ha mindezt a UI v\u00e9gzi, nem sz\u00fcks\u00e9ges minden alkalommal a h\u00e1tt\u00e9rrendszerhez fordulni). Az adatok megjelen\u00edt\u00e9se sor\u00e1n a UI felel\u0151s olyan egyszer\u0171 transzform\u00e1ci\u00f3k\u00e9rt is, mint p\u00e9ld\u00e1ul a d\u00e1tum felhaszn\u00e1l\u00f3bar\u00e1t megjelen\u00edt\u00e9se. A kor\u00e1bban eml\u00edtett p\u00e9lda alapj\u00e1n teh\u00e1t egy d\u00e1tumot a felhaszn\u00e1l\u00f3i fel\u00fclet feladata a \"15:23\", 3:23 AM\", vagy ak\u00e1r a \"15 perccel ezel\u0151tt\" sz\u00f6veges megjelen\u00edt\u00e9sre \u00e1talak\u00edtani. Tov\u00e1bb\u00e1, a felhaszn\u00e1l\u00f3i fel\u00fclet feladata az un. lokaliz\u00e1ci\u00f3 is. A lokaliz\u00e1ci\u00f3 a UI felhaszn\u00e1l\u00f3 \u00e1ltal v\u00e1lasztott nyelven val\u00f3 megjelen\u00edt\u00e9se, amely kiterjed a statikus sz\u00f6vegekre, feliratokra is, de egyben a kult\u00fara f\u00fcgg\u0151 adat transzform\u00e1ci\u00f3kra is (mint a d\u00e1tumok, sz\u00e1mok, p\u00e9nznemek megjelen\u00edt\u00e9se is). A felhaszn\u00e1l\u00f3i fel\u00fclet felel m\u00e9g a v\u00e9gfelhaszn\u00e1l\u00f3 interakci\u00f3inak kezel\u00e9s\u00e9\u00e9rt. Ha egy gombra kattintottak, akkor a UI kezdem\u00e9nyezi a k\u00e9rt funkci\u00f3 v\u00e9grehajt\u00e1s\u00e1t, \u00e9s t\u00e1j\u00e9koztatja a v\u00e9geredm\u00e9nyr\u0151l a felhaszn\u00e1l\u00f3t. Amikor a felhaszn\u00e1l\u00f3 adatot visz be a rendszerbe, azt is a felhaszn\u00e1l\u00f3i fel\u00fclet biztos\u00edtja, \u00e9s ez a r\u00e9teg felel az adatok valid\u00e1ci\u00f3j\u00e1\u00e9rt (ellen\u0151rz\u00e9s\u00e9\u00e9rt) is. A valid\u00e1ci\u00f3 sor\u00e1n egyszer\u0171bb ellen\u0151rz\u00e9sek hajthat\u00f3k v\u00e9gre, mint p\u00e9ld\u00e1ul, hogy a sz\u00fcks\u00e9ges mez\u0151k nem maradhatnak \u00fcresen, az email c\u00edmben kell legyen @ karakter, a megadott percnek 0 \u00e9s 59 k\u00f6z\u00e9 kell esnie, stb. Valid\u00e1ci\u00f3 A valid\u00e1ci\u00f3t nem el\u00e9g, ha kiz\u00e1r\u00f3lag a felhaszn\u00e1l\u00f3i fel\u00fclet v\u00e9gzi. A v\u00e1lasztott technol\u00f3gi\u00e1t\u00f3l f\u00fcgg\u0151en a UI k\u00f6nnyen \"kiker\u00fclhet\u0151\", \u00e9s lehet\u0151s\u00e9g van az adatokat k\u00f6zvetlen\u00fcl a h\u00e1tt\u00e9rrendszernek k\u00fcldeni. Ilyen esetben, ha a valid\u00e1ci\u00f3t csak a felhaszn\u00e1l\u00f3 fel\u00fclet val\u00f3s\u00edtan\u00e1 meg, \u00e9rv\u00e9nytelen adat ker\u00fclhetne a rendszerbe. Ez\u00e9rt a valid\u00e1ci\u00f3kat tipikusan megism\u00e9tli a h\u00e1tt\u00e9rrendszer is. Ennek ellen\u00e9re praktikus ezeket a felhaszn\u00e1l\u00f3i fel\u00fcleten is elv\u00e9gezni, mert azonnali visszajelz\u00e9st tudunk \u00edgy adni a felhaszn\u00e1l\u00f3nak. A r\u00e9teggel enn\u00e9l r\u00e9szleteseben nem foglalkozunk ezen t\u00e1rgy keretei k\u00f6z\u00f6tt.","title":"Megjelen\u00edt\u00e9si r\u00e9teg"},{"location":"jegyzet/architektura/#retegfuggetlen-szolgaltatasok","text":"R\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok ( crosscutting concerns ) n\u00e9ven szoktuk hivatkozni az alkalmaz\u00e1s olyan szolg\u00e1ltat\u00e1sait, amelyek nem csak egy r\u00e9tegben jelennek meg. Az ilyen szolg\u00e1ltat\u00e1sok implement\u00e1l\u00e1sakor igyeksz\u00fcnk el\u00e9rni, hogy b\u00e1r t\u00f6bb r\u00e9tegben is jelen van az adott szolg\u00e1ltat\u00e1s, m\u00e9gis, egy k\u00f6z\u00f6s implement\u00e1ci\u00f3t, k\u00f3dot, megold\u00e1st haszn\u00e1ljunk.","title":"R\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok"},{"location":"jegyzet/architektura/#biztonsag","text":"A biztons\u00e1gi szolg\u00e1ltat\u00e1sok lefedik a felhaszn\u00e1l\u00f3k bel\u00e9ptet\u00e9s\u00e9t ( authentik\u00e1ci\u00f3 ) \u00e9s a hozz\u00e1f\u00e9r\u00e9s ellen\u0151rz\u00e9s\u00e9t ( authoriz\u00e1ci\u00f3 ), valamint a nyomk\u00f6vet\u00e9st \u00e9s audit\u00e1l\u00e1st. Az authentik\u00e1ci\u00f3 a \"ki vagy\" k\u00e9rd\u00e9st, m\u00edg az authoriz\u00e1ci\u00f3 a \"mihez van jogod\" k\u00e9rd\u00e9st kezeli. Az authentik\u00e1ci\u00f3 nem csak a felhaszn\u00e1l\u00f3i fel\u00fcleten t\u00f6rt\u00e9n\u0151 bejelentkez\u00e9st jelenti. Az adatb\u00e1zis szerverek fel\u00e9 is tipikusan sz\u00fcks\u00e9g\u00fcnk van bejelentkez\u00e9sre, vagy ha k\u00fcls\u0151 szolg\u00e1ltat\u00e1s fel\u00e9 fordulunk, oda is be kell jelentkezn\u00fcnk. Ez\u00e9rt teh\u00e1t ez az aspektus t\u00f6bb r\u00e9tegben is jelen van. Bejelentkez\u00e9sre t\u00f6bbf\u00e9le megk\u00f6zel\u00edt\u00e9st v\u00e1laszthatunk. K\u00e9sz\u00edthet\u00fcnk saj\u00e1t bejelentkez\u00e9st, haszn\u00e1lhatunk valamilyen c\u00edmt\u00e1ras megold\u00e1st, vagy OAuth bejelentkez\u00e9st. Ha a mi alkalmaz\u00e1sunk bejelentkeztetett egy felhaszn\u00e1l\u00f3t, akkor eld\u00f6nthetj\u00fck, hogy a k\u00fcls\u0151 szolg\u00e1ltat\u00e1s fel\u00e9 ennek a felhaszn\u00e1l\u00f3nak a nev\u00e9ben fordulunk (pl. ahogy a Gmail a Google Drive-r\u00f3l sz\u00e1rmaz\u00f3 f\u00e1jlokat a bejelentkezett felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra list\u00e1zza), avagy egy k\u00f6zponti felhaszn\u00e1l\u00f3 nev\u00e9ben j\u00e1runk el (pl. ha a rendszer emailt k\u00fcld, akkor azt tipikusan egy k\u00f6zpontilag konfigur\u00e1lt fi\u00f3k nev\u00e9ben k\u00fcldi el). A hozz\u00e1f\u00e9r\u00e9s szab\u00e1lyoz\u00e1s megszabja, hogy milyen funkci\u00f3khoz ki f\u00e9rhet hozz\u00e1. Ennek ellen\u0151rz\u00e9se t\u00f6rt\u00e9nhet a felhaszn\u00e1l\u00f3i fel\u00fcleten is (ne is jelenjen meg a a nem el\u00e9rhet\u0151 funkci\u00f3), de ahogy a bemenetek valid\u00e1ci\u00f3j\u00e1n\u00e1l is eml\u00edt\u00e9sre ker\u00fclt, az \u00fczleti logik\u00e1nak meg kell ism\u00e9telnie az ellen\u0151rz\u00e9st. Fontos, hogy ez a k\u00e9t valid\u00e1ci\u00f3 azonos szab\u00e1lyrendszer szerint dolgozzon. A nyomk\u00f6vet\u00e9s, audit\u00e1l\u00e1s feladata, hogy visszakereshet\u0151v\u00e9 v\u00e1ljon a rendszerben, hogy ki, mikor, mit csin\u00e1lt. C\u00e9lja, hogy egy ember ne tudja \"elt\u00fcntetni a nyomokat\". Ez a fajta napl\u00f3z\u00e1s t\u00f6bb ponton is megt\u00f6rt\u00e9nhet, tipikusan az \u00fczleti logik\u00e1ban \u00e9s az adatb\u00e1zisban.","title":"Biztons\u00e1g"},{"location":"jegyzet/architektura/#uzemeltetes","text":"Az \u00fczemeltet\u00e9si szempontok figyelembe v\u00e9tele el\u0151seg\u00edti, hogy a szoftver fejleszt\u00e9s ut\u00e1ni \u00e9letciklusa sor\u00e1n is kiel\u00e9g\u00edtse a felhaszn\u00e1l\u00f3k ig\u00e9nyeit. Ide olyan feladatok megold\u00e1sa tartozik, mint az egys\u00e9ges kiv\u00e9telkezel\u00e9s, a megfelel\u0151 napl\u00f3z\u00e1s \u00e9s monitoroz\u00e1s, valamint a konfigur\u00e1l\u00e1s \u00e9s konfigur\u00e1ci\u00f3-kezel\u00e9s. A kiv\u00e9telkezel\u00e9s sor\u00e1n egy olyan egys\u00e9ges m\u00f3dszert kell kialak\u00edtani, ami az alkalmaz\u00e1s fut\u00e1sa sor\u00e1n keletkez\u0151 minden kiv\u00e9telt megfog. Mindenk\u00e9ppen r\u00f6gz\u00edteni kell a hib\u00e1kat (pl. napl\u00f3z\u00e1ssal), \u00e9s emellett a felhaszn\u00e1l\u00f3t is valamilyen m\u00f3don t\u00e1j\u00e9koztatni a hiba jelleg\u00e9r\u0151l (pl. hogy pr\u00f3b\u00e1lja-e \u00fajra a m\u0171veletet, vagy v\u00e1rjon a jav\u00edt\u00e1sig). Az egys\u00e9ges kiv\u00e9telkezel\u00e9s az\u00e9rt nagyon fontos, mert az architekt\u00fara als\u00f3bb r\u00e9tegeiben el\u0151fordul\u00f3 hib\u00e1kat az \u00fczemeltet\u00e9s \u00e9s fejleszt\u00e9s nem l\u00e1tja, csak ha azok megfelel\u0151en kezelve \u00e9s r\u00f6gz\u00edtve lesznek. A napl\u00f3z\u00e1s \u00e9s monitoroz\u00e1s az \u00fczemszer\u0171 \u00e9s nem rendeltet\u00e9sszer\u0171 viselked\u00e9s k\u00f6vet\u00e9s\u00e9hez is fontos. A napl\u00f3z\u00e1s \u00e1ltal\u00e1ban sz\u00f6veges form\u00e1tum\u00fa rendszer \u00fczenetek r\u00f6gz\u00edt\u00e9s\u00e9t jelenti. A monitoroz\u00e1s a rendszer \u00e1llapot\u00e1t meghat\u00e1rozott jellemz\u0151k (un. KPI -k, key performance indicator ) k\u00f6vet\u00e9s\u00e9t jelenti. Ilyen KPI lehet a mem\u00f3ria fogyaszt\u00e1s, a hib\u00e1s k\u00e9r\u00e9sek sz\u00e1ma, a kiszolg\u00e1lt felhaszn\u00e1l\u00f3k sz\u00e1ma, stb. A konfigur\u00e1ci\u00f3 kezel\u00e9s pedig arr\u00f3l sz\u00f3l, hogy az alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9t befoly\u00e1sol\u00f3 be\u00e1ll\u00edt\u00e1sokat hol t\u00e1roljuk, \u00e9s hogyan k\u00f6tj\u00fck be \u0151ket az alkalmaz\u00e1sba. Konfigur\u00e1ci\u00f3nak min\u0151s\u00fclnek kiszolg\u00e1l\u00f3k el\u00e9r\u00e9si \u00fatvonalai (pl. az adatb\u00e1zis szerver c\u00edme), de ak\u00e1r a megjelen\u00edt\u00e9si r\u00e9tegben haszn\u00e1lt h\u00e1tt\u00e9rsz\u00edn is. Alapelv, hogy a be\u00e1ll\u00edt\u00e1sokat min\u00e9l kev\u00e9sb\u00e9 \"\u00e9gess\u00fck be\" a forr\u00e1sk\u00f3dba, hogy alkalmazkodni tudjunk az \u00fczemeltet\u00e9s sor\u00e1n el\u0151fordul\u00f3 k\u00fcl\u00f6nb\u00f6z\u0151 k\u00f6rnyezetekhez. A konfigur\u00e1ci\u00f3 t\u00f6rt\u00e9nhet tipikusan konfigur\u00e1ci\u00f3s f\u00e1jlokkal, vagy kifejezetten konfigur\u00e1ci\u00f3-menedzsment c\u00e9lra szolg\u00e1l\u00f3 eszk\u00f6z\u00f6kkel is. Az \u00fczemeltet\u00e9si aspektusokkal nem fogunk r\u00e9szletesebben foglalkozni. Tipikusan a v\u00e1lasztott platform k\u00e9pess\u00e9geit \u00e9s lehet\u0151s\u00e9geit haszn\u00e1ljuk a megval\u00f3s\u00edt\u00e1shoz.","title":"\u00dczemeltet\u00e9s"},{"location":"jegyzet/architektura/#kommunikacio","text":"A kommunik\u00e1ci\u00f3s szolg\u00e1ltat\u00e1s az egyes r\u00e9tegek k\u00f6z\u00f6tti kommunik\u00e1ci\u00f3s forma megv\u00e1laszt\u00e1s\u00e1\u00e9rt \u00e9s kezel\u00e9s\u00e9\u00e9rt felel. Ennek helyes megv\u00e1laszt\u00e1sa nem csak architektur\u00e1lis k\u00e9rd\u00e9s, mert nagyban f\u00fcgg a telep\u00edt\u00e9s mik\u00e9ntj\u00e9t\u0151l is. Amennyiben az egyes r\u00e9tegek elt\u00e9r\u0151 kiszolg\u00e1l\u00f3n ker\u00fclnek elhelyez\u00e9sre, h\u00e1l\u00f3zati alap\u00fa kommunik\u00e1ci\u00f3ra van sz\u00fcks\u00e9g; m\u00edg azonos kiszolg\u00e1l\u00f3n \u00fczemeltetett komponensek k\u00f6z\u00f6tt egyszer\u0171bb megold\u00e1sokat haszn\u00e1lhatunk. Manaps\u00e1g szinte minden alkalmaz\u00e1sban valahol megjelenik a h\u00e1l\u00f3zati kommunik\u00e1ci\u00f3: tipikusan az adatb\u00e1zis \u00e9s adatforr\u00e1sok ir\u00e1ny\u00e1ba, illetve a megjelen\u00edt\u00e9si r\u00e9teg \u00e9s a szolg\u00e1ltat\u00e1si interf\u00e9szek k\u00f6z\u00f6tt. Itt tipikusan HTTP vagy arra \u00e9p\u00fcl\u0151 kommunik\u00e1ci\u00f3t szoktak alkalmazni, b\u00e1r nagyobb teljes\u00edtm\u00e9nyt ig\u00e9nyl\u0151 alkalmaz\u00e1sok eset\u00e9n \u00e9rdemes lehet TCP alap\u00fa bin\u00e1ris kommunik\u00e1ci\u00f3t v\u00e1lasztani. Nagy rendszerek eset\u00e9n, ahol az egyes r\u00e9tegek maguk is elosztva, t\u00f6bb kiszolg\u00e1l\u00f3n tal\u00e1lhat\u00f3ak, pedig gyakori az \u00fczenetsorok ( message queue ) haszn\u00e1lata. A kommunik\u00e1ci\u00f3 r\u00e9sz\u00e9nek tekintj\u00fck \u00e1ltal\u00e1ban a titkos\u00edt\u00e1st is. Amennyiben az egyes r\u00e9tegek k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon futnak, fontos, hogy megfelel\u0151en titkos\u00edtsuk a kommunik\u00e1ci\u00f3t. A felhaszn\u00e1l\u00f3i fel\u00fclet \u00e9s a szolg\u00e1ltat\u00e1si interf\u00e9szek k\u00f6z\u00f6tt ez \u00e1ltal\u00e1ban HTTPS/TLS kommunik\u00e1ci\u00f3t jelent.","title":"Kommunik\u00e1ci\u00f3"},{"location":"jegyzet/architektura/#backend-es-frontend","text":"Ha az alkalmaz\u00e1sra egy kicsit m\u00e1s szemsz\u00f6gb\u0151l n\u00e9z\u00fcnk, akkor meg szoktuk k\u00fcl\u00f6nb\u00f6ztetni a backend \u00e9s a frontend r\u00e9szt. A frontend nagyr\u00e9szt a felhaszn\u00e1l\u00f3i fel\u00fclet, vagyis a prezent\u00e1ci\u00f3s r\u00e9teg, ill. annak v\u00e1ltozatos megjelen\u00e9si form\u00e1i (b\u00f6ng\u00e9sz\u0151ben fut\u00f3 webalkalmaz\u00e1s UI, nat\u00edv mobil alkalmaz\u00e1s, vastag kliens UI, stb). A felhaszn\u00e1l\u00f3 ezzel l\u00e9p kapcsolatba. A backend pedig a \"h\u00e1tt\u00e9rben\" fut\u00f3 rendszer, a szolg\u00e1ltat\u00e1si API-k, az \u00fczleti logikai r\u00e9teg, az adatel\u00e9r\u00e9s, adatb\u00e1zisok. A frontend nem csak felhaszn\u00e1l\u00f3 sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n jelenik meg. Frontend technol\u00f3gia f\u00fcggv\u00e9ny\u00e9ben gyakran el\u0151fordul, hogy a felhaszn\u00e1l\u00f3i fel\u00fclet egy r\u00e9sz\u00e9t a backend k\u00e9sz\u00edti el. Ezt szokt\u00e1k szerver oldali renderel\u00e9snek h\u00edvni. Ha \u00f6sszefoglal\u00f3an akarjuk hivatkozni, akkor a t\u00e1rgy keret\u00e9ben a backend technol\u00f3gi\u00e1kkal foglalkozunk.","title":"Backend \u00e9s frontend"},{"location":"jegyzet/architektura/#ellenorzo-kerdesek","text":"Mik a h\u00e1romr\u00e9teg\u0171 architekt\u00fara r\u00e9tegei? Mik a felel\u0151ss\u00e9geik? Ismertesse a r\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sokat! D\u00f6ntse el, hogy igaz vagy hamis az al\u00e1bbi \u00e1ll\u00edt\u00e1s: Az adatbevitel valid\u00e1ci\u00f3j\u00e1\u00e9rt csak a megjelen\u00edt\u00e9si r\u00e9teg felel. Az architekt\u00fara szempontj\u00e1b\u00f3l helytelen, ha SQL parancsok ker\u00fclnek az \u00fczleti logikai r\u00e9tegbe. A h\u00e1romr\u00e9teg\u0171 architekt\u00fara r\u00e9tegei mindig k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon futnak. A h\u00e1romr\u00e9teg\u0171 architekt\u00fara akkor lesz t\u00f6bbr\u00e9teg\u0171, pl. n\u00e9gyr\u00e9teg\u0171, ha teljes\u00edtm\u00e9ny okokb\u00f3l az \u00fczleti logikai r\u00e9teget m\u00e1s kiszolg\u00e1l\u00f3ra vissz\u00fck, mint az adatel\u00e9r\u00e9si r\u00e9teget. A r\u00e9teges fel\u00e9p\u00edt\u00e9s garant\u00e1lja, hogy a r\u00e9tegek \u00e1ltal biztos\u00edtott szolg\u00e1ltat\u00e1sokat tetsz\u0151legesen megv\u00e1ltoztathatjuk, ez nem \u00e9rinti a t\u00f6bbi r\u00e9teget. A frontend \u00e9s a megjelen\u00edt\u00e9si r\u00e9teg egy \u00e9s ugyanaz. Kiv\u00e9telkezel\u00e9sre csak az \u00fczleti logikai r\u00e9tegben van sz\u00fcks\u00e9g.","title":"Ellen\u0151rz\u0151 k\u00e9rd\u00e9sek"},{"location":"jegyzet/di/","text":"F\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s ASP.NET Core k\u00f6rnyezetben \u00b6 Defin\u00edci\u00f3 F\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s ( Dependency Injection , r\u00f6viden DI) egy tervez\u00e9si minta. A fejleszt\u0151ket seg\u00edti abban, hogy az alkalmaz\u00e1s egyes r\u00e9szei laza csatol\u00e1ssal ker\u00fcljenek kialak\u00edt\u00e1sra. A f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s egy mechanizmus arra, hogy az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gi gr\u00e1fjainak l\u00e9trehoz\u00e1s\u00e1t f\u00fcggetlen\u00edts\u00fck az oszt\u00e1ly defin\u00edci\u00f3j\u00e1t\u00f3l. C\u00e9lok k\u00f6nnyebb b\u0151v\u00edthet\u0151s\u00e9g \u00e9s karbantarthat\u00f3s\u00e1g unit tesztelhet\u0151s\u00e9g k\u00f3d \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g Term\u00e9szetesen a fenti defin\u00edc\u00f3b\u00f3l \u00f6nmag\u00e1ban nem der\u00fcl ki, pontosan milyen probl\u00e9m\u00e1kat \u00e9s milyen m\u00f3don old meg a f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s. A k\u00f6vetkez\u0151 fejezetekben egy p\u00e9lda seg\u00edts\u00e9g\u00e9vel helyezz\u00fck kontextusba a probl\u00e9mak\u00f6rt, illetve p\u00e9lda keret\u00e9ben megismerked\u00fcnk az ASP.NET Core be\u00e9p\u00edtett DI szolg\u00e1ltat\u00e1s\u00e1nak alapjaival. Minta alkalmaz\u00e1s A C# forr\u00e1sk\u00f3d eg\u00e9sz itt \u00e9rhet\u0151 el: https://github.com/bmeviauac01/todoapi-di-sample P\u00e9lda 1. f\u00e1zis - szolg\u00e1ltat\u00e1s oszt\u00e1ly be\u00e9getett f\u00fcgg\u0151s\u00e9gekkel \u00b6 A p\u00e9ld\u00e1nkban egy teend\u0151lista (TODO) kezel\u0151 alkalmaz\u00e1s e-mail \u00e9rtes\u00edt\u00e9seket k\u00fcld\u0151 r\u00e9szeibe tekint\u00fcnk bele, k\u00f3dr\u00e9szletek seg\u00edts\u00e9g\u00e9vel. Megjegyz\u00e9s: a k\u00f3d a t\u00f6m\u00f6rs\u00e9g \u00e9rdek\u00e9ben minimalisztikus. A p\u00e9ld\u00e1nk \"bel\u00e9p\u00e9si pontja\" a ToDoService oszt\u00e1ly SendReminderIfNeeded m\u0171velete. // Teend\u0151k kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly public class ToDoService { const string smtpAddress = \"smtp.myserver.com\" ; // Megvizsg\u00e1lja a param\u00e9terk\u00e9nt kapott todoItem objektumot, \u00e9s ha sz\u00fcks\u00e9ges, // e-mail \u00e9rtes\u00edt\u00e9st k\u00fcld a teend\u0151r\u0151l a teend\u0151ben szerepl\u0151 kontakt szem\u00e9lynek. public void SendReminderIfNeeded ( TodoItem todoItem ) { if ( checkIfTodoReminderIsToBeSent ( todoItem )) { NotificationService notificationService = new NotificationService ( smtpAddress ); notificationService . SendEmailReminder ( todoItem . LinkedContactId , todoItem . Name ); } } bool checkIfTodoReminderIsToBeSent ( TodoItem todoItem ) { bool send = true ; /* ... */ return send ; } // ... } // Entit\u00e1soszt\u00e1ly, egy v\u00e9grehajtand\u00f3 feladat adatait z\u00e1rja egys\u00e9gbe public class TodoItem { // Adatb\u00e1zis kulcs public long Id { get ; set ; } // Teend\u0151 neve/le\u00edr\u00e1sa public string Name { get ; set ; } // Jelzi, hogy a teend\u0151 elv\u00e9g\u00e9sre ker\u00fclt-e public bool IsComplete { get ; set ; } // Egy teend\u0151h\u00f6z lehet\u0151s\u00e9g van kontakt szem\u00e9ly hozz\u00e1rendel\u00e9s\u00e9re: ha -1, nincs // kontakt szem\u00e9ly hozz\u00e1rendelve, egy\u00e9bk\u00e9nt pedig a kontakt szem\u00e9ly azonos\u00edt\u00f3ja. public int LinkedContactId { get ; set ; } = - 1 ; } A fenti k\u00f3dban ( ToDoService.SendReminderIfNeeded ) azt l\u00e1tjuk, hogy az e-mail k\u00fcld\u00e9s l\u00e9nyegi logik\u00e1j\u00e1t a NotificationService oszt\u00e1lyban kell keresn\u00fcnk. Val\u00f3ban, vizsg\u00e1l\u00f3d\u00e1sunk k\u00f6zpontj\u00e1ba ez az oszt\u00e1ly ker\u00fcl. A k\u00f6vetkez\u0151 k\u00f3dr\u00e9szlet ezen oszt\u00e1ly k\u00f3dj\u00e1t, valamint a f\u00fcgg\u0151s\u00e9geit mutatja be: // \u00c9rtes\u00edt\u00e9sek k\u00fcld\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly class NotificationService { // Az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei EMailSender _emailSender ; Logger _logger ; ContactRepository _contactRepository ; public NotificationService ( string smtpAddress ) { _logger = new Logger (); _emailSender = new EMailSender ( _logger , smtpAddress ); _contactRepository = new ContactRepository (); } // E-mail \u00e9rtes\u00edt\u00e9st k\u00fcld az adott azonos\u00edt\u00f3j\u00fa kontakt szem\u00e9lynek (a contactId // egy kulcs a Contacts t\u00e1bl\u00e1ban) public void SendEmailReminder ( int contactId , string todoMessage ) { string emailTo = _contactRepository . GetContactEMailAddress ( contactId ); string emailSubject = \"TODO reminder\" ; string emailMessage = \"Reminder about the following todo item: \" + todoMessage ; _emailSender . SendMail ( emailTo , emailSubject , emailMessage ); } } // Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 oszt\u00e1ly public class Logger { public void LogInformation ( string text ) { /* ...*/ } public void LogError ( string text ) { /* ...*/ } } // E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 oszt\u00e1ly public class EMailSender { Logger _logger ; string _smtpAddress ; public EMailSender ( Logger logger , string smtpAddress ) { _logger = logger ; _smtpAddress = smtpAddress ; } public void SendMail ( string to , string subject , string message ) { _logger . LogInformation ( $ \"Sendding e-mail. To: {to} Subject: {subject} Body: {message}\" ); // ... } } // Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly public class ContactRepository { public string GetContactEMailAddress ( int contactId ) { // ... } // ... } P\u00e1r \u00e1ltal\u00e1nos gondolat: A NotificationService oszt\u00e1ly t\u00f6bb f\u00fcgg\u0151s\u00e9ggel rendelkezik ( EMailSender , Logger , ContactRepository oszt\u00e1lyok), ezen oszt\u00e1lyokra \u00e9p\u00edtve val\u00f3s\u00edtja meg a szolg\u00e1ltat\u00e1sait. A f\u00fcgg\u0151s\u00e9g oszt\u00e1lyoknak lehetnek tov\u00e1bbi f\u00fcgg\u0151s\u00e9geik: az EMailSender remek p\u00e9lda erre, \u00e9p\u00edt a Logger oszt\u00e1lyra. Megjegyz\u00e9s: a NotificationService , EMailSender , Logger , ContactRepository oszt\u00e1lyokat szolg\u00e1ltat\u00e1soszt\u00e1lyoknak tekintj\u00fck, mert t\u00e9nyleges logik\u00e1t is tartalmaznak, nem csak adatokat z\u00e1rnak egys\u00e9gbe, mint pl. a TodoItem . Mint l\u00e1that\u00f3, a SendEmailReminder m\u0171veletet egy objektumgr\u00e1f szolg\u00e1lja ki, ahol a NotificationService a gy\u00f6k\u00e9robjektum, melynek h\u00e1rom f\u00fcgg\u0151s\u00e9ge van, \u00e9s a f\u00fcgg\u0151s\u00e9geinek (legal\u00e1bbis az EMailSender -nek) vannak tov\u00e1bbi f\u00fcgg\u0151s\u00e9gei. A k\u00f6vetkez\u0151 \u00e1bra ezt az objektumgr\u00e1fot illusztr\u00e1lja: Megjegyz\u00e9s Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, m\u00e9rt a NotificationService -t, \u00e9s nem a ToDoService -t tekintj\u00fck gy\u00f6k\u00e9robjektumnak. Val\u00f3j\u00e1ban ez csak a n\u00e9z\u0151pontunkon m\u00falik: az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt a ToDoService -t egyfajta bel\u00e9p\u00e9si pontnak (\"kliensnek\") tekintj\u00fck a k\u00e9r\u00e9s vonatkoz\u00e1s\u00e1ban annak \u00e9rdek\u00e9ben, hogy kevesebb oszt\u00e1lyt kelljen a k\u00f6vetkez\u0151kben megvizsg\u00e1lnunk \u00e9s \u00e1talak\u00edtanunk. Egy val\u00f3 \u00e9letbeli alkalmaz\u00e1sban a ToDoService -t is j\u00f3 es\u00e9llyel a f\u00fcgg\u0151s\u00e9gi gr\u00e1f r\u00e9sz\u00e9nek tekinten\u00e9nk. Tekints\u00fck \u00e1t a megold\u00e1s legfontosabb jellemz\u0151it: Az oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit maga p\u00e9ld\u00e1nyos\u00edtja Az oszt\u00e1ly a f\u00fcgg\u0151s\u00e9gei konkr\u00e9t t\u00edpus\u00e1t\u00f3l f\u00fcgg (nem pedig interf\u00e9szekt\u0151l, \"absztrakci\u00f3kt\u00f3l\") Ez a megk\u00f6zel\u00edt\u00e9s t\u00f6bb s\u00falyos negat\u00edvummal b\u00edr: Rugalmatlans\u00e1g, neh\u00e9z b\u0151v\u00edthet\u0151s\u00e9g . A NotificationService (m\u00f3dos\u00edt\u00e1s n\u00e9lk\u00fcl) nem tud m\u00e1s lev\u00e9lk\u00fcld\u0151, napl\u00f3z\u00f3 \u00e9s contact repository implement\u00e1ci\u00f3kkal egy\u00fctt m\u0171k\u00f6dni, csak a be\u00e9getett EMailSender , Logger \u00e9s ContactRepository oszt\u00e1lyokkal. Vagyis pl. nem tudjuk m\u00e1s napl\u00f3z\u00f3 komponenssel, vagy pl. olyan contact repository-vel haszn\u00e1lni, amely m\u00e1s adatforr\u00e1sb\u00f3l dolgozik. Unit tesztelhet\u0151s\u00e9g hi\u00e1nya . A NotificationService (m\u00f3dos\u00edt\u00e1s n\u00e9lk\u00fcl) nem unit tesztelhet\u0151. Ehhez ugyanis le kell cser\u00e9lni az EMailSender , Logger \u00e9s ContactRepository f\u00fcgg\u0151s\u00e9geit olyanokra, melyek (tesztel\u00e9st seg\u00edt\u0151) egyszer\u0171/r\u00f6gz\u00edtett v\u00e1laszokat viselked\u00e9st mutatnak. Ne feledj\u00fck: a unit tesztel\u00e9s l\u00e9nyege, hogy egy oszt\u00e1ly viselked\u00e9s\u00e9t \u00f6nmag\u00e1ban tesztelj\u00fck (pl. az adatb\u00e1zist haszn\u00e1l\u00f3 ContactRepository helyett egy olyan ContactRepository-ra van sz\u00fcks\u00e9g, mely gyorsan, mem\u00f3ri\u00e1b\u00f3l szolg\u00e1lja ki a k\u00e9r\u00e9seket, a teszt el\u0151felt\u00e9teleinek megfelel\u0151en). Van m\u00e9g egy, els\u0151 r\u00e1n\u00e9z\u00e9sre nehezen \u00e9szrevehet\u0151 kellemetlen k\u00f6vetkezm\u00e9ny: a p\u00e9ld\u00e1nkban a smtpAddress param\u00e9tert is \u00e1t kell adni a NotificationService konstruktor\u00e1nak, az\u00e9rt, hogy azt tov\u00e1bb\u00edtani tudja az \u00e1ltala p\u00e9ld\u00e1nyos\u00edtott EMailSender f\u00fcgg\u0151s\u00e9g\u00e9nek. Ugyanakkor a smtpAddress a NotificationService sz\u00e1m\u00e1ra egy transzparens, \"\u00e9rtelmetlen\" inform\u00e1ci\u00f3, elviekben \"semmi k\u00f6ze hozz\u00e1\". Sajnos jelen pillanatban m\u00e9gis \u00e1t kell vezetni rajta, mert \u0151 p\u00e9ld\u00e1nyos\u00edtja az EMailSender -t, aki sz\u00e1m\u00e1ra ez az inform\u00e1ci\u00f3 relev\u00e1ns. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben \u00fagy alak\u00edtjuk \u00e1t a megold\u00e1sunkat, hogy a negat\u00edvumok t\u00f6bbs\u00e9g\u00e9t\u0151l meg tudjunk szabadulni. P\u00e9lda 2. f\u00e1zis - szolg\u00e1ltat\u00e1s oszt\u00e1ly manu\u00e1lis f\u00fcgg\u0151s\u00e9g injekt\u00e1l\u00e1ssal \u00b6 A kor\u00e1bbi megold\u00e1sunkat alak\u00edtjuk \u00e1t, a funkcion\u00e1lis k\u00f6vetelm\u00e9nyek v\u00e1ltozatlanok. Az \u00e1talak\u00edt\u00e1s legfontosabb ir\u00e1nyelvei: a f\u00fcgg\u0151s\u00e9geket absztrakci\u00f3kra, \"interf\u00e9sz alapokra\" helyezz\u00fck , \u00e9s az oszt\u00e1lyok nem maguk p\u00e9ld\u00e1nyos\u00edtj\u00e1k a f\u00fcgg\u0151s\u00e9geiket . public class ToDoService { const string smtpAddress = \"smtp.myserver.com\" ; // Megvizsg\u00e1lja a param\u00e9terk\u00e9nt kapott todoItem objektumot, \u00e9s ha sz\u00fcks\u00e9ges, // e-mail \u00e9rtes\u00edt\u00e9st k\u00fcld a teend\u0151r\u0151l a teend\u0151ben szerepl\u0151 kontakt szem\u00e9lynek. public void SendReminderIfNeeded ( TodoItem todoItem ) { if ( checkIfTodoReminderIsToBeSent ( todoItem )) { var logger = new Logger (); var emailSender = new EMailSender ( logger , smtpAddress ); var contactRepository = new ContactRepository (); NotificationService notificationService = new NotificationService ( logger , emailSender , contactRepository ); notificationService . SendEmailReminder ( todoItem . LinkedContactId , todoItem . Name ); } } bool checkIfTodoReminderIsToBeSent ( TodoItem todoItem ) { bool send = true ; /* ... */ return send ; } } // \u00c9rtes\u00edt\u00e9sek k\u00fcld\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly class NotificationService { // Az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei IEMailSender _emailSender ; ILogger _logger ; IContactRepository _contactRepository ; public NotificationService ( ILogger logger , IEMailSender emailSender , IContactRepository contactRepository ) { _logger = logger ; _emailSender = emailSender ; _contactRepository = contactRepository ; } // E-mail \u00e9rtes\u00edt\u00e9st k\u00fcld az adott azonos\u00edt\u00f3j\u00fa kontakt szem\u00e9lynek (a contactId // egy kulcs a Contacts t\u00e1bl\u00e1ban) public void SendEmailReminder ( int contactId , string todoMessage ) { string emailTo = _contactRepository . GetContactEMailAddress ( contactId ); string emailSubject = \"TODO reminder\" ; string emailMessage = \"Reminder about the following todo item: \" + todoMessage ; _emailSender . SendMail ( emailTo , emailSubject , emailMessage ); } } #region Contracts (abstractions) // Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 interf\u00e9sz public interface ILogger { void LogInformation ( string text ); void LogError ( string text ); } // E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 interf\u00e9sz public interface IEMailSender { void SendMail ( string to , string subject , string message ); } // Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 interf\u00e9sz public interface IContactRepository { string GetContactEMailAddress ( int contactId ); } #endregion #region Implementations // Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 oszt\u00e1ly public class Logger : ILogger { public void LogInformation ( string text ) { /* ...*/ } public void LogError ( string text ) { /* ...*/ } } // E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 oszt\u00e1ly public class EMailSender : IEMailSender { ILogger _logger ; string _smtpAddress ; public EMailSender ( ILogger logger , string smtpAddress ) { _logger = logger ; _smtpAddress = smtpAddress ; } public void SendMail ( string to , string subject , string message ) { _logger . LogInformation ( $ \"Sendding e-mail. To: {to} Subject: {subject} Body: {message}\" ); // ... } } // Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly public class ContactRepository : IContactRepository { public string GetContactEMailAddress ( int contactId ) { // ... } // ... } #endregion A kor\u00e1bbi megold\u00e1st a k\u00f6vetkez\u0151 pontokban fejlesztett\u00fck tov\u00e1bb: A NotificationService oszt\u00e1ly m\u00e1r nem maga p\u00e9ld\u00e1nyos\u00edtja a f\u00fcgg\u0151s\u00e9geit, hanem konstruktor param\u00e9terekben kapja meg. Interf\u00e9szeket (absztrakci\u00f3kat) vezett\u00fcnk be a f\u00fcgg\u0151s\u00e9gek kezel\u00e9s\u00e9re. A NotificationService oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit interf\u00e9szek form\u00e1j\u00e1ban kapja meg. Azt, amikor egy oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit k\u00edv\u00fclr\u0151l kapja meg, DEPENDENCY INJECTION -nek (DI) vagyis f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1snak nevezz\u00fck. Eset\u00fcnkben konstruktor param\u00e9terekben kapj\u00e1k meg az oszt\u00e1lyok f\u00fcgg\u0151s\u00e9geiket. A DI ezen form\u00e1j\u00e1t CONSTRUCTOR INJECTION -nek (konstruktor injekt\u00e1l\u00e1s) nevezz\u00fck. Ez a f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s legyakoribb - \u00e9s legink\u00e1bb javasolt m\u00f3dja (alternat\u00edva pl. a property injection, amikor is publikus property setter seg\u00edts\u00e9g\u00e9vel \u00e1ll\u00edtjuk be az oszt\u00e1ly adott f\u00fcgg\u0151s\u00e9g\u00e9t). Megold\u00e1sunkban a NotificationService f\u00fcgg\u0151s\u00e9geit az oszt\u00e1ly (k\u00f6zvetlen) FELHASZN\u00c1L\u00d3JA p\u00e9ld\u00e1nyos\u00edtja ( ToDoService oszt\u00e1ly). Els\u0151dlegesen ebb\u0151l ered\u0151en a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k \u00e1llnak m\u00e9g fent: A NotificationService felhaszn\u00e1l\u00f3ja, vagyis a ToDoService.SendReminderIfNeeded m\u00e9g mindig f\u00fcgg a konkr\u00e9t implement\u00e1ci\u00f3s t\u00edpusokt\u00f3l (hiszen neki sz\u00fcks\u00e9ges p\u00e9ld\u00e1nyos\u00edtania a Logger , EMailSender \u00e9s ContactRepository oszt\u00e1lyokat). Ha az alkalmaz\u00e1sunkban t\u00f6bb helyen haszn\u00e1ljuk a Logger , EMailSender \u00e9s ContactRepository oszt\u00e1lyokat, mindenhol k\u00fcl\u00f6n-k\u00fcl\u00f6n explicit p\u00e9ld\u00e1nyos\u00edtani kell \u0151ket. Vagyis mindenhol k\u00fcl\u00f6n-k\u00fcl\u00f6n d\u00f6nteni kell \u00e9s meg kell adni, hogy milyen absztrakci\u00f3 (interf\u00e9sz t\u00edpus) eset\u00e9n milyen implement\u00e1ci\u00f3s t\u00edpust haszn\u00e1lunk az alkalmaz\u00e1sban. Ez a k\u00f3d/logika duplik\u00e1ci\u00f3 speci\u00e1lis, kiss\u00e9 nehezen kisz\u00farhat\u00f3 esete. A c\u00e9lunk ezzel szemben az lenne, hogy egyetlen k\u00f6zponti helyen hat\u00e1rozzuk meg hogy milyen absztrakci\u00f3 (interf\u00e9sz t\u00edpus) eset\u00e9n milyen implement\u00e1ci\u00f3s t\u00edpust kell mindenhol haszn\u00e1lni az alkalmaz\u00e1sban (pl. ILogger->Logger, IMailSender->EMailSender). Ez\u00e1ltal egyr\u00e9szt egy helyen, k\u00f6nnyen \u00e1t tudn\u00e1nk tekinteni a lek\u00e9pez\u00e9seinket. M\u00e1sr\u00e9szt ha meg akarjuk v\u00e1ltoztatni az egyik lek\u00e9pez\u00e9st (pl. ILogger eset\u00e9n Logger helyett AdvancedLogger haszn\u00e1lata), azt el\u00e9g egy k\u00f6zponti helyen megtenni. P\u00e9lda 3. f\u00e1zis - f\u00fcgg\u0151s\u00e9gek injekt\u00e1l\u00e1sa .NET Core Dependency Injection alapokon \u00b6 Az el\u0151z\u0151 fejezetben z\u00e1r\u00f3gondolatk\u00e9nt megfogalmazott k\u00e9t probl\u00e9ma megold\u00e1s\u00e1ra m\u00e1r n\u00e9mi extra seg\u00edts\u00e9gre van sz\u00fcks\u00e9g\u00fcnk: egy Inversion of Control (IoC) kont\u00e9nerre. Egy IoC kont\u00e9nerbe absztrakci\u00f3s t\u00edpus -> implement\u00e1ci\u00f3s t\u00edpus lek\u00e9pez\u00e9seket tudunk t\u00e1rolni (REGISTER), majd ezt k\u00f6vet\u0151en absztrakci\u00f3s t\u00edpus alapj\u00e1n implement\u00e1ci\u00f3s t\u00edpusokat p\u00e9ld\u00e1nyos\u00edtani (RESOLVE). R\u00e9szletesebben: REGISTER (regisztr\u00e1ci\u00f3) : Az alkalmaz\u00e1s indul\u00e1sakor egyszer, k\u00f6zpontos\u00edtva egy Inversion of Control (IoC) kont\u00e9nerbe beregisztr\u00e1ljuk a f\u00fcgg\u0151s\u00e9gi lek\u00e9pez\u00e9seket (pl. ILogger->Logger, IMailSender->EMailSender). Ez a DI folyamat REGISTER l\u00e9p\u00e9se. Megjegyz\u00e9s: ezzel megoldottuk az el\u0151z\u0151 fejezeben felvezetett 2. probl\u00e9m\u00e1t, a lek\u00e9pez\u00e9seket egy k\u00f6zponti helyen \u00e9s nem az alkalmaz\u00e1sban sz\u00e9tsz\u00f3rva adjuk meg. RESOLVE (f\u00fcgg\u0151s\u00e9gfelold\u00e1s) : Amikor az alkalmaz\u00e1s fut\u00e1sakor sz\u00fcks\u00e9g\u00fcnk van egy implement\u00e1ci\u00f3s objektumra, a kont\u00e9nert\u0151l az absztrakci\u00f3 (interf\u00e9szt) t\u00edpus\u00e1t megadva k\u00e9r\u00fcnk egy implement\u00e1ci\u00f3t (pl. ILoggert megadva egy Logger objektumot kapunk). A resolve l\u00e9p\u00e9st az alkalmaz\u00e1s \" bel\u00e9p\u00e9si pontj\u00e1ban \" tessz\u00fck meg (pl. WebApi eset\u00e9n az egyes API k\u00e9r\u00e9sek be\u00e9rkez\u00e9sekor). A felold\u00e1st a kont\u00e9nert\u0151l csak a \" ROOT OBJECT \"-re (pl. WebApi eset\u00e9n a megfelel\u0151 Controller oszt\u00e1lyra) k\u00e9rj\u00fck explicit m\u00f3don: ez legy\u00e1rtja a root objectet, illetve annak valamennyi f\u00fcgg\u0151s\u00e9g\u00e9t, \u00e9s valamennyi k\u00f6zvetett f\u00fcgg\u0151s\u00e9g\u00e9t: el\u0151\u00e1ll egy objektumgr\u00e1f. Ez az AUTOWIRING folyamata. Megjegyz\u00e9s: Web API eset\u00e9n a Resolve l\u00e9p\u00e9st a keretrendszer v\u00e9gzi el: mi csak annyit tapasztalunk, hogy a controller oszt\u00e1lyunk automatikusan p\u00e9ld\u00e1nyos\u00edt\u00f3dik, \u00e9s valamennyi konstruktor param\u00e9tere automatikusan kit\u00f6lt\u00e9sre ker\u00fcl (a REGISTER l\u00e9p\u00e9s regisztr\u00e1ci\u00f3i alapj\u00e1n). Szerencs\u00e9re a .NET Core rendelkezik IoC Container alap\u00fa dependency injection szolg\u00e1ltat\u00e1ssal. A k\u00f6vetkez\u0151kben a tov\u00e1bbfejlesztett e-mail \u00e9rtes\u00edt\u0151 megold\u00e1sunkat p\u00e9ldak\u00e9nt haszn\u00e1lva vil\u00e1g\u00edtjuk meg jobban a mechanizmust. 1) REGISTER l\u00e9p\u00e9s (f\u00fcgg\u0151s\u00e9gek beregisztr\u00e1l\u00e1sa) \u00b6 Asp.Net Core k\u00f6rnyezetben a f\u00fcgg\u0151s\u00e9gek beregisztr\u00e1l\u00e1sa a Startup oszt\u00e1lyunk ConfigureServices(IServiceCollection services) m\u0171velet\u00e9ben t\u00f6rt\u00e9nik, m\u00e9gpedig a IServiceCollection AddSingleton , AddTransient \u00e9s AddScoped m\u0171veleteivel. Els\u0151 l\u00e9p\u00e9sben f\u00f3kusz\u00e1ljunk a ConfigureServices sz\u00e1munka legizgalmasabb r\u00e9szeire: public class Startup { public void ConfigureServices ( IServiceCollection services ) { // ... services . AddSingleton < ILogger , Logger >(); services . AddTransient < INotificationService , NotificationService >(); services . AddScoped < IContactRepository , ContactRepository >(); services . AddSingleton < IEMailSender , EMailSender >( sp => new EMailSender ( sp . GetRequiredService < ILogger >(), \"smtp.myserver.com\" ) ); // ... } A Startup.ConfigureServices -t a keretrendszer h\u00edvja az alkalmaz\u00e1s indul\u00e1sakor. Param\u00e9terben egy IServiceCollection services objektumot kapunk, sz\u00e1munkra ez reprezent\u00e1lja a keretendszer \u00e1ltal m\u00e1r el\u0151re p\u00e9ld\u00e1nyos\u00edtott IoC kont\u00e9nert, ebbe tudjuk a saj\u00e1t f\u00fcgg\u0151s\u00e9geinket beregisztr\u00e1lni. A services . AddSingleton < ILogger , Logger >(); sorral ILogger t\u00edpusk\u00e9nt a Logger implement\u00e1ci\u00f3s t\u00edpust regisztr\u00e1ljuk be (ILogger->Logger lek\u00e9pz\u00e9s), m\u00e9gpedig az AddSingleton m\u0171velet hat\u00e1s\u00e1ra singleton -k\u00e9nt. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l egy ILogger objektumot k\u00e9r\u00fcnk (resolve), a kont\u00e9nert\u0151l egy Logger objektumot kapunk, m\u00e9gpedig mindig ugyanazt a p\u00e9ld\u00e1nyt . A services . AddTransient < INotificationService , NotificationService >(); sorral INotificationService t\u00edpusk\u00e9nt a NotificationService implement\u00e1ci\u00f3s t\u00edpust regiszt\u00e1ljuk be (INotificationService->NotificationService lek\u00e9pz\u00e9s), m\u00e9gpedig az AddTransient m\u0171velet hat\u00e1s\u00e1ra tranziens m\u00f3don. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l egy INotificationService objektumot k\u00e9r\u00fcnk (resolve), a kont\u00e9nert\u0151l egy NotificationService objektumot kapunk, m\u00e9gpedig minden lek\u00e9rdez\u00e9skor egy \u00fajonnan l\u00e9trehozott p\u00e9ld\u00e1nyt . A services . AddScoped < IContactRepository , ContactRepository >(); sor IContactRepository t\u00edpusk\u00e9nt a ContactRepository implement\u00e1ci\u00f3s t\u00edpust regisztr\u00e1lja be (IContactRepository->ContactRepository lek\u00e9pz\u00e9s), m\u00e9gpedig az AddScoped m\u0171velet hat\u00e1s\u00e1ra scope-olt m\u00f3don. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l IContactRepository objektumot k\u00e9r\u00fcnk (resolve), ContactRepository objektumot kapunk, m\u00e9gpedig adott hat\u00f3k\u00f6r\u00f6n bel\u00fcl ugyanazt , elt\u00e9r\u0151 hat\u00f3k\u00f6r\u00f6kben m\u00e1sokat. A Web API alkalmaz\u00e1sokn\u00e1l egy-egy API k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sz\u00e1m\u00edt egy-egy megfelel\u0151 hat\u00f3k\u00f6rnek: vagyis a kont\u00e9nert\u0151l egy k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sor\u00e1n ugyanazt az objektump\u00e9ld\u00e1nyt, elt\u00e9r\u0151 k\u00e9r\u00e9sek eset\u00e9n m\u00e1sokat kapunk. A mintaalkalmaz\u00e1s Startup.ConfigureServices -ben tov\u00e1bbi regisztr\u00e1ci\u00f3kkal is tal\u00e1lkozunk, ezekre k\u00e9s\u0151bb t\u00e9r\u00fcnk vissza. 2) RESOLVE l\u00e9p\u00e9s (f\u00fcgg\u0151s\u00e9gek felold\u00e1sa) \u00b6 Alapok \u00b6 Jelen pillanatban ott tartunk, hogy az alkalmaz\u00e1s indul\u00e1sakor beregisztr\u00e1ltuk a szolg\u00e1ltat\u00e1s t\u00edpusok f\u00fcgg\u0151s\u00e9gi lek\u00e9pez\u00e9seit az ASP.NET Core IoC kont\u00e9ner\u00e9be. A t\u00edpuslek\u00e9pez\u00e9seink a k\u00f6vetkez\u0151k: ILogger -> Logger, singletonk\u00e9nt INotificationService -> NotificationService, tranziensk\u00e9nt IContactRepository -> ContactRepository, scope-oltk\u00e9nt IEMailSender -> EMailSender, singletonk\u00e9nt Ezt k\u00f6vet\u0151en, amikor sz\u00fcks\u00e9g\u00fcnk van egy adott implement\u00e1ci\u00f3s t\u00edpusra, a kont\u00e9nert\u0151l az (absztrakci\u00f3s) t\u00edpus, mint kulcs alapj\u00e1n k\u00e9rhet\u00fcnk egy implement\u00e1ci\u00f3s p\u00e9ld\u00e1nyt. Ennek sor\u00e1n ASP.NET Core k\u00f6rnyezetben a kont\u00e9nert egy IServiceProvider hivatkoz\u00e1s form\u00e1j\u00e1ban kapjuk meg, \u00e9s a GetService m\u0171velet k\u00fcl\u00f6nb\u00f6z\u0151 form\u00e1it haszn\u00e1ljuk. Pl.: void SimpleResolve ( IServiceProvider sp ) { // Mivel az ILogger t\u00edpushoz a Logger oszt\u00e1lyt regisztr\u00e1ltuk, // egy Logger p\u00e9ld\u00e1nnyal t\u00e9r vissza. var logger1 = sp . GetService ( typeof ( ILogger )); // A t\u00edpus generikus param\u00e9terben is megadhatjuk, k\u00e9nyelmesebb, ezt szoktuk haszn\u00e1lni. // Ehhez sz\u00fcks\u00e9g van a Microsoft.Extensions.DependencyInjection n\u00e9vt\u00e9r using-ol\u00e1s\u00e1ra, // mert ez a GetService forma ott defini\u00e1lt extension methodk\u00e9nt. // Mivel az ILogger t\u00edpushoz a Logger oszt\u00e1lyt regisztr\u00e1ltuk, // egy Logger p\u00e9ld\u00e1nnyal t\u00e9r vissza. var logger2 = sp . GetService < ILogger >(); // M\u00edg a GetService null-t ad vissza, ha nem siker\u00fcl feloldani a // kont\u00e9ner alapj\u00e1n a hivatkoz\u00e1st, a GetRequiredService kiv\u00e9telt dob. var logger3 = sp . GetRequiredService < ILogger >(); // ... } A p\u00e9ld\u00e1ban k\u00f3dkommentek r\u00e9szletesen elmagyar\u00e1zz\u00e1k a viselked\u00e9st. Minden esetben a l\u00e9nyeg az, hogy vagy a typeof oper\u00e1torral, vagy generikus param\u00e9terben megadunk egy absztrakci\u00f3s t\u00edpust, \u00e9s a GetService egy az ahhoz beregisztr\u00e1lt implement\u00e1ci\u00f3s t\u00edpussal t\u00e9r vissza. Objektumgr\u00e1f felold\u00e1sa, autowiring \u00b6 Az el\u0151z\u0151 p\u00e9ld\u00e1nkban a kont\u00e9ner a felold\u00e1s sor\u00e1n komolyabb \"fejt\u00f6r\u00e9s\" n\u00e9lk\u00fcl tudta a Logger oszt\u00e1lyt p\u00e9ld\u00e1nyos\u00edtani, ugyanis annak nincsenek tov\u00e1bbi f\u00fcgg\u0151s\u00e9gei: egyetlen default konstruktorral rendelkezik. Tekints\u00fck most az INotificationService felold\u00e1s\u00e1t: public void ObjectGraphResolve ( IServiceProvider sp ) { var notifService = sp . GetService < INotificationService >(); // ... } A felold\u00e1s (GetService h\u00edv\u00e1s) sor\u00e1n a kont\u00e9nernek egy NotificationService objektumot kell l\u00e9trehoznia. Ez csak \u00fagy lehets\u00e9ges, ha minden konstruktor param\u00e9ter\u00e9nek megfelel\u0151 objektumot ad meg. Ez a gyakorlatban azt jelenti, hogy a l\u00e9trehoz\u00e1s sor\u00e1n feloldja az oszt\u00e1ly k\u00f6zvetlen \u00e9s k\u00f6zvetett f\u00fcgg\u0151s\u00e9geit, rekurz\u00edvan: A NotificationService oszt\u00e1ly egy h\u00e1romparam\u00e9teres konstruktorral rendelkezik (vagyis h\u00e1rom f\u00fcgg\u0151s\u00e9ge is van): NotificationService(ILogger logger, IEMailSender emailSender, IContactRepository contactRepository) . A konstruktorparam\u00e9tereket a GetService egyes\u00e9vel feloldja a regisztr\u00e1ci\u00f3k alapj\u00e1n: ILogger logger: egy Logger objektum lesz, mindig ugyanaz (mert singleton) IEMailSender emailSender: EMailSender objektum lesz, minden alkalommal m\u00e1s (mert transient) Ennek van egy ILogger logger konstruktor param\u00e9tere, amit fel kell oldani: Egy Logger objektum lesz, mindig ugyanaz (mert singleton) IContactRepository contactRepository: ContactRepository objektum lesz, hat\u00f3k\u00f6r\u00f6nk\u00e9nt - Web API eset\u00e9n API h\u00edv\u00e1sonk\u00e9nt - m\u00e1s (mert scoped). A felold\u00e1s v\u00e9g\u00e9re - vagyis amikor visszat\u00e9r a fenti GetService<INotificationService>() h\u00edv\u00e1s - el\u0151\u00e1ll a teljesen felparam\u00e9terezett NotificationService objektum, valamennyi k\u00f6zvetlen \u00e9s k\u00f6zvetett f\u00fcgg\u0151s\u00e9g\u00e9vel, vagyis egy objektumgr\u00e1f -ot kapunk: A DI keretrendszer/IoC kont\u00e9nerek azon tulajdons\u00e1g\u00e1t, hogy az objektumok f\u00fcgg\u0151s\u00e9geinek felder\u00edt\u00e9s\u00e9vel (a gyakorlatban jellemz\u0151en a konstruktor param\u00e9terek felder\u00edt\u00e9s\u00e9vel) a beregisztr\u00e1lt absztrakci\u00f3->implement\u00e1ci\u00f3 lek\u00e9pez\u00e9sek alapj\u00e1n k\u00e9pes objektumgr\u00e1fokat el\u0151\u00e1ll\u00edtani autowiring -nek nevezz\u00fck. F\u00fcgg\u0151s\u00e9gfelold\u00e1s ASP.NET Web API oszt\u00e1lyok eset\u00e9n \u00b6 Azon t\u00fal, hogy a megold\u00e1sunkat kont\u00e9ner alapokra helyezz\u00fck, p\u00e1r tov\u00e1bbi v\u00e1ltoztat\u00e1st is v\u00e9grehajtunk a todo alkalmaz\u00e1sunkon. A ToDoService oszt\u00e1lyt megsz\u00fcntetj\u00fck, a funkcionalit\u00e1s\u00e1t kicsit m\u00e1s form\u00e1ban egy ASP.NET Core ControllerBase lesz\u00e1rmazott TodoController oszt\u00e1lyba mozgatjuk. Ez az oszt\u00e1ly lesz a bel\u00e9p\u00e9si pont \u00e9s a gy\u00f6k\u00e9robjektum a k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sor\u00e1n. Ez\u00e1ltal a megold\u00e1sunk jobban t\u00fckr\u00f6zi egy val\u00f3s Web API, MVC Web app, illetve Web Razor Pages app alkalmaz\u00e1s megk\u00f6zel\u00edt\u00e9s\u00e9t. A ToDoService oszt\u00e1lyt megtarthattuk volna a h\u00edv\u00e1si/f\u00fcgg\u0151s\u00e9gi l\u00e1ncunk k\u00f6zep\u00e9n, de demonstr\u00e1l\u00e1si c\u00e9ljainkat jobban szolg\u00e1lja egy egyszer\u0171s\u00edtett megk\u00f6zel\u00edt\u00e9s. Ezen t\u00falmen\u0151en bevezet\u00fcnk egy Entity Framework DbContext lesz\u00e1rmazott TodoContext oszt\u00e1lyt annak \u00e9rdek\u00e9ben, hogy demonstr\u00e1lni tudjuk, mik\u00e9ppen t\u00f6rt\u00e9nhet ennek injekt\u00e1l\u00e1sa a repository vagy egy\u00e9b oszt\u00e1lyainkba. Az objektumgr\u00e1funk a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki: Az el\u0151z\u0151 k\u00e9t fejezetben feltett\u00fck, hogy a GetService h\u00edv\u00e1s\u00e1hoz egy IServiceProvider objektum rendelkez\u00e9sre \u00e1ll. Ha mi magunk hozunk l\u00e9tre egy kont\u00e9nert, akkor ez \u00edgy is van. Azonban csak a legritk\u00e1bb esetben szoktunk kont\u00e9nert k\u00f6zvetlen\u00fcl l\u00e9trehozni. Egy tipikus ASP.NET Web API alkalmaz\u00e1s eset\u00e9n a kont\u00e9nert a keretrendszer hozza l\u00e9tre, \u00e9s sz\u00e1munkra k\u00f6zvetlen\u00fcl nem is hozz\u00e1f\u00e9rhet\u0151. Ennek k\u00f6vetkezt\u00e9ben IServiceProvider hez - p\u00e1r indul\u00e1skori konfigur\u00e1ci\u00f3s \u00e9s kiterjeszt\u00e9si pontot eltekintve - hozz\u00e1f\u00e9r\u00e9st nem is kapunk. A j\u00f3 h\u00edr az, hogy erre nincs is sz\u00fcks\u00e9g. A DI alapkoncepci\u00f3j\u00e1ba ugyanis az is beletartozik, hogy a f\u00fcgg\u0151s\u00e9gfelold\u00e1st csak az alkalmaz\u00e1s bel\u00e9p\u00e9si pontj\u00e1ban a \"root object\"-re (gy\u00f6k\u00e9robjektum) v\u00e9gezz\u00fck el. Web API eset\u00e9ben a bel\u00e9p\u00e9si pontot az egyes API k\u00e9r\u00e9sek kiszolg\u00e1l\u00e1sa jelenti. Amikor be\u00e9rkezik egy k\u00e9r\u00e9s, akkor az Url \u00e9s a rooting szab\u00e1lyok alapj\u00e1n a keretrendszer meghat\u00e1rozza, mely Controller/ControllerBase lesz\u00e1rmazott oszt\u00e1lyt kell p\u00e9ld\u00e1nyos\u00edtani, \u00e9s azt l\u00e9tre is hozza. Amennyiben a controller oszt\u00e1lynak vannak f\u00fcgg\u0151s\u00e9gei (konstruktor param\u00e9terek), azok is felold\u00e1sra ker\u00fclnek a beregisztr\u00e1lt lek\u00e9pez\u00e9sek alapj\u00e1n, bele\u00e9rtve a k\u00f6zvetett f\u00fcgg\u0151s\u00e9geket is. El\u0151\u00e1ll a teljes objektumgr\u00e1f, a root object maga a controller oszt\u00e1ly . N\u00e9zz\u00fck ezt a gyakorlatban a kor\u00e1bbi p\u00e9ld\u00e1nk tov\u00e1bbfejleszt\u00e9s\u00e9vel, melyet egy TodoController oszt\u00e1llyal eg\u00e9sz\u00edtett\u00fcnk ki: [Route(\"api/[controller] \")] [ApiController] public class TodoController : ControllerBase { // A TodoController oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei private readonly TodoContext _context ; // ez egy DbContext private readonly INotificationService _notificationService ; // A f\u00fcgg\u0151s\u00e9geket konstruktor param\u00e9terben kapja meg. public TodoController ( TodoContext context , INotificationService notificationService ) { _context = context ; _notificationService = notificationService ; // Fill wit some initial data if ( _context . TodoItems . Count () == 0 ) { _context . TodoItems . Add ( new TodoItem { Name = \"Item1\" }); _context . TodoItems . Add ( new TodoItem { Name = \"Item2\" , LinkedContactId = 2 }); _context . SaveChanges (); } } // API kezel\u0151f\u00fcggv\u00e9ny e-mail eml\u00e9keztet\u0151 \u00e9rtes\u00edt\u00e9s kik\u00fcld\u00e9s\u00e9re. // P\u00e9lda: http post erre a c\u00edmre (pl. PostMan-nel): // http://localhost:58922/api/todo/2/reminder // Ez a 2-es azonos\u00edt\u00f3j\u00fa todo item kontakt szem\u00e9ly\u00e9nek \u00e9rtes\u00edt\u00e9st k\u00fcld a todo itemr\u0151l. [HttpPost(\"{id}/reminder\")] public IActionResult ReminderMessageToLinkedContact ( long id ) { // Todo item kikeres\u00e9se, haszn\u00e1lja a _context DbContext objektumot var item = _context . TodoItems . Find ( id ); if ( item == null ) return NotFound (); // Eml\u00e9keztet\u0151 e-mail kik\u00fcld\u00e9se _notificationService . SendEmailReminder ( item . LinkedContactId , item . Name ); // Val\u00f3j\u00e1ban nem hozunk l\u00e9tre semmit, egyszer\u0171 OK a v\u00e1lasz return Ok (); } // ... tov\u00e1bbi m\u0171veletek } A http://<g\u00e9pc\u00edm>/api/todo url al\u00e1 bees\u0151 k\u00e9r\u00e9seket a routing szab\u00e1lyok alapj\u00e1n a TodoController oszt\u00e1ly kapja meg. Az \u00e9rtes\u00edt\u00e9s kik\u00fcld\u00e9s\u00e9t triggerel\u0151 http://<g\u00e9pc\u00edm>/api/todo/<todo-id>/reminder c\u00edmre \u00e9rkez\u0151 post k\u00e9r\u00e9st pedig a TodoController.ReminderMessageToLinkedContact m\u0171velete. A TodoController -t a keretrendszer p\u00e9ld\u00e1nyos\u00edtja, minden k\u00e9r\u00e9shez \u00faj objektumot hoz l\u00e9tre. Az oszt\u00e1lynak k\u00e9t f\u00fcgg\u0151s\u00e9ge van, melyeket konstruktor param\u00e9terben kap meg. Az els\u0151 egy TodoContext objektum, ami egy DbContext lesz\u00e1rmazott. A m\u00e1sik a m\u00e1r j\u00f3l ismert INotificationService . Mint az el\u0151z\u0151 fejezetben l\u00e1ttuk, a DI keretrendszer ezeket is p\u00e9ld\u00e1nyos\u00edtja a regisztr\u00e1lt lek\u00e9pez\u00e9sek alapj\u00e1n (az \u00f6sszes k\u00f6zvetett f\u00fcgg\u0151s\u00e9geikkel), param\u00e9terk\u00e9nt \u00e1tadja TodoController konstruktornak, ahol ezeket tagv\u00e1ltoz\u00f3kban elt\u00e1roljuk. \u00cdgy ezek a be\u00e9rkez\u0151 k\u00e9r\u00e9seket kiszolg\u00e1l\u00f3 m\u0171veletekben, mint pl. a ReminderMessageToLinkedContact -ben m\u00e1r rendelkez\u00e9sre \u00e1llnak. Megjegyz\u00e9s A TodoContext felold\u00e1sa csak akkor lehets\u00e9ges, ha ezt az IoC kont\u00e9nerbe el\u0151zetesen beregisztr\u00e1ltuk. Erre a k\u00f6vetkez\u0151 fejezetben t\u00e9r\u00fcnk ki. Entity Framework DbContext regisztr\u00e1ci\u00f3 \u00e9s felold\u00e1s \u00b6 Alkalmaz\u00e1sokban - k\u00fcl\u00f6n\u00f6sen Asp.Net Core eset\u00e9ben - a DbContext haszn\u00e1lat\u00e1nak k\u00e9t m\u00f3dja lehets\u00e9ges: Minden alkalommal, amikor sz\u00fcks\u00e9g van r\u00e1, egy using blokkban p\u00e9ld\u00e1nyos\u00edtjuk \u00e9s fel is szabad\u00edtjuk. \u00cdgy egy be\u00e9rkez\u0151 k\u00e9r\u00e9s sor\u00e1n t\u00f6bb DbContext objektump\u00e9ld\u00e1ny is felhaszn\u00e1l\u00e1sra ker\u00fclhet. A DbContext -et be\u00e9rkez\u0151 k\u00e9r\u00e9senk\u00e9nt hozzuk l\u00e9tre, egy k\u00e9r\u00e9sen bel\u00fcl viszont megosztottan ugyanazt az objektump\u00e9ld\u00e1nyt haszn\u00e1lj\u00e1k az oszt\u00e1lyaink. Ez esetben a DbContext -re mint egy oszt\u00e1lyok k\u00f6z\u00f6tt megosztott repository-ra, pontosabban unit of work-re gondolunk. A bej\u00f6v\u0151 k\u00e9r\u00e9s sor\u00e1n egy DbContext objektumot hozunk l\u00e9tre, \u00e9s ezt injekt\u00e1ljuk be az erre \u00e9p\u00edt\u0151 oszt\u00e1lyoknak. Ez ut\u00f3bbi megk\u00f6zel\u00edt\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1ra remek k\u00e9zre es\u0151 be\u00e9p\u00edtett DI alap\u00fa megold\u00e1st ny\u00fajt az ASP.NET Core: a kont\u00e9nerbe indul\u00e1skor beregisztr\u00e1ljuk a DbContext oszt\u00e1lyunkat, mely \u00edgy a Controller \u00e9s egy\u00e9b f\u00fcgg\u0151s\u00e9gei sz\u00e1m\u00e1ra automatikusan beinjekt\u00e1l\u00e1sra ker\u00fcl. N\u00e9zz\u00fck meg, hogyan is t\u00f6rt\u00e9nik a TodoContext DbContext lesz\u00e1rmazott oszt\u00e1lyunk beregisztr\u00e1l\u00e1sa a p\u00e9ld\u00e1nkban. A regisztr\u00e1ci\u00f3 helye a szok\u00e1sos Startup.ConfigureServices : public void ConfigureServices ( IServiceCollection services ) { // ... services . AddDbContext < TodoContext >( opt => opt . UseInMemoryDatabase ( \"TodoList\" )); // ... } Az AddDbContext egy a keretrendszer \u00e1ltal az IServiceCollection interf\u00e9szre defini\u00e1lt extension method. Ez a DbContext oszt\u00e1lyunk k\u00e9nyelmes beregisztr\u00e1ci\u00f3j\u00e1t teszi lehet\u0151v\u00e9. Ennek belsej\u00e9be nem l\u00e1tunk bele, mindenesetre lelke a scope-ot regisztr\u00e1ci\u00f3. \"Pszeudok\u00f3ddal\": services . AddScoped < TodoContext , TodoContext >(); Mint a p\u00e9ld\u00e1ban l\u00e1that\u00f3, a TodoContext beregisztr\u00e1l\u00e1sa nem egy absztrakci\u00f3val t\u00f6rt\u00e9nik (nincs ITodoContext interf\u00e9sz), hanem mag\u00e1val a TodoContext implement\u00e1ci\u00f3s t\u00edpussal . A DI keretrendszerek/IoC kont\u00e9nerek t\u00e1mogatj\u00e1k, hogy a regisztr\u00e1ci\u00f3 sor\u00e1n az absztrakci\u00f3 egy konkr\u00e9t t\u00edpus legyen, jellemz\u0151sen maga az implement\u00e1ci\u00f3s t\u00edpus . Ezt a megk\u00f6zel\u00edt\u00e9st csak indokolt esetben haszn\u00e1ljuk. ASP.NET Core k\u00f6rnyezetben a DbContext lesz\u00e1rmazott oszt\u00e1lyunk sz\u00e1m\u00e1ra soha nem vezet\u00fcnk be interf\u00e9szt, hanem az oszt\u00e1ly\u00e1nak a t\u00edpus\u00e1val ker\u00fcl beregisztr\u00e1l\u00e1sra az IoC kont\u00e9nerbe (a p\u00e9ld\u00e1nkban is TodoContext -> TodoContext lek\u00e9pez\u00e9s t\u00f6rt\u00e9nik). A DbContext \u00f6nmag\u00e1ban is sz\u00e1mos perzisztencial providerrel (pl. MSSQL, Oracle, mem\u00f3ria, stb.) tud egy\u00fctt m\u0171k\u00f6dni, \u00edgy alkalmaz\u00e1sf\u00fcgg\u0151, mennyire van \u00e9rtelme absztrah\u00e1lni. Ha absztrah\u00e1ljuk az adathozz\u00e1f\u00e9r\u00e9st, akkor nem a DbContext -hez vezet\u00fcnk be interf\u00e9szt, hanem a Repository tervez\u00e9si mint\u00e1t haszn\u00e1ljuk, \u00e9s az egyes repository implement\u00e1ci\u00f3khoz vezet\u00fcnk be interf\u00e9szeket, valamint ezek vonatkoz\u00e1s\u00e1ban t\u00f6rt\u00e9nik az IoC kont\u00e9nerben a lek\u00e9pez\u00e9s (pl. ITodoRepository -> TodoRepository ). A repository oszt\u00e1lyok pedig vagy maguk p\u00e9ld\u00e1nyos\u00edtj\u00e1k a DbContext objektumokat, vagy konstruktor param\u00e9terben ker\u00fcl sz\u00e1mukra beinjekt\u00e1l\u00e1sra). Megjegyz\u00e9s Jelen dokumentumnak nem c\u00e9lja \u00e1ll\u00e1st foglalni abban, mely esetben c\u00e9lszer\u0171 Repository vagy egy\u00e9b mint\u00e1k seg\u00edts\u00e9g\u00e9vel a controller illetve service oszt\u00e1lyok sz\u00e1m\u00e1ra az EF/DbContext alap\u00fa adathozz\u00e1f\u00e9r\u00e9st egy DAL r\u00e9tegben elrejteni, illetve ezzel szemben mely esetben haszn\u00e1ljuk a DbContext oszt\u00e1lyt k\u00f6zvetlen\u00fcl a controller/szolg\u00e1ltat\u00e1s objektumainkban (vagyis a BLL-ben). Az illusztr\u00e1ci\u00f3 kedv\u00e9\u00e9rt a TodoApi alkalmaz\u00e1sunk ebben az \u00e9rtelemben vegyes megold\u00e1st alkalmaz: a TodoItem objektumok perziszt\u00e1l\u00e1s\u00e1ra a szolg\u00e1ltat\u00e1s oszt\u00e1lyok k\u00f6zvetlen\u00fcl a DbContext-et haszn\u00e1lj\u00e1k, m\u00edg a Contact-ok kezel\u00e9s\u00e9re a Repository mint\u00e1t haszn\u00e1ljuk. A fenti p\u00e9ld\u00e1ban az is l\u00e1that\u00f3, hogy a AddDbContext sor\u00e1n a DbContext (eset\u00fcnkben TodoContext ) regisztr\u00e1l\u00e1sakor egy lambda kifejez\u00e9st is meg tudunk adni: opt => opt . UseInMemoryDatabase ( \"TodoList\" ) Ezen a lambda kifejez\u00e9s\u00fcnket a kont\u00e9ner a k\u00e9s\u0151bbiekben a resolve sor\u00e1n - vagyis amikor egy TodoContext p\u00e9ld\u00e1nyos\u00edt\u00e1sa t\u00f6rt\u00e9nik - megh\u00edvja, \u00e9s param\u00e9terk\u00e9nt egy opci\u00f3z\u00f3 objektumot kapunk (a p\u00e9ld\u00e1ban opt argumentum): ennek seg\u00edts\u00e9g\u00e9vel lehet\u0151s\u00e9g\u00fcnk van a l\u00e9trehozand\u00f3 TodoContext objektum opci\u00f3z\u00e1s\u00e1ra, konfigur\u00e1l\u00e1s\u00e1ra. A p\u00e9ld\u00e1nkban a UseInMemoryDatabase m\u0171velet h\u00edv\u00e1s\u00e1val egy \"TodoList\" nev\u0171 mem\u00f3riaadatb\u00e1zist hozunk l\u00e9tre. Halad\u00f3(bb) f\u00fcgg\u0151s\u00e9gregisztr\u00e1ci\u00f3 p\u00e9lda \u00b6 Nem k\u00f6telez\u0151 tananyag. T\u00e9rj\u00fcnk ki a Startup.ConfigureServices kor\u00e1bban nem ismertetett r\u00e9szeire. Az EMailSender beregisztr\u00e1l\u00e1sa els\u0151 r\u00e1n\u00e9z\u00e9sre eg\u00e9szen tr\u00fckk\u00f6snek t\u0171nik: services . AddSingleton < IEMailSender , EMailSender >( sp => new EMailSender ( sp . GetRequiredService < ILogger >(), \"smtp.myserver.com\" ) ); A jobb meg\u00e9rt\u00e9s \u00e9rdek\u00e9ben n\u00e9zz\u00fck meg az EMailSender konstruktor\u00e1t: public EMailSender ( ILogger logger , string smtpAddress ) { _logger = logger ; _smtpAddress = smtpAddress ; } Az EMailSender t a kont\u00e9nernek kell majd a felold\u00e1s sor\u00e1n p\u00e9ld\u00e1nyos\u00edtania, ehhez a konstruktor param\u00e9tereket megfelel\u0151en meg kell tudni adnia. A logger param\u00e9ter teljesen \"rendben van\", a kont\u00e9ner ILogger->Logger regisztr\u00e1ci\u00f3ja alapj\u00e1n a kont\u00e9ner fel tudja oldani. Az smtpAddress param\u00e9ter \u00e9rt\u00e9k\u00e9t viszont nem tudja kital\u00e1lni. Az ASP.NET Core a probl\u00e9ma megold\u00e1s\u00e1ra a keretrendszer \"options\" mechanizmus\u00e1t javasolja, mely lehet\u0151v\u00e9 teszi, hogy az \u00e9rt\u00e9ket valamilyen konfigur\u00e1ci\u00f3b\u00f3l olvassuk be. Ez sz\u00e1munkra egy messzire vezet\u0151 sz\u00e1l lenne, \u00edgy egyszer\u0171s\u00edt\u00e9sk\u00e9ppen m\u00e1s megold\u00e1shoz folyamodtunk. Az AddSingleton (\u00e9s a t\u00f6bbi Add... m\u0171veletnek) van olyan overloadja, melyben egy lambda kifejez\u00e9st tudunk megadni. Ezt a lambd\u00e1t a kont\u00e9ner a k\u00e9s\u0151bbiekben a resolve sor\u00e1n (vagyis amikor egy IEMailSender alapj\u00e1n egy EMailSender t k\u00e9r\u00fcnk a kont\u00e9nert\u0151l) h\u00edvja, minden egyes p\u00e9ld\u00e1nyos\u00edt\u00e1s sor\u00e1n: ebben mi magunk p\u00e9ld\u00e1nyos\u00edtjuk az EMailSender objektumot, a konstruktor param\u00e9tereket az ig\u00e9nyeink szerint meghat\u00e1rozva. S\u0151t, a kont\u00e9ner \"van olyan kedves\", hogy lambda param\u00e9terben kapunk egy IServiceCollection objektumot (p\u00e9ld\u00e1nkban ez az sp ), \u00e9s ezzel a kont\u00e9nerben m\u00e1r megl\u00e9v\u0151 regisztr\u00e1ci\u00f3k alapj\u00e1n a GetRequiredService \u00e9s GetService h\u00edv\u00e1sokkal k\u00e9nyelmesen tudunk t\u00edpusokat feloldani, amennyiben sz\u00fcks\u00e9g van r\u00e1. Tov\u00e1bbi t\u00e9mak\u00f6r\u00f6k \u00b6 Dependency Injection/IoC kont\u00e9nerek \u00e1ltal\u00e1noss\u00e1g\u00e1ban \u00b6 A .NET Core be\u00e9p\u00edtett DI kont\u00e9ner jellemz\u0151i: Alapszolg\u00e1ltat\u00e1sokat ny\u00fajt (pl. property injection-t nem t\u00e1mogat). Ha enn\u00e9l t\u00f6bbre van sz\u00fcks\u00e9g, haszn\u00e1lhatunk m\u00e1s IoC kont\u00e9nert is, az ASP.NET Core egy\u00fctt tud m\u0171k\u00f6dni vele. Sz\u00e1mos .NET (legyen az .NET Core, .NET Framework vagy mindkett\u0151) k\u00f6rnyezetben haszn\u00e1lhat\u00f3 Dependecy Injection/IoC kont\u00e9ner oszt\u00e1lyk\u00f6nyvt\u00e1r l\u00e9tezik, pl.: AutoFac, DryIoc, LightInject, Castle Windsor, Ninject, StructureMap, SimpleInjector, MEF. Microsoft.Extensions.DependencyInjection NuGet package-ben van implement\u00e1lva (az alapn\u00e9vt\u00e9r is ez) ASP.NET Core alkalmaz\u00e1sok eset\u00e9n m\u00e1r a .NET projekt l\u00e9trehoz\u00e1sakor telep\u00edtve van. S\u0151t, mint l\u00e1ttuk: az ASP.NET Core middleware intenz\u00edven haszn\u00e1lja \u00e9s \u00e9p\u00edt r\u00e1, a runtime konfigur\u00e1ci\u00f3/kiterjeszthet\u0151s\u00e9g alappill\u00e9re. Egy\u00e9b .NET Core alkalmaz\u00e1sok eset\u00e9n (pl. Console) a Microsoft.Extensions.DependencyInjection NuGet package-dzsel manu\u00e1lisan kell telep\u00edteni. Megjegyz\u00e9s: a NuGet package haszn\u00e1lhat\u00f3 (teljes) .NET Frameworkkel is, mivel .NET Standard-et t\u00e1mogat. Service Locator antipattern \u00b6 Az IoC kont\u00e9nerek haszn\u00e1lat\u00e1nak a dependency injectionnel szemben van egy m\u00e1sik haszn\u00e1lati m\u00f3dja. Ennek az a l\u00e9nyege, hogy az oszt\u00e1lyok sz\u00e1m\u00e1ra nem konstruktor param\u00e9terekben adjuk \u00e1t/injekt\u00e1ljuk be a f\u00fcgg\u0151s\u00e9geiket, hanem azokat az oszt\u00e1lyok a met\u00f3dusaikban az IoC kont\u00e9nert\u0151l a GetService m\u0171velettel magunk k\u00e9rdezik le. Ezt a megk\u00f6zel\u00edt\u00e9st Service Locator mint\u00e1nak nevezz\u00fck. Ez antipattern -nek tekintend\u0151, ugyanis a k\u00f3dban sz\u00e9tsz\u00f3rtan, minden egyes f\u00fcgg\u0151s\u00e9g felold\u00e1sakor haszn\u00e1ljuk a kont\u00e9nert, \u00edgy a k\u00f3dunk nagy r\u00e9sze f\u00fcggeni fog mag\u00e1t\u00f3l a kont\u00e9nert\u0151l! Ezzel szemben a dependency injection eset\u00e9ben a f\u00fcgg\u0151s\u00e9gfelold\u00e1st csak az alkalmaz\u00e1s bel\u00e9p\u00e9si pontj\u00e1ban a \"root object\"-ekre v\u00e9gezz\u00fck el, a k\u00f3dunk t\u00f6bbi r\u00e9sze teljesen f\u00fcggetlen a kont\u00e9nert\u0151l. Vegy\u00fck \u00e9szre, hogy a kor\u00e1bbi p\u00e9ld\u00e1nkban a TodoController, NotificationService, EMailSender, Logger \u00e9s ContactRepository oszt\u00e1lyainkban sehol nem hivatkoztunk a kont\u00e9nerre (sem IServiceProvider-k\u00e9nt, sem m\u00e1s m\u00f3don). ASP.NET Core keretrendszer szolg\u00e1ltat\u00e1sok \u00b6 Az ASP.NET Core sz\u00e1mos be\u00e9p\u00edtett szolg\u00e1ltat\u00e1ssal rendelkezik. Pl. ilyen az (MVC) alap\u00fa Wep API t\u00e1mogat\u00e1s is, vagy a felhaszn\u00e1l\u00f3 fel\u00fclettel is rendelkez\u0151 MVC/Razor alap\u00fa webalkalmaz\u00e1s t\u00e1mogat\u00e1s.Ezek t\u00f6bbs\u00e9ge maga is a DI keretrendszert haszn\u00e1lja f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1sra. ASP.NET Web API eset\u00e9n a Startup.ConfigureServices -ben szerepelnie kell az al\u00e1bbi sornak: services . AddMvc () . SetCompatibilityVersion ( CompatibilityVersion . Version_2_1 ); Az AddMvc egy be\u00e9p\u00edtett extension metod az IServiceProvider interf\u00e9szre vonatkoz\u00f3an, mely sz\u00e1mos (messze 100 feletti darabsz\u00e1m\u00fa!), a Wep API middleware/pipeline bels\u0151 m\u0171k\u00f6d\u00e9s\u00e9hez \u00e9s konfigur\u00e1ci\u00f3j\u00e1hoz sz\u00fcks\u00e9ges szolg\u00e1ltat\u00e1s \u00e9s konfigur\u00e1ci\u00f3s objektumot regisztr\u00e1l a kont\u00e9nerbe. .NET Core 3.0-t\u00f3l kezdve a helyzet n\u00e9mik\u00e9pp m\u00e1s. Az AddMvc() h\u00edv\u00e1sa helyett jellemz\u0151en az AddControllers() m\u0171veletet h\u00edvjuk, mely jelent\u0151sen kevesebb kont\u00e9nerregisztr\u00e1ci\u00f3t von mag\u00e1val. Szolg\u00e1ltat\u00e1s objektumok dispose-ol\u00e1sa \u00b6 A kont\u00e9ner az \u00e1ltala l\u00e9trehozott objektumokra Dispose -t h\u00edv, amennyiben az objektumok oszt\u00e1lya implement\u00e1lja az IDisposable interf\u00e9szt. Irodalom \u00b6 https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection https://stackify.com/net-core-dependency-injection/amp https://medium.com/volosoft/asp-net-core-dependency-injection-best-practices-tips-tricks-c6e9c67f9d96","title":"F\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s ASP.NET Core k\u00f6rnyezetben"},{"location":"jegyzet/di/#fuggoseginjektalas-aspnet-core-kornyezetben","text":"Defin\u00edci\u00f3 F\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s ( Dependency Injection , r\u00f6viden DI) egy tervez\u00e9si minta. A fejleszt\u0151ket seg\u00edti abban, hogy az alkalmaz\u00e1s egyes r\u00e9szei laza csatol\u00e1ssal ker\u00fcljenek kialak\u00edt\u00e1sra. A f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s egy mechanizmus arra, hogy az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gi gr\u00e1fjainak l\u00e9trehoz\u00e1s\u00e1t f\u00fcggetlen\u00edts\u00fck az oszt\u00e1ly defin\u00edci\u00f3j\u00e1t\u00f3l. C\u00e9lok k\u00f6nnyebb b\u0151v\u00edthet\u0151s\u00e9g \u00e9s karbantarthat\u00f3s\u00e1g unit tesztelhet\u0151s\u00e9g k\u00f3d \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g Term\u00e9szetesen a fenti defin\u00edc\u00f3b\u00f3l \u00f6nmag\u00e1ban nem der\u00fcl ki, pontosan milyen probl\u00e9m\u00e1kat \u00e9s milyen m\u00f3don old meg a f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s. A k\u00f6vetkez\u0151 fejezetekben egy p\u00e9lda seg\u00edts\u00e9g\u00e9vel helyezz\u00fck kontextusba a probl\u00e9mak\u00f6rt, illetve p\u00e9lda keret\u00e9ben megismerked\u00fcnk az ASP.NET Core be\u00e9p\u00edtett DI szolg\u00e1ltat\u00e1s\u00e1nak alapjaival. Minta alkalmaz\u00e1s A C# forr\u00e1sk\u00f3d eg\u00e9sz itt \u00e9rhet\u0151 el: https://github.com/bmeviauac01/todoapi-di-sample","title":"F\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s ASP.NET Core k\u00f6rnyezetben"},{"location":"jegyzet/di/#pelda-1-fazis-szolgaltatas-osztaly-beegetett-fuggosegekkel","text":"A p\u00e9ld\u00e1nkban egy teend\u0151lista (TODO) kezel\u0151 alkalmaz\u00e1s e-mail \u00e9rtes\u00edt\u00e9seket k\u00fcld\u0151 r\u00e9szeibe tekint\u00fcnk bele, k\u00f3dr\u00e9szletek seg\u00edts\u00e9g\u00e9vel. Megjegyz\u00e9s: a k\u00f3d a t\u00f6m\u00f6rs\u00e9g \u00e9rdek\u00e9ben minimalisztikus. A p\u00e9ld\u00e1nk \"bel\u00e9p\u00e9si pontja\" a ToDoService oszt\u00e1ly SendReminderIfNeeded m\u0171velete. // Teend\u0151k kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly public class ToDoService { const string smtpAddress = \"smtp.myserver.com\" ; // Megvizsg\u00e1lja a param\u00e9terk\u00e9nt kapott todoItem objektumot, \u00e9s ha sz\u00fcks\u00e9ges, // e-mail \u00e9rtes\u00edt\u00e9st k\u00fcld a teend\u0151r\u0151l a teend\u0151ben szerepl\u0151 kontakt szem\u00e9lynek. public void SendReminderIfNeeded ( TodoItem todoItem ) { if ( checkIfTodoReminderIsToBeSent ( todoItem )) { NotificationService notificationService = new NotificationService ( smtpAddress ); notificationService . SendEmailReminder ( todoItem . LinkedContactId , todoItem . Name ); } } bool checkIfTodoReminderIsToBeSent ( TodoItem todoItem ) { bool send = true ; /* ... */ return send ; } // ... } // Entit\u00e1soszt\u00e1ly, egy v\u00e9grehajtand\u00f3 feladat adatait z\u00e1rja egys\u00e9gbe public class TodoItem { // Adatb\u00e1zis kulcs public long Id { get ; set ; } // Teend\u0151 neve/le\u00edr\u00e1sa public string Name { get ; set ; } // Jelzi, hogy a teend\u0151 elv\u00e9g\u00e9sre ker\u00fclt-e public bool IsComplete { get ; set ; } // Egy teend\u0151h\u00f6z lehet\u0151s\u00e9g van kontakt szem\u00e9ly hozz\u00e1rendel\u00e9s\u00e9re: ha -1, nincs // kontakt szem\u00e9ly hozz\u00e1rendelve, egy\u00e9bk\u00e9nt pedig a kontakt szem\u00e9ly azonos\u00edt\u00f3ja. public int LinkedContactId { get ; set ; } = - 1 ; } A fenti k\u00f3dban ( ToDoService.SendReminderIfNeeded ) azt l\u00e1tjuk, hogy az e-mail k\u00fcld\u00e9s l\u00e9nyegi logik\u00e1j\u00e1t a NotificationService oszt\u00e1lyban kell keresn\u00fcnk. Val\u00f3ban, vizsg\u00e1l\u00f3d\u00e1sunk k\u00f6zpontj\u00e1ba ez az oszt\u00e1ly ker\u00fcl. A k\u00f6vetkez\u0151 k\u00f3dr\u00e9szlet ezen oszt\u00e1ly k\u00f3dj\u00e1t, valamint a f\u00fcgg\u0151s\u00e9geit mutatja be: // \u00c9rtes\u00edt\u00e9sek k\u00fcld\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly class NotificationService { // Az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei EMailSender _emailSender ; Logger _logger ; ContactRepository _contactRepository ; public NotificationService ( string smtpAddress ) { _logger = new Logger (); _emailSender = new EMailSender ( _logger , smtpAddress ); _contactRepository = new ContactRepository (); } // E-mail \u00e9rtes\u00edt\u00e9st k\u00fcld az adott azonos\u00edt\u00f3j\u00fa kontakt szem\u00e9lynek (a contactId // egy kulcs a Contacts t\u00e1bl\u00e1ban) public void SendEmailReminder ( int contactId , string todoMessage ) { string emailTo = _contactRepository . GetContactEMailAddress ( contactId ); string emailSubject = \"TODO reminder\" ; string emailMessage = \"Reminder about the following todo item: \" + todoMessage ; _emailSender . SendMail ( emailTo , emailSubject , emailMessage ); } } // Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 oszt\u00e1ly public class Logger { public void LogInformation ( string text ) { /* ...*/ } public void LogError ( string text ) { /* ...*/ } } // E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 oszt\u00e1ly public class EMailSender { Logger _logger ; string _smtpAddress ; public EMailSender ( Logger logger , string smtpAddress ) { _logger = logger ; _smtpAddress = smtpAddress ; } public void SendMail ( string to , string subject , string message ) { _logger . LogInformation ( $ \"Sendding e-mail. To: {to} Subject: {subject} Body: {message}\" ); // ... } } // Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly public class ContactRepository { public string GetContactEMailAddress ( int contactId ) { // ... } // ... } P\u00e1r \u00e1ltal\u00e1nos gondolat: A NotificationService oszt\u00e1ly t\u00f6bb f\u00fcgg\u0151s\u00e9ggel rendelkezik ( EMailSender , Logger , ContactRepository oszt\u00e1lyok), ezen oszt\u00e1lyokra \u00e9p\u00edtve val\u00f3s\u00edtja meg a szolg\u00e1ltat\u00e1sait. A f\u00fcgg\u0151s\u00e9g oszt\u00e1lyoknak lehetnek tov\u00e1bbi f\u00fcgg\u0151s\u00e9geik: az EMailSender remek p\u00e9lda erre, \u00e9p\u00edt a Logger oszt\u00e1lyra. Megjegyz\u00e9s: a NotificationService , EMailSender , Logger , ContactRepository oszt\u00e1lyokat szolg\u00e1ltat\u00e1soszt\u00e1lyoknak tekintj\u00fck, mert t\u00e9nyleges logik\u00e1t is tartalmaznak, nem csak adatokat z\u00e1rnak egys\u00e9gbe, mint pl. a TodoItem . Mint l\u00e1that\u00f3, a SendEmailReminder m\u0171veletet egy objektumgr\u00e1f szolg\u00e1lja ki, ahol a NotificationService a gy\u00f6k\u00e9robjektum, melynek h\u00e1rom f\u00fcgg\u0151s\u00e9ge van, \u00e9s a f\u00fcgg\u0151s\u00e9geinek (legal\u00e1bbis az EMailSender -nek) vannak tov\u00e1bbi f\u00fcgg\u0151s\u00e9gei. A k\u00f6vetkez\u0151 \u00e1bra ezt az objektumgr\u00e1fot illusztr\u00e1lja: Megjegyz\u00e9s Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, m\u00e9rt a NotificationService -t, \u00e9s nem a ToDoService -t tekintj\u00fck gy\u00f6k\u00e9robjektumnak. Val\u00f3j\u00e1ban ez csak a n\u00e9z\u0151pontunkon m\u00falik: az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt a ToDoService -t egyfajta bel\u00e9p\u00e9si pontnak (\"kliensnek\") tekintj\u00fck a k\u00e9r\u00e9s vonatkoz\u00e1s\u00e1ban annak \u00e9rdek\u00e9ben, hogy kevesebb oszt\u00e1lyt kelljen a k\u00f6vetkez\u0151kben megvizsg\u00e1lnunk \u00e9s \u00e1talak\u00edtanunk. Egy val\u00f3 \u00e9letbeli alkalmaz\u00e1sban a ToDoService -t is j\u00f3 es\u00e9llyel a f\u00fcgg\u0151s\u00e9gi gr\u00e1f r\u00e9sz\u00e9nek tekinten\u00e9nk. Tekints\u00fck \u00e1t a megold\u00e1s legfontosabb jellemz\u0151it: Az oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit maga p\u00e9ld\u00e1nyos\u00edtja Az oszt\u00e1ly a f\u00fcgg\u0151s\u00e9gei konkr\u00e9t t\u00edpus\u00e1t\u00f3l f\u00fcgg (nem pedig interf\u00e9szekt\u0151l, \"absztrakci\u00f3kt\u00f3l\") Ez a megk\u00f6zel\u00edt\u00e9s t\u00f6bb s\u00falyos negat\u00edvummal b\u00edr: Rugalmatlans\u00e1g, neh\u00e9z b\u0151v\u00edthet\u0151s\u00e9g . A NotificationService (m\u00f3dos\u00edt\u00e1s n\u00e9lk\u00fcl) nem tud m\u00e1s lev\u00e9lk\u00fcld\u0151, napl\u00f3z\u00f3 \u00e9s contact repository implement\u00e1ci\u00f3kkal egy\u00fctt m\u0171k\u00f6dni, csak a be\u00e9getett EMailSender , Logger \u00e9s ContactRepository oszt\u00e1lyokkal. Vagyis pl. nem tudjuk m\u00e1s napl\u00f3z\u00f3 komponenssel, vagy pl. olyan contact repository-vel haszn\u00e1lni, amely m\u00e1s adatforr\u00e1sb\u00f3l dolgozik. Unit tesztelhet\u0151s\u00e9g hi\u00e1nya . A NotificationService (m\u00f3dos\u00edt\u00e1s n\u00e9lk\u00fcl) nem unit tesztelhet\u0151. Ehhez ugyanis le kell cser\u00e9lni az EMailSender , Logger \u00e9s ContactRepository f\u00fcgg\u0151s\u00e9geit olyanokra, melyek (tesztel\u00e9st seg\u00edt\u0151) egyszer\u0171/r\u00f6gz\u00edtett v\u00e1laszokat viselked\u00e9st mutatnak. Ne feledj\u00fck: a unit tesztel\u00e9s l\u00e9nyege, hogy egy oszt\u00e1ly viselked\u00e9s\u00e9t \u00f6nmag\u00e1ban tesztelj\u00fck (pl. az adatb\u00e1zist haszn\u00e1l\u00f3 ContactRepository helyett egy olyan ContactRepository-ra van sz\u00fcks\u00e9g, mely gyorsan, mem\u00f3ri\u00e1b\u00f3l szolg\u00e1lja ki a k\u00e9r\u00e9seket, a teszt el\u0151felt\u00e9teleinek megfelel\u0151en). Van m\u00e9g egy, els\u0151 r\u00e1n\u00e9z\u00e9sre nehezen \u00e9szrevehet\u0151 kellemetlen k\u00f6vetkezm\u00e9ny: a p\u00e9ld\u00e1nkban a smtpAddress param\u00e9tert is \u00e1t kell adni a NotificationService konstruktor\u00e1nak, az\u00e9rt, hogy azt tov\u00e1bb\u00edtani tudja az \u00e1ltala p\u00e9ld\u00e1nyos\u00edtott EMailSender f\u00fcgg\u0151s\u00e9g\u00e9nek. Ugyanakkor a smtpAddress a NotificationService sz\u00e1m\u00e1ra egy transzparens, \"\u00e9rtelmetlen\" inform\u00e1ci\u00f3, elviekben \"semmi k\u00f6ze hozz\u00e1\". Sajnos jelen pillanatban m\u00e9gis \u00e1t kell vezetni rajta, mert \u0151 p\u00e9ld\u00e1nyos\u00edtja az EMailSender -t, aki sz\u00e1m\u00e1ra ez az inform\u00e1ci\u00f3 relev\u00e1ns. A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben \u00fagy alak\u00edtjuk \u00e1t a megold\u00e1sunkat, hogy a negat\u00edvumok t\u00f6bbs\u00e9g\u00e9t\u0151l meg tudjunk szabadulni.","title":"P\u00e9lda 1. f\u00e1zis - szolg\u00e1ltat\u00e1s oszt\u00e1ly be\u00e9getett f\u00fcgg\u0151s\u00e9gekkel"},{"location":"jegyzet/di/#pelda-2-fazis-szolgaltatas-osztaly-manualis-fuggoseg-injektalassal","text":"A kor\u00e1bbi megold\u00e1sunkat alak\u00edtjuk \u00e1t, a funkcion\u00e1lis k\u00f6vetelm\u00e9nyek v\u00e1ltozatlanok. Az \u00e1talak\u00edt\u00e1s legfontosabb ir\u00e1nyelvei: a f\u00fcgg\u0151s\u00e9geket absztrakci\u00f3kra, \"interf\u00e9sz alapokra\" helyezz\u00fck , \u00e9s az oszt\u00e1lyok nem maguk p\u00e9ld\u00e1nyos\u00edtj\u00e1k a f\u00fcgg\u0151s\u00e9geiket . public class ToDoService { const string smtpAddress = \"smtp.myserver.com\" ; // Megvizsg\u00e1lja a param\u00e9terk\u00e9nt kapott todoItem objektumot, \u00e9s ha sz\u00fcks\u00e9ges, // e-mail \u00e9rtes\u00edt\u00e9st k\u00fcld a teend\u0151r\u0151l a teend\u0151ben szerepl\u0151 kontakt szem\u00e9lynek. public void SendReminderIfNeeded ( TodoItem todoItem ) { if ( checkIfTodoReminderIsToBeSent ( todoItem )) { var logger = new Logger (); var emailSender = new EMailSender ( logger , smtpAddress ); var contactRepository = new ContactRepository (); NotificationService notificationService = new NotificationService ( logger , emailSender , contactRepository ); notificationService . SendEmailReminder ( todoItem . LinkedContactId , todoItem . Name ); } } bool checkIfTodoReminderIsToBeSent ( TodoItem todoItem ) { bool send = true ; /* ... */ return send ; } } // \u00c9rtes\u00edt\u00e9sek k\u00fcld\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly class NotificationService { // Az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei IEMailSender _emailSender ; ILogger _logger ; IContactRepository _contactRepository ; public NotificationService ( ILogger logger , IEMailSender emailSender , IContactRepository contactRepository ) { _logger = logger ; _emailSender = emailSender ; _contactRepository = contactRepository ; } // E-mail \u00e9rtes\u00edt\u00e9st k\u00fcld az adott azonos\u00edt\u00f3j\u00fa kontakt szem\u00e9lynek (a contactId // egy kulcs a Contacts t\u00e1bl\u00e1ban) public void SendEmailReminder ( int contactId , string todoMessage ) { string emailTo = _contactRepository . GetContactEMailAddress ( contactId ); string emailSubject = \"TODO reminder\" ; string emailMessage = \"Reminder about the following todo item: \" + todoMessage ; _emailSender . SendMail ( emailTo , emailSubject , emailMessage ); } } #region Contracts (abstractions) // Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 interf\u00e9sz public interface ILogger { void LogInformation ( string text ); void LogError ( string text ); } // E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 interf\u00e9sz public interface IEMailSender { void SendMail ( string to , string subject , string message ); } // Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 interf\u00e9sz public interface IContactRepository { string GetContactEMailAddress ( int contactId ); } #endregion #region Implementations // Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 oszt\u00e1ly public class Logger : ILogger { public void LogInformation ( string text ) { /* ...*/ } public void LogError ( string text ) { /* ...*/ } } // E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 oszt\u00e1ly public class EMailSender : IEMailSender { ILogger _logger ; string _smtpAddress ; public EMailSender ( ILogger logger , string smtpAddress ) { _logger = logger ; _smtpAddress = smtpAddress ; } public void SendMail ( string to , string subject , string message ) { _logger . LogInformation ( $ \"Sendding e-mail. To: {to} Subject: {subject} Body: {message}\" ); // ... } } // Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly public class ContactRepository : IContactRepository { public string GetContactEMailAddress ( int contactId ) { // ... } // ... } #endregion A kor\u00e1bbi megold\u00e1st a k\u00f6vetkez\u0151 pontokban fejlesztett\u00fck tov\u00e1bb: A NotificationService oszt\u00e1ly m\u00e1r nem maga p\u00e9ld\u00e1nyos\u00edtja a f\u00fcgg\u0151s\u00e9geit, hanem konstruktor param\u00e9terekben kapja meg. Interf\u00e9szeket (absztrakci\u00f3kat) vezett\u00fcnk be a f\u00fcgg\u0151s\u00e9gek kezel\u00e9s\u00e9re. A NotificationService oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit interf\u00e9szek form\u00e1j\u00e1ban kapja meg. Azt, amikor egy oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit k\u00edv\u00fclr\u0151l kapja meg, DEPENDENCY INJECTION -nek (DI) vagyis f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1snak nevezz\u00fck. Eset\u00fcnkben konstruktor param\u00e9terekben kapj\u00e1k meg az oszt\u00e1lyok f\u00fcgg\u0151s\u00e9geiket. A DI ezen form\u00e1j\u00e1t CONSTRUCTOR INJECTION -nek (konstruktor injekt\u00e1l\u00e1s) nevezz\u00fck. Ez a f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s legyakoribb - \u00e9s legink\u00e1bb javasolt m\u00f3dja (alternat\u00edva pl. a property injection, amikor is publikus property setter seg\u00edts\u00e9g\u00e9vel \u00e1ll\u00edtjuk be az oszt\u00e1ly adott f\u00fcgg\u0151s\u00e9g\u00e9t). Megold\u00e1sunkban a NotificationService f\u00fcgg\u0151s\u00e9geit az oszt\u00e1ly (k\u00f6zvetlen) FELHASZN\u00c1L\u00d3JA p\u00e9ld\u00e1nyos\u00edtja ( ToDoService oszt\u00e1ly). Els\u0151dlegesen ebb\u0151l ered\u0151en a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k \u00e1llnak m\u00e9g fent: A NotificationService felhaszn\u00e1l\u00f3ja, vagyis a ToDoService.SendReminderIfNeeded m\u00e9g mindig f\u00fcgg a konkr\u00e9t implement\u00e1ci\u00f3s t\u00edpusokt\u00f3l (hiszen neki sz\u00fcks\u00e9ges p\u00e9ld\u00e1nyos\u00edtania a Logger , EMailSender \u00e9s ContactRepository oszt\u00e1lyokat). Ha az alkalmaz\u00e1sunkban t\u00f6bb helyen haszn\u00e1ljuk a Logger , EMailSender \u00e9s ContactRepository oszt\u00e1lyokat, mindenhol k\u00fcl\u00f6n-k\u00fcl\u00f6n explicit p\u00e9ld\u00e1nyos\u00edtani kell \u0151ket. Vagyis mindenhol k\u00fcl\u00f6n-k\u00fcl\u00f6n d\u00f6nteni kell \u00e9s meg kell adni, hogy milyen absztrakci\u00f3 (interf\u00e9sz t\u00edpus) eset\u00e9n milyen implement\u00e1ci\u00f3s t\u00edpust haszn\u00e1lunk az alkalmaz\u00e1sban. Ez a k\u00f3d/logika duplik\u00e1ci\u00f3 speci\u00e1lis, kiss\u00e9 nehezen kisz\u00farhat\u00f3 esete. A c\u00e9lunk ezzel szemben az lenne, hogy egyetlen k\u00f6zponti helyen hat\u00e1rozzuk meg hogy milyen absztrakci\u00f3 (interf\u00e9sz t\u00edpus) eset\u00e9n milyen implement\u00e1ci\u00f3s t\u00edpust kell mindenhol haszn\u00e1lni az alkalmaz\u00e1sban (pl. ILogger->Logger, IMailSender->EMailSender). Ez\u00e1ltal egyr\u00e9szt egy helyen, k\u00f6nnyen \u00e1t tudn\u00e1nk tekinteni a lek\u00e9pez\u00e9seinket. M\u00e1sr\u00e9szt ha meg akarjuk v\u00e1ltoztatni az egyik lek\u00e9pez\u00e9st (pl. ILogger eset\u00e9n Logger helyett AdvancedLogger haszn\u00e1lata), azt el\u00e9g egy k\u00f6zponti helyen megtenni.","title":"P\u00e9lda 2. f\u00e1zis - szolg\u00e1ltat\u00e1s oszt\u00e1ly manu\u00e1lis f\u00fcgg\u0151s\u00e9g injekt\u00e1l\u00e1ssal"},{"location":"jegyzet/di/#pelda-3-fazis-fuggosegek-injektalasa-net-core-dependency-injection-alapokon","text":"Az el\u0151z\u0151 fejezetben z\u00e1r\u00f3gondolatk\u00e9nt megfogalmazott k\u00e9t probl\u00e9ma megold\u00e1s\u00e1ra m\u00e1r n\u00e9mi extra seg\u00edts\u00e9gre van sz\u00fcks\u00e9g\u00fcnk: egy Inversion of Control (IoC) kont\u00e9nerre. Egy IoC kont\u00e9nerbe absztrakci\u00f3s t\u00edpus -> implement\u00e1ci\u00f3s t\u00edpus lek\u00e9pez\u00e9seket tudunk t\u00e1rolni (REGISTER), majd ezt k\u00f6vet\u0151en absztrakci\u00f3s t\u00edpus alapj\u00e1n implement\u00e1ci\u00f3s t\u00edpusokat p\u00e9ld\u00e1nyos\u00edtani (RESOLVE). R\u00e9szletesebben: REGISTER (regisztr\u00e1ci\u00f3) : Az alkalmaz\u00e1s indul\u00e1sakor egyszer, k\u00f6zpontos\u00edtva egy Inversion of Control (IoC) kont\u00e9nerbe beregisztr\u00e1ljuk a f\u00fcgg\u0151s\u00e9gi lek\u00e9pez\u00e9seket (pl. ILogger->Logger, IMailSender->EMailSender). Ez a DI folyamat REGISTER l\u00e9p\u00e9se. Megjegyz\u00e9s: ezzel megoldottuk az el\u0151z\u0151 fejezeben felvezetett 2. probl\u00e9m\u00e1t, a lek\u00e9pez\u00e9seket egy k\u00f6zponti helyen \u00e9s nem az alkalmaz\u00e1sban sz\u00e9tsz\u00f3rva adjuk meg. RESOLVE (f\u00fcgg\u0151s\u00e9gfelold\u00e1s) : Amikor az alkalmaz\u00e1s fut\u00e1sakor sz\u00fcks\u00e9g\u00fcnk van egy implement\u00e1ci\u00f3s objektumra, a kont\u00e9nert\u0151l az absztrakci\u00f3 (interf\u00e9szt) t\u00edpus\u00e1t megadva k\u00e9r\u00fcnk egy implement\u00e1ci\u00f3t (pl. ILoggert megadva egy Logger objektumot kapunk). A resolve l\u00e9p\u00e9st az alkalmaz\u00e1s \" bel\u00e9p\u00e9si pontj\u00e1ban \" tessz\u00fck meg (pl. WebApi eset\u00e9n az egyes API k\u00e9r\u00e9sek be\u00e9rkez\u00e9sekor). A felold\u00e1st a kont\u00e9nert\u0151l csak a \" ROOT OBJECT \"-re (pl. WebApi eset\u00e9n a megfelel\u0151 Controller oszt\u00e1lyra) k\u00e9rj\u00fck explicit m\u00f3don: ez legy\u00e1rtja a root objectet, illetve annak valamennyi f\u00fcgg\u0151s\u00e9g\u00e9t, \u00e9s valamennyi k\u00f6zvetett f\u00fcgg\u0151s\u00e9g\u00e9t: el\u0151\u00e1ll egy objektumgr\u00e1f. Ez az AUTOWIRING folyamata. Megjegyz\u00e9s: Web API eset\u00e9n a Resolve l\u00e9p\u00e9st a keretrendszer v\u00e9gzi el: mi csak annyit tapasztalunk, hogy a controller oszt\u00e1lyunk automatikusan p\u00e9ld\u00e1nyos\u00edt\u00f3dik, \u00e9s valamennyi konstruktor param\u00e9tere automatikusan kit\u00f6lt\u00e9sre ker\u00fcl (a REGISTER l\u00e9p\u00e9s regisztr\u00e1ci\u00f3i alapj\u00e1n). Szerencs\u00e9re a .NET Core rendelkezik IoC Container alap\u00fa dependency injection szolg\u00e1ltat\u00e1ssal. A k\u00f6vetkez\u0151kben a tov\u00e1bbfejlesztett e-mail \u00e9rtes\u00edt\u0151 megold\u00e1sunkat p\u00e9ldak\u00e9nt haszn\u00e1lva vil\u00e1g\u00edtjuk meg jobban a mechanizmust.","title":"P\u00e9lda 3. f\u00e1zis - f\u00fcgg\u0151s\u00e9gek injekt\u00e1l\u00e1sa .NET Core Dependency Injection alapokon"},{"location":"jegyzet/di/#1-register-lepes-fuggosegek-beregisztralasa","text":"Asp.Net Core k\u00f6rnyezetben a f\u00fcgg\u0151s\u00e9gek beregisztr\u00e1l\u00e1sa a Startup oszt\u00e1lyunk ConfigureServices(IServiceCollection services) m\u0171velet\u00e9ben t\u00f6rt\u00e9nik, m\u00e9gpedig a IServiceCollection AddSingleton , AddTransient \u00e9s AddScoped m\u0171veleteivel. Els\u0151 l\u00e9p\u00e9sben f\u00f3kusz\u00e1ljunk a ConfigureServices sz\u00e1munka legizgalmasabb r\u00e9szeire: public class Startup { public void ConfigureServices ( IServiceCollection services ) { // ... services . AddSingleton < ILogger , Logger >(); services . AddTransient < INotificationService , NotificationService >(); services . AddScoped < IContactRepository , ContactRepository >(); services . AddSingleton < IEMailSender , EMailSender >( sp => new EMailSender ( sp . GetRequiredService < ILogger >(), \"smtp.myserver.com\" ) ); // ... } A Startup.ConfigureServices -t a keretrendszer h\u00edvja az alkalmaz\u00e1s indul\u00e1sakor. Param\u00e9terben egy IServiceCollection services objektumot kapunk, sz\u00e1munkra ez reprezent\u00e1lja a keretendszer \u00e1ltal m\u00e1r el\u0151re p\u00e9ld\u00e1nyos\u00edtott IoC kont\u00e9nert, ebbe tudjuk a saj\u00e1t f\u00fcgg\u0151s\u00e9geinket beregisztr\u00e1lni. A services . AddSingleton < ILogger , Logger >(); sorral ILogger t\u00edpusk\u00e9nt a Logger implement\u00e1ci\u00f3s t\u00edpust regisztr\u00e1ljuk be (ILogger->Logger lek\u00e9pz\u00e9s), m\u00e9gpedig az AddSingleton m\u0171velet hat\u00e1s\u00e1ra singleton -k\u00e9nt. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l egy ILogger objektumot k\u00e9r\u00fcnk (resolve), a kont\u00e9nert\u0151l egy Logger objektumot kapunk, m\u00e9gpedig mindig ugyanazt a p\u00e9ld\u00e1nyt . A services . AddTransient < INotificationService , NotificationService >(); sorral INotificationService t\u00edpusk\u00e9nt a NotificationService implement\u00e1ci\u00f3s t\u00edpust regiszt\u00e1ljuk be (INotificationService->NotificationService lek\u00e9pz\u00e9s), m\u00e9gpedig az AddTransient m\u0171velet hat\u00e1s\u00e1ra tranziens m\u00f3don. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l egy INotificationService objektumot k\u00e9r\u00fcnk (resolve), a kont\u00e9nert\u0151l egy NotificationService objektumot kapunk, m\u00e9gpedig minden lek\u00e9rdez\u00e9skor egy \u00fajonnan l\u00e9trehozott p\u00e9ld\u00e1nyt . A services . AddScoped < IContactRepository , ContactRepository >(); sor IContactRepository t\u00edpusk\u00e9nt a ContactRepository implement\u00e1ci\u00f3s t\u00edpust regisztr\u00e1lja be (IContactRepository->ContactRepository lek\u00e9pz\u00e9s), m\u00e9gpedig az AddScoped m\u0171velet hat\u00e1s\u00e1ra scope-olt m\u00f3don. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l IContactRepository objektumot k\u00e9r\u00fcnk (resolve), ContactRepository objektumot kapunk, m\u00e9gpedig adott hat\u00f3k\u00f6r\u00f6n bel\u00fcl ugyanazt , elt\u00e9r\u0151 hat\u00f3k\u00f6r\u00f6kben m\u00e1sokat. A Web API alkalmaz\u00e1sokn\u00e1l egy-egy API k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sz\u00e1m\u00edt egy-egy megfelel\u0151 hat\u00f3k\u00f6rnek: vagyis a kont\u00e9nert\u0151l egy k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sor\u00e1n ugyanazt az objektump\u00e9ld\u00e1nyt, elt\u00e9r\u0151 k\u00e9r\u00e9sek eset\u00e9n m\u00e1sokat kapunk. A mintaalkalmaz\u00e1s Startup.ConfigureServices -ben tov\u00e1bbi regisztr\u00e1ci\u00f3kkal is tal\u00e1lkozunk, ezekre k\u00e9s\u0151bb t\u00e9r\u00fcnk vissza.","title":"1) REGISTER l\u00e9p\u00e9s (f\u00fcgg\u0151s\u00e9gek beregisztr\u00e1l\u00e1sa)"},{"location":"jegyzet/di/#2-resolve-lepes-fuggosegek-feloldasa","text":"","title":"2) RESOLVE l\u00e9p\u00e9s (f\u00fcgg\u0151s\u00e9gek felold\u00e1sa)"},{"location":"jegyzet/di/#alapok","text":"Jelen pillanatban ott tartunk, hogy az alkalmaz\u00e1s indul\u00e1sakor beregisztr\u00e1ltuk a szolg\u00e1ltat\u00e1s t\u00edpusok f\u00fcgg\u0151s\u00e9gi lek\u00e9pez\u00e9seit az ASP.NET Core IoC kont\u00e9ner\u00e9be. A t\u00edpuslek\u00e9pez\u00e9seink a k\u00f6vetkez\u0151k: ILogger -> Logger, singletonk\u00e9nt INotificationService -> NotificationService, tranziensk\u00e9nt IContactRepository -> ContactRepository, scope-oltk\u00e9nt IEMailSender -> EMailSender, singletonk\u00e9nt Ezt k\u00f6vet\u0151en, amikor sz\u00fcks\u00e9g\u00fcnk van egy adott implement\u00e1ci\u00f3s t\u00edpusra, a kont\u00e9nert\u0151l az (absztrakci\u00f3s) t\u00edpus, mint kulcs alapj\u00e1n k\u00e9rhet\u00fcnk egy implement\u00e1ci\u00f3s p\u00e9ld\u00e1nyt. Ennek sor\u00e1n ASP.NET Core k\u00f6rnyezetben a kont\u00e9nert egy IServiceProvider hivatkoz\u00e1s form\u00e1j\u00e1ban kapjuk meg, \u00e9s a GetService m\u0171velet k\u00fcl\u00f6nb\u00f6z\u0151 form\u00e1it haszn\u00e1ljuk. Pl.: void SimpleResolve ( IServiceProvider sp ) { // Mivel az ILogger t\u00edpushoz a Logger oszt\u00e1lyt regisztr\u00e1ltuk, // egy Logger p\u00e9ld\u00e1nnyal t\u00e9r vissza. var logger1 = sp . GetService ( typeof ( ILogger )); // A t\u00edpus generikus param\u00e9terben is megadhatjuk, k\u00e9nyelmesebb, ezt szoktuk haszn\u00e1lni. // Ehhez sz\u00fcks\u00e9g van a Microsoft.Extensions.DependencyInjection n\u00e9vt\u00e9r using-ol\u00e1s\u00e1ra, // mert ez a GetService forma ott defini\u00e1lt extension methodk\u00e9nt. // Mivel az ILogger t\u00edpushoz a Logger oszt\u00e1lyt regisztr\u00e1ltuk, // egy Logger p\u00e9ld\u00e1nnyal t\u00e9r vissza. var logger2 = sp . GetService < ILogger >(); // M\u00edg a GetService null-t ad vissza, ha nem siker\u00fcl feloldani a // kont\u00e9ner alapj\u00e1n a hivatkoz\u00e1st, a GetRequiredService kiv\u00e9telt dob. var logger3 = sp . GetRequiredService < ILogger >(); // ... } A p\u00e9ld\u00e1ban k\u00f3dkommentek r\u00e9szletesen elmagyar\u00e1zz\u00e1k a viselked\u00e9st. Minden esetben a l\u00e9nyeg az, hogy vagy a typeof oper\u00e1torral, vagy generikus param\u00e9terben megadunk egy absztrakci\u00f3s t\u00edpust, \u00e9s a GetService egy az ahhoz beregisztr\u00e1lt implement\u00e1ci\u00f3s t\u00edpussal t\u00e9r vissza.","title":"Alapok"},{"location":"jegyzet/di/#objektumgraf-feloldasa-autowiring","text":"Az el\u0151z\u0151 p\u00e9ld\u00e1nkban a kont\u00e9ner a felold\u00e1s sor\u00e1n komolyabb \"fejt\u00f6r\u00e9s\" n\u00e9lk\u00fcl tudta a Logger oszt\u00e1lyt p\u00e9ld\u00e1nyos\u00edtani, ugyanis annak nincsenek tov\u00e1bbi f\u00fcgg\u0151s\u00e9gei: egyetlen default konstruktorral rendelkezik. Tekints\u00fck most az INotificationService felold\u00e1s\u00e1t: public void ObjectGraphResolve ( IServiceProvider sp ) { var notifService = sp . GetService < INotificationService >(); // ... } A felold\u00e1s (GetService h\u00edv\u00e1s) sor\u00e1n a kont\u00e9nernek egy NotificationService objektumot kell l\u00e9trehoznia. Ez csak \u00fagy lehets\u00e9ges, ha minden konstruktor param\u00e9ter\u00e9nek megfelel\u0151 objektumot ad meg. Ez a gyakorlatban azt jelenti, hogy a l\u00e9trehoz\u00e1s sor\u00e1n feloldja az oszt\u00e1ly k\u00f6zvetlen \u00e9s k\u00f6zvetett f\u00fcgg\u0151s\u00e9geit, rekurz\u00edvan: A NotificationService oszt\u00e1ly egy h\u00e1romparam\u00e9teres konstruktorral rendelkezik (vagyis h\u00e1rom f\u00fcgg\u0151s\u00e9ge is van): NotificationService(ILogger logger, IEMailSender emailSender, IContactRepository contactRepository) . A konstruktorparam\u00e9tereket a GetService egyes\u00e9vel feloldja a regisztr\u00e1ci\u00f3k alapj\u00e1n: ILogger logger: egy Logger objektum lesz, mindig ugyanaz (mert singleton) IEMailSender emailSender: EMailSender objektum lesz, minden alkalommal m\u00e1s (mert transient) Ennek van egy ILogger logger konstruktor param\u00e9tere, amit fel kell oldani: Egy Logger objektum lesz, mindig ugyanaz (mert singleton) IContactRepository contactRepository: ContactRepository objektum lesz, hat\u00f3k\u00f6r\u00f6nk\u00e9nt - Web API eset\u00e9n API h\u00edv\u00e1sonk\u00e9nt - m\u00e1s (mert scoped). A felold\u00e1s v\u00e9g\u00e9re - vagyis amikor visszat\u00e9r a fenti GetService<INotificationService>() h\u00edv\u00e1s - el\u0151\u00e1ll a teljesen felparam\u00e9terezett NotificationService objektum, valamennyi k\u00f6zvetlen \u00e9s k\u00f6zvetett f\u00fcgg\u0151s\u00e9g\u00e9vel, vagyis egy objektumgr\u00e1f -ot kapunk: A DI keretrendszer/IoC kont\u00e9nerek azon tulajdons\u00e1g\u00e1t, hogy az objektumok f\u00fcgg\u0151s\u00e9geinek felder\u00edt\u00e9s\u00e9vel (a gyakorlatban jellemz\u0151en a konstruktor param\u00e9terek felder\u00edt\u00e9s\u00e9vel) a beregisztr\u00e1lt absztrakci\u00f3->implement\u00e1ci\u00f3 lek\u00e9pez\u00e9sek alapj\u00e1n k\u00e9pes objektumgr\u00e1fokat el\u0151\u00e1ll\u00edtani autowiring -nek nevezz\u00fck.","title":"Objektumgr\u00e1f felold\u00e1sa, autowiring"},{"location":"jegyzet/di/#fuggosegfeloldas-aspnet-web-api-osztalyok-eseten","text":"Azon t\u00fal, hogy a megold\u00e1sunkat kont\u00e9ner alapokra helyezz\u00fck, p\u00e1r tov\u00e1bbi v\u00e1ltoztat\u00e1st is v\u00e9grehajtunk a todo alkalmaz\u00e1sunkon. A ToDoService oszt\u00e1lyt megsz\u00fcntetj\u00fck, a funkcionalit\u00e1s\u00e1t kicsit m\u00e1s form\u00e1ban egy ASP.NET Core ControllerBase lesz\u00e1rmazott TodoController oszt\u00e1lyba mozgatjuk. Ez az oszt\u00e1ly lesz a bel\u00e9p\u00e9si pont \u00e9s a gy\u00f6k\u00e9robjektum a k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sor\u00e1n. Ez\u00e1ltal a megold\u00e1sunk jobban t\u00fckr\u00f6zi egy val\u00f3s Web API, MVC Web app, illetve Web Razor Pages app alkalmaz\u00e1s megk\u00f6zel\u00edt\u00e9s\u00e9t. A ToDoService oszt\u00e1lyt megtarthattuk volna a h\u00edv\u00e1si/f\u00fcgg\u0151s\u00e9gi l\u00e1ncunk k\u00f6zep\u00e9n, de demonstr\u00e1l\u00e1si c\u00e9ljainkat jobban szolg\u00e1lja egy egyszer\u0171s\u00edtett megk\u00f6zel\u00edt\u00e9s. Ezen t\u00falmen\u0151en bevezet\u00fcnk egy Entity Framework DbContext lesz\u00e1rmazott TodoContext oszt\u00e1lyt annak \u00e9rdek\u00e9ben, hogy demonstr\u00e1lni tudjuk, mik\u00e9ppen t\u00f6rt\u00e9nhet ennek injekt\u00e1l\u00e1sa a repository vagy egy\u00e9b oszt\u00e1lyainkba. Az objektumgr\u00e1funk a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki: Az el\u0151z\u0151 k\u00e9t fejezetben feltett\u00fck, hogy a GetService h\u00edv\u00e1s\u00e1hoz egy IServiceProvider objektum rendelkez\u00e9sre \u00e1ll. Ha mi magunk hozunk l\u00e9tre egy kont\u00e9nert, akkor ez \u00edgy is van. Azonban csak a legritk\u00e1bb esetben szoktunk kont\u00e9nert k\u00f6zvetlen\u00fcl l\u00e9trehozni. Egy tipikus ASP.NET Web API alkalmaz\u00e1s eset\u00e9n a kont\u00e9nert a keretrendszer hozza l\u00e9tre, \u00e9s sz\u00e1munkra k\u00f6zvetlen\u00fcl nem is hozz\u00e1f\u00e9rhet\u0151. Ennek k\u00f6vetkezt\u00e9ben IServiceProvider hez - p\u00e1r indul\u00e1skori konfigur\u00e1ci\u00f3s \u00e9s kiterjeszt\u00e9si pontot eltekintve - hozz\u00e1f\u00e9r\u00e9st nem is kapunk. A j\u00f3 h\u00edr az, hogy erre nincs is sz\u00fcks\u00e9g. A DI alapkoncepci\u00f3j\u00e1ba ugyanis az is beletartozik, hogy a f\u00fcgg\u0151s\u00e9gfelold\u00e1st csak az alkalmaz\u00e1s bel\u00e9p\u00e9si pontj\u00e1ban a \"root object\"-re (gy\u00f6k\u00e9robjektum) v\u00e9gezz\u00fck el. Web API eset\u00e9ben a bel\u00e9p\u00e9si pontot az egyes API k\u00e9r\u00e9sek kiszolg\u00e1l\u00e1sa jelenti. Amikor be\u00e9rkezik egy k\u00e9r\u00e9s, akkor az Url \u00e9s a rooting szab\u00e1lyok alapj\u00e1n a keretrendszer meghat\u00e1rozza, mely Controller/ControllerBase lesz\u00e1rmazott oszt\u00e1lyt kell p\u00e9ld\u00e1nyos\u00edtani, \u00e9s azt l\u00e9tre is hozza. Amennyiben a controller oszt\u00e1lynak vannak f\u00fcgg\u0151s\u00e9gei (konstruktor param\u00e9terek), azok is felold\u00e1sra ker\u00fclnek a beregisztr\u00e1lt lek\u00e9pez\u00e9sek alapj\u00e1n, bele\u00e9rtve a k\u00f6zvetett f\u00fcgg\u0151s\u00e9geket is. El\u0151\u00e1ll a teljes objektumgr\u00e1f, a root object maga a controller oszt\u00e1ly . N\u00e9zz\u00fck ezt a gyakorlatban a kor\u00e1bbi p\u00e9ld\u00e1nk tov\u00e1bbfejleszt\u00e9s\u00e9vel, melyet egy TodoController oszt\u00e1llyal eg\u00e9sz\u00edtett\u00fcnk ki: [Route(\"api/[controller] \")] [ApiController] public class TodoController : ControllerBase { // A TodoController oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei private readonly TodoContext _context ; // ez egy DbContext private readonly INotificationService _notificationService ; // A f\u00fcgg\u0151s\u00e9geket konstruktor param\u00e9terben kapja meg. public TodoController ( TodoContext context , INotificationService notificationService ) { _context = context ; _notificationService = notificationService ; // Fill wit some initial data if ( _context . TodoItems . Count () == 0 ) { _context . TodoItems . Add ( new TodoItem { Name = \"Item1\" }); _context . TodoItems . Add ( new TodoItem { Name = \"Item2\" , LinkedContactId = 2 }); _context . SaveChanges (); } } // API kezel\u0151f\u00fcggv\u00e9ny e-mail eml\u00e9keztet\u0151 \u00e9rtes\u00edt\u00e9s kik\u00fcld\u00e9s\u00e9re. // P\u00e9lda: http post erre a c\u00edmre (pl. PostMan-nel): // http://localhost:58922/api/todo/2/reminder // Ez a 2-es azonos\u00edt\u00f3j\u00fa todo item kontakt szem\u00e9ly\u00e9nek \u00e9rtes\u00edt\u00e9st k\u00fcld a todo itemr\u0151l. [HttpPost(\"{id}/reminder\")] public IActionResult ReminderMessageToLinkedContact ( long id ) { // Todo item kikeres\u00e9se, haszn\u00e1lja a _context DbContext objektumot var item = _context . TodoItems . Find ( id ); if ( item == null ) return NotFound (); // Eml\u00e9keztet\u0151 e-mail kik\u00fcld\u00e9se _notificationService . SendEmailReminder ( item . LinkedContactId , item . Name ); // Val\u00f3j\u00e1ban nem hozunk l\u00e9tre semmit, egyszer\u0171 OK a v\u00e1lasz return Ok (); } // ... tov\u00e1bbi m\u0171veletek } A http://<g\u00e9pc\u00edm>/api/todo url al\u00e1 bees\u0151 k\u00e9r\u00e9seket a routing szab\u00e1lyok alapj\u00e1n a TodoController oszt\u00e1ly kapja meg. Az \u00e9rtes\u00edt\u00e9s kik\u00fcld\u00e9s\u00e9t triggerel\u0151 http://<g\u00e9pc\u00edm>/api/todo/<todo-id>/reminder c\u00edmre \u00e9rkez\u0151 post k\u00e9r\u00e9st pedig a TodoController.ReminderMessageToLinkedContact m\u0171velete. A TodoController -t a keretrendszer p\u00e9ld\u00e1nyos\u00edtja, minden k\u00e9r\u00e9shez \u00faj objektumot hoz l\u00e9tre. Az oszt\u00e1lynak k\u00e9t f\u00fcgg\u0151s\u00e9ge van, melyeket konstruktor param\u00e9terben kap meg. Az els\u0151 egy TodoContext objektum, ami egy DbContext lesz\u00e1rmazott. A m\u00e1sik a m\u00e1r j\u00f3l ismert INotificationService . Mint az el\u0151z\u0151 fejezetben l\u00e1ttuk, a DI keretrendszer ezeket is p\u00e9ld\u00e1nyos\u00edtja a regisztr\u00e1lt lek\u00e9pez\u00e9sek alapj\u00e1n (az \u00f6sszes k\u00f6zvetett f\u00fcgg\u0151s\u00e9geikkel), param\u00e9terk\u00e9nt \u00e1tadja TodoController konstruktornak, ahol ezeket tagv\u00e1ltoz\u00f3kban elt\u00e1roljuk. \u00cdgy ezek a be\u00e9rkez\u0151 k\u00e9r\u00e9seket kiszolg\u00e1l\u00f3 m\u0171veletekben, mint pl. a ReminderMessageToLinkedContact -ben m\u00e1r rendelkez\u00e9sre \u00e1llnak. Megjegyz\u00e9s A TodoContext felold\u00e1sa csak akkor lehets\u00e9ges, ha ezt az IoC kont\u00e9nerbe el\u0151zetesen beregisztr\u00e1ltuk. Erre a k\u00f6vetkez\u0151 fejezetben t\u00e9r\u00fcnk ki.","title":"F\u00fcgg\u0151s\u00e9gfelold\u00e1s ASP.NET Web API oszt\u00e1lyok eset\u00e9n"},{"location":"jegyzet/di/#entity-framework-dbcontext-regisztracio-es-feloldas","text":"Alkalmaz\u00e1sokban - k\u00fcl\u00f6n\u00f6sen Asp.Net Core eset\u00e9ben - a DbContext haszn\u00e1lat\u00e1nak k\u00e9t m\u00f3dja lehets\u00e9ges: Minden alkalommal, amikor sz\u00fcks\u00e9g van r\u00e1, egy using blokkban p\u00e9ld\u00e1nyos\u00edtjuk \u00e9s fel is szabad\u00edtjuk. \u00cdgy egy be\u00e9rkez\u0151 k\u00e9r\u00e9s sor\u00e1n t\u00f6bb DbContext objektump\u00e9ld\u00e1ny is felhaszn\u00e1l\u00e1sra ker\u00fclhet. A DbContext -et be\u00e9rkez\u0151 k\u00e9r\u00e9senk\u00e9nt hozzuk l\u00e9tre, egy k\u00e9r\u00e9sen bel\u00fcl viszont megosztottan ugyanazt az objektump\u00e9ld\u00e1nyt haszn\u00e1lj\u00e1k az oszt\u00e1lyaink. Ez esetben a DbContext -re mint egy oszt\u00e1lyok k\u00f6z\u00f6tt megosztott repository-ra, pontosabban unit of work-re gondolunk. A bej\u00f6v\u0151 k\u00e9r\u00e9s sor\u00e1n egy DbContext objektumot hozunk l\u00e9tre, \u00e9s ezt injekt\u00e1ljuk be az erre \u00e9p\u00edt\u0151 oszt\u00e1lyoknak. Ez ut\u00f3bbi megk\u00f6zel\u00edt\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1ra remek k\u00e9zre es\u0151 be\u00e9p\u00edtett DI alap\u00fa megold\u00e1st ny\u00fajt az ASP.NET Core: a kont\u00e9nerbe indul\u00e1skor beregisztr\u00e1ljuk a DbContext oszt\u00e1lyunkat, mely \u00edgy a Controller \u00e9s egy\u00e9b f\u00fcgg\u0151s\u00e9gei sz\u00e1m\u00e1ra automatikusan beinjekt\u00e1l\u00e1sra ker\u00fcl. N\u00e9zz\u00fck meg, hogyan is t\u00f6rt\u00e9nik a TodoContext DbContext lesz\u00e1rmazott oszt\u00e1lyunk beregisztr\u00e1l\u00e1sa a p\u00e9ld\u00e1nkban. A regisztr\u00e1ci\u00f3 helye a szok\u00e1sos Startup.ConfigureServices : public void ConfigureServices ( IServiceCollection services ) { // ... services . AddDbContext < TodoContext >( opt => opt . UseInMemoryDatabase ( \"TodoList\" )); // ... } Az AddDbContext egy a keretrendszer \u00e1ltal az IServiceCollection interf\u00e9szre defini\u00e1lt extension method. Ez a DbContext oszt\u00e1lyunk k\u00e9nyelmes beregisztr\u00e1ci\u00f3j\u00e1t teszi lehet\u0151v\u00e9. Ennek belsej\u00e9be nem l\u00e1tunk bele, mindenesetre lelke a scope-ot regisztr\u00e1ci\u00f3. \"Pszeudok\u00f3ddal\": services . AddScoped < TodoContext , TodoContext >(); Mint a p\u00e9ld\u00e1ban l\u00e1that\u00f3, a TodoContext beregisztr\u00e1l\u00e1sa nem egy absztrakci\u00f3val t\u00f6rt\u00e9nik (nincs ITodoContext interf\u00e9sz), hanem mag\u00e1val a TodoContext implement\u00e1ci\u00f3s t\u00edpussal . A DI keretrendszerek/IoC kont\u00e9nerek t\u00e1mogatj\u00e1k, hogy a regisztr\u00e1ci\u00f3 sor\u00e1n az absztrakci\u00f3 egy konkr\u00e9t t\u00edpus legyen, jellemz\u0151sen maga az implement\u00e1ci\u00f3s t\u00edpus . Ezt a megk\u00f6zel\u00edt\u00e9st csak indokolt esetben haszn\u00e1ljuk. ASP.NET Core k\u00f6rnyezetben a DbContext lesz\u00e1rmazott oszt\u00e1lyunk sz\u00e1m\u00e1ra soha nem vezet\u00fcnk be interf\u00e9szt, hanem az oszt\u00e1ly\u00e1nak a t\u00edpus\u00e1val ker\u00fcl beregisztr\u00e1l\u00e1sra az IoC kont\u00e9nerbe (a p\u00e9ld\u00e1nkban is TodoContext -> TodoContext lek\u00e9pez\u00e9s t\u00f6rt\u00e9nik). A DbContext \u00f6nmag\u00e1ban is sz\u00e1mos perzisztencial providerrel (pl. MSSQL, Oracle, mem\u00f3ria, stb.) tud egy\u00fctt m\u0171k\u00f6dni, \u00edgy alkalmaz\u00e1sf\u00fcgg\u0151, mennyire van \u00e9rtelme absztrah\u00e1lni. Ha absztrah\u00e1ljuk az adathozz\u00e1f\u00e9r\u00e9st, akkor nem a DbContext -hez vezet\u00fcnk be interf\u00e9szt, hanem a Repository tervez\u00e9si mint\u00e1t haszn\u00e1ljuk, \u00e9s az egyes repository implement\u00e1ci\u00f3khoz vezet\u00fcnk be interf\u00e9szeket, valamint ezek vonatkoz\u00e1s\u00e1ban t\u00f6rt\u00e9nik az IoC kont\u00e9nerben a lek\u00e9pez\u00e9s (pl. ITodoRepository -> TodoRepository ). A repository oszt\u00e1lyok pedig vagy maguk p\u00e9ld\u00e1nyos\u00edtj\u00e1k a DbContext objektumokat, vagy konstruktor param\u00e9terben ker\u00fcl sz\u00e1mukra beinjekt\u00e1l\u00e1sra). Megjegyz\u00e9s Jelen dokumentumnak nem c\u00e9lja \u00e1ll\u00e1st foglalni abban, mely esetben c\u00e9lszer\u0171 Repository vagy egy\u00e9b mint\u00e1k seg\u00edts\u00e9g\u00e9vel a controller illetve service oszt\u00e1lyok sz\u00e1m\u00e1ra az EF/DbContext alap\u00fa adathozz\u00e1f\u00e9r\u00e9st egy DAL r\u00e9tegben elrejteni, illetve ezzel szemben mely esetben haszn\u00e1ljuk a DbContext oszt\u00e1lyt k\u00f6zvetlen\u00fcl a controller/szolg\u00e1ltat\u00e1s objektumainkban (vagyis a BLL-ben). Az illusztr\u00e1ci\u00f3 kedv\u00e9\u00e9rt a TodoApi alkalmaz\u00e1sunk ebben az \u00e9rtelemben vegyes megold\u00e1st alkalmaz: a TodoItem objektumok perziszt\u00e1l\u00e1s\u00e1ra a szolg\u00e1ltat\u00e1s oszt\u00e1lyok k\u00f6zvetlen\u00fcl a DbContext-et haszn\u00e1lj\u00e1k, m\u00edg a Contact-ok kezel\u00e9s\u00e9re a Repository mint\u00e1t haszn\u00e1ljuk. A fenti p\u00e9ld\u00e1ban az is l\u00e1that\u00f3, hogy a AddDbContext sor\u00e1n a DbContext (eset\u00fcnkben TodoContext ) regisztr\u00e1l\u00e1sakor egy lambda kifejez\u00e9st is meg tudunk adni: opt => opt . UseInMemoryDatabase ( \"TodoList\" ) Ezen a lambda kifejez\u00e9s\u00fcnket a kont\u00e9ner a k\u00e9s\u0151bbiekben a resolve sor\u00e1n - vagyis amikor egy TodoContext p\u00e9ld\u00e1nyos\u00edt\u00e1sa t\u00f6rt\u00e9nik - megh\u00edvja, \u00e9s param\u00e9terk\u00e9nt egy opci\u00f3z\u00f3 objektumot kapunk (a p\u00e9ld\u00e1ban opt argumentum): ennek seg\u00edts\u00e9g\u00e9vel lehet\u0151s\u00e9g\u00fcnk van a l\u00e9trehozand\u00f3 TodoContext objektum opci\u00f3z\u00e1s\u00e1ra, konfigur\u00e1l\u00e1s\u00e1ra. A p\u00e9ld\u00e1nkban a UseInMemoryDatabase m\u0171velet h\u00edv\u00e1s\u00e1val egy \"TodoList\" nev\u0171 mem\u00f3riaadatb\u00e1zist hozunk l\u00e9tre.","title":"Entity Framework DbContext regisztr\u00e1ci\u00f3 \u00e9s felold\u00e1s"},{"location":"jegyzet/di/#haladobb-fuggosegregisztracio-pelda","text":"Nem k\u00f6telez\u0151 tananyag. T\u00e9rj\u00fcnk ki a Startup.ConfigureServices kor\u00e1bban nem ismertetett r\u00e9szeire. Az EMailSender beregisztr\u00e1l\u00e1sa els\u0151 r\u00e1n\u00e9z\u00e9sre eg\u00e9szen tr\u00fckk\u00f6snek t\u0171nik: services . AddSingleton < IEMailSender , EMailSender >( sp => new EMailSender ( sp . GetRequiredService < ILogger >(), \"smtp.myserver.com\" ) ); A jobb meg\u00e9rt\u00e9s \u00e9rdek\u00e9ben n\u00e9zz\u00fck meg az EMailSender konstruktor\u00e1t: public EMailSender ( ILogger logger , string smtpAddress ) { _logger = logger ; _smtpAddress = smtpAddress ; } Az EMailSender t a kont\u00e9nernek kell majd a felold\u00e1s sor\u00e1n p\u00e9ld\u00e1nyos\u00edtania, ehhez a konstruktor param\u00e9tereket megfelel\u0151en meg kell tudni adnia. A logger param\u00e9ter teljesen \"rendben van\", a kont\u00e9ner ILogger->Logger regisztr\u00e1ci\u00f3ja alapj\u00e1n a kont\u00e9ner fel tudja oldani. Az smtpAddress param\u00e9ter \u00e9rt\u00e9k\u00e9t viszont nem tudja kital\u00e1lni. Az ASP.NET Core a probl\u00e9ma megold\u00e1s\u00e1ra a keretrendszer \"options\" mechanizmus\u00e1t javasolja, mely lehet\u0151v\u00e9 teszi, hogy az \u00e9rt\u00e9ket valamilyen konfigur\u00e1ci\u00f3b\u00f3l olvassuk be. Ez sz\u00e1munkra egy messzire vezet\u0151 sz\u00e1l lenne, \u00edgy egyszer\u0171s\u00edt\u00e9sk\u00e9ppen m\u00e1s megold\u00e1shoz folyamodtunk. Az AddSingleton (\u00e9s a t\u00f6bbi Add... m\u0171veletnek) van olyan overloadja, melyben egy lambda kifejez\u00e9st tudunk megadni. Ezt a lambd\u00e1t a kont\u00e9ner a k\u00e9s\u0151bbiekben a resolve sor\u00e1n (vagyis amikor egy IEMailSender alapj\u00e1n egy EMailSender t k\u00e9r\u00fcnk a kont\u00e9nert\u0151l) h\u00edvja, minden egyes p\u00e9ld\u00e1nyos\u00edt\u00e1s sor\u00e1n: ebben mi magunk p\u00e9ld\u00e1nyos\u00edtjuk az EMailSender objektumot, a konstruktor param\u00e9tereket az ig\u00e9nyeink szerint meghat\u00e1rozva. S\u0151t, a kont\u00e9ner \"van olyan kedves\", hogy lambda param\u00e9terben kapunk egy IServiceCollection objektumot (p\u00e9ld\u00e1nkban ez az sp ), \u00e9s ezzel a kont\u00e9nerben m\u00e1r megl\u00e9v\u0151 regisztr\u00e1ci\u00f3k alapj\u00e1n a GetRequiredService \u00e9s GetService h\u00edv\u00e1sokkal k\u00e9nyelmesen tudunk t\u00edpusokat feloldani, amennyiben sz\u00fcks\u00e9g van r\u00e1.","title":"Halad\u00f3(bb) f\u00fcgg\u0151s\u00e9gregisztr\u00e1ci\u00f3 p\u00e9lda"},{"location":"jegyzet/di/#tovabbi-temakorok","text":"","title":"Tov\u00e1bbi t\u00e9mak\u00f6r\u00f6k"},{"location":"jegyzet/di/#dependency-injectionioc-kontenerek-altalanossagaban","text":"A .NET Core be\u00e9p\u00edtett DI kont\u00e9ner jellemz\u0151i: Alapszolg\u00e1ltat\u00e1sokat ny\u00fajt (pl. property injection-t nem t\u00e1mogat). Ha enn\u00e9l t\u00f6bbre van sz\u00fcks\u00e9g, haszn\u00e1lhatunk m\u00e1s IoC kont\u00e9nert is, az ASP.NET Core egy\u00fctt tud m\u0171k\u00f6dni vele. Sz\u00e1mos .NET (legyen az .NET Core, .NET Framework vagy mindkett\u0151) k\u00f6rnyezetben haszn\u00e1lhat\u00f3 Dependecy Injection/IoC kont\u00e9ner oszt\u00e1lyk\u00f6nyvt\u00e1r l\u00e9tezik, pl.: AutoFac, DryIoc, LightInject, Castle Windsor, Ninject, StructureMap, SimpleInjector, MEF. Microsoft.Extensions.DependencyInjection NuGet package-ben van implement\u00e1lva (az alapn\u00e9vt\u00e9r is ez) ASP.NET Core alkalmaz\u00e1sok eset\u00e9n m\u00e1r a .NET projekt l\u00e9trehoz\u00e1sakor telep\u00edtve van. S\u0151t, mint l\u00e1ttuk: az ASP.NET Core middleware intenz\u00edven haszn\u00e1lja \u00e9s \u00e9p\u00edt r\u00e1, a runtime konfigur\u00e1ci\u00f3/kiterjeszthet\u0151s\u00e9g alappill\u00e9re. Egy\u00e9b .NET Core alkalmaz\u00e1sok eset\u00e9n (pl. Console) a Microsoft.Extensions.DependencyInjection NuGet package-dzsel manu\u00e1lisan kell telep\u00edteni. Megjegyz\u00e9s: a NuGet package haszn\u00e1lhat\u00f3 (teljes) .NET Frameworkkel is, mivel .NET Standard-et t\u00e1mogat.","title":"Dependency Injection/IoC kont\u00e9nerek \u00e1ltal\u00e1noss\u00e1g\u00e1ban"},{"location":"jegyzet/di/#service-locator-antipattern","text":"Az IoC kont\u00e9nerek haszn\u00e1lat\u00e1nak a dependency injectionnel szemben van egy m\u00e1sik haszn\u00e1lati m\u00f3dja. Ennek az a l\u00e9nyege, hogy az oszt\u00e1lyok sz\u00e1m\u00e1ra nem konstruktor param\u00e9terekben adjuk \u00e1t/injekt\u00e1ljuk be a f\u00fcgg\u0151s\u00e9geiket, hanem azokat az oszt\u00e1lyok a met\u00f3dusaikban az IoC kont\u00e9nert\u0151l a GetService m\u0171velettel magunk k\u00e9rdezik le. Ezt a megk\u00f6zel\u00edt\u00e9st Service Locator mint\u00e1nak nevezz\u00fck. Ez antipattern -nek tekintend\u0151, ugyanis a k\u00f3dban sz\u00e9tsz\u00f3rtan, minden egyes f\u00fcgg\u0151s\u00e9g felold\u00e1sakor haszn\u00e1ljuk a kont\u00e9nert, \u00edgy a k\u00f3dunk nagy r\u00e9sze f\u00fcggeni fog mag\u00e1t\u00f3l a kont\u00e9nert\u0151l! Ezzel szemben a dependency injection eset\u00e9ben a f\u00fcgg\u0151s\u00e9gfelold\u00e1st csak az alkalmaz\u00e1s bel\u00e9p\u00e9si pontj\u00e1ban a \"root object\"-ekre v\u00e9gezz\u00fck el, a k\u00f3dunk t\u00f6bbi r\u00e9sze teljesen f\u00fcggetlen a kont\u00e9nert\u0151l. Vegy\u00fck \u00e9szre, hogy a kor\u00e1bbi p\u00e9ld\u00e1nkban a TodoController, NotificationService, EMailSender, Logger \u00e9s ContactRepository oszt\u00e1lyainkban sehol nem hivatkoztunk a kont\u00e9nerre (sem IServiceProvider-k\u00e9nt, sem m\u00e1s m\u00f3don).","title":"Service Locator antipattern"},{"location":"jegyzet/di/#aspnet-core-keretrendszer-szolgaltatasok","text":"Az ASP.NET Core sz\u00e1mos be\u00e9p\u00edtett szolg\u00e1ltat\u00e1ssal rendelkezik. Pl. ilyen az (MVC) alap\u00fa Wep API t\u00e1mogat\u00e1s is, vagy a felhaszn\u00e1l\u00f3 fel\u00fclettel is rendelkez\u0151 MVC/Razor alap\u00fa webalkalmaz\u00e1s t\u00e1mogat\u00e1s.Ezek t\u00f6bbs\u00e9ge maga is a DI keretrendszert haszn\u00e1lja f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1sra. ASP.NET Web API eset\u00e9n a Startup.ConfigureServices -ben szerepelnie kell az al\u00e1bbi sornak: services . AddMvc () . SetCompatibilityVersion ( CompatibilityVersion . Version_2_1 ); Az AddMvc egy be\u00e9p\u00edtett extension metod az IServiceProvider interf\u00e9szre vonatkoz\u00f3an, mely sz\u00e1mos (messze 100 feletti darabsz\u00e1m\u00fa!), a Wep API middleware/pipeline bels\u0151 m\u0171k\u00f6d\u00e9s\u00e9hez \u00e9s konfigur\u00e1ci\u00f3j\u00e1hoz sz\u00fcks\u00e9ges szolg\u00e1ltat\u00e1s \u00e9s konfigur\u00e1ci\u00f3s objektumot regisztr\u00e1l a kont\u00e9nerbe. .NET Core 3.0-t\u00f3l kezdve a helyzet n\u00e9mik\u00e9pp m\u00e1s. Az AddMvc() h\u00edv\u00e1sa helyett jellemz\u0151en az AddControllers() m\u0171veletet h\u00edvjuk, mely jelent\u0151sen kevesebb kont\u00e9nerregisztr\u00e1ci\u00f3t von mag\u00e1val.","title":"ASP.NET Core keretrendszer szolg\u00e1ltat\u00e1sok"},{"location":"jegyzet/di/#szolgaltatas-objektumok-dispose-olasa","text":"A kont\u00e9ner az \u00e1ltala l\u00e9trehozott objektumokra Dispose -t h\u00edv, amennyiben az objektumok oszt\u00e1lya implement\u00e1lja az IDisposable interf\u00e9szt.","title":"Szolg\u00e1ltat\u00e1s objektumok dispose-ol\u00e1sa"},{"location":"jegyzet/di/#irodalom","text":"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection https://stackify.com/net-core-dependency-injection/amp https://medium.com/volosoft/asp-net-core-dependency-injection-best-practices-tips-tricks-c6e9c67f9d96","title":"Irodalom"},{"location":"jegyzet/linq/","text":"LINQ: Language Integrated Query \u00b6 Adottak a k\u00f6vetkez\u0151 oszt\u00e1lyok, \u00e9s list\u00e1k ilyen objektumokb\u00f3l. class Product { public int ID ; public string Name ; public int Price ; public int VATID ; } class VAT { public int ID ; public int Percentage ; } List < Product > products = ... List < VAT > vat = ... LINQ kifejez\u00e9sek \u00e9s az IQueryable \u00b6 Vegy\u00fcnk egy egyszer\u0171 kifejez\u00e9st: products.Where(p => p.Price < 1000) . Ezen kifejez\u00e9s nem teljes abban az \u00e9rtelemben, hogy a sz\u0171r\u00e9s nem ker\u00fclt v\u00e9grehajt\u00e1sra . A LINQ kifejez\u00e9sek eredm\u00e9nye egy IQueryable<T> generikus interf\u00e9sz, amely nem tartalmazza az eredm\u00e9nyeket, csup\u00e1n egy le\u00edr\u00f3t, hogy mi a kifejez\u00e9s. Ezt k\u00e9s\u0151i ki\u00e9rt\u00e9kel\u00e9snek (deferred execution) h\u00edvjuk, ugyanis a le\u00edrt m\u0171velet csak akkor fog v\u00e9grehajt\u00f3dni, amikor az eredm\u00e9nyekre t\u00e9nylegesen is sz\u00fcks\u00e9g van: amikor elkezd\u00fcnk iter\u00e1lni az eredm\u00e9nyhalmazon (pl. foreach), amikor elk\u00e9rj\u00fck az els\u0151 elemet (l\u00e1sd k\u00e9s\u0151bb, pl. .First() ), amikor list\u00e1t k\u00e9r\u00fcnk az eredm\u00e9nyhalmazb\u00f3l ( .ToList() ). Ez a m\u0171k\u00f6d\u00e9s az\u00e9rt praktikus, mert \u00edgy tudjuk szintaktikailag egym\u00e1s ut\u00e1n f\u0171zni a LINQ m\u0171veleteket, mint p\u00e9ld\u00e1ul: var l = products . Where ( p => p . Price < 1000 ) . Where ( p => p . Name . Contains ( 's' )) . OrderBy ( p => p . Name ) . Select ( p => p . Name ) ... // az l v\u00e1ltoz\u00f3 nem tartalmazza az eredm\u00e9nyhalmazt foreach ( var x in l ) // itt fog lefutni a t\u00e9nyleges ki\u00e9rt\u00e9kel\u00e9s { ... } Ki\u00e9rt\u00e9kel\u00e9s Ha mindenk\u00e9ppen szeretn\u00e9nk k\u00e9rni a lefuttat\u00e1st, akkor tipikusan a .ToList() -et haszn\u00e1ljuk. Ezzel azonban vigy\u00e1zzunk, fontoljuk meg, t\u00e9nyleg erre van-e sz\u00fcks\u00e9g\u00fcnk. LINQ m\u0171veletek \u00b6 Az al\u00e1bbi p\u00e9ld\u00e1kn\u00e1l, ahol el\u00e9rhet\u0151, mindk\u00e9t szintaktik\u00e1t mutatjuk. A k\u00e9t f\u00e9le szintaktika teljesen egyen\u00e9rt\u00e9k\u0171. Sz\u0171r\u00e9s \u00b6 products . Where ( p => p . Price < 1000 ) from p in products where p . Price < 1000 Projekci\u00f3 \u00b6 products . Select ( p => p . Name ) from p in products select p . Name Join \u00b6 from p in products join v in vat on p . VATID equals v . Id select p . Price * v . Percentage products . Join ( vat , p => p . VATID , v => v . Id , ( p , v ) => p . Price * v . Percentage ) Sorrendez\u00e9s \u00b6 products . OrderBy [ Descending ]( p => p . Name ) . ThenBy [ Descending ]( p => p . Price ) from p in products orderby p . Name , p . Price [ descending ] Halmaz m\u0171veletek \u00b6 products . Select ( p => p . Name ). Distinct () products . Where ( p => p . Price < 1000 ) . Union ( products . Where ( p => p . Price > 100000 ) ) // hasonl\u00f3an Except, Intersect Aggreg\u00e1ci\u00f3 \u00b6 products . Count () products . Select ( p => p . Price ). Average () // hasonl\u00f3an Sum, Min, Max Els\u0151, utols\u00f3 \u00b6 products . First () products . Last () products . Where ( p => p . Id == 12 ). FirstOrDefault () products . Where ( p => p . Id == 12 ). SingleOrDefault () Lapoz\u00e1s \u00b6 products . Take ( 10 ) products . Skip ( 10 ). Take ( 10 ) Tartalmaz\u00e1s (l\u00e9tezik-e) \u00b6 products . Any ( p => p . Price == 1234 ) products . Where ( p => p . Price == 1234 ). Any () Csoportos\u00edt\u00e1s \u00b6 from p in products group p by p . VATID products . GroupBy ( p => p . VATID ) Bonyolultabb projekci\u00f3 \u00b6 A projekci\u00f3 sor\u00e1n t\u00f6bb f\u00e9le m\u00f3don k\u00e9rhetj\u00fck az eredm\u00e9nyeket. Eg\u00e9sz objektum \u00b6 from p in products ... select p Ilyenkor az eredm\u00e9ny IQueryable<Product> , azaz Product oszt\u00e1ly p\u00e9ld\u00e1nyokat kapunk. Csak bizonyos mez\u0151 \u00b6 from p in products ... select p . Name Ilyenkor az eredm\u00e9ny IQueryable<string> , azaz csak a neveket kapjuk. Neves\u00edtett t\u00edpusok \u00b6 from p in products ... select new MyType ( p . Name , p . Price ) Ilyenkor az eredm\u00e9ny IQueryable<MyType> , ahol a MyType oszt\u00e1lyt deklar\u00e1lnunk kell, \u00e9s a select-ben a konstruktor\u00e1t h\u00edvjuk meg. N\u00e9vtelen t\u00edpusok \u00b6 from p in products where p . Price > 1000 select new { ID = p . ID , Name = p . Name }; N\u00e9vtelen t\u00edpust a new { } szintaktik\u00e1val hozhatunk l\u00e9tre. Ebb\u0151l a ford\u00edt\u00f3 egy oszt\u00e1ly defin\u00edci\u00f3t k\u00e9sz\u00edt a megadott nev\u0171 property-kkel. Ezt tipikusan akkor \u00e9rdemes haszn\u00e1lni, ha egy-k\u00e9t tulajdons\u00e1got szeretn\u00e9nk csak lek\u00e9rdezni, \u00e9s nincs sz\u00fcks\u00e9g\u00fcnk az eg\u00e9sz objektumra. Egy m\u00e1sik gyakori haszn\u00e1lati esete a n\u00e9vtelen t\u00edpusnak, amikor nem egy rekord p\u00e1r tulajdons\u00e1g\u00e1ra vagyunk k\u00edv\u00e1ncsiak, hanem sz\u00e1m\u00edtott \u00e9rt\u00e9ket k\u00e9rdez\u00fcnk le, pl. a term\u00e9kek neve \u00e9s brutt\u00f3 \u00e1ra: from p in products join v in vat on p . VATID equals v . Id select new { Name = p . Name , FullPrice = p . Price * v . Percentage } Tov\u00e1bbi inform\u00e1ci\u00f3k \u00e9s p\u00e9ld\u00e1k \u00b6 Lambda kifejez\u00e9sek: https://www.tutorialsteacher.com/linq/linq-lambda-expression Linq: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/","title":"LINQ: Language Integrated Query"},{"location":"jegyzet/linq/#linq-language-integrated-query","text":"Adottak a k\u00f6vetkez\u0151 oszt\u00e1lyok, \u00e9s list\u00e1k ilyen objektumokb\u00f3l. class Product { public int ID ; public string Name ; public int Price ; public int VATID ; } class VAT { public int ID ; public int Percentage ; } List < Product > products = ... List < VAT > vat = ...","title":"LINQ: Language Integrated Query"},{"location":"jegyzet/linq/#linq-kifejezesek-es-az-iqueryable","text":"Vegy\u00fcnk egy egyszer\u0171 kifejez\u00e9st: products.Where(p => p.Price < 1000) . Ezen kifejez\u00e9s nem teljes abban az \u00e9rtelemben, hogy a sz\u0171r\u00e9s nem ker\u00fclt v\u00e9grehajt\u00e1sra . A LINQ kifejez\u00e9sek eredm\u00e9nye egy IQueryable<T> generikus interf\u00e9sz, amely nem tartalmazza az eredm\u00e9nyeket, csup\u00e1n egy le\u00edr\u00f3t, hogy mi a kifejez\u00e9s. Ezt k\u00e9s\u0151i ki\u00e9rt\u00e9kel\u00e9snek (deferred execution) h\u00edvjuk, ugyanis a le\u00edrt m\u0171velet csak akkor fog v\u00e9grehajt\u00f3dni, amikor az eredm\u00e9nyekre t\u00e9nylegesen is sz\u00fcks\u00e9g van: amikor elkezd\u00fcnk iter\u00e1lni az eredm\u00e9nyhalmazon (pl. foreach), amikor elk\u00e9rj\u00fck az els\u0151 elemet (l\u00e1sd k\u00e9s\u0151bb, pl. .First() ), amikor list\u00e1t k\u00e9r\u00fcnk az eredm\u00e9nyhalmazb\u00f3l ( .ToList() ). Ez a m\u0171k\u00f6d\u00e9s az\u00e9rt praktikus, mert \u00edgy tudjuk szintaktikailag egym\u00e1s ut\u00e1n f\u0171zni a LINQ m\u0171veleteket, mint p\u00e9ld\u00e1ul: var l = products . Where ( p => p . Price < 1000 ) . Where ( p => p . Name . Contains ( 's' )) . OrderBy ( p => p . Name ) . Select ( p => p . Name ) ... // az l v\u00e1ltoz\u00f3 nem tartalmazza az eredm\u00e9nyhalmazt foreach ( var x in l ) // itt fog lefutni a t\u00e9nyleges ki\u00e9rt\u00e9kel\u00e9s { ... } Ki\u00e9rt\u00e9kel\u00e9s Ha mindenk\u00e9ppen szeretn\u00e9nk k\u00e9rni a lefuttat\u00e1st, akkor tipikusan a .ToList() -et haszn\u00e1ljuk. Ezzel azonban vigy\u00e1zzunk, fontoljuk meg, t\u00e9nyleg erre van-e sz\u00fcks\u00e9g\u00fcnk.","title":"LINQ kifejez\u00e9sek \u00e9s az IQueryable"},{"location":"jegyzet/linq/#linq-muveletek","text":"Az al\u00e1bbi p\u00e9ld\u00e1kn\u00e1l, ahol el\u00e9rhet\u0151, mindk\u00e9t szintaktik\u00e1t mutatjuk. A k\u00e9t f\u00e9le szintaktika teljesen egyen\u00e9rt\u00e9k\u0171.","title":"LINQ m\u0171veletek"},{"location":"jegyzet/linq/#szures","text":"products . Where ( p => p . Price < 1000 ) from p in products where p . Price < 1000","title":"Sz\u0171r\u00e9s"},{"location":"jegyzet/linq/#projekcio","text":"products . Select ( p => p . Name ) from p in products select p . Name","title":"Projekci\u00f3"},{"location":"jegyzet/linq/#join","text":"from p in products join v in vat on p . VATID equals v . Id select p . Price * v . Percentage products . Join ( vat , p => p . VATID , v => v . Id , ( p , v ) => p . Price * v . Percentage )","title":"Join"},{"location":"jegyzet/linq/#sorrendezes","text":"products . OrderBy [ Descending ]( p => p . Name ) . ThenBy [ Descending ]( p => p . Price ) from p in products orderby p . Name , p . Price [ descending ]","title":"Sorrendez\u00e9s"},{"location":"jegyzet/linq/#halmaz-muveletek","text":"products . Select ( p => p . Name ). Distinct () products . Where ( p => p . Price < 1000 ) . Union ( products . Where ( p => p . Price > 100000 ) ) // hasonl\u00f3an Except, Intersect","title":"Halmaz m\u0171veletek"},{"location":"jegyzet/linq/#aggregacio","text":"products . Count () products . Select ( p => p . Price ). Average () // hasonl\u00f3an Sum, Min, Max","title":"Aggreg\u00e1ci\u00f3"},{"location":"jegyzet/linq/#elso-utolso","text":"products . First () products . Last () products . Where ( p => p . Id == 12 ). FirstOrDefault () products . Where ( p => p . Id == 12 ). SingleOrDefault ()","title":"Els\u0151, utols\u00f3"},{"location":"jegyzet/linq/#lapozas","text":"products . Take ( 10 ) products . Skip ( 10 ). Take ( 10 )","title":"Lapoz\u00e1s"},{"location":"jegyzet/linq/#tartalmazas-letezik-e","text":"products . Any ( p => p . Price == 1234 ) products . Where ( p => p . Price == 1234 ). Any ()","title":"Tartalmaz\u00e1s (l\u00e9tezik-e)"},{"location":"jegyzet/linq/#csoportositas","text":"from p in products group p by p . VATID products . GroupBy ( p => p . VATID )","title":"Csoportos\u00edt\u00e1s"},{"location":"jegyzet/linq/#bonyolultabb-projekcio","text":"A projekci\u00f3 sor\u00e1n t\u00f6bb f\u00e9le m\u00f3don k\u00e9rhetj\u00fck az eredm\u00e9nyeket.","title":"Bonyolultabb projekci\u00f3"},{"location":"jegyzet/linq/#egesz-objektum","text":"from p in products ... select p Ilyenkor az eredm\u00e9ny IQueryable<Product> , azaz Product oszt\u00e1ly p\u00e9ld\u00e1nyokat kapunk.","title":"Eg\u00e9sz objektum"},{"location":"jegyzet/linq/#csak-bizonyos-mezo","text":"from p in products ... select p . Name Ilyenkor az eredm\u00e9ny IQueryable<string> , azaz csak a neveket kapjuk.","title":"Csak bizonyos mez\u0151"},{"location":"jegyzet/linq/#nevesitett-tipusok","text":"from p in products ... select new MyType ( p . Name , p . Price ) Ilyenkor az eredm\u00e9ny IQueryable<MyType> , ahol a MyType oszt\u00e1lyt deklar\u00e1lnunk kell, \u00e9s a select-ben a konstruktor\u00e1t h\u00edvjuk meg.","title":"Neves\u00edtett t\u00edpusok"},{"location":"jegyzet/linq/#nevtelen-tipusok","text":"from p in products where p . Price > 1000 select new { ID = p . ID , Name = p . Name }; N\u00e9vtelen t\u00edpust a new { } szintaktik\u00e1val hozhatunk l\u00e9tre. Ebb\u0151l a ford\u00edt\u00f3 egy oszt\u00e1ly defin\u00edci\u00f3t k\u00e9sz\u00edt a megadott nev\u0171 property-kkel. Ezt tipikusan akkor \u00e9rdemes haszn\u00e1lni, ha egy-k\u00e9t tulajdons\u00e1got szeretn\u00e9nk csak lek\u00e9rdezni, \u00e9s nincs sz\u00fcks\u00e9g\u00fcnk az eg\u00e9sz objektumra. Egy m\u00e1sik gyakori haszn\u00e1lati esete a n\u00e9vtelen t\u00edpusnak, amikor nem egy rekord p\u00e1r tulajdons\u00e1g\u00e1ra vagyunk k\u00edv\u00e1ncsiak, hanem sz\u00e1m\u00edtott \u00e9rt\u00e9ket k\u00e9rdez\u00fcnk le, pl. a term\u00e9kek neve \u00e9s brutt\u00f3 \u00e1ra: from p in products join v in vat on p . VATID equals v . Id select new { Name = p . Name , FullPrice = p . Price * v . Percentage }","title":"N\u00e9vtelen t\u00edpusok"},{"location":"jegyzet/linq/#tovabbi-informaciok-es-peldak","text":"Lambda kifejez\u00e9sek: https://www.tutorialsteacher.com/linq/linq-lambda-expression Linq: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/","title":"Tov\u00e1bbi inform\u00e1ci\u00f3k \u00e9s p\u00e9ld\u00e1k"},{"location":"jegyzet/mongodb/","text":"MongoDB alapok, m\u0171veletek, \u00e9s a MongoDB .NET Driver \u00b6 NoSQL adatb\u00e1zisok \u00b6 A NoSQL adatb\u00e1zisok a rel\u00e1ci\u00f3s s\u00e9m\u00e1t\u00f3l elt\u00e9r\u0151en m\u0171k\u00f6d\u0151 adatb\u00e1zisok \u00f6sszefoglal\u00f3 neve. A n\u00e9v valamennyire megt\u00e9veszt\u0151, mert a fogalomnak kev\u00e9s k\u00f6ze van az SQL nyelvhez - ehelyett a relev\u00e1ns k\u00fcl\u00f6nbs\u00e9g az adatreprezent\u00e1ci\u00f3ban \u00e9s a s\u00e9m\u00e1ban van. De m\u00e9gis mi\u00e9rt van sz\u00fcks\u00e9g\u00fcnk \u00faj fajta adatb\u00e1zisokra, amikor a rel\u00e1ci\u00f3s adatb\u00e1zisok r\u00e9g\u00f3ta j\u00f3l haszn\u00e1lhat\u00f3ak? Egy kis m\u00e9ret\u0171 adatb\u00e1zis egyszer\u0171 s\u00e9m\u00e1val k\u00f6nnyen le\u00edrhat\u00f3 rel\u00e1ci\u00f3s modellben, m\u00e9g k\u00e9nyelmes is. De az alkalmaz\u00e1saink fejl\u0151dnek, egyre t\u00f6bb funkci\u00f3t kell ell\u00e1tniuk, ezzel egy\u00fctt komplexebb\u00e9 v\u00e1lik a s\u00e9ma is, illetve egyre t\u00f6bb adatot kell elt\u00e1rolni \u00e9s n\u0151 az adatb\u00e1zis. Ez egy bizonyos hat\u00e1r felett komplik\u00e1lt\u00e1 v\u00e1lik. A rel\u00e1ci\u00f3s adatb\u00e1zisok h\u00e1tr\u00e1nya, hogy a folyamatos v\u00e1ltoz\u00e1sok, s\u00e9ma v\u00e1ltoztat\u00e1st ig\u00e9nyelnek. Ahhoz, hogy ezt karban tudjuk tartani folyamatosan migr\u00e1lni kell az adatokat \u00e9s ez nem egyszer\u0171 feladat. Tov\u00e1bb\u00e1 teljes\u00edtm\u00e9ny probl\u00e9m\u00e1kkal, azaz ink\u00e1bb konzisztencia- \u00e9s sk\u00e1l\u00e1z\u00e1si probl\u00e9m\u00e1kkal j\u00e1rhat, ha rel\u00e1ci\u00f3s adatb\u00e1zist haszn\u00e1lunk - ezzel azonban nem foglalkozunk m\u00e9lyebben. Ezekre a probl\u00e9m\u00e1kra a NoSQL adatb\u00e1zisok ny\u00fajtanak megold\u00e1st. Ebben a vil\u00e1gban elhagyjuk a szigor\u00fa s\u00e9m\u00e1kat, helyette egy flexibilis s\u00e9m\u00e1t fogunk alkalmazni . Azaz nem lesznek er\u0151s elv\u00e1r\u00e1saink az adatb\u00e1zisban t\u00e1rolt adatokkal szemben. A MongoDB alap koncepci\u00f3i \u00b6 A MongoDB egy kliens-szerver architekt\u00far\u00e1j\u00fa nem-rel\u00e1ci\u00f3s adatb\u00e1zis. A k\u00e9p jobb oldal\u00e1n l\u00e1that\u00f3 a mongod , azaz Mongo d\u00e9mon, vagyis az a processz, ami az adatb\u00e1zis el\u00e9r\u00e9s\u00e9t biztos\u00edtja. A m\u00e1sik oldal a mi alkalmaz\u00e1sunk, ahonnan a kliens kapcsol\u00f3dik a szerverhez egy h\u00e1l\u00f3zati kapcsolaton kereszt\u00fcl. Ez a h\u00e1l\u00f3zati kapcsolat az un. wire protocol -on kereszt\u00fcl t\u00f6rt\u00e9nik, ez a MongoDB saj\u00e1t protokollja. Ebben a protokollban JSON form\u00e1j\u00fa adat kommunik\u00e1ci\u00f3 zajlik bin\u00e1risan (azaz BSON). Logikai fel\u00e9p\u00edt\u00e9s \u00b6 Egy MongoDB-alap\u00fa adatb\u00e1zis rendszer legfels\u0151 r\u00e9tege az un. klaszter , ebbe szervezz\u00fck a szervereket. Mi klaszterekkel ebben a t\u00e1rgyban nem foglalkozunk, azok a sk\u00e1l\u00e1z\u00e1s eszk\u00f6zei. A m\u00e1sodik szint a szerver szintje (a mongod processz), ami alatt az adatb\u00e1zis foglal helyet. Egy szerver/klaszter t\u00f6bb adatb\u00e1zist t\u00e1rolhat. Az adatb\u00e1zisok pedig gy\u0171jtem\u00e9nyekb\u0151l ( collection ) \u00e9p\u00fclnek fel. Ha a rel\u00e1ci\u00f3s adatb\u00e1zisokkal meg akarjuk feleltetni, akkor a gy\u0171jtem\u00e9nyek a t\u00e1bl\u00e1k megfelel\u0151i, ezen bel\u00fcl a sorok/rekordok pedig a gy\u0171jtem\u00e9nyben t\u00e1rolt dokumentumok lesznek. N\u00e9zz\u00fck ezeket pontosabban. Dokumentum \u00b6 A dokumentum a MongoDB alap t\u00e1rol\u00e1si egys\u00e9ge. Egy dokumentum egy JSON (jelleg\u0171) f\u00e1jl, teh\u00e1t kulcs-\u00e9rt\u00e9k p\u00e1rokat tartalmaz. Maga a MongoDB BSON-k\u00e9nt, bin\u00e1ris reprezent\u00e1ci\u00f3k\u00e9nt t\u00e1rolja mindezt. { name : \"sue\" , age : 26 , status : \"A\" , groups : [ \"news\" , \"sports\" ] } Kulcsoknak t\u00f6bbnyire b\u00e1rmilyen szabad sz\u00f6veget v\u00e1laszthatunk, de a neveknek egyedinek kell lenni\u00fck \u00e9s nem kezd\u0151dhetnek a $ karakterrel. A nevek case sensitive-ek. Az \u00e9rt\u00e9k lehet sz\u00f6veg, sz\u00e1m, d\u00e1tum, bin\u00e1ris, be\u00e1gyazott elem, null , vagy ak\u00e1r a fenti p\u00e9ld\u00e1ban a groups kulcsn\u00e1l l\u00e1that\u00f3an t\u00f6mb is - rel\u00e1ci\u00f3s adatb\u00e1zisban ezt \u00edgy nem lehet reprezent\u00e1lni. Az objektum orient\u00e1lt vil\u00e1gban egy dokumentum felel meg egy objektumnak. Fontos megk\u00f6t\u00e9s, hogy a dokumentumok maxim\u00e1lis m\u00e9rete 16MB lehet, \u00e9s ez nem konfigur\u00e1lhat\u00f3 \u00e9rt\u00e9k. Gy\u0171jtem\u00e9ny \u00b6 Rel\u00e1ci\u00f3s t\u00e1bla anal\u00f3gi\u00e1ja a gy\u0171jtem\u00e9ny, de nincs s\u00e9m\u00e1ja, \u00edgy ezeket l\u00e9trehozni, defini\u00e1lni se kell, els\u0151 haszn\u00e1latkor a rendszer automatikusan l\u00e9trehozza \u0151ket. \u00dagy fogalmazhatjuk meg, hogy a gy\u0171jtem\u00e9ny a \"hasonl\u00f3\" dokumentumok gy\u0171jt\u0151helye. B\u00e1r nincs s\u00e9ma, indexeket ennek ellen\u00e9re defini\u00e1lhatunk a gy\u0171jtem\u00e9nyeken, amely a gyors keres\u00e9st fogj\u00e1k seg\u00edteni. S\u00e9ma hi\u00e1ny\u00e1ban nincs tartom\u00e1nyi integrit\u00e1si krit\u00e9rium, teh\u00e1t p\u00e9ld\u00e1ul a helyes adatt\u00edpusok \u00e9s tartom\u00e1nyi krit\u00e9riumok biztos\u00edt\u00e1s\u00e1ban az adatb\u00e1zis nem ny\u00fajt seg\u00edts\u00e9get. Adatb\u00e1zis \u00b6 Az adatb\u00e1zis ugyanazt a c\u00e9lt szolg\u00e1lja, mint rel\u00e1ci\u00f3s adatb\u00e1zisban. Ez fogja \u00f6ssze az alkalmaz\u00e1s adatait logikailag. Illetve hozz\u00e1f\u00e9r\u00e9si jogosults\u00e1gokat adatb\u00e1zis szinten tudunk adni. Az adatb\u00e1zisok neve case sensitive \u00e9s konvenci\u00f3 szerint tipikusan csupa kisbet\u0171. Kulcs \u00b6 Minden dokumentum egy\u00e9rtelm\u0171 azonos\u00edt\u00f3ja az _id mez\u0151, m\u00e1st kulcsot nem tudunk defini\u00e1lni. Ezt a mez\u0151t besz\u00far\u00e1skor nem sz\u00fcks\u00e9ges explicit megadni (de lehet), tipikusan a kliens driver vagy a szerver gener\u00e1lja (alap\u00e9rtelmez\u00e9sben egy 12 b\u00e1jtos ObjectId -t k\u00e9sz\u00edt). Az _id mez\u0151t\u0151l f\u00fcggetlen\u00fcl egyedis\u00e9get indexek seg\u00edts\u00e9g\u00e9vel tudunk garant\u00e1lni. Amennyiben sz\u00fcks\u00e9ges, defini\u00e1lhatunk teh\u00e1t m\u00e1s, kulcs-szer\u0171 mez\u0151ket is. Az \u00edgy defini\u00e1lt egyedi mez\u0151k lehetnek \u00f6sszetettek is (teh\u00e1t lehet t\u00f6bb mez\u0151 egy\u00fcttes egyedis\u00e9g\u00e9t el\u0151\u00edrni). K\u00fcls\u0151 kulcs hivatkoz\u00e1sok MongoDB-ben nincsenek. Tudunk hivatkozni m\u00e1s dokumentumokra azok kulcsainak bem\u00e1sol\u00e1s\u00e1val, azonban ezekre a rendszer nem v\u00e1llal garanci\u00e1t (pl. a hivatkozott dokumentum t\u00f6r\u00f6lhet\u0151). MongoDB m\u0171veletek \u00e9s a MongoDB .NET Driver \u00b6 Az al\u00e1bbi, illusztr\u00e1ci\u00f3ra haszn\u00e1lt k\u00f3dr\u00e9szletek a hivatalos MongoDB.Driver Nuget csomagot haszn\u00e1lj\u00e1k. Kapcsolat l\u00e9tes\u00edt\u00e9se \u00b6 A MongoDB adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez els\u0151 l\u00e9p\u00e9sben sz\u00fcks\u00e9g\u00fcnk van egy kapcsolatra. A kapcsolatot egy MongoClient oszt\u00e1ly reprezent\u00e1lja. A kapcsolathoz sz\u00fcks\u00e9g\u00fcnk van a szerver el\u00e9rhet\u0151s\u00e9g\u00e9re (a connection stringr\u0151l r\u00e9szletesebben l\u00e1sd: https://docs.mongodb.com/manual/reference/connection-string/ ). var client = new MongoClient ( \"mongodb://localhost:27017\" ); A kapcsolatot singleton-k\u00e9nt \u00e9rdemes kezelni, nem kell Dispose-olni. Kapcsolat \u00e9letciklusa A kapcsolatot tipikusan egy glob\u00e1lis statikus v\u00e1ltoz\u00f3ban t\u00e1roljuk, avagy a k\u00f6rnyezet \u00e1ltal t\u00e1mogatott IoC (Inversion of Control) / DI (Dependency Injection) t\u00e1rol\u00f3ban helyezz\u00fck el. Az adatb\u00e1zis neve szerepelhet ugyan a connection stringben (pl. mongodb://localhost:27017/adatvez ), azt csak az authentik\u00e1ci\u00f3hoz haszn\u00e1lja a rendszer. \u00cdgy a kapcsolat fel\u00e9p\u00edt\u00e9se ut\u00e1n meg kell adnunk, milyen adatb\u00e1zist fogunk haszn\u00e1lni. var db = client . GetDatabase ( \"adatvez\" ); Az adatb\u00e1zisnak nem kell el\u0151zetesen l\u00e9tezni. A fenti h\u00edv\u00e1s hat\u00e1s\u00e1ra, ha m\u00e9g nem l\u00e9tezik az adatb\u00e1zis, automatikusan l\u00e9trej\u00f6n. Gy\u0171jtem\u00e9nyek kezel\u00e9se \u00b6 Egy rel\u00e1ci\u00f3s adatb\u00e1zist\u00f3l elt\u00e9r\u0151en MongoDB-ben a m\u0171veleteinket mindig egyetlen gy\u0171jtem\u00e9nyen v\u00e9gezz\u00fck , \u00edgy a gy\u0171jtem\u00e9ny kiv\u00e1laszt\u00e1sa nem a kiadott parancs r\u00e9sze (mint az SQL nyelvben a where ), hanem a m\u0171velet el\u0151felt\u00e9tele. Egy adott gy\u0171jtem\u00e9nyt a GetCollection h\u00edv\u00e1ssal kaphatunk meg, generikus param\u00e9tere a dokumentum t\u00edpust megval\u00f3s\u00edt\u00f3 C# oszt\u00e1ly. var collection = db . GetCollection < BsonDocument >( \"products\" ); A .NET MongoDB driver alap koncepci\u00f3ja szerint minden dokumentumot lek\u00e9pez egy .NET objektumra. Ezzel automatikusan megval\u00f3s\u00edtja az un. ODM (Object Document Mapping) funkci\u00f3t. Az ODM az ORM megfelel\u0151je a NoSQL adatb\u00e1zisok vil\u00e1g\u00e1ban. \"Nyers\" json M\u00e1s nyelveken \u00e9s platformokon a MongoDB driverek nem mindig v\u00e9gzik el a lek\u00e9pez\u00e9st objektumokra, \u00edgy az interneten tal\u00e1lhat\u00f3 p\u00e9ld\u00e1kban gyakran \"nyers\" JSON dokumentumokon kereszt\u00fcli kommunik\u00e1ci\u00f3t mutatnak. Igyekezz\u00fcnk ezt elker\u00fclni, ahogy az ORM t\u00e9mak\u00f6r\u00e9ben megtanultuk, k\u00e9nyelmesebb \u00e9s biztons\u00e1gosabb az objektumorient\u00e1lt lek\u00e9pz\u00e9s. Az el\u0151z\u0151 p\u00e9ld\u00e1ban BsonDocument t\u00edpus\u00fa dokumentumot haszn\u00e1lunk. A BsonDocument egy \u00e1ltal\u00e1nos dokumentum reprezent\u00e1ci\u00f3, amiben kulcs-\u00e9rt\u00e9k p\u00e1rokat t\u00e1rolhatunk. Haszn\u00e1lata k\u00e9nyelmetlen \u00e9s nem t\u00edpusbiztos, ez\u00e9rt \u00e1ltal\u00e1ban nem ezt a megold\u00e1st haszn\u00e1ljuk. A javasolt megold\u00e1st l\u00e1sd hamarosan. A gy\u0171jtem\u00e9nyt reprezent\u00e1l\u00f3 v\u00e1ltoz\u00f3n tudunk tov\u00e1bbi m\u0171veleteket futtatni, p\u00e9ld\u00e1ul besz\u00farunk egy dokumentumot, majd list\u00e1zzuk a gy\u0171jtem\u00e9ny tartalm\u00e1t. A gy\u0171jtem\u00e9ny els\u0151 haszn\u00e1latkor automatikusan l\u00e9tre fog j\u00f6nni, azaz semmilyen m\u00f3don nem sz\u00fcks\u00e9ges defini\u00e1lnunk. collection . InsertOne ( new BsonDocument () { { \"name\" , \"Apple\" }, { \"categoryName\" , \"Apple\" }, { \"price\" , 123 } }); // minden dokumentum list\u00e1z\u00e1sa: sz\u00fcks\u00e9g van egy sz\u0171r\u00e9si felt\u00e9telre, ami itt // egy \u00fcres felt\u00e9tel, azaz minden dokumentumra illeszkedik var list = collection . Find ( new BsonDocument ()). ToList (); foreach ( var l in list ) Console . WriteLine ( l ); Elnevez\u00e9si konvenci\u00f3 A dokumentumban a kulcs nevek konvenci\u00f3 szerint kisbet\u0171vel kezd\u0151dnek, mint price vagy categoryName (ez az un. camel case \u00edr\u00e1sm\u00f3d). Ez a szok\u00e1s a MongoDB vil\u00e1g\u00e1nak megfelel\u0151 szeml\u00e9let historikus okokb\u00f3l. Hacsak nincs j\u00f3 okunk r\u00e1, ne t\u00e9rj\u00fcnk el ett\u0151l. Dokumentumok lek\u00e9pz\u00e9se C# objektumokra \u00b6 Ahogy a rel\u00e1ci\u00f3s adatb\u00e1zisokn\u00e1l l\u00e1thattuk az objektum-rel\u00e1ci\u00f3s lek\u00e9pz\u00e9st, MongoDB eset\u00e9n is c\u00e9lszer\u0171 objektumokkal \u00e9s oszt\u00e1lyokkal dolgoznunk. A MongoDB .NET drivere ezt teljes m\u00e9rt\u00e9kben biztos\u00edtja sz\u00e1munkra. Els\u0151 l\u00e9p\u00e9sk\u00e9nt defini\u00e1lnunk kell a C# oszt\u00e1lyt, ill. oszt\u00e1lyokat, amikre az adatb\u00e1zis tartalm\u00e1t lek\u00e9pezz\u00fck. Mivel itt nincs az adatb\u00e1zisnak \u00e9s t\u00e1bl\u00e1nak s\u00e9m\u00e1ja, nem tudjuk a s\u00e9ma alapj\u00e1n ger\u00e1lni a C# k\u00f3dot (mint Entity Framework eset\u00e9n csin\u00e1ltuk). \u00cdgy ebben a vil\u00e1gban ink\u00e1bb a Code First elvet k\u00f6vetj\u00fck, azaz a C# k\u00f3dot k\u00e9sz\u00edtj\u00fck el, \u00e9s abb\u00f3l k\u00e9sz\u00fcl az adatb\u00e1zis \u00e9s gy\u0171jtem\u00e9ny (hab\u00e1r tudjuk, hogy itt nincs sz\u00f3 az oszt\u00e1ly alapj\u00e1n t\u00e1bl\u00e1k l\u00e9trehoz\u00e1s\u00e1r\u00f3l). Defini\u00e1ljuk a Term\u00e9kek reprezent\u00e1l\u00e1shoz az al\u00e1bbi oszt\u00e1lyokat. public class Product { public ObjectId Id { get ; set ; } // ez lesz az els\u0151dleges kulcs helyett az _id azonos\u00edt\u00f3 public string Name { get ; set ; } public float Price { get ; set ; } public int Stock { get ; set ; } public string [] Categories { get ; set ; } // t\u00f6mb \u00e9rt\u00e9k\u0171 mez\u0151 public VAT VAT { get ; set ; } // be\u00e1gyaz\u00e1st alkalmazunk } public class VAT // mivel ez be\u00e1gyazott entit\u00e1s, \u00edgy nem adunk neki egyedi azonos\u00edt\u00f3t { public string VATCategoryName { get ; set ; } public float Percentage { get ; set ; } } Figyelj\u00fck meg, hogy kor\u00e1bban price n\u00e9ven haszn\u00e1ltuk a dokumentumban a kulcsot, de a C# oszt\u00e1lyban az un. Pascal Case szerint nagybet\u0171vel kezdj\u00fck: Price . A MongoDB .NET drivere be\u00e9p\u00fcl a C# nyelvbe \u00e9s a .NET k\u00f6rnyezetbe, \u00e9s annak szok\u00e1sait tiszteletben tartja, \u00edgy az oszt\u00e1ly defin\u00edci\u00f3ban szerepl\u0151 mez\u0151 nevek \u00e9s a MongoDB dokumentumaiban a kulcsok lek\u00e9pz\u00e9se automatikusan meg fog t\u00f6rt\u00e9nni, a Price oszt\u00e1ly tulajdons\u00e1gb\u00f3l price kulcs n\u00e9v lesz a dokumentumban. A lek\u00e9pz\u00e9s testreszab\u00e1sa \u00b6 A C# oszt\u00e1ly - MongoDB dokumentum lek\u00e9pz\u00e9s automatikus, de testreszabhat\u00f3. Amennyiben el szeretn\u00e9nk t\u00e9rni az alap konvenci\u00f3kt\u00f3l, t\u00f6bb f\u00e9le m\u00f3don is megtehetj\u00fck. A legegyszer\u0171bb, ha az oszt\u00e1ly defin\u00edci\u00f3j\u00e1ban attrib\u00fatumokkal jel\u00f6lj\u00fck a testreszab\u00e1st: public class Product { // _id mez\u0151re k\u00e9pz\u0151dik le [BsonId] public ObjectId Azonosito { get ; set ; } // megadhatjuk a MongoDB dokumentumban haszn\u00e1latos nevet [BsonElement(\"price\")] public string Ar { get ; set ; } // kihagyhatunk egyes mez\u0151ket [BsonIgnore] public string NemMentett { get ; set ; } } M\u00e1sik lehet\u0151s\u00e9g\u00fcnk magasabb szinten un. konvenci\u00f3-csomagokat beregisztr\u00e1lni. A konvenci\u00f3-csomagok \u00e1ltal\u00e1nosan le\u00edrj\u00e1k, hogyan t\u00f6rt\u00e9njen a lek\u00e9pez\u00e9s. (Az alap viselked\u00e9s is egy konvenci\u00f3-csomag alapj\u00e1n defini\u00e1lt.) P\u00e9ld\u00e1ul az al\u00e1bbiakkal megadhatjuk, hogy camel case-re szeretn\u00e9nk a mez\u0151 neveket lek\u00e9pezni, valamint a default \u00e9rt\u00e9kkel rendelkez\u0151 adattagokat (C# nyelv szerint defini\u00e1lt default \u00e9rt\u00e9k) szeretn\u00e9nk kihagyni a dokumentumb\u00f3l. // konvenci\u00f3k defini\u00e1l\u00e1sa var pack = new ConventionPack (); pack . Add ( new CamelCaseElementNameConvention ()); pack . Add ( new IgnoreIfDefaultConvention ( true )); // konvenci\u00f3k beregisztr\u00e1l\u00e1sa // az els\u0151 param\u00e9ter egy n\u00e9v // az utols\u00f3 param\u00e9terrel sz\u0171r\u00e9si felt\u00e9telt adhatunk meg, hol haszn\u00e1land\u00f3ak a konvenci\u00f3k ConventionRegistry . Register ( \"adatvez\" , pack , t => true ); Enn\u00e9l bonyolultabb testreszab\u00e1sokra is lehet\u0151s\u00e9g\u00fcnk van, p\u00e9ld\u00e1ul defini\u00e1lhatunk konverzi\u00f3s logik\u00e1t a C# reprezent\u00e1ci\u00f3 \u00e9s a MongoDB reprezent\u00e1ci\u00f3 k\u00f6z\u00f6tti ford\u00edt\u00e1shoz, illetve megadhatjuk a lesz\u00e1rmaz\u00e1si hierarchia ment\u00e9s\u00e9nek m\u00f3dj\u00e1t. Ezekr\u0151l r\u00e9szletesebben a hivatalos dokument\u00e1ci\u00f3ban: https://mongodb.github.io/mongo-csharp-driver/2.8/reference/bson/serialization/ . Lek\u00e9rdez\u00e9sek \u00b6 A tov\u00e1bbiakban a t\u00edpusos, Product oszt\u00e1lyra lek\u00e9pz\u0151 m\u00f3don haszn\u00e1ljuk a gy\u0171jtem\u00e9nyt, \u00e9s \u00edgy v\u00e9gz\u00fcnk m\u0171veletet. Ez a javasolt megold\u00e1s, a BsonDocument alap\u00fa megold\u00e1st csak sz\u00fcks\u00e9g eset\u00e9n haszn\u00e1ljuk. A legegyszer\u0171bb lek\u00e9rdez\u00e9st m\u00e1r l\u00e1thattuk, list\u00e1zzunk minden dokumentumot: var collection = db . GetCollection < Product >( \"products\" ); var lista = collection . Find ( new BsonDocument ()). ToList (); foreach ( var p in lista ) Console . WriteLine ( $ \"Id: {p.Id}, Name: {p.Name}\" ); A list\u00e1z\u00e1s a Find met\u00f3dussal t\u00f6rt\u00e9nik. Az elnevez\u00e9s j\u00f3l mutatja a MongoDB filoz\u00f3fi\u00e1j\u00e1t: az adatb\u00e1zis keres\u00e9sre val\u00f3, minden elem list\u00e1z\u00e1sa nem praktikus, ez\u00e9rt nincs is r\u00e1 egyszer\u0171 szintaktika. A Find egy keres\u00e9si felt\u00e9telt v\u00e1r, ami itt egy \u00fcres felt\u00e9tel, azaz mindenre illeszkedik. A keres\u00e9si felt\u00e9telt t\u00f6bb f\u00e9le m\u00f3don le\u00edrhatjuk. A BsonDocument alap\u00fa sz\u0171r\u00e9sben nyersen, a MongoDB szintaktik\u00e1ja szerint kell meg\u00edrni a sz\u0171r\u00e9si felt\u00e9telt. Erre lehet\u0151s\u00e9g\u00fcnk van ugyan, de elker\u00fclj\u00fck, mert a MongoDB .NET drivere ezt megoldja sz\u00e1munkra, ha az al\u00e1bbiak szerint adjuk meg a keres\u00e9si felt\u00e9telt. A legt\u00f6bb esetben egy Lambda-kifejez\u00e9ssel le\u00edrhatjuk a felt\u00e9telt. collection . Find ( x => x . Price < 123 ); Ilyenkor a Lambda-kifejez\u00e9s egy Predicate<T> t\u00edpus\u00fa delegate, azaz a megadott oszt\u00e1lyt\u00edpuson (itt: Product ) fogalmazzuk meg, \u00e9s bool visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171. Teh\u00e1t a fenti p\u00e9ld\u00e1ban az x v\u00e1ltoz\u00f3 egy Product objektumot reprezent\u00e1l. Ez a keres\u00e9s m\u0171k\u00f6dik term\u00e9szetesen bonyolultabb esetekre is. collection . Find ( x => x . Price < 123 && x . Name . Contains ( \"red\" )); A Lambda kifejez\u00e9sekkel le\u00edrt sz\u0171r\u00e9si felt\u00e9telek elrejtik, hogy a MongoDB-ben val\u00f3j\u00e1ban milyen keres\u00e9si felt\u00e9teleink is vannak. P\u00e9ld\u00e1ul az el\u0151bbi Contains keres\u00e9si felt\u00e9tel egy regul\u00e1ris kifejez\u00e9ssel val\u00f3 keres\u00e9st fog val\u00f3j\u00e1ban jelenteni. A MongoDB saj\u00e1t nyelv\u00e9n az el\u0151bbi sz\u0171r\u00e9s \u00edgy n\u00e9z ki: { \"price\" : { \"$lt\" : 123.0 }, \"name\" : \"/red/s\" } Vegy\u00fck \u00e9szre, hogy ez a fajta le\u00edr\u00e1s \u00f6nmaga is egy dokumentum. Ha saj\u00e1t magunk akarn\u00e1nk meg\u00edrni a sz\u0171r\u00e9si felt\u00e9telt, akkor egy BsonDocument -ben kellene ezt a dokumentumot \u00f6ssze\u00e1ll\u00edtanunk. A sz\u0171r\u00e9si felt\u00e9telt le\u00edr\u00f3 dokumentum kulcsai a sz\u0171r\u00e9shez haszn\u00e1lt mez\u0151k, az \u00e9rt\u00e9k pedig a sz\u0171r\u00e9si felt\u00e9tel. A felt\u00e9tel bizonyos esetekben egy skal\u00e1r \u00e9rt\u00e9k, mint a regul\u00e1ris kifejez\u00e9s (vagy ha egyenl\u0151s\u00e9gre sz\u0171rn\u00e9nk), m\u00e1s esetekben a felt\u00e9tel egy be\u00e1gyazott dokumentum, mint a < felt\u00e9tel eset\u00e9n. Ebben az $lt kulcs egy speci\u00e1lis kulcs, azt jel\u00f6li, hogy a less than oper\u00e1torral kell a ki\u00e9rt\u00e9kel\u00e9s v\u00e9gezni, \u00e9s az oper\u00e1tor jobb oldal\u00e1n a 123.0 \u00e9rt\u00e9k \u00e1ll. A regul\u00e1ris kifejez\u00e9st a JavaScript RegExp szintaktika szerint kell megadni. Az ilyen m\u00f3don felsorolt felt\u00e9telek automatikusan \u00e9s kapcsolatba ker\u00fclnek. A Lambda-kifejez\u00e9s helyett egy hasonl\u00f3 le\u00edr\u00e1st magunk is el\u0151\u00e1ll\u00edthatunk an\u00e9lk\u00fcl, hogy sz\u00f6veges form\u00e1ban kellene \u00f6ssze\u00e1ll\u00edtanunk a sz\u0171r\u00e9si felt\u00e9telt. A MongoDB .NET drivere lehet\u0151s\u00e9get ad nek\u00fcnk arra, hogy egy un. builder seg\u00edts\u00e9g\u00e9vel \u00e9p\u00edts\u00fck fel a sz\u0171r\u00e9si felt\u00e9telt. collection . Find ( Builders < Product >. Filter . And ( Builders < Product >. Filter . Lt ( x => x . Price , 123 ), Builders < Product >. Filter . Regex ( x => x . Name , \"/red/s\" ), ) ); A fenti szintaktikai kicsit b\u0151besz\u00e9d\u0171bb ugyan, mint a Lambda-kifejez\u00e9s, de k\u00f6zelebb \u00e1ll a MongoDB vil\u00e1g\u00e1hoz, \u00e9s jobban le\u00edrja, mit is szeretn\u00e9nk val\u00f3j\u00e1ban. Tekinthet\u00fcnk erre a szintaktik\u00e1ra \u00fagy, mint az SQL nyelvre: deklarat\u00edv, c\u00e9lorient\u00e1lt, de a platform k\u00e9pess\u00e9geit szem el\u0151tt tart\u00f3 le\u00edr\u00e1s. Emellett azonban t\u00edpusbiztos is. A Builders<T> generikus oszt\u00e1ly egy seg\u00e9doszt\u00e1ly, amivel sz\u0171r\u00e9si, \u00e9s k\u00e9s\u0151bb l\u00e1tni fogjuk, egy\u00e9b MongoDB specifikus defin\u00edci\u00f3kat \u00e9p\u00edthet\u00fcnk fel. A Builders<Product>.Filter a Product C# oszt\u00e1lyhoz illeszked\u0151 sz\u0171r\u00e9si felt\u00e9telek defini\u00e1l\u00e1s\u00e1ra haszn\u00e1lhat\u00f3. El\u0151sz\u00f6r egy \u00e9s kapcsolatot hozunk l\u00e9tre, amelyen bel\u00fcl k\u00e9t sz\u0171r\u00e9si felt\u00e9tel\u00fcnk lesz. Az oper\u00e1torok a kor\u00e1bban l\u00e1tott less than \u00e9s a regul\u00e1ris kifejez\u00e9s. Ezen f\u00fcggv\u00e9nyeknek k\u00e9t param\u00e9tert adunk \u00e1t: a mez\u0151t, amire sz\u0171rni szeretn\u00e9nk, \u00e9s az operandust. Expression szintaktika Vegy\u00fck \u00e9szre, hogy se itt, se a Lambda-kifejez\u00e9sekben nem haszn\u00e1ltunk string alap\u00fa mez\u0151neveket, mindenhol ugyanazzal a szintaktik\u00e1val (ez a C# Expression ) az oszt\u00e1lydefin\u00edci\u00f3ra hivatkoztunk. Ez az\u00e9rt praktikus \u00edgy, mert elker\u00fclj\u00fck a mez\u0151nevek elg\u00e9pel\u00e9s\u00e9t. Val\u00f3j\u00e1ban mindegyik le\u00edr\u00e1s, amit haszn\u00e1ltunk, ugyanazt a sz\u0171r\u00e9si felt\u00e9telt jelenti. A MongoDB driver mindegyik szintaktik\u00e1t lek\u00e9pezi a saj\u00e1t bels\u0151 reprezent\u00e1ci\u00f3j\u00e1v\u00e1. A Lambda-kifejez\u00e9s alap\u00fa kevesebb karaktert ig\u00e9nyel, \u00e9s jobban illeszkedik a C# nyelvbe, m\u00edg az ut\u00f3bbi a MongoDB saj\u00e1toss\u00e1gainak kifejez\u00e9s\u00e9re val\u00f3. B\u00e1rmelyiket haszn\u00e1lhatjuk. Lek\u00e9rdez\u00e9s eredm\u00e9ny\u00e9nek felhaszn\u00e1l\u00e1sa \u00b6 A collection.Find(...) f\u00fcggv\u00e9ny eredm\u00e9nye m\u00e9g nem az eredm\u00e9nyhalmaz, hanem csak egy le\u00edr\u00f3 a lek\u00e9rdez\u00e9s v\u00e9grehajt\u00e1s\u00e1hoz. Az eredm\u00e9ny \u00e1ltal\u00e1ban h\u00e1rom f\u00e9le m\u00f3don k\u00e9rhet\u0151 le \u00e9s dolgozhat\u00f3 fel. List\u00e1z\u00e1s \u00b6 K\u00e9rj\u00fck a teljes eredm\u00e9nyhalmazt egy listak\u00e9nt: collection.Find(...).ToList() . Els\u0151/egyetlen elem lek\u00e9r\u00e9se \u00b6 Amennyiben csak az els\u0151 elemre van sz\u00fcks\u00e9g\u00fcnk, vagy tudjuk, hogy csak egy elem lesz, akkor haszn\u00e1lhatjuk a collection.Find(...).First() , .FirstOrDefault() , vagy .Single() , .SingleOrDefault() f\u00fcggv\u00e9nyeket. Kurzor \u00b6 Ha az eredm\u00e9nyhalmaz sok dokumentumot tartalmaz, c\u00e9lszer\u0171 kurzorral feldolgozni. A MongoDB limit\u00e1lja a lek\u00e9rdez\u00e9sre adott v\u00e1lasz m\u00e9ret\u00e9t, ez\u00e9rt ha t\u00fal sok dokumentumot k\u00e9rdez\u00fcnk le, el\u0151fordulhat, hogy az eredm\u00e9ny helyett hib\u00e1t fogunk kapni. Ennek felold\u00e1s\u00e1ra haszn\u00e1ljuk a kurzorokat, ahol mindig csak egy r\u00e9szhalmaz\u00e1t kapjuk a dokumentumoknak. var cur = collection . Find (...). ToCursor (); while ( cur . MoveNext ()) // kurzor l\u00e9ptet\u00e9se { foreach ( var t in cur . Current ) // a kurzor aktu\u00e1lis eleme nem egy dokumentum, hanem egy lista { ... } } Sz\u0171r\u00e9shez haszn\u00e1lhat\u00f3 oper\u00e1torok \u00b6 A sz\u0171r\u00e9si felt\u00e9telek a dokumentumban tal\u00e1lhat\u00f3 mez\u0151kre vonatkoznak, \u00e9s a sz\u0171r\u00e9si felt\u00e9tel mindig egy konstans. Teh\u00e1t nem lehets\u00e9ges p\u00e9ld\u00e1ul k\u00e9t mez\u0151t \u00f6sszehasonl\u00edtani , \u00e9s nem tudunk m\u00e1s gy\u0171jtem\u00e9nyekre se hivatkozni. L\u00e9tezik a MongoDB-ben egy un. aggreg\u00e1ci\u00f3s pipeline, amely seg\u00edts\u00e9g\u00e9vel bonyolultabb lek\u00e9rdez\u00e9seket is megfogalmazhatunk, most viszont az egyszer\u0171 lek\u00e9rdez\u00e9sekre koncentr\u00e1lunk. A sz\u0171r\u00e9si felt\u00e9tel teh\u00e1t a dokumentum egy mez\u0151j\u00e9t egy \u00e1ltalunk megadott konstanshoz hasonl\u00edtja. Az al\u00e1bbi lehet\u0151s\u00e9gek a leggyakrabban haszn\u00e1ltak. \u00d6sszehasonl\u00edt\u00e1si oper\u00e1torok \u00b6 collection . Find ( x => x . Price == 123 ); collection . Find ( Builders < Product >. Filter . Eq ( x => x . Price , 123 )); //Eq, mint equals collection . Find ( x => x . Price != 123 ); collection . Find ( Builders < Product >. Filter . Ne ( x => x . Price , 123 )); // Ne, mint not equals collection . Find ( x => x . Price >= 123 ); collection . Find ( Builders < Product >. Filter . Gte ( x => x . Price , 123 )); // Gte, mint greater than or equal to collection . Find ( x => x . Price < 123 ); collection . Find ( Builders < Product >. Filter . Lt ( x => x . Price , 123 )); // Lt, mint less than Logikai oper\u00e1torok \u00b6 collection . Find ( x => x . Price > 500 && x . Price < 1000 ); collection . Find ( Builders < Product >. Filter . And ( Builders < Product >. Filter . Gt ( x => x . Price , 500 ), Builders < Product >. Filter . Lt ( x => x . Price , 1000 ) ) ); collection . Find ( x => x . Price < 500 || x . Stock < 10 ); collection . Find ( Builders < Product >. Filter . Or ( Builders < Product >. Filter . Lt ( x => x . Price , 500 ), Builders < Product >. Filter . Lt ( x => x . Stock , 10 ) ) ); collection . Find ( x => !( x . Price < 500 || x . Stock < 10 )); collection . Find ( Builders < Product >. Filter . Not ( Builders < Product >. Filter . Or ( Builders < Product >. Filter . Lt ( x => x . Price , 500 ), Builders < Product >. Filter . Lt ( x => x . Stock , 10 ) ) ) ); T\u00f6bb \u00e9rt\u00e9k k\u00f6z\u00fcl valamelyikkel megegyez\u0151 \u00b6 collection . Find ( x => x . Id == ... || x . Id = ...); collection . Find ( Builders < Product >. Filter . In ( x => x . Id , new [] { ... })); // hasonl\u00f3an l\u00e9tezik a Nin, mint not in oper\u00e1tor \u00c9rt\u00e9k l\u00e9tezik (nem null) \u00b6 collection . Find ( x => x . VAT != null ); collection . Find ( Builders < Product >. Filter . Exists ( x => x . VAT )); L\u00e9tezik-e A l\u00e9tezik-e, azaz nem null sz\u0171r\u00e9s az\u00e9rt k\u00fcl\u00f6nleges, mert a MongoDB szempontj\u00e1b\u00f3l k\u00e9t m\u00f3don is lehet null egy \u00e9rt\u00e9k: ha a kulcs l\u00e9tezik a dokumentumban \u00e9s \u00e9rt\u00e9ke null; avagy, ha a kulcs nem is l\u00e9tezik. Sz\u0171r\u00e9s be\u00e1gyazott dokumentum mez\u0151j\u00e9re \u00b6 A MongoDB szempontj\u00e1b\u00f3l a be\u00e1gyazott dokumentumok ugyan\u00fagy haszn\u00e1lhat\u00f3k sz\u0171r\u00e9sre, teh\u00e1t az al\u00e1bbiak mind \u00e9rv\u00e9nyesek, \u00e9s az se okoz gondot, ha a be\u00e1gyaztott dokumentum (a p\u00e9ld\u00e1kban az VAT nem l\u00e9tezik): collection . Find ( x => x . VAT . Percentage < 27 ); collection . Find ( Builders < Product >. Filter . Lt ( x => x . VAT . Percentage , 27 )); collection . Find ( Builders < Product >. Filter . Exists ( x => x . VAT . Percentage , exists : false )); // ez a nem l\u00e9tezik, azaz null sz\u0171r\u00e9s Sz\u0171r\u00e9s t\u00f6mb \u00e9rt\u00e9k\u0171 mez\u0151re \u00b6 A dokumentum b\u00e1rmely mez\u0151je lehet t\u00f6mb \u00e9rt\u00e9k\u0171, mint a p\u00e9ld\u00e1ban a string[] Categories . MongoDB-ben a t\u00f6mb\u00f6kkel is egyszer\u0171en tudunk dolgozni, az Any* sz\u0171r\u00e9si felt\u00e9telekkel. // azon term\u00e9keket, amelyek a jelzett kateg\u00f3ri\u00e1ban vannak collection . Find ( Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" )); // azon term\u00e9keket, amelyek legal\u00e1bb egy olyan kateg\u00f3ri\u00e1hoz tartoznak, amelyet nem soroltunk fel collection . Find ( Builders < Product >. Filter . AnyNin ( x => x . Categories , new [] { \"Labd\u00e1k\" , \"\u00dct\u0151k\" })); Any... Az Any* felt\u00e9telek a t\u00f6mb minden elem\u00e9t vizsg\u00e1lj\u00e1k, de a dokumentum szempontj\u00e1b\u00f3l csak egyszer illeszkednek. Teh\u00e1t, ha a t\u00f6mb t\u00f6bb eleme is illeszkedik egy felt\u00e9telre, att\u00f3l m\u00e9g csak egyszer kapjuk meg a dokumentumot az eredm\u00e9nyhalmazban. Lek\u00e9rdez\u00e9s-v\u00e9grehajt\u00f3 pipeline \u00b6 A MongoDB lek\u00e9rdez\u00e9sek egy un. pipeline-on haladnak v\u00e9gig. Ennek r\u00e9szleteivel nem fogunk megismerkedni, de az egyszer\u0171 sz\u0171r\u00e9seken k\u00edv\u00fcl p\u00e1r tov\u00e1bbi, lek\u00e9rdez\u00e9sekben haszn\u00e1lt elemet fogunk l\u00e1tni. Lapoz\u00e1s, rendez\u00e9s \u00b6 A lapoz\u00e1shoz megadatjuk, maxim\u00e1lisan h\u00e1ny illeszked\u0151 dokumentumot k\u00e9r\u00fcnk: collection . Find (...). Limit ( 100 ); A k\u00f6vetkez\u0151 lapon tal\u00e1lhat\u00f3 elemekhez pedig kihagyjuk az els\u0151 lapon m\u00e1r l\u00e1tott elemeket: collection . Find (...). Skip ( 100 ). Limit ( 100 ); A Skip \u00e9s Limit ebben a form\u00e1ban nem \u00e9rtelmes, ugyanis rendez\u00e9s n\u00e9lk\u00fcl az \"els\u0151 100 elem\" lek\u00e9rdez\u00e9s (a kliens sz\u00e1m\u00e1ra) nem determinisztikus. Teh\u00e1t az ilyen jelleg\u0171 lek\u00e9rdez\u00e9sekhez sz\u00fcks\u00e9ges, hogy egy megfelel\u0151 rendez\u00e9st is megadjunk. A rendez\u00e9s defini\u00e1l\u00e1sa a kor\u00e1bban m\u00e1r l\u00e1tott Builders<T> seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik. collection . Find (...) . Sort ( Builders < Product >. Sort . Ascending ( x => x . Name )) . Skip ( 100 ). Limit ( 100 ); Lapoz\u00e1si probl\u00e9ma A fenti lapoz\u00e1s m\u00e9g mindig nem teljesen helyes. P\u00e9ld\u00e1ul, ha a k\u00e9t lap lek\u00e9rdez\u00e9se k\u00f6zben egy term\u00e9k t\u00f6rl\u00e9sre ker\u00fcl, akkor \"eggyel arr\u00e9bb cs\u00fasznak\" a term\u00e9kek, \u00e9s lesz egy term\u00e9k, amely kimarad a k\u00f6vetkez\u0151 lapoz\u00e1sn\u00e1l. Ez nem csak a MongoDB probl\u00e9m\u00e1ja. Gondolkodtat\u00f3 feladat: hogyan oldhat\u00f3 meg ez a probl\u00e9ma? Darabsz\u00e1m lek\u00e9rdez\u00e9s \u00b6 A lek\u00e9rdez\u00e9sre illeszked\u0151 dokumentumok sz\u00e1m\u00e1t k\u00e9t f\u00e9le m\u00f3don is lek\u00e9rdezhetj\u00fck: collection . CountDocuments ( Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" )); collection . Find ( Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" )). CountDocuments (); Csoportos\u00edt\u00e1s \u00b6 A csoportos\u00edt\u00e1s szintaktikailag bonyolult m\u0171velet. A csoportos\u00edt\u00e1shoz egy aggreg\u00e1ci\u00f3s pipeline-t kell defini\u00e1lnunk. Ezzel r\u00e9szletesebben nem foglalkozunk, az al\u00e1bbi p\u00e9lda mutatja a haszn\u00e1lat\u00e1t. // A \"Labd\u00e1k\" kateg\u00f3ri\u00e1ba tartoz\u00f3 term\u00e9kek az \u00c1FA kulcs szerint csoportos\u00edtva foreach ( var g in collection . Aggregate () . Match ( Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" )) // sz\u0171r\u00e9s . Group ( x => x . VAT . Percentage , x => x ) // csoportos\u00edt\u00e1s . ToList ()) { Console . WriteLine ( $ \"VAT percentage: {g.Key}\" ); foreach ( var p in g ) Console . WriteLine ( $ \"\\tProduct: {p.Name}\" ); } Besz\u00far\u00e1s, m\u00f3dos\u00edt\u00e1s, t\u00f6rl\u00e9s \u00b6 A lek\u00e9rdez\u00e9sek ut\u00e1n ismerkedj\u00fcnk meg az adatm\u00f3dos\u00edt\u00e1sokkal. \u00daj dokumentum besz\u00far\u00e1sa \u00b6 \u00daj dokumentum besz\u00far\u00e1s\u00e1hoz az \u00faj dokumentumot reprezent\u00e1l\u00f3 objektumra van sz\u00fcks\u00e9g\u00fcnk. Ezt a gy\u0171jtem\u00e9nyhez tudjuk hozz\u00e1adni. var newProduct = new Product { Name = \"Alma\" , Price = 890 , Categories = new [] { \"Gy\u00fcm\u00f6lcs\u00f6k\" } }; collection . InsertOne ( newProduct ); Console . WriteLine ( $ \"Besz\u00fart rekord id: {newProduct.Id}\" ); // besz\u00far\u00e1s ut\u00e1n friss\u00edt\u00e9sre ker\u00fcl a C# objektum, \u00e9s lek\u00e9rdezhet\u0151 az Id-ja Figyelj\u00fck meg, hogy az Id mez\u0151t nem t\u00f6lt\u00f6tt\u00fck ki. Ezt a kliens oldali driver p\u00f3tolni fogja. Ha akarjuk, mi is adhatunk neki \u00e9rt\u00e9ket, de nem szok\u00e1s. Eml\u00e9kezz\u00fcnk r\u00e1, hogy a MongoDB-ben nincs s\u00e9ma, \u00edgy a besz\u00fart dokumentum lehet teljesen elt\u00e9r\u0151 a gy\u0171jtem\u00e9nyben tal\u00e1lhat\u00f3 t\u00f6bbi elemt\u0151l. Illetve figyelj\u00fck meg, hogy nem adtunk minden mez\u0151nek \u00e9rt\u00e9ket. Mivel nincsenek integrit\u00e1si krit\u00e9riumok, \u00edgy minden besz\u00far\u00e1s sikerrel fog j\u00e1rni, viszont a lek\u00e9rdez\u00e9sn\u00e9l lehetnek bel\u0151le probl\u00e9m\u00e1k (pl. ha felt\u00e9telezz\u00fck, hogy a rakt\u00e1rk\u00e9szlet mindig ki van t\u00f6ltve). T\u00f6bb dokumentum besz\u00far\u00e1s\u00e1ra az InsertMany f\u00fcggv\u00e9ny haszn\u00e1lhat\u00f3, azonban ne felejtkezz\u00fcnk el arr\u00f3l, hogy nincsenek tranzakci\u00f3k, \u00edgy a t\u00f6bb dokumentum besz\u00far\u00e1sa egyenk\u00e9nt f\u00fcggetlen m\u0171velet. Ha a besz\u00far\u00e1sok v\u00e9grehajt\u00e1sa k\u00f6zben valamely okb\u00f3l hiba t\u00f6rt\u00e9nik, az addig sikeresen besz\u00fart dokumentumok az adatb\u00e1zisban maradnak. Az egyes dokumentumok azonban atomi m\u00f3don ker\u00fclnek ment\u00e9sre, teh\u00e1t egy hiba sor\u00e1n se ker\u00fclhet egy \"f\u00e9l\" dokumentum az adatb\u00e1zisba. Dokumentumok t\u00f6rl\u00e9se \u00b6 A t\u00f6rl\u00e9shez egy sz\u0171r\u00e9si felt\u00e9telt kell defini\u00e1lnunk, \u00e9s vagy a DeleteOne , vagy a DeleteMany f\u00fcggv\u00e9nnyel t\u00f6r\u00f6lhet\u00fcnk. A k\u00fcl\u00f6nbs\u00e9g, hogy a DeleteOne az els\u0151 illeszked\u0151 dokumentumot t\u00f6rli csak, m\u00edg a DeleteMany az \u00f6sszeset. Ha tudjuk, hogy a felt\u00e9telnek csak egy dokumentum felelhet meg (p\u00e9ld\u00e1ul id alapj\u00e1n t\u00f6rl\u00fcnk), akkor \u00e9rdemes a DeleteOne -t haszn\u00e1lni, mert az adatb\u00e1zisnak nem kell kimer\u00edt\u0151 keres\u00e9st v\u00e9geznie. A t\u00f6rl\u00e9s felt\u00e9tele a keres\u00e9sn\u00e9l megismert szintaktik\u00e1kkal \u00edrhat\u00f3 le. A t\u00f6rl\u00e9s teh\u00e1t elt\u00e9r az Entity Framework eset\u00e9n tapasztalhat\u00f3 viselked\u00e9sr\u0151l. Itt nem kell az entit\u00e1snak bet\u00f6ltve lennie, \u00e9s nem az entit\u00e1st t\u00f6r\u00f6lj\u00fck, hanem sz\u0171r\u00e9si felt\u00e9tellel \u00edrjuk le a t\u00f6rl\u00e9st. var deleteResult = collection . DeleteOne ( x => x . Id == new ObjectId ( \"...\" )); Console . WriteLine ( $ \"T\u00f6r\u00f6lve: {deleteResult.DeletedCount} db\" ); Ha szeretn\u00e9nk a t\u00f6r\u00f6lt elemet megkapni, akkor haszn\u00e1lhatjuk a FindOneAndDelete -t, amely visszaadja a t\u00f6r\u00f6lt entit\u00e1st mag\u00e1t. Dokumentumok megv\u00e1ltoztat\u00e1sa \u00b6 A MongoDB tal\u00e1n leg\u00e9rdekesebb k\u00e9pess\u00e9gei a dokumentumok megv\u00e1ltoztat\u00e1sa k\u00f6r\u00fcl tal\u00e1lhat\u00f3ak. M\u00edg a kor\u00e1bbiak, a lek\u00e9rdez\u00e9sek, besz\u00far\u00e1sok, t\u00f6rl\u00e9sek a legt\u00f6bb adatb\u00e1zis (ak\u00e1r rel\u00e1ci\u00f3s, ak\u00e1r NoSQL) eset\u00e9n hasonl\u00f3ak, a MongoDB a m\u00f3dos\u00edt\u00f3 m\u0171veletekben j\u00f3val sz\u00e9lesebb spektrumot t\u00e1mogat. Alapvet\u0151en k\u00e9t f\u00e9le m\u00f3don tudunk egy dokumentumot megv\u00e1ltoztatni: lecser\u00e9lni az eg\u00e9sz dokumentumot egy \u00fajra, avagy r\u00e9szeit friss\u00edteni. Dokumentum teljes cser\u00e9je \u00b6 A dokumentum teljes cser\u00e9j\u00e9hez sz\u00fcks\u00e9g\u00fcnk van egy sz\u0171r\u00e9si felt\u00e9telre, amellyel megadjuk, mely dokumentumot akarjuk cser\u00e9lni; valamint sz\u00fcks\u00e9g\u00fcnk van az \u00faj dokumentumra. var replacementProduct = new Product { Name = \"Alma\" , Price = 890 , Categories = new [] { \"Gy\u00fcm\u00f6lcs\u00f6k\" } }; var replaceResult = collection . ReplaceOne ( x => x . Id == new ObjectId ( \"...\" ), replacementProduct ); Console . WriteLine ( $ \"M\u00f3dos\u00edtva: {replaceResult.ModifiedCount}\" ); Ez a csere 1-1 jelleg\u0171, azaz egy dokumentumot cser\u00e9l\u00fcnk egy dokumentumra. A m\u0171velet mag\u00e1ban atomi, azaz ha menet k\u00f6zben megszakad, akkor se fordulhat el\u0151, hogy egy f\u00e9l dokumentum ker\u00fclt elment\u00e9sre. Ha szeretn\u00e9nk megkapni a csere el\u0151tti dokumentumot, akkor a FindOneAndReplace met\u00f3dust haszn\u00e1lhatjuk. \u00c9rdekess\u00e9g A csere sor\u00e1n lehet\u0151s\u00e9g van a dokumentum id-j\u00e1nak m\u00f3dos\u00edt\u00e1s\u00e1ra is. Ha a csere dokumentumban m\u00e1s id szerepel, a dokumentum id-ja megv\u00e1ltozik. Dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torok \u00b6 A dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torokkal atomi m\u00f3don tudunk a dokumentum mez\u0151inek \u00e9rt\u00e9k\u00e9n v\u00e1ltoztatni an\u00e9lk\u00fcl, hogy a teljes dokumentumot lecser\u00e9ln\u00e9nk. A m\u00f3dos\u00edt\u00f3 m\u0171veletek le\u00edr\u00e1s\u00e1hoz a kor\u00e1bban m\u00e1r l\u00e1tott Builders<T> seg\u00edts\u00e9g\u00e9t vessz\u00fck ig\u00e9nybe. \u00c1ll\u00edtsunk be a rakt\u00e1rk\u00e9szletet egy konstans \u00e9rt\u00e9kre: collection . UpdateOne ( filter : x => x . Id == new ObjectId ( \"...\" ), update : Builders < Product >. Update . Set ( x => x . Stock , 5 )); Az UpdateOne f\u00fcggv\u00e9ny els\u0151 param\u00e9tere a sz\u0171r\u00e9si felt\u00e9tel. Le\u00edr\u00e1s\u00e1hoz b\u00e1rmely kor\u00e1bban ismertetett szintaktika haszn\u00e1lhat\u00f3. M\u00e1sodik param\u00e9tere a m\u00f3dos\u00edt\u00f3 m\u0171velet le\u00edr\u00f3ja, amelyet a Builders<T> seg\u00edts\u00e9g\u00e9vel \u00e9p\u00edthet\u00fcnk fel. A fenti p\u00e9ldak\u00f3dban a param\u00e9terek nev\u00e9t is ki\u00edrtuk ( filter: \u00e9s update: ), hogy egy\u00e9rtelm\u0171 legyen, param\u00e9ter mit jelk\u00e9pez. Ez nem k\u00f6telez\u0151, de az olvashat\u00f3s\u00e1got n\u00f6veli (a k\u00f3dsorok hossz\u00e1nak rov\u00e1s\u00e1ra). A m\u00f3dos\u00edt\u00e1s nem csak egy m\u0171veletet tartalmazhat. collection . UpdateOne ( filter : x => x . Id == new ObjectId ( \"...\" ), update : Builders < Product >. Update . Set ( x => x . Stock , 5 ) // rakt\u00e1rk\u00e9szlet legyen 5 . CurrentDate ( x => x . StockUpdated ) // mai d\u00e1tumot be\u00edrjuk, mint a friss\u00edt\u00e1s ideje . Unset ( x => x . NeedsUpdate ) // t\u00f6r\u00f6lj\u00fck a friss\u00edtend\u0151 jelz\u00e9st ); A tipikusan haszn\u00e1lt m\u00f3dos\u00edt\u00f3 oper\u00e1torok: Set : mez\u0151 \u00e9rt\u00e9k\u00e9nek be\u00e1ll\u00edt\u00e1sa; SetOnInsert : mint a Set , de csak \u00faj dokumentum besz\u00far\u00e1sa eset\u00e9n fut le (l\u00e1sd upsert al\u00e1bb); Unset : mez\u0151 t\u00f6rl\u00e9se (a kulcs \u00e9s \u00e9rt\u00e9k elt\u00e1vol\u00edt\u00e1sa a dokumentumb\u00f3l); CurrentDate : aktu\u00e1lis d\u00e1tum be\u00edr\u00e1sa; Inc : \u00e9rt\u00e9k n\u00f6vel\u00e9se; Min , Max : mez\u0151 \u00e9rt\u00e9k\u00e9nek lecser\u00e9l\u00e9se, amennyiben a megadott \u00e9rt\u00e9k kisebb/nagyobb, mint a mez\u0151 jelenlegi \u00e9rt\u00e9ke; Mul : \u00e9rt\u00e9k megszorz\u00e1sa; PopFirst , PopLast : t\u00f6mbb\u0151l els\u0151/utols\u00f3 elem elt\u00e1vol\u00edt\u00e1sa; Pull : t\u00f6mbb\u0151l \u00e9rt\u00e9k elt\u00e1vol\u00edt\u00e1sa; Push : t\u00f6mbh\u00f6z \u00e9rt\u00e9k hozz\u00e1ad\u00e1sa a v\u00e9g\u00e9re (tov\u00e1bbi lehet\u0151s\u00e9gek ugyanebben az oper\u00e1torban: t\u00f6mb sorrendez\u00e9se, t\u00f6mb els\u0151 n elem\u00e9nek megtart\u00e1sa); AddToSet : t\u00f6mbh\u00f6z \u00e9rt\u00e9k hozz\u00e1ad\u00e1sa, ha m\u00e9g nem l\u00e9tezik. A fenti m\u0171veletek akkor is \u00e9rtelmezettek, ha a megadott mez\u0151 nem l\u00e9tezik. Az oper\u00e1tor t\u00edpus\u00e1t\u00f3l f\u00fcgg\u0151en egy alap\u00e9rtelmezett \u00e9rt\u00e9ken v\u00e9gzi a m\u00f3dos\u00edt\u00e1st az adatb\u00e1zis. P\u00e9ld\u00e1ul az Inc \u00e9s Mul eset\u00e9n a mez\u0151 0 \u00e9rt\u00e9ket vesz fel, \u00e9s azon t\u00f6rt\u00e9nik a m\u00f3dos\u00edt\u00e1s. A t\u00f6mb m\u0171veletek eset\u00e9n egy \u00fcres t\u00f6mb ker\u00fcl m\u00f3dos\u00edt\u00e1sra. A t\u00f6bbi m\u0171velet eset\u00e9n dokument\u00e1ci\u00f3b\u00f3l kikereshet\u0151 a viselked\u00e9s. A fent l\u00e1tott m\u00f3dszerrel nem csak egyetlen dokumentum m\u00f3dos\u00edthat\u00f3. A k\u00e9rt szerkeszt\u0151 m\u0171velet t\u00f6bb, a sz\u0171r\u00e9si felt\u00e9telre illeszked\u0151 dokumentumon is elv\u00e9gezhet\u0151. P\u00e9ld\u00e1ul: a ny\u00e1ri szezonra val\u00f3 tekintettel minden labd\u00e1ra adjunk 25% engedm\u00e9nyt, \u00e9s adjuk \u0151ket hozz\u00e1 az akci\u00f3s kateg\u00f3ri\u00e1hoz. collection . UpdateMany ( filter : Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" ), update : Builders < Product >. Update . Mul ( x => x . Price , 0.75 ) . AddToSet ( x => x . Categories , \"Akci\u00f3s term\u00e9kek\" )); A m\u00f3dos\u00edt\u00f3 oper\u00e1torok atomi m\u00f3don teszik szerkeszthet\u0151v\u00e9 a dokumentumainkat. Haszn\u00e1latukkal kik\u00fcsz\u00f6b\u00f6lhet\u0151 a konkurens adathozz\u00e1f\u00e9r\u00e9sb\u0151l ered\u0151 probl\u00e9m\u00e1k egy r\u00e9sze. Upsert : neml\u00e9tez\u0151 dokumentum cser\u00e9je \u00b6 M\u00f3dos\u00edt\u00f3 m\u0171velet sor\u00e1n lehet\u0151s\u00e9g\u00fcnk van az un. upsert (update/insert) jelleg\u0171 m\u0171k\u00f6d\u00e9sre. Ez azt jelenti, hogy vagy besz\u00far\u00e1s, vagy m\u00f3dos\u00edt\u00e1s t\u00f6rt\u00e9nik, annak f\u00fcggv\u00e9ny\u00e9ben, hogy megtal\u00e1lhat\u00f3 volt-e az elem az adatb\u00e1zisban. Az alapvet\u0151 viselked\u00e9s nem upsert, azt k\u00fcl\u00f6n k\u00e9rn\u00fcnk kell. collection . ReplaceOne ( filter : x => x . Id == new ObjectId ( \"...\" ), replacement : replacementObject , options : new UpdateOptions () { IsUpsert = true }); Nem csak a teljes dokumentum cser\u00e9je eset\u00e9n van lehet\u0151s\u00e9g\u00fcnk upsert-re. A dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torokkal is elv\u00e9gezhetj\u00fck ugyanezt. Ahogy l\u00e1thattuk, a m\u00f3dos\u00edt\u00f3 oper\u00e1torokat nem zavarja, ha nem l\u00e9tezik egy mez\u0151. Ugyan\u00edgy nem okoz gondot, ha nem l\u00e9tezik a dokumentum; ez azzal egyen\u00e9rt\u00e9k\u0171, mintha egy teljesen \u00fcres dokumentumon v\u00e9gezn\u00e9nk el a m\u00f3dos\u00edt\u00f3 m\u0171veleteket. collection . UpdateOne ( filter : ..., update : ..., options : new UpdateOptions () { IsUpsert = true }); Az upsert m\u0171velet egy eszk\u00f6z a konkurens m\u00f3dos\u00edt\u00e1sok ter\u00e9n a tranzakci\u00f3 hi\u00e1ny\u00e1ra. Mivel nincs tranzakci\u00f3nk, ez\u00e9rt nem tudunk meggy\u0151z\u0151dni arr\u00f3l a besz\u00far\u00e1s el\u0151tt, hogy m\u00e9g nem l\u00e9tezik egy adott rekord. Helyette haszn\u00e1lhatjuk az upsert m\u00f3dszert, ami atomi lek\u00e9rdez\u00e9st \u00e9s besz\u00far\u00e1st/m\u00f3dos\u00edt\u00e1st tesz lehet\u0151v\u00e9. merge SQL nyelvben a merge parancs ny\u00fajt erre hasonl\u00f3 megold\u00e1st.","title":"MongoDB alapok, m\u0171veletek, \u00e9s a MongoDB .NET Driver"},{"location":"jegyzet/mongodb/#mongodb-alapok-muveletek-es-a-mongodb-net-driver","text":"","title":"MongoDB alapok, m\u0171veletek, \u00e9s a MongoDB .NET Driver"},{"location":"jegyzet/mongodb/#nosql-adatbazisok","text":"A NoSQL adatb\u00e1zisok a rel\u00e1ci\u00f3s s\u00e9m\u00e1t\u00f3l elt\u00e9r\u0151en m\u0171k\u00f6d\u0151 adatb\u00e1zisok \u00f6sszefoglal\u00f3 neve. A n\u00e9v valamennyire megt\u00e9veszt\u0151, mert a fogalomnak kev\u00e9s k\u00f6ze van az SQL nyelvhez - ehelyett a relev\u00e1ns k\u00fcl\u00f6nbs\u00e9g az adatreprezent\u00e1ci\u00f3ban \u00e9s a s\u00e9m\u00e1ban van. De m\u00e9gis mi\u00e9rt van sz\u00fcks\u00e9g\u00fcnk \u00faj fajta adatb\u00e1zisokra, amikor a rel\u00e1ci\u00f3s adatb\u00e1zisok r\u00e9g\u00f3ta j\u00f3l haszn\u00e1lhat\u00f3ak? Egy kis m\u00e9ret\u0171 adatb\u00e1zis egyszer\u0171 s\u00e9m\u00e1val k\u00f6nnyen le\u00edrhat\u00f3 rel\u00e1ci\u00f3s modellben, m\u00e9g k\u00e9nyelmes is. De az alkalmaz\u00e1saink fejl\u0151dnek, egyre t\u00f6bb funkci\u00f3t kell ell\u00e1tniuk, ezzel egy\u00fctt komplexebb\u00e9 v\u00e1lik a s\u00e9ma is, illetve egyre t\u00f6bb adatot kell elt\u00e1rolni \u00e9s n\u0151 az adatb\u00e1zis. Ez egy bizonyos hat\u00e1r felett komplik\u00e1lt\u00e1 v\u00e1lik. A rel\u00e1ci\u00f3s adatb\u00e1zisok h\u00e1tr\u00e1nya, hogy a folyamatos v\u00e1ltoz\u00e1sok, s\u00e9ma v\u00e1ltoztat\u00e1st ig\u00e9nyelnek. Ahhoz, hogy ezt karban tudjuk tartani folyamatosan migr\u00e1lni kell az adatokat \u00e9s ez nem egyszer\u0171 feladat. Tov\u00e1bb\u00e1 teljes\u00edtm\u00e9ny probl\u00e9m\u00e1kkal, azaz ink\u00e1bb konzisztencia- \u00e9s sk\u00e1l\u00e1z\u00e1si probl\u00e9m\u00e1kkal j\u00e1rhat, ha rel\u00e1ci\u00f3s adatb\u00e1zist haszn\u00e1lunk - ezzel azonban nem foglalkozunk m\u00e9lyebben. Ezekre a probl\u00e9m\u00e1kra a NoSQL adatb\u00e1zisok ny\u00fajtanak megold\u00e1st. Ebben a vil\u00e1gban elhagyjuk a szigor\u00fa s\u00e9m\u00e1kat, helyette egy flexibilis s\u00e9m\u00e1t fogunk alkalmazni . Azaz nem lesznek er\u0151s elv\u00e1r\u00e1saink az adatb\u00e1zisban t\u00e1rolt adatokkal szemben.","title":"NoSQL adatb\u00e1zisok"},{"location":"jegyzet/mongodb/#a-mongodb-alap-koncepcioi","text":"A MongoDB egy kliens-szerver architekt\u00far\u00e1j\u00fa nem-rel\u00e1ci\u00f3s adatb\u00e1zis. A k\u00e9p jobb oldal\u00e1n l\u00e1that\u00f3 a mongod , azaz Mongo d\u00e9mon, vagyis az a processz, ami az adatb\u00e1zis el\u00e9r\u00e9s\u00e9t biztos\u00edtja. A m\u00e1sik oldal a mi alkalmaz\u00e1sunk, ahonnan a kliens kapcsol\u00f3dik a szerverhez egy h\u00e1l\u00f3zati kapcsolaton kereszt\u00fcl. Ez a h\u00e1l\u00f3zati kapcsolat az un. wire protocol -on kereszt\u00fcl t\u00f6rt\u00e9nik, ez a MongoDB saj\u00e1t protokollja. Ebben a protokollban JSON form\u00e1j\u00fa adat kommunik\u00e1ci\u00f3 zajlik bin\u00e1risan (azaz BSON).","title":"A MongoDB alap koncepci\u00f3i"},{"location":"jegyzet/mongodb/#logikai-felepites","text":"Egy MongoDB-alap\u00fa adatb\u00e1zis rendszer legfels\u0151 r\u00e9tege az un. klaszter , ebbe szervezz\u00fck a szervereket. Mi klaszterekkel ebben a t\u00e1rgyban nem foglalkozunk, azok a sk\u00e1l\u00e1z\u00e1s eszk\u00f6zei. A m\u00e1sodik szint a szerver szintje (a mongod processz), ami alatt az adatb\u00e1zis foglal helyet. Egy szerver/klaszter t\u00f6bb adatb\u00e1zist t\u00e1rolhat. Az adatb\u00e1zisok pedig gy\u0171jtem\u00e9nyekb\u0151l ( collection ) \u00e9p\u00fclnek fel. Ha a rel\u00e1ci\u00f3s adatb\u00e1zisokkal meg akarjuk feleltetni, akkor a gy\u0171jtem\u00e9nyek a t\u00e1bl\u00e1k megfelel\u0151i, ezen bel\u00fcl a sorok/rekordok pedig a gy\u0171jtem\u00e9nyben t\u00e1rolt dokumentumok lesznek. N\u00e9zz\u00fck ezeket pontosabban.","title":"Logikai fel\u00e9p\u00edt\u00e9s"},{"location":"jegyzet/mongodb/#dokumentum","text":"A dokumentum a MongoDB alap t\u00e1rol\u00e1si egys\u00e9ge. Egy dokumentum egy JSON (jelleg\u0171) f\u00e1jl, teh\u00e1t kulcs-\u00e9rt\u00e9k p\u00e1rokat tartalmaz. Maga a MongoDB BSON-k\u00e9nt, bin\u00e1ris reprezent\u00e1ci\u00f3k\u00e9nt t\u00e1rolja mindezt. { name : \"sue\" , age : 26 , status : \"A\" , groups : [ \"news\" , \"sports\" ] } Kulcsoknak t\u00f6bbnyire b\u00e1rmilyen szabad sz\u00f6veget v\u00e1laszthatunk, de a neveknek egyedinek kell lenni\u00fck \u00e9s nem kezd\u0151dhetnek a $ karakterrel. A nevek case sensitive-ek. Az \u00e9rt\u00e9k lehet sz\u00f6veg, sz\u00e1m, d\u00e1tum, bin\u00e1ris, be\u00e1gyazott elem, null , vagy ak\u00e1r a fenti p\u00e9ld\u00e1ban a groups kulcsn\u00e1l l\u00e1that\u00f3an t\u00f6mb is - rel\u00e1ci\u00f3s adatb\u00e1zisban ezt \u00edgy nem lehet reprezent\u00e1lni. Az objektum orient\u00e1lt vil\u00e1gban egy dokumentum felel meg egy objektumnak. Fontos megk\u00f6t\u00e9s, hogy a dokumentumok maxim\u00e1lis m\u00e9rete 16MB lehet, \u00e9s ez nem konfigur\u00e1lhat\u00f3 \u00e9rt\u00e9k.","title":"Dokumentum"},{"location":"jegyzet/mongodb/#gyujtemeny","text":"Rel\u00e1ci\u00f3s t\u00e1bla anal\u00f3gi\u00e1ja a gy\u0171jtem\u00e9ny, de nincs s\u00e9m\u00e1ja, \u00edgy ezeket l\u00e9trehozni, defini\u00e1lni se kell, els\u0151 haszn\u00e1latkor a rendszer automatikusan l\u00e9trehozza \u0151ket. \u00dagy fogalmazhatjuk meg, hogy a gy\u0171jtem\u00e9ny a \"hasonl\u00f3\" dokumentumok gy\u0171jt\u0151helye. B\u00e1r nincs s\u00e9ma, indexeket ennek ellen\u00e9re defini\u00e1lhatunk a gy\u0171jtem\u00e9nyeken, amely a gyors keres\u00e9st fogj\u00e1k seg\u00edteni. S\u00e9ma hi\u00e1ny\u00e1ban nincs tartom\u00e1nyi integrit\u00e1si krit\u00e9rium, teh\u00e1t p\u00e9ld\u00e1ul a helyes adatt\u00edpusok \u00e9s tartom\u00e1nyi krit\u00e9riumok biztos\u00edt\u00e1s\u00e1ban az adatb\u00e1zis nem ny\u00fajt seg\u00edts\u00e9get.","title":"Gy\u0171jtem\u00e9ny"},{"location":"jegyzet/mongodb/#adatbazis","text":"Az adatb\u00e1zis ugyanazt a c\u00e9lt szolg\u00e1lja, mint rel\u00e1ci\u00f3s adatb\u00e1zisban. Ez fogja \u00f6ssze az alkalmaz\u00e1s adatait logikailag. Illetve hozz\u00e1f\u00e9r\u00e9si jogosults\u00e1gokat adatb\u00e1zis szinten tudunk adni. Az adatb\u00e1zisok neve case sensitive \u00e9s konvenci\u00f3 szerint tipikusan csupa kisbet\u0171.","title":"Adatb\u00e1zis"},{"location":"jegyzet/mongodb/#kulcs","text":"Minden dokumentum egy\u00e9rtelm\u0171 azonos\u00edt\u00f3ja az _id mez\u0151, m\u00e1st kulcsot nem tudunk defini\u00e1lni. Ezt a mez\u0151t besz\u00far\u00e1skor nem sz\u00fcks\u00e9ges explicit megadni (de lehet), tipikusan a kliens driver vagy a szerver gener\u00e1lja (alap\u00e9rtelmez\u00e9sben egy 12 b\u00e1jtos ObjectId -t k\u00e9sz\u00edt). Az _id mez\u0151t\u0151l f\u00fcggetlen\u00fcl egyedis\u00e9get indexek seg\u00edts\u00e9g\u00e9vel tudunk garant\u00e1lni. Amennyiben sz\u00fcks\u00e9ges, defini\u00e1lhatunk teh\u00e1t m\u00e1s, kulcs-szer\u0171 mez\u0151ket is. Az \u00edgy defini\u00e1lt egyedi mez\u0151k lehetnek \u00f6sszetettek is (teh\u00e1t lehet t\u00f6bb mez\u0151 egy\u00fcttes egyedis\u00e9g\u00e9t el\u0151\u00edrni). K\u00fcls\u0151 kulcs hivatkoz\u00e1sok MongoDB-ben nincsenek. Tudunk hivatkozni m\u00e1s dokumentumokra azok kulcsainak bem\u00e1sol\u00e1s\u00e1val, azonban ezekre a rendszer nem v\u00e1llal garanci\u00e1t (pl. a hivatkozott dokumentum t\u00f6r\u00f6lhet\u0151).","title":"Kulcs"},{"location":"jegyzet/mongodb/#mongodb-muveletek-es-a-mongodb-net-driver","text":"Az al\u00e1bbi, illusztr\u00e1ci\u00f3ra haszn\u00e1lt k\u00f3dr\u00e9szletek a hivatalos MongoDB.Driver Nuget csomagot haszn\u00e1lj\u00e1k.","title":"MongoDB m\u0171veletek \u00e9s a MongoDB .NET Driver"},{"location":"jegyzet/mongodb/#kapcsolat-letesitese","text":"A MongoDB adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez els\u0151 l\u00e9p\u00e9sben sz\u00fcks\u00e9g\u00fcnk van egy kapcsolatra. A kapcsolatot egy MongoClient oszt\u00e1ly reprezent\u00e1lja. A kapcsolathoz sz\u00fcks\u00e9g\u00fcnk van a szerver el\u00e9rhet\u0151s\u00e9g\u00e9re (a connection stringr\u0151l r\u00e9szletesebben l\u00e1sd: https://docs.mongodb.com/manual/reference/connection-string/ ). var client = new MongoClient ( \"mongodb://localhost:27017\" ); A kapcsolatot singleton-k\u00e9nt \u00e9rdemes kezelni, nem kell Dispose-olni. Kapcsolat \u00e9letciklusa A kapcsolatot tipikusan egy glob\u00e1lis statikus v\u00e1ltoz\u00f3ban t\u00e1roljuk, avagy a k\u00f6rnyezet \u00e1ltal t\u00e1mogatott IoC (Inversion of Control) / DI (Dependency Injection) t\u00e1rol\u00f3ban helyezz\u00fck el. Az adatb\u00e1zis neve szerepelhet ugyan a connection stringben (pl. mongodb://localhost:27017/adatvez ), azt csak az authentik\u00e1ci\u00f3hoz haszn\u00e1lja a rendszer. \u00cdgy a kapcsolat fel\u00e9p\u00edt\u00e9se ut\u00e1n meg kell adnunk, milyen adatb\u00e1zist fogunk haszn\u00e1lni. var db = client . GetDatabase ( \"adatvez\" ); Az adatb\u00e1zisnak nem kell el\u0151zetesen l\u00e9tezni. A fenti h\u00edv\u00e1s hat\u00e1s\u00e1ra, ha m\u00e9g nem l\u00e9tezik az adatb\u00e1zis, automatikusan l\u00e9trej\u00f6n.","title":"Kapcsolat l\u00e9tes\u00edt\u00e9se"},{"location":"jegyzet/mongodb/#gyujtemenyek-kezelese","text":"Egy rel\u00e1ci\u00f3s adatb\u00e1zist\u00f3l elt\u00e9r\u0151en MongoDB-ben a m\u0171veleteinket mindig egyetlen gy\u0171jtem\u00e9nyen v\u00e9gezz\u00fck , \u00edgy a gy\u0171jtem\u00e9ny kiv\u00e1laszt\u00e1sa nem a kiadott parancs r\u00e9sze (mint az SQL nyelvben a where ), hanem a m\u0171velet el\u0151felt\u00e9tele. Egy adott gy\u0171jtem\u00e9nyt a GetCollection h\u00edv\u00e1ssal kaphatunk meg, generikus param\u00e9tere a dokumentum t\u00edpust megval\u00f3s\u00edt\u00f3 C# oszt\u00e1ly. var collection = db . GetCollection < BsonDocument >( \"products\" ); A .NET MongoDB driver alap koncepci\u00f3ja szerint minden dokumentumot lek\u00e9pez egy .NET objektumra. Ezzel automatikusan megval\u00f3s\u00edtja az un. ODM (Object Document Mapping) funkci\u00f3t. Az ODM az ORM megfelel\u0151je a NoSQL adatb\u00e1zisok vil\u00e1g\u00e1ban. \"Nyers\" json M\u00e1s nyelveken \u00e9s platformokon a MongoDB driverek nem mindig v\u00e9gzik el a lek\u00e9pez\u00e9st objektumokra, \u00edgy az interneten tal\u00e1lhat\u00f3 p\u00e9ld\u00e1kban gyakran \"nyers\" JSON dokumentumokon kereszt\u00fcli kommunik\u00e1ci\u00f3t mutatnak. Igyekezz\u00fcnk ezt elker\u00fclni, ahogy az ORM t\u00e9mak\u00f6r\u00e9ben megtanultuk, k\u00e9nyelmesebb \u00e9s biztons\u00e1gosabb az objektumorient\u00e1lt lek\u00e9pz\u00e9s. Az el\u0151z\u0151 p\u00e9ld\u00e1ban BsonDocument t\u00edpus\u00fa dokumentumot haszn\u00e1lunk. A BsonDocument egy \u00e1ltal\u00e1nos dokumentum reprezent\u00e1ci\u00f3, amiben kulcs-\u00e9rt\u00e9k p\u00e1rokat t\u00e1rolhatunk. Haszn\u00e1lata k\u00e9nyelmetlen \u00e9s nem t\u00edpusbiztos, ez\u00e9rt \u00e1ltal\u00e1ban nem ezt a megold\u00e1st haszn\u00e1ljuk. A javasolt megold\u00e1st l\u00e1sd hamarosan. A gy\u0171jtem\u00e9nyt reprezent\u00e1l\u00f3 v\u00e1ltoz\u00f3n tudunk tov\u00e1bbi m\u0171veleteket futtatni, p\u00e9ld\u00e1ul besz\u00farunk egy dokumentumot, majd list\u00e1zzuk a gy\u0171jtem\u00e9ny tartalm\u00e1t. A gy\u0171jtem\u00e9ny els\u0151 haszn\u00e1latkor automatikusan l\u00e9tre fog j\u00f6nni, azaz semmilyen m\u00f3don nem sz\u00fcks\u00e9ges defini\u00e1lnunk. collection . InsertOne ( new BsonDocument () { { \"name\" , \"Apple\" }, { \"categoryName\" , \"Apple\" }, { \"price\" , 123 } }); // minden dokumentum list\u00e1z\u00e1sa: sz\u00fcks\u00e9g van egy sz\u0171r\u00e9si felt\u00e9telre, ami itt // egy \u00fcres felt\u00e9tel, azaz minden dokumentumra illeszkedik var list = collection . Find ( new BsonDocument ()). ToList (); foreach ( var l in list ) Console . WriteLine ( l ); Elnevez\u00e9si konvenci\u00f3 A dokumentumban a kulcs nevek konvenci\u00f3 szerint kisbet\u0171vel kezd\u0151dnek, mint price vagy categoryName (ez az un. camel case \u00edr\u00e1sm\u00f3d). Ez a szok\u00e1s a MongoDB vil\u00e1g\u00e1nak megfelel\u0151 szeml\u00e9let historikus okokb\u00f3l. Hacsak nincs j\u00f3 okunk r\u00e1, ne t\u00e9rj\u00fcnk el ett\u0151l.","title":"Gy\u0171jtem\u00e9nyek kezel\u00e9se"},{"location":"jegyzet/mongodb/#dokumentumok-lekepzese-c-objektumokra","text":"Ahogy a rel\u00e1ci\u00f3s adatb\u00e1zisokn\u00e1l l\u00e1thattuk az objektum-rel\u00e1ci\u00f3s lek\u00e9pz\u00e9st, MongoDB eset\u00e9n is c\u00e9lszer\u0171 objektumokkal \u00e9s oszt\u00e1lyokkal dolgoznunk. A MongoDB .NET drivere ezt teljes m\u00e9rt\u00e9kben biztos\u00edtja sz\u00e1munkra. Els\u0151 l\u00e9p\u00e9sk\u00e9nt defini\u00e1lnunk kell a C# oszt\u00e1lyt, ill. oszt\u00e1lyokat, amikre az adatb\u00e1zis tartalm\u00e1t lek\u00e9pezz\u00fck. Mivel itt nincs az adatb\u00e1zisnak \u00e9s t\u00e1bl\u00e1nak s\u00e9m\u00e1ja, nem tudjuk a s\u00e9ma alapj\u00e1n ger\u00e1lni a C# k\u00f3dot (mint Entity Framework eset\u00e9n csin\u00e1ltuk). \u00cdgy ebben a vil\u00e1gban ink\u00e1bb a Code First elvet k\u00f6vetj\u00fck, azaz a C# k\u00f3dot k\u00e9sz\u00edtj\u00fck el, \u00e9s abb\u00f3l k\u00e9sz\u00fcl az adatb\u00e1zis \u00e9s gy\u0171jtem\u00e9ny (hab\u00e1r tudjuk, hogy itt nincs sz\u00f3 az oszt\u00e1ly alapj\u00e1n t\u00e1bl\u00e1k l\u00e9trehoz\u00e1s\u00e1r\u00f3l). Defini\u00e1ljuk a Term\u00e9kek reprezent\u00e1l\u00e1shoz az al\u00e1bbi oszt\u00e1lyokat. public class Product { public ObjectId Id { get ; set ; } // ez lesz az els\u0151dleges kulcs helyett az _id azonos\u00edt\u00f3 public string Name { get ; set ; } public float Price { get ; set ; } public int Stock { get ; set ; } public string [] Categories { get ; set ; } // t\u00f6mb \u00e9rt\u00e9k\u0171 mez\u0151 public VAT VAT { get ; set ; } // be\u00e1gyaz\u00e1st alkalmazunk } public class VAT // mivel ez be\u00e1gyazott entit\u00e1s, \u00edgy nem adunk neki egyedi azonos\u00edt\u00f3t { public string VATCategoryName { get ; set ; } public float Percentage { get ; set ; } } Figyelj\u00fck meg, hogy kor\u00e1bban price n\u00e9ven haszn\u00e1ltuk a dokumentumban a kulcsot, de a C# oszt\u00e1lyban az un. Pascal Case szerint nagybet\u0171vel kezdj\u00fck: Price . A MongoDB .NET drivere be\u00e9p\u00fcl a C# nyelvbe \u00e9s a .NET k\u00f6rnyezetbe, \u00e9s annak szok\u00e1sait tiszteletben tartja, \u00edgy az oszt\u00e1ly defin\u00edci\u00f3ban szerepl\u0151 mez\u0151 nevek \u00e9s a MongoDB dokumentumaiban a kulcsok lek\u00e9pz\u00e9se automatikusan meg fog t\u00f6rt\u00e9nni, a Price oszt\u00e1ly tulajdons\u00e1gb\u00f3l price kulcs n\u00e9v lesz a dokumentumban.","title":"Dokumentumok lek\u00e9pz\u00e9se C# objektumokra"},{"location":"jegyzet/mongodb/#a-lekepzes-testreszabasa","text":"A C# oszt\u00e1ly - MongoDB dokumentum lek\u00e9pz\u00e9s automatikus, de testreszabhat\u00f3. Amennyiben el szeretn\u00e9nk t\u00e9rni az alap konvenci\u00f3kt\u00f3l, t\u00f6bb f\u00e9le m\u00f3don is megtehetj\u00fck. A legegyszer\u0171bb, ha az oszt\u00e1ly defin\u00edci\u00f3j\u00e1ban attrib\u00fatumokkal jel\u00f6lj\u00fck a testreszab\u00e1st: public class Product { // _id mez\u0151re k\u00e9pz\u0151dik le [BsonId] public ObjectId Azonosito { get ; set ; } // megadhatjuk a MongoDB dokumentumban haszn\u00e1latos nevet [BsonElement(\"price\")] public string Ar { get ; set ; } // kihagyhatunk egyes mez\u0151ket [BsonIgnore] public string NemMentett { get ; set ; } } M\u00e1sik lehet\u0151s\u00e9g\u00fcnk magasabb szinten un. konvenci\u00f3-csomagokat beregisztr\u00e1lni. A konvenci\u00f3-csomagok \u00e1ltal\u00e1nosan le\u00edrj\u00e1k, hogyan t\u00f6rt\u00e9njen a lek\u00e9pez\u00e9s. (Az alap viselked\u00e9s is egy konvenci\u00f3-csomag alapj\u00e1n defini\u00e1lt.) P\u00e9ld\u00e1ul az al\u00e1bbiakkal megadhatjuk, hogy camel case-re szeretn\u00e9nk a mez\u0151 neveket lek\u00e9pezni, valamint a default \u00e9rt\u00e9kkel rendelkez\u0151 adattagokat (C# nyelv szerint defini\u00e1lt default \u00e9rt\u00e9k) szeretn\u00e9nk kihagyni a dokumentumb\u00f3l. // konvenci\u00f3k defini\u00e1l\u00e1sa var pack = new ConventionPack (); pack . Add ( new CamelCaseElementNameConvention ()); pack . Add ( new IgnoreIfDefaultConvention ( true )); // konvenci\u00f3k beregisztr\u00e1l\u00e1sa // az els\u0151 param\u00e9ter egy n\u00e9v // az utols\u00f3 param\u00e9terrel sz\u0171r\u00e9si felt\u00e9telt adhatunk meg, hol haszn\u00e1land\u00f3ak a konvenci\u00f3k ConventionRegistry . Register ( \"adatvez\" , pack , t => true ); Enn\u00e9l bonyolultabb testreszab\u00e1sokra is lehet\u0151s\u00e9g\u00fcnk van, p\u00e9ld\u00e1ul defini\u00e1lhatunk konverzi\u00f3s logik\u00e1t a C# reprezent\u00e1ci\u00f3 \u00e9s a MongoDB reprezent\u00e1ci\u00f3 k\u00f6z\u00f6tti ford\u00edt\u00e1shoz, illetve megadhatjuk a lesz\u00e1rmaz\u00e1si hierarchia ment\u00e9s\u00e9nek m\u00f3dj\u00e1t. Ezekr\u0151l r\u00e9szletesebben a hivatalos dokument\u00e1ci\u00f3ban: https://mongodb.github.io/mongo-csharp-driver/2.8/reference/bson/serialization/ .","title":"A lek\u00e9pz\u00e9s testreszab\u00e1sa"},{"location":"jegyzet/mongodb/#lekerdezesek","text":"A tov\u00e1bbiakban a t\u00edpusos, Product oszt\u00e1lyra lek\u00e9pz\u0151 m\u00f3don haszn\u00e1ljuk a gy\u0171jtem\u00e9nyt, \u00e9s \u00edgy v\u00e9gz\u00fcnk m\u0171veletet. Ez a javasolt megold\u00e1s, a BsonDocument alap\u00fa megold\u00e1st csak sz\u00fcks\u00e9g eset\u00e9n haszn\u00e1ljuk. A legegyszer\u0171bb lek\u00e9rdez\u00e9st m\u00e1r l\u00e1thattuk, list\u00e1zzunk minden dokumentumot: var collection = db . GetCollection < Product >( \"products\" ); var lista = collection . Find ( new BsonDocument ()). ToList (); foreach ( var p in lista ) Console . WriteLine ( $ \"Id: {p.Id}, Name: {p.Name}\" ); A list\u00e1z\u00e1s a Find met\u00f3dussal t\u00f6rt\u00e9nik. Az elnevez\u00e9s j\u00f3l mutatja a MongoDB filoz\u00f3fi\u00e1j\u00e1t: az adatb\u00e1zis keres\u00e9sre val\u00f3, minden elem list\u00e1z\u00e1sa nem praktikus, ez\u00e9rt nincs is r\u00e1 egyszer\u0171 szintaktika. A Find egy keres\u00e9si felt\u00e9telt v\u00e1r, ami itt egy \u00fcres felt\u00e9tel, azaz mindenre illeszkedik. A keres\u00e9si felt\u00e9telt t\u00f6bb f\u00e9le m\u00f3don le\u00edrhatjuk. A BsonDocument alap\u00fa sz\u0171r\u00e9sben nyersen, a MongoDB szintaktik\u00e1ja szerint kell meg\u00edrni a sz\u0171r\u00e9si felt\u00e9telt. Erre lehet\u0151s\u00e9g\u00fcnk van ugyan, de elker\u00fclj\u00fck, mert a MongoDB .NET drivere ezt megoldja sz\u00e1munkra, ha az al\u00e1bbiak szerint adjuk meg a keres\u00e9si felt\u00e9telt. A legt\u00f6bb esetben egy Lambda-kifejez\u00e9ssel le\u00edrhatjuk a felt\u00e9telt. collection . Find ( x => x . Price < 123 ); Ilyenkor a Lambda-kifejez\u00e9s egy Predicate<T> t\u00edpus\u00fa delegate, azaz a megadott oszt\u00e1lyt\u00edpuson (itt: Product ) fogalmazzuk meg, \u00e9s bool visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171. Teh\u00e1t a fenti p\u00e9ld\u00e1ban az x v\u00e1ltoz\u00f3 egy Product objektumot reprezent\u00e1l. Ez a keres\u00e9s m\u0171k\u00f6dik term\u00e9szetesen bonyolultabb esetekre is. collection . Find ( x => x . Price < 123 && x . Name . Contains ( \"red\" )); A Lambda kifejez\u00e9sekkel le\u00edrt sz\u0171r\u00e9si felt\u00e9telek elrejtik, hogy a MongoDB-ben val\u00f3j\u00e1ban milyen keres\u00e9si felt\u00e9teleink is vannak. P\u00e9ld\u00e1ul az el\u0151bbi Contains keres\u00e9si felt\u00e9tel egy regul\u00e1ris kifejez\u00e9ssel val\u00f3 keres\u00e9st fog val\u00f3j\u00e1ban jelenteni. A MongoDB saj\u00e1t nyelv\u00e9n az el\u0151bbi sz\u0171r\u00e9s \u00edgy n\u00e9z ki: { \"price\" : { \"$lt\" : 123.0 }, \"name\" : \"/red/s\" } Vegy\u00fck \u00e9szre, hogy ez a fajta le\u00edr\u00e1s \u00f6nmaga is egy dokumentum. Ha saj\u00e1t magunk akarn\u00e1nk meg\u00edrni a sz\u0171r\u00e9si felt\u00e9telt, akkor egy BsonDocument -ben kellene ezt a dokumentumot \u00f6ssze\u00e1ll\u00edtanunk. A sz\u0171r\u00e9si felt\u00e9telt le\u00edr\u00f3 dokumentum kulcsai a sz\u0171r\u00e9shez haszn\u00e1lt mez\u0151k, az \u00e9rt\u00e9k pedig a sz\u0171r\u00e9si felt\u00e9tel. A felt\u00e9tel bizonyos esetekben egy skal\u00e1r \u00e9rt\u00e9k, mint a regul\u00e1ris kifejez\u00e9s (vagy ha egyenl\u0151s\u00e9gre sz\u0171rn\u00e9nk), m\u00e1s esetekben a felt\u00e9tel egy be\u00e1gyazott dokumentum, mint a < felt\u00e9tel eset\u00e9n. Ebben az $lt kulcs egy speci\u00e1lis kulcs, azt jel\u00f6li, hogy a less than oper\u00e1torral kell a ki\u00e9rt\u00e9kel\u00e9s v\u00e9gezni, \u00e9s az oper\u00e1tor jobb oldal\u00e1n a 123.0 \u00e9rt\u00e9k \u00e1ll. A regul\u00e1ris kifejez\u00e9st a JavaScript RegExp szintaktika szerint kell megadni. Az ilyen m\u00f3don felsorolt felt\u00e9telek automatikusan \u00e9s kapcsolatba ker\u00fclnek. A Lambda-kifejez\u00e9s helyett egy hasonl\u00f3 le\u00edr\u00e1st magunk is el\u0151\u00e1ll\u00edthatunk an\u00e9lk\u00fcl, hogy sz\u00f6veges form\u00e1ban kellene \u00f6ssze\u00e1ll\u00edtanunk a sz\u0171r\u00e9si felt\u00e9telt. A MongoDB .NET drivere lehet\u0151s\u00e9get ad nek\u00fcnk arra, hogy egy un. builder seg\u00edts\u00e9g\u00e9vel \u00e9p\u00edts\u00fck fel a sz\u0171r\u00e9si felt\u00e9telt. collection . Find ( Builders < Product >. Filter . And ( Builders < Product >. Filter . Lt ( x => x . Price , 123 ), Builders < Product >. Filter . Regex ( x => x . Name , \"/red/s\" ), ) ); A fenti szintaktikai kicsit b\u0151besz\u00e9d\u0171bb ugyan, mint a Lambda-kifejez\u00e9s, de k\u00f6zelebb \u00e1ll a MongoDB vil\u00e1g\u00e1hoz, \u00e9s jobban le\u00edrja, mit is szeretn\u00e9nk val\u00f3j\u00e1ban. Tekinthet\u00fcnk erre a szintaktik\u00e1ra \u00fagy, mint az SQL nyelvre: deklarat\u00edv, c\u00e9lorient\u00e1lt, de a platform k\u00e9pess\u00e9geit szem el\u0151tt tart\u00f3 le\u00edr\u00e1s. Emellett azonban t\u00edpusbiztos is. A Builders<T> generikus oszt\u00e1ly egy seg\u00e9doszt\u00e1ly, amivel sz\u0171r\u00e9si, \u00e9s k\u00e9s\u0151bb l\u00e1tni fogjuk, egy\u00e9b MongoDB specifikus defin\u00edci\u00f3kat \u00e9p\u00edthet\u00fcnk fel. A Builders<Product>.Filter a Product C# oszt\u00e1lyhoz illeszked\u0151 sz\u0171r\u00e9si felt\u00e9telek defini\u00e1l\u00e1s\u00e1ra haszn\u00e1lhat\u00f3. El\u0151sz\u00f6r egy \u00e9s kapcsolatot hozunk l\u00e9tre, amelyen bel\u00fcl k\u00e9t sz\u0171r\u00e9si felt\u00e9tel\u00fcnk lesz. Az oper\u00e1torok a kor\u00e1bban l\u00e1tott less than \u00e9s a regul\u00e1ris kifejez\u00e9s. Ezen f\u00fcggv\u00e9nyeknek k\u00e9t param\u00e9tert adunk \u00e1t: a mez\u0151t, amire sz\u0171rni szeretn\u00e9nk, \u00e9s az operandust. Expression szintaktika Vegy\u00fck \u00e9szre, hogy se itt, se a Lambda-kifejez\u00e9sekben nem haszn\u00e1ltunk string alap\u00fa mez\u0151neveket, mindenhol ugyanazzal a szintaktik\u00e1val (ez a C# Expression ) az oszt\u00e1lydefin\u00edci\u00f3ra hivatkoztunk. Ez az\u00e9rt praktikus \u00edgy, mert elker\u00fclj\u00fck a mez\u0151nevek elg\u00e9pel\u00e9s\u00e9t. Val\u00f3j\u00e1ban mindegyik le\u00edr\u00e1s, amit haszn\u00e1ltunk, ugyanazt a sz\u0171r\u00e9si felt\u00e9telt jelenti. A MongoDB driver mindegyik szintaktik\u00e1t lek\u00e9pezi a saj\u00e1t bels\u0151 reprezent\u00e1ci\u00f3j\u00e1v\u00e1. A Lambda-kifejez\u00e9s alap\u00fa kevesebb karaktert ig\u00e9nyel, \u00e9s jobban illeszkedik a C# nyelvbe, m\u00edg az ut\u00f3bbi a MongoDB saj\u00e1toss\u00e1gainak kifejez\u00e9s\u00e9re val\u00f3. B\u00e1rmelyiket haszn\u00e1lhatjuk.","title":"Lek\u00e9rdez\u00e9sek"},{"location":"jegyzet/mongodb/#lekerdezes-eredmenyenek-felhasznalasa","text":"A collection.Find(...) f\u00fcggv\u00e9ny eredm\u00e9nye m\u00e9g nem az eredm\u00e9nyhalmaz, hanem csak egy le\u00edr\u00f3 a lek\u00e9rdez\u00e9s v\u00e9grehajt\u00e1s\u00e1hoz. Az eredm\u00e9ny \u00e1ltal\u00e1ban h\u00e1rom f\u00e9le m\u00f3don k\u00e9rhet\u0151 le \u00e9s dolgozhat\u00f3 fel.","title":"Lek\u00e9rdez\u00e9s eredm\u00e9ny\u00e9nek felhaszn\u00e1l\u00e1sa"},{"location":"jegyzet/mongodb/#listazas","text":"K\u00e9rj\u00fck a teljes eredm\u00e9nyhalmazt egy listak\u00e9nt: collection.Find(...).ToList() .","title":"List\u00e1z\u00e1s"},{"location":"jegyzet/mongodb/#elsoegyetlen-elem-lekerese","text":"Amennyiben csak az els\u0151 elemre van sz\u00fcks\u00e9g\u00fcnk, vagy tudjuk, hogy csak egy elem lesz, akkor haszn\u00e1lhatjuk a collection.Find(...).First() , .FirstOrDefault() , vagy .Single() , .SingleOrDefault() f\u00fcggv\u00e9nyeket.","title":"Els\u0151/egyetlen elem lek\u00e9r\u00e9se"},{"location":"jegyzet/mongodb/#kurzor","text":"Ha az eredm\u00e9nyhalmaz sok dokumentumot tartalmaz, c\u00e9lszer\u0171 kurzorral feldolgozni. A MongoDB limit\u00e1lja a lek\u00e9rdez\u00e9sre adott v\u00e1lasz m\u00e9ret\u00e9t, ez\u00e9rt ha t\u00fal sok dokumentumot k\u00e9rdez\u00fcnk le, el\u0151fordulhat, hogy az eredm\u00e9ny helyett hib\u00e1t fogunk kapni. Ennek felold\u00e1s\u00e1ra haszn\u00e1ljuk a kurzorokat, ahol mindig csak egy r\u00e9szhalmaz\u00e1t kapjuk a dokumentumoknak. var cur = collection . Find (...). ToCursor (); while ( cur . MoveNext ()) // kurzor l\u00e9ptet\u00e9se { foreach ( var t in cur . Current ) // a kurzor aktu\u00e1lis eleme nem egy dokumentum, hanem egy lista { ... } }","title":"Kurzor"},{"location":"jegyzet/mongodb/#szureshez-hasznalhato-operatorok","text":"A sz\u0171r\u00e9si felt\u00e9telek a dokumentumban tal\u00e1lhat\u00f3 mez\u0151kre vonatkoznak, \u00e9s a sz\u0171r\u00e9si felt\u00e9tel mindig egy konstans. Teh\u00e1t nem lehets\u00e9ges p\u00e9ld\u00e1ul k\u00e9t mez\u0151t \u00f6sszehasonl\u00edtani , \u00e9s nem tudunk m\u00e1s gy\u0171jtem\u00e9nyekre se hivatkozni. L\u00e9tezik a MongoDB-ben egy un. aggreg\u00e1ci\u00f3s pipeline, amely seg\u00edts\u00e9g\u00e9vel bonyolultabb lek\u00e9rdez\u00e9seket is megfogalmazhatunk, most viszont az egyszer\u0171 lek\u00e9rdez\u00e9sekre koncentr\u00e1lunk. A sz\u0171r\u00e9si felt\u00e9tel teh\u00e1t a dokumentum egy mez\u0151j\u00e9t egy \u00e1ltalunk megadott konstanshoz hasonl\u00edtja. Az al\u00e1bbi lehet\u0151s\u00e9gek a leggyakrabban haszn\u00e1ltak.","title":"Sz\u0171r\u00e9shez haszn\u00e1lhat\u00f3 oper\u00e1torok"},{"location":"jegyzet/mongodb/#osszehasonlitasi-operatorok","text":"collection . Find ( x => x . Price == 123 ); collection . Find ( Builders < Product >. Filter . Eq ( x => x . Price , 123 )); //Eq, mint equals collection . Find ( x => x . Price != 123 ); collection . Find ( Builders < Product >. Filter . Ne ( x => x . Price , 123 )); // Ne, mint not equals collection . Find ( x => x . Price >= 123 ); collection . Find ( Builders < Product >. Filter . Gte ( x => x . Price , 123 )); // Gte, mint greater than or equal to collection . Find ( x => x . Price < 123 ); collection . Find ( Builders < Product >. Filter . Lt ( x => x . Price , 123 )); // Lt, mint less than","title":"\u00d6sszehasonl\u00edt\u00e1si oper\u00e1torok"},{"location":"jegyzet/mongodb/#logikai-operatorok","text":"collection . Find ( x => x . Price > 500 && x . Price < 1000 ); collection . Find ( Builders < Product >. Filter . And ( Builders < Product >. Filter . Gt ( x => x . Price , 500 ), Builders < Product >. Filter . Lt ( x => x . Price , 1000 ) ) ); collection . Find ( x => x . Price < 500 || x . Stock < 10 ); collection . Find ( Builders < Product >. Filter . Or ( Builders < Product >. Filter . Lt ( x => x . Price , 500 ), Builders < Product >. Filter . Lt ( x => x . Stock , 10 ) ) ); collection . Find ( x => !( x . Price < 500 || x . Stock < 10 )); collection . Find ( Builders < Product >. Filter . Not ( Builders < Product >. Filter . Or ( Builders < Product >. Filter . Lt ( x => x . Price , 500 ), Builders < Product >. Filter . Lt ( x => x . Stock , 10 ) ) ) );","title":"Logikai oper\u00e1torok"},{"location":"jegyzet/mongodb/#tobb-ertek-kozul-valamelyikkel-megegyezo","text":"collection . Find ( x => x . Id == ... || x . Id = ...); collection . Find ( Builders < Product >. Filter . In ( x => x . Id , new [] { ... })); // hasonl\u00f3an l\u00e9tezik a Nin, mint not in oper\u00e1tor","title":"T\u00f6bb \u00e9rt\u00e9k k\u00f6z\u00fcl valamelyikkel megegyez\u0151"},{"location":"jegyzet/mongodb/#ertek-letezik-nem-null","text":"collection . Find ( x => x . VAT != null ); collection . Find ( Builders < Product >. Filter . Exists ( x => x . VAT )); L\u00e9tezik-e A l\u00e9tezik-e, azaz nem null sz\u0171r\u00e9s az\u00e9rt k\u00fcl\u00f6nleges, mert a MongoDB szempontj\u00e1b\u00f3l k\u00e9t m\u00f3don is lehet null egy \u00e9rt\u00e9k: ha a kulcs l\u00e9tezik a dokumentumban \u00e9s \u00e9rt\u00e9ke null; avagy, ha a kulcs nem is l\u00e9tezik.","title":"\u00c9rt\u00e9k l\u00e9tezik (nem null)"},{"location":"jegyzet/mongodb/#szures-beagyazott-dokumentum-mezojere","text":"A MongoDB szempontj\u00e1b\u00f3l a be\u00e1gyazott dokumentumok ugyan\u00fagy haszn\u00e1lhat\u00f3k sz\u0171r\u00e9sre, teh\u00e1t az al\u00e1bbiak mind \u00e9rv\u00e9nyesek, \u00e9s az se okoz gondot, ha a be\u00e1gyaztott dokumentum (a p\u00e9ld\u00e1kban az VAT nem l\u00e9tezik): collection . Find ( x => x . VAT . Percentage < 27 ); collection . Find ( Builders < Product >. Filter . Lt ( x => x . VAT . Percentage , 27 )); collection . Find ( Builders < Product >. Filter . Exists ( x => x . VAT . Percentage , exists : false )); // ez a nem l\u00e9tezik, azaz null sz\u0171r\u00e9s","title":"Sz\u0171r\u00e9s be\u00e1gyazott dokumentum mez\u0151j\u00e9re"},{"location":"jegyzet/mongodb/#szures-tomb-erteku-mezore","text":"A dokumentum b\u00e1rmely mez\u0151je lehet t\u00f6mb \u00e9rt\u00e9k\u0171, mint a p\u00e9ld\u00e1ban a string[] Categories . MongoDB-ben a t\u00f6mb\u00f6kkel is egyszer\u0171en tudunk dolgozni, az Any* sz\u0171r\u00e9si felt\u00e9telekkel. // azon term\u00e9keket, amelyek a jelzett kateg\u00f3ri\u00e1ban vannak collection . Find ( Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" )); // azon term\u00e9keket, amelyek legal\u00e1bb egy olyan kateg\u00f3ri\u00e1hoz tartoznak, amelyet nem soroltunk fel collection . Find ( Builders < Product >. Filter . AnyNin ( x => x . Categories , new [] { \"Labd\u00e1k\" , \"\u00dct\u0151k\" })); Any... Az Any* felt\u00e9telek a t\u00f6mb minden elem\u00e9t vizsg\u00e1lj\u00e1k, de a dokumentum szempontj\u00e1b\u00f3l csak egyszer illeszkednek. Teh\u00e1t, ha a t\u00f6mb t\u00f6bb eleme is illeszkedik egy felt\u00e9telre, att\u00f3l m\u00e9g csak egyszer kapjuk meg a dokumentumot az eredm\u00e9nyhalmazban.","title":"Sz\u0171r\u00e9s t\u00f6mb \u00e9rt\u00e9k\u0171 mez\u0151re"},{"location":"jegyzet/mongodb/#lekerdezes-vegrehajto-pipeline","text":"A MongoDB lek\u00e9rdez\u00e9sek egy un. pipeline-on haladnak v\u00e9gig. Ennek r\u00e9szleteivel nem fogunk megismerkedni, de az egyszer\u0171 sz\u0171r\u00e9seken k\u00edv\u00fcl p\u00e1r tov\u00e1bbi, lek\u00e9rdez\u00e9sekben haszn\u00e1lt elemet fogunk l\u00e1tni.","title":"Lek\u00e9rdez\u00e9s-v\u00e9grehajt\u00f3 pipeline"},{"location":"jegyzet/mongodb/#lapozas-rendezes","text":"A lapoz\u00e1shoz megadatjuk, maxim\u00e1lisan h\u00e1ny illeszked\u0151 dokumentumot k\u00e9r\u00fcnk: collection . Find (...). Limit ( 100 ); A k\u00f6vetkez\u0151 lapon tal\u00e1lhat\u00f3 elemekhez pedig kihagyjuk az els\u0151 lapon m\u00e1r l\u00e1tott elemeket: collection . Find (...). Skip ( 100 ). Limit ( 100 ); A Skip \u00e9s Limit ebben a form\u00e1ban nem \u00e9rtelmes, ugyanis rendez\u00e9s n\u00e9lk\u00fcl az \"els\u0151 100 elem\" lek\u00e9rdez\u00e9s (a kliens sz\u00e1m\u00e1ra) nem determinisztikus. Teh\u00e1t az ilyen jelleg\u0171 lek\u00e9rdez\u00e9sekhez sz\u00fcks\u00e9ges, hogy egy megfelel\u0151 rendez\u00e9st is megadjunk. A rendez\u00e9s defini\u00e1l\u00e1sa a kor\u00e1bban m\u00e1r l\u00e1tott Builders<T> seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik. collection . Find (...) . Sort ( Builders < Product >. Sort . Ascending ( x => x . Name )) . Skip ( 100 ). Limit ( 100 ); Lapoz\u00e1si probl\u00e9ma A fenti lapoz\u00e1s m\u00e9g mindig nem teljesen helyes. P\u00e9ld\u00e1ul, ha a k\u00e9t lap lek\u00e9rdez\u00e9se k\u00f6zben egy term\u00e9k t\u00f6rl\u00e9sre ker\u00fcl, akkor \"eggyel arr\u00e9bb cs\u00fasznak\" a term\u00e9kek, \u00e9s lesz egy term\u00e9k, amely kimarad a k\u00f6vetkez\u0151 lapoz\u00e1sn\u00e1l. Ez nem csak a MongoDB probl\u00e9m\u00e1ja. Gondolkodtat\u00f3 feladat: hogyan oldhat\u00f3 meg ez a probl\u00e9ma?","title":"Lapoz\u00e1s, rendez\u00e9s"},{"location":"jegyzet/mongodb/#darabszam-lekerdezes","text":"A lek\u00e9rdez\u00e9sre illeszked\u0151 dokumentumok sz\u00e1m\u00e1t k\u00e9t f\u00e9le m\u00f3don is lek\u00e9rdezhetj\u00fck: collection . CountDocuments ( Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" )); collection . Find ( Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" )). CountDocuments ();","title":"Darabsz\u00e1m lek\u00e9rdez\u00e9s"},{"location":"jegyzet/mongodb/#csoportositas","text":"A csoportos\u00edt\u00e1s szintaktikailag bonyolult m\u0171velet. A csoportos\u00edt\u00e1shoz egy aggreg\u00e1ci\u00f3s pipeline-t kell defini\u00e1lnunk. Ezzel r\u00e9szletesebben nem foglalkozunk, az al\u00e1bbi p\u00e9lda mutatja a haszn\u00e1lat\u00e1t. // A \"Labd\u00e1k\" kateg\u00f3ri\u00e1ba tartoz\u00f3 term\u00e9kek az \u00c1FA kulcs szerint csoportos\u00edtva foreach ( var g in collection . Aggregate () . Match ( Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" )) // sz\u0171r\u00e9s . Group ( x => x . VAT . Percentage , x => x ) // csoportos\u00edt\u00e1s . ToList ()) { Console . WriteLine ( $ \"VAT percentage: {g.Key}\" ); foreach ( var p in g ) Console . WriteLine ( $ \"\\tProduct: {p.Name}\" ); }","title":"Csoportos\u00edt\u00e1s"},{"location":"jegyzet/mongodb/#beszuras-modositas-torles","text":"A lek\u00e9rdez\u00e9sek ut\u00e1n ismerkedj\u00fcnk meg az adatm\u00f3dos\u00edt\u00e1sokkal.","title":"Besz\u00far\u00e1s, m\u00f3dos\u00edt\u00e1s, t\u00f6rl\u00e9s"},{"location":"jegyzet/mongodb/#uj-dokumentum-beszurasa","text":"\u00daj dokumentum besz\u00far\u00e1s\u00e1hoz az \u00faj dokumentumot reprezent\u00e1l\u00f3 objektumra van sz\u00fcks\u00e9g\u00fcnk. Ezt a gy\u0171jtem\u00e9nyhez tudjuk hozz\u00e1adni. var newProduct = new Product { Name = \"Alma\" , Price = 890 , Categories = new [] { \"Gy\u00fcm\u00f6lcs\u00f6k\" } }; collection . InsertOne ( newProduct ); Console . WriteLine ( $ \"Besz\u00fart rekord id: {newProduct.Id}\" ); // besz\u00far\u00e1s ut\u00e1n friss\u00edt\u00e9sre ker\u00fcl a C# objektum, \u00e9s lek\u00e9rdezhet\u0151 az Id-ja Figyelj\u00fck meg, hogy az Id mez\u0151t nem t\u00f6lt\u00f6tt\u00fck ki. Ezt a kliens oldali driver p\u00f3tolni fogja. Ha akarjuk, mi is adhatunk neki \u00e9rt\u00e9ket, de nem szok\u00e1s. Eml\u00e9kezz\u00fcnk r\u00e1, hogy a MongoDB-ben nincs s\u00e9ma, \u00edgy a besz\u00fart dokumentum lehet teljesen elt\u00e9r\u0151 a gy\u0171jtem\u00e9nyben tal\u00e1lhat\u00f3 t\u00f6bbi elemt\u0151l. Illetve figyelj\u00fck meg, hogy nem adtunk minden mez\u0151nek \u00e9rt\u00e9ket. Mivel nincsenek integrit\u00e1si krit\u00e9riumok, \u00edgy minden besz\u00far\u00e1s sikerrel fog j\u00e1rni, viszont a lek\u00e9rdez\u00e9sn\u00e9l lehetnek bel\u0151le probl\u00e9m\u00e1k (pl. ha felt\u00e9telezz\u00fck, hogy a rakt\u00e1rk\u00e9szlet mindig ki van t\u00f6ltve). T\u00f6bb dokumentum besz\u00far\u00e1s\u00e1ra az InsertMany f\u00fcggv\u00e9ny haszn\u00e1lhat\u00f3, azonban ne felejtkezz\u00fcnk el arr\u00f3l, hogy nincsenek tranzakci\u00f3k, \u00edgy a t\u00f6bb dokumentum besz\u00far\u00e1sa egyenk\u00e9nt f\u00fcggetlen m\u0171velet. Ha a besz\u00far\u00e1sok v\u00e9grehajt\u00e1sa k\u00f6zben valamely okb\u00f3l hiba t\u00f6rt\u00e9nik, az addig sikeresen besz\u00fart dokumentumok az adatb\u00e1zisban maradnak. Az egyes dokumentumok azonban atomi m\u00f3don ker\u00fclnek ment\u00e9sre, teh\u00e1t egy hiba sor\u00e1n se ker\u00fclhet egy \"f\u00e9l\" dokumentum az adatb\u00e1zisba.","title":"\u00daj dokumentum besz\u00far\u00e1sa"},{"location":"jegyzet/mongodb/#dokumentumok-torlese","text":"A t\u00f6rl\u00e9shez egy sz\u0171r\u00e9si felt\u00e9telt kell defini\u00e1lnunk, \u00e9s vagy a DeleteOne , vagy a DeleteMany f\u00fcggv\u00e9nnyel t\u00f6r\u00f6lhet\u00fcnk. A k\u00fcl\u00f6nbs\u00e9g, hogy a DeleteOne az els\u0151 illeszked\u0151 dokumentumot t\u00f6rli csak, m\u00edg a DeleteMany az \u00f6sszeset. Ha tudjuk, hogy a felt\u00e9telnek csak egy dokumentum felelhet meg (p\u00e9ld\u00e1ul id alapj\u00e1n t\u00f6rl\u00fcnk), akkor \u00e9rdemes a DeleteOne -t haszn\u00e1lni, mert az adatb\u00e1zisnak nem kell kimer\u00edt\u0151 keres\u00e9st v\u00e9geznie. A t\u00f6rl\u00e9s felt\u00e9tele a keres\u00e9sn\u00e9l megismert szintaktik\u00e1kkal \u00edrhat\u00f3 le. A t\u00f6rl\u00e9s teh\u00e1t elt\u00e9r az Entity Framework eset\u00e9n tapasztalhat\u00f3 viselked\u00e9sr\u0151l. Itt nem kell az entit\u00e1snak bet\u00f6ltve lennie, \u00e9s nem az entit\u00e1st t\u00f6r\u00f6lj\u00fck, hanem sz\u0171r\u00e9si felt\u00e9tellel \u00edrjuk le a t\u00f6rl\u00e9st. var deleteResult = collection . DeleteOne ( x => x . Id == new ObjectId ( \"...\" )); Console . WriteLine ( $ \"T\u00f6r\u00f6lve: {deleteResult.DeletedCount} db\" ); Ha szeretn\u00e9nk a t\u00f6r\u00f6lt elemet megkapni, akkor haszn\u00e1lhatjuk a FindOneAndDelete -t, amely visszaadja a t\u00f6r\u00f6lt entit\u00e1st mag\u00e1t.","title":"Dokumentumok t\u00f6rl\u00e9se"},{"location":"jegyzet/mongodb/#dokumentumok-megvaltoztatasa","text":"A MongoDB tal\u00e1n leg\u00e9rdekesebb k\u00e9pess\u00e9gei a dokumentumok megv\u00e1ltoztat\u00e1sa k\u00f6r\u00fcl tal\u00e1lhat\u00f3ak. M\u00edg a kor\u00e1bbiak, a lek\u00e9rdez\u00e9sek, besz\u00far\u00e1sok, t\u00f6rl\u00e9sek a legt\u00f6bb adatb\u00e1zis (ak\u00e1r rel\u00e1ci\u00f3s, ak\u00e1r NoSQL) eset\u00e9n hasonl\u00f3ak, a MongoDB a m\u00f3dos\u00edt\u00f3 m\u0171veletekben j\u00f3val sz\u00e9lesebb spektrumot t\u00e1mogat. Alapvet\u0151en k\u00e9t f\u00e9le m\u00f3don tudunk egy dokumentumot megv\u00e1ltoztatni: lecser\u00e9lni az eg\u00e9sz dokumentumot egy \u00fajra, avagy r\u00e9szeit friss\u00edteni.","title":"Dokumentumok megv\u00e1ltoztat\u00e1sa"},{"location":"jegyzet/mongodb/#dokumentum-teljes-csereje","text":"A dokumentum teljes cser\u00e9j\u00e9hez sz\u00fcks\u00e9g\u00fcnk van egy sz\u0171r\u00e9si felt\u00e9telre, amellyel megadjuk, mely dokumentumot akarjuk cser\u00e9lni; valamint sz\u00fcks\u00e9g\u00fcnk van az \u00faj dokumentumra. var replacementProduct = new Product { Name = \"Alma\" , Price = 890 , Categories = new [] { \"Gy\u00fcm\u00f6lcs\u00f6k\" } }; var replaceResult = collection . ReplaceOne ( x => x . Id == new ObjectId ( \"...\" ), replacementProduct ); Console . WriteLine ( $ \"M\u00f3dos\u00edtva: {replaceResult.ModifiedCount}\" ); Ez a csere 1-1 jelleg\u0171, azaz egy dokumentumot cser\u00e9l\u00fcnk egy dokumentumra. A m\u0171velet mag\u00e1ban atomi, azaz ha menet k\u00f6zben megszakad, akkor se fordulhat el\u0151, hogy egy f\u00e9l dokumentum ker\u00fclt elment\u00e9sre. Ha szeretn\u00e9nk megkapni a csere el\u0151tti dokumentumot, akkor a FindOneAndReplace met\u00f3dust haszn\u00e1lhatjuk. \u00c9rdekess\u00e9g A csere sor\u00e1n lehet\u0151s\u00e9g van a dokumentum id-j\u00e1nak m\u00f3dos\u00edt\u00e1s\u00e1ra is. Ha a csere dokumentumban m\u00e1s id szerepel, a dokumentum id-ja megv\u00e1ltozik.","title":"Dokumentum teljes cser\u00e9je"},{"location":"jegyzet/mongodb/#dokumentum-modosito-operatorok","text":"A dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torokkal atomi m\u00f3don tudunk a dokumentum mez\u0151inek \u00e9rt\u00e9k\u00e9n v\u00e1ltoztatni an\u00e9lk\u00fcl, hogy a teljes dokumentumot lecser\u00e9ln\u00e9nk. A m\u00f3dos\u00edt\u00f3 m\u0171veletek le\u00edr\u00e1s\u00e1hoz a kor\u00e1bban m\u00e1r l\u00e1tott Builders<T> seg\u00edts\u00e9g\u00e9t vessz\u00fck ig\u00e9nybe. \u00c1ll\u00edtsunk be a rakt\u00e1rk\u00e9szletet egy konstans \u00e9rt\u00e9kre: collection . UpdateOne ( filter : x => x . Id == new ObjectId ( \"...\" ), update : Builders < Product >. Update . Set ( x => x . Stock , 5 )); Az UpdateOne f\u00fcggv\u00e9ny els\u0151 param\u00e9tere a sz\u0171r\u00e9si felt\u00e9tel. Le\u00edr\u00e1s\u00e1hoz b\u00e1rmely kor\u00e1bban ismertetett szintaktika haszn\u00e1lhat\u00f3. M\u00e1sodik param\u00e9tere a m\u00f3dos\u00edt\u00f3 m\u0171velet le\u00edr\u00f3ja, amelyet a Builders<T> seg\u00edts\u00e9g\u00e9vel \u00e9p\u00edthet\u00fcnk fel. A fenti p\u00e9ldak\u00f3dban a param\u00e9terek nev\u00e9t is ki\u00edrtuk ( filter: \u00e9s update: ), hogy egy\u00e9rtelm\u0171 legyen, param\u00e9ter mit jelk\u00e9pez. Ez nem k\u00f6telez\u0151, de az olvashat\u00f3s\u00e1got n\u00f6veli (a k\u00f3dsorok hossz\u00e1nak rov\u00e1s\u00e1ra). A m\u00f3dos\u00edt\u00e1s nem csak egy m\u0171veletet tartalmazhat. collection . UpdateOne ( filter : x => x . Id == new ObjectId ( \"...\" ), update : Builders < Product >. Update . Set ( x => x . Stock , 5 ) // rakt\u00e1rk\u00e9szlet legyen 5 . CurrentDate ( x => x . StockUpdated ) // mai d\u00e1tumot be\u00edrjuk, mint a friss\u00edt\u00e1s ideje . Unset ( x => x . NeedsUpdate ) // t\u00f6r\u00f6lj\u00fck a friss\u00edtend\u0151 jelz\u00e9st ); A tipikusan haszn\u00e1lt m\u00f3dos\u00edt\u00f3 oper\u00e1torok: Set : mez\u0151 \u00e9rt\u00e9k\u00e9nek be\u00e1ll\u00edt\u00e1sa; SetOnInsert : mint a Set , de csak \u00faj dokumentum besz\u00far\u00e1sa eset\u00e9n fut le (l\u00e1sd upsert al\u00e1bb); Unset : mez\u0151 t\u00f6rl\u00e9se (a kulcs \u00e9s \u00e9rt\u00e9k elt\u00e1vol\u00edt\u00e1sa a dokumentumb\u00f3l); CurrentDate : aktu\u00e1lis d\u00e1tum be\u00edr\u00e1sa; Inc : \u00e9rt\u00e9k n\u00f6vel\u00e9se; Min , Max : mez\u0151 \u00e9rt\u00e9k\u00e9nek lecser\u00e9l\u00e9se, amennyiben a megadott \u00e9rt\u00e9k kisebb/nagyobb, mint a mez\u0151 jelenlegi \u00e9rt\u00e9ke; Mul : \u00e9rt\u00e9k megszorz\u00e1sa; PopFirst , PopLast : t\u00f6mbb\u0151l els\u0151/utols\u00f3 elem elt\u00e1vol\u00edt\u00e1sa; Pull : t\u00f6mbb\u0151l \u00e9rt\u00e9k elt\u00e1vol\u00edt\u00e1sa; Push : t\u00f6mbh\u00f6z \u00e9rt\u00e9k hozz\u00e1ad\u00e1sa a v\u00e9g\u00e9re (tov\u00e1bbi lehet\u0151s\u00e9gek ugyanebben az oper\u00e1torban: t\u00f6mb sorrendez\u00e9se, t\u00f6mb els\u0151 n elem\u00e9nek megtart\u00e1sa); AddToSet : t\u00f6mbh\u00f6z \u00e9rt\u00e9k hozz\u00e1ad\u00e1sa, ha m\u00e9g nem l\u00e9tezik. A fenti m\u0171veletek akkor is \u00e9rtelmezettek, ha a megadott mez\u0151 nem l\u00e9tezik. Az oper\u00e1tor t\u00edpus\u00e1t\u00f3l f\u00fcgg\u0151en egy alap\u00e9rtelmezett \u00e9rt\u00e9ken v\u00e9gzi a m\u00f3dos\u00edt\u00e1st az adatb\u00e1zis. P\u00e9ld\u00e1ul az Inc \u00e9s Mul eset\u00e9n a mez\u0151 0 \u00e9rt\u00e9ket vesz fel, \u00e9s azon t\u00f6rt\u00e9nik a m\u00f3dos\u00edt\u00e1s. A t\u00f6mb m\u0171veletek eset\u00e9n egy \u00fcres t\u00f6mb ker\u00fcl m\u00f3dos\u00edt\u00e1sra. A t\u00f6bbi m\u0171velet eset\u00e9n dokument\u00e1ci\u00f3b\u00f3l kikereshet\u0151 a viselked\u00e9s. A fent l\u00e1tott m\u00f3dszerrel nem csak egyetlen dokumentum m\u00f3dos\u00edthat\u00f3. A k\u00e9rt szerkeszt\u0151 m\u0171velet t\u00f6bb, a sz\u0171r\u00e9si felt\u00e9telre illeszked\u0151 dokumentumon is elv\u00e9gezhet\u0151. P\u00e9ld\u00e1ul: a ny\u00e1ri szezonra val\u00f3 tekintettel minden labd\u00e1ra adjunk 25% engedm\u00e9nyt, \u00e9s adjuk \u0151ket hozz\u00e1 az akci\u00f3s kateg\u00f3ri\u00e1hoz. collection . UpdateMany ( filter : Builders < Product >. Filter . AnyEq ( x => x . Categories , \"Labd\u00e1k\" ), update : Builders < Product >. Update . Mul ( x => x . Price , 0.75 ) . AddToSet ( x => x . Categories , \"Akci\u00f3s term\u00e9kek\" )); A m\u00f3dos\u00edt\u00f3 oper\u00e1torok atomi m\u00f3don teszik szerkeszthet\u0151v\u00e9 a dokumentumainkat. Haszn\u00e1latukkal kik\u00fcsz\u00f6b\u00f6lhet\u0151 a konkurens adathozz\u00e1f\u00e9r\u00e9sb\u0151l ered\u0151 probl\u00e9m\u00e1k egy r\u00e9sze.","title":"Dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torok"},{"location":"jegyzet/mongodb/#upsert-nemletezo-dokumentum-csereje","text":"M\u00f3dos\u00edt\u00f3 m\u0171velet sor\u00e1n lehet\u0151s\u00e9g\u00fcnk van az un. upsert (update/insert) jelleg\u0171 m\u0171k\u00f6d\u00e9sre. Ez azt jelenti, hogy vagy besz\u00far\u00e1s, vagy m\u00f3dos\u00edt\u00e1s t\u00f6rt\u00e9nik, annak f\u00fcggv\u00e9ny\u00e9ben, hogy megtal\u00e1lhat\u00f3 volt-e az elem az adatb\u00e1zisban. Az alapvet\u0151 viselked\u00e9s nem upsert, azt k\u00fcl\u00f6n k\u00e9rn\u00fcnk kell. collection . ReplaceOne ( filter : x => x . Id == new ObjectId ( \"...\" ), replacement : replacementObject , options : new UpdateOptions () { IsUpsert = true }); Nem csak a teljes dokumentum cser\u00e9je eset\u00e9n van lehet\u0151s\u00e9g\u00fcnk upsert-re. A dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torokkal is elv\u00e9gezhetj\u00fck ugyanezt. Ahogy l\u00e1thattuk, a m\u00f3dos\u00edt\u00f3 oper\u00e1torokat nem zavarja, ha nem l\u00e9tezik egy mez\u0151. Ugyan\u00edgy nem okoz gondot, ha nem l\u00e9tezik a dokumentum; ez azzal egyen\u00e9rt\u00e9k\u0171, mintha egy teljesen \u00fcres dokumentumon v\u00e9gezn\u00e9nk el a m\u00f3dos\u00edt\u00f3 m\u0171veleteket. collection . UpdateOne ( filter : ..., update : ..., options : new UpdateOptions () { IsUpsert = true }); Az upsert m\u0171velet egy eszk\u00f6z a konkurens m\u00f3dos\u00edt\u00e1sok ter\u00e9n a tranzakci\u00f3 hi\u00e1ny\u00e1ra. Mivel nincs tranzakci\u00f3nk, ez\u00e9rt nem tudunk meggy\u0151z\u0151dni arr\u00f3l a besz\u00far\u00e1s el\u0151tt, hogy m\u00e9g nem l\u00e9tezik egy adott rekord. Helyette haszn\u00e1lhatjuk az upsert m\u00f3dszert, ami atomi lek\u00e9rdez\u00e9st \u00e9s besz\u00far\u00e1st/m\u00f3dos\u00edt\u00e1st tesz lehet\u0151v\u00e9. merge SQL nyelvben a merge parancs ny\u00fajt erre hasonl\u00f3 megold\u00e1st.","title":"Upsert: neml\u00e9tez\u0151 dokumentum cser\u00e9je"},{"location":"jegyzet/mssql/server-side-programming/","text":"Microsoft SQL Server programoz\u00e1sa \u00b6 A p\u00e9ld\u00e1k a minta adatb\u00e1zison futtathat\u00f3ak. V\u00e1ltoz\u00f3k \u00b6 V\u00e1ltoz\u00f3 deklar\u00e1ci\u00f3: DECLARE @ num int SELECT @ num -- NULL \u00c9rt\u00e9kad\u00e1s a SET utas\u00edt\u00e1ssal, vagy a deklar\u00e1ci\u00f3ban: DECLARE @ num int = 5 SELECT @ num -- 5 SET @ num = 3 SELECT @ num -- 3 A v\u00e1ltoz\u00f3 nem k\u00f6t\u0151dik az utas\u00edt\u00e1s blokkhoz. A v\u00e1ltoz\u00f3 az un. batch -en bel\u00fcl vagy t\u00e1rolt elj\u00e1r\u00e1son bel\u00fcl \u00e9rv\u00e9nyes: BEGIN DECLARE @ num int SET @ num = 3 END SELECT @ num -- Ez m\u0171k\u00f6dik, a v\u00e1ltoz\u00f3 az utas\u00edt\u00e1s blokkon k\u00edv\u00fcl is el\u00e9rhet\u0151. -- 3 GO -- \u00faj batch-et kezd SELECT @ num -- Hiba: Must declare the scalar variable \"@num\". V\u00e1ltoz\u00f3 \u00e9rt\u00e9kad\u00e1sa lek\u00e9rdez\u00e9ssel: DECLARE @ name nvarchar ( max ) SELECT @ name = Name FROM Customer WHERE ID = 1 SELECT @ name Ha a lek\u00e9rdez\u00e9s t\u00f6bb sorral t\u00e9r vissza, az utols\u00f3 \u00e9rt\u00e9k marad a v\u00e1ltoz\u00f3ban: DECLARE @ name nvarchar ( max ) SELECT @ name = Name FROM Customer -- t\u00f6bb illeszked\u0151 sor is lesz SELECT @ name -- SELECT utols\u00f3 eredm\u00e9nye ker\u00fcl a v\u00e1ltoz\u00f3ba Ha a lek\u00e9rdez\u00e9s nem t\u00e9r vissza eredm\u00e9nnyel, a v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke nem v\u00e1ltozik: DECLARE @ name nvarchar ( max ) SET @ name = 'aaa' SELECT @ name = Name FROM Customer WHERE ID = 99999999 -- nincs illeszked\u0151 sor SELECT @ name -- aaa Utas\u00edt\u00e1s blokkok \u00e9s vez\u00e9rl\u00e9si szerkezetek \u00b6 Utas\u00edt\u00e1s blokk: BEGIN DECLARE @ num int SET @ num = 3 END El\u00e1gaz\u00e1s (ha l\u00e9tezik a felhaszn\u00e1l\u00f3, friss\u00edts\u00fck az email c\u00edm\u00e9t): DECLARE @ name nvarchar ( max ) SELECT @ name = Name FROM Customer WHERE ID = 123 IF @ name IS NOT NULL BEGIN PRINT 'Updating email' UPDATE Customer SET Email = 'agh*******@gmail.com' WHERE ID = 123 END ELSE BEGIN PRINT 'No such customer' END Ciklus (gener\u00e1ljunk legal\u00e1bb 1000 term\u00e9ket - pl. tesztel\u00e9shez): WHILE ( SELECT COUNT ( * ) FROM Product ) < 1000 BEGIN INSERT INTO Product ( Name , Price , Stock , VATID , CategoryID ) VALUES ( 'Abc' , 1 , 1 , 3 , 13 ) END T\u00e1rolt elj\u00e1r\u00e1s \u00b6 \u00c1FA kulcs r\u00f6gz\u00edt\u00e9se a VAT t\u00e1bl\u00e1ba, olyan kulcs nem r\u00f6gz\u00edthet\u0151 mely m\u00e1r l\u00e9tezik: create or alter procedure InsertNewVAT -- t\u00e1rolt elj\u00e1r\u00e1s l\u00e9trehoz\u00e1sa, neve @ Percentage int -- t\u00e1rolt elj\u00e1r\u00e1s param\u00e9terei as begin tran -- nem megism\u00e9telhet\u0151 olvas\u00e1s elker\u00fcl\u00e9se v\u00e9gett set transaction isolation level repeatable read declare @ Count int select @ Count = count ( * ) from VAT where Percentage = @ Percentage if @ Count = 0 insert into VAT values ( @ Percentage ) else print 'error' ; commit T\u00e1rolt elj\u00e1r\u00e1s megh\u00edv\u00e1sa: exec InsertNewVAT 27 T\u00e1rolt elj\u00e1r\u00e1s t\u00f6rl\u00e9se: drop procedure InsertNewVAT SQL Server 2016 el\u0151tt nem volt create or alter , csak k\u00fcl\u00f6n-k\u00fcl\u00f6n. T\u00e1rolt f\u00fcggv\u00e9ny \u00b6 \u00c1fakulcsok lek\u00e9r\u00e9se egy adott sz\u00e1zal\u00e9k felett: CREATE FUNCTION VATPercentages ( @ min int ) RETURNS TABLE AS RETURN ( SELECT ID , Percentage FROM VAT WHERE Percentage > @ min ); Haszn\u00e1lata: SELECT * FROM VATPercentages ( 20 ) Hibakezel\u00e9s \u00b6 \u00c1FA kulcs r\u00f6gz\u00edt\u00e9se az \u00c1FA t\u00e1bl\u00e1ba, ha m\u00e1r l\u00e9tezik az \u00c1FA kulcs, dobjon hib\u00e1t: create or alter procedure InsertNewVAT @ Percentage int as begin tran set transaction isolation level repeatable read declare @ Count int select @ Count = count ( * ) from VAT where Percentage = @ Percentage if @ Count = 0 insert into VAT values ( @ Percentage ) else throw 51000 , 'error' , 1 ; commit Hiba lekezel\u00e9se (elkap\u00e1sa): begin try exec InsertNewVAT 27 end try begin catch SELECT ERROR_NUMBER () AS ErrorNumber , ERROR_SEVERITY () AS ErrorSeverity , ERROR_STATE () AS ErrorState , ERROR_PROCEDURE () AS ErrorProcedure , ERROR_LINE () AS ErrorLine , ERROR_MESSAGE () AS ErrorMessage ; end catch Trigger \u00b6 Napl\u00f3zzuk a term\u00e9kek t\u00f6rl\u00e9s\u00e9t egy napl\u00f3 t\u00e1bl\u00e1ba: -- Napl\u00f3 t\u00e1bla l\u00e9trehoz\u00e1sa create table AuditLog ([ Description ] [ nvarchar ]( max ) NULL ) go -- Napl\u00f3z\u00f3 trigger create or alter trigger ProductDeleteLog on Product for delete as insert into AuditLog ( Description ) select 'Product deleted: ' + convert ( nvarchar , d . Name ) from deleted d Tegy\u00fck fel, hogy a vev\u0151knek k\u00e9t email c\u00edme is van: egy a bejelentkez\u00e9shez, \u00e9s megadhatnak egy m\u00e1sikat, amit az \u00e9rtes\u00edt\u00e9sekhez haszn\u00e1lni akarnak. Hogy ne kelljen mindig mindk\u00e9t email c\u00edmet lek\u00e9rdezni, \u00e9s v\u00e1lasztani a kett\u0151 k\u00f6z\u00fcl, legyen el\u00e9rhet\u0151 adatb\u00e1zisban a val\u00f3ban haszn\u00e1lt email c\u00edm: -- Plusz email c\u00edm oszlopok a vev\u0151knek alter table Customer add [ NotificationEmail ] nvarchar ( max ), [ EffectiveEmail ] nvarchar ( max ) go -- Haszn\u00e1lt email c\u00edmet friss\u00edt\u0151 trigger create or alter trigger CustomerEmailUpdate on Customer for insert , update as update Customer set EffectiveEmail = ISNULL ( i . NotificationEmail , i . Email ) from Customer c join inserted i on c . ID = i . ID A megrendel\u00e9s t\u00e1bl\u00e1ba felvett v\u00e9g\u00f6sszeg oszlopot (amely a megrendel\u00e9s teljes nett\u00f3 \u00e1ra) automatikusan tartsuk karban: create or alter trigger OrderTotalUpdateTrigger on OrderItem for insert , update , delete as update Order set Total = isnull ( Total , 0 ) + TotalChange from Order inner join ( select i . OrderID , sum ( Amount * Price ) as TotalChange from inserted i group by i . OrderID ) OrderChange on Order . ID = OrderChange . OrderID update Order set Total = isnull ( Total , 0 ) \u2013 TotalChange from Order inner join ( select d . OrderID , sum ( Amount * Price ) as TotalChange from deleted d group by d . OrderID ) OrderChange on Order . ID = OrderChange . OrderID Kurzor \u00b6 Keress\u00fck meg azon term\u00e9keket, amib\u0151l alig van rakt\u00e1ron, \u00e9s ha a legutols\u00f3 elad\u00e1s t\u00f6bb, mint egy \u00e9ve volt, akkor adjunk kedvezm\u00e9nyt a term\u00e9kre: DECLARE @ ProductName nvarchar ( max ) DECLARE @ ProductID int DECLARE @ LastOrder datetime DECLARE products_cur CURSOR FAST_FORWARD READ_ONLY FOR SELECT Id , Name FROM Product WHERE Stock < 3 OPEN products_cur FETCH FROM products_cur INTO @ ProductID , @ ProductName WHILE @@ FETCH_STATUS = 0 BEGIN SELECT @ LastOrder = MAX ([ Order ]. Date ) FROM [ Order ] JOIN OrderItem ON [ Order ]. Id = OrderItem . OrderId WHERE OrderItem . ProductID = @ ProductId PRINT CONCAT ( 'ProductID: ' , convert ( nvarchar , @ ProductID ), ' Last order: ' , ISNULL ( convert ( nvarchar , @ LastOrder ), 'No last order' )) IF @ LastOrder IS NULL OR @ LastOrder < DATEADD ( year , - 1 , GETDATE ()) BEGIN UPDATE Product SET Price = Price * 0 . 75 WHERE Id = @ ProductID END FETCH FROM products_cur INTO @ ProductID , @ ProductName END CLOSE products_cur DEALLOCATE products_cur","title":"Microsoft SQL Server programoz\u00e1sa"},{"location":"jegyzet/mssql/server-side-programming/#microsoft-sql-server-programozasa","text":"A p\u00e9ld\u00e1k a minta adatb\u00e1zison futtathat\u00f3ak.","title":"Microsoft SQL Server programoz\u00e1sa"},{"location":"jegyzet/mssql/server-side-programming/#valtozok","text":"V\u00e1ltoz\u00f3 deklar\u00e1ci\u00f3: DECLARE @ num int SELECT @ num -- NULL \u00c9rt\u00e9kad\u00e1s a SET utas\u00edt\u00e1ssal, vagy a deklar\u00e1ci\u00f3ban: DECLARE @ num int = 5 SELECT @ num -- 5 SET @ num = 3 SELECT @ num -- 3 A v\u00e1ltoz\u00f3 nem k\u00f6t\u0151dik az utas\u00edt\u00e1s blokkhoz. A v\u00e1ltoz\u00f3 az un. batch -en bel\u00fcl vagy t\u00e1rolt elj\u00e1r\u00e1son bel\u00fcl \u00e9rv\u00e9nyes: BEGIN DECLARE @ num int SET @ num = 3 END SELECT @ num -- Ez m\u0171k\u00f6dik, a v\u00e1ltoz\u00f3 az utas\u00edt\u00e1s blokkon k\u00edv\u00fcl is el\u00e9rhet\u0151. -- 3 GO -- \u00faj batch-et kezd SELECT @ num -- Hiba: Must declare the scalar variable \"@num\". V\u00e1ltoz\u00f3 \u00e9rt\u00e9kad\u00e1sa lek\u00e9rdez\u00e9ssel: DECLARE @ name nvarchar ( max ) SELECT @ name = Name FROM Customer WHERE ID = 1 SELECT @ name Ha a lek\u00e9rdez\u00e9s t\u00f6bb sorral t\u00e9r vissza, az utols\u00f3 \u00e9rt\u00e9k marad a v\u00e1ltoz\u00f3ban: DECLARE @ name nvarchar ( max ) SELECT @ name = Name FROM Customer -- t\u00f6bb illeszked\u0151 sor is lesz SELECT @ name -- SELECT utols\u00f3 eredm\u00e9nye ker\u00fcl a v\u00e1ltoz\u00f3ba Ha a lek\u00e9rdez\u00e9s nem t\u00e9r vissza eredm\u00e9nnyel, a v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke nem v\u00e1ltozik: DECLARE @ name nvarchar ( max ) SET @ name = 'aaa' SELECT @ name = Name FROM Customer WHERE ID = 99999999 -- nincs illeszked\u0151 sor SELECT @ name -- aaa","title":"V\u00e1ltoz\u00f3k"},{"location":"jegyzet/mssql/server-side-programming/#utasitas-blokkok-es-vezerlesi-szerkezetek","text":"Utas\u00edt\u00e1s blokk: BEGIN DECLARE @ num int SET @ num = 3 END El\u00e1gaz\u00e1s (ha l\u00e9tezik a felhaszn\u00e1l\u00f3, friss\u00edts\u00fck az email c\u00edm\u00e9t): DECLARE @ name nvarchar ( max ) SELECT @ name = Name FROM Customer WHERE ID = 123 IF @ name IS NOT NULL BEGIN PRINT 'Updating email' UPDATE Customer SET Email = 'agh*******@gmail.com' WHERE ID = 123 END ELSE BEGIN PRINT 'No such customer' END Ciklus (gener\u00e1ljunk legal\u00e1bb 1000 term\u00e9ket - pl. tesztel\u00e9shez): WHILE ( SELECT COUNT ( * ) FROM Product ) < 1000 BEGIN INSERT INTO Product ( Name , Price , Stock , VATID , CategoryID ) VALUES ( 'Abc' , 1 , 1 , 3 , 13 ) END","title":"Utas\u00edt\u00e1s blokkok \u00e9s vez\u00e9rl\u00e9si szerkezetek"},{"location":"jegyzet/mssql/server-side-programming/#tarolt-eljaras","text":"\u00c1FA kulcs r\u00f6gz\u00edt\u00e9se a VAT t\u00e1bl\u00e1ba, olyan kulcs nem r\u00f6gz\u00edthet\u0151 mely m\u00e1r l\u00e9tezik: create or alter procedure InsertNewVAT -- t\u00e1rolt elj\u00e1r\u00e1s l\u00e9trehoz\u00e1sa, neve @ Percentage int -- t\u00e1rolt elj\u00e1r\u00e1s param\u00e9terei as begin tran -- nem megism\u00e9telhet\u0151 olvas\u00e1s elker\u00fcl\u00e9se v\u00e9gett set transaction isolation level repeatable read declare @ Count int select @ Count = count ( * ) from VAT where Percentage = @ Percentage if @ Count = 0 insert into VAT values ( @ Percentage ) else print 'error' ; commit T\u00e1rolt elj\u00e1r\u00e1s megh\u00edv\u00e1sa: exec InsertNewVAT 27 T\u00e1rolt elj\u00e1r\u00e1s t\u00f6rl\u00e9se: drop procedure InsertNewVAT SQL Server 2016 el\u0151tt nem volt create or alter , csak k\u00fcl\u00f6n-k\u00fcl\u00f6n.","title":"T\u00e1rolt elj\u00e1r\u00e1s"},{"location":"jegyzet/mssql/server-side-programming/#tarolt-fuggveny","text":"\u00c1fakulcsok lek\u00e9r\u00e9se egy adott sz\u00e1zal\u00e9k felett: CREATE FUNCTION VATPercentages ( @ min int ) RETURNS TABLE AS RETURN ( SELECT ID , Percentage FROM VAT WHERE Percentage > @ min ); Haszn\u00e1lata: SELECT * FROM VATPercentages ( 20 )","title":"T\u00e1rolt f\u00fcggv\u00e9ny"},{"location":"jegyzet/mssql/server-side-programming/#hibakezeles","text":"\u00c1FA kulcs r\u00f6gz\u00edt\u00e9se az \u00c1FA t\u00e1bl\u00e1ba, ha m\u00e1r l\u00e9tezik az \u00c1FA kulcs, dobjon hib\u00e1t: create or alter procedure InsertNewVAT @ Percentage int as begin tran set transaction isolation level repeatable read declare @ Count int select @ Count = count ( * ) from VAT where Percentage = @ Percentage if @ Count = 0 insert into VAT values ( @ Percentage ) else throw 51000 , 'error' , 1 ; commit Hiba lekezel\u00e9se (elkap\u00e1sa): begin try exec InsertNewVAT 27 end try begin catch SELECT ERROR_NUMBER () AS ErrorNumber , ERROR_SEVERITY () AS ErrorSeverity , ERROR_STATE () AS ErrorState , ERROR_PROCEDURE () AS ErrorProcedure , ERROR_LINE () AS ErrorLine , ERROR_MESSAGE () AS ErrorMessage ; end catch","title":"Hibakezel\u00e9s"},{"location":"jegyzet/mssql/server-side-programming/#trigger","text":"Napl\u00f3zzuk a term\u00e9kek t\u00f6rl\u00e9s\u00e9t egy napl\u00f3 t\u00e1bl\u00e1ba: -- Napl\u00f3 t\u00e1bla l\u00e9trehoz\u00e1sa create table AuditLog ([ Description ] [ nvarchar ]( max ) NULL ) go -- Napl\u00f3z\u00f3 trigger create or alter trigger ProductDeleteLog on Product for delete as insert into AuditLog ( Description ) select 'Product deleted: ' + convert ( nvarchar , d . Name ) from deleted d Tegy\u00fck fel, hogy a vev\u0151knek k\u00e9t email c\u00edme is van: egy a bejelentkez\u00e9shez, \u00e9s megadhatnak egy m\u00e1sikat, amit az \u00e9rtes\u00edt\u00e9sekhez haszn\u00e1lni akarnak. Hogy ne kelljen mindig mindk\u00e9t email c\u00edmet lek\u00e9rdezni, \u00e9s v\u00e1lasztani a kett\u0151 k\u00f6z\u00fcl, legyen el\u00e9rhet\u0151 adatb\u00e1zisban a val\u00f3ban haszn\u00e1lt email c\u00edm: -- Plusz email c\u00edm oszlopok a vev\u0151knek alter table Customer add [ NotificationEmail ] nvarchar ( max ), [ EffectiveEmail ] nvarchar ( max ) go -- Haszn\u00e1lt email c\u00edmet friss\u00edt\u0151 trigger create or alter trigger CustomerEmailUpdate on Customer for insert , update as update Customer set EffectiveEmail = ISNULL ( i . NotificationEmail , i . Email ) from Customer c join inserted i on c . ID = i . ID A megrendel\u00e9s t\u00e1bl\u00e1ba felvett v\u00e9g\u00f6sszeg oszlopot (amely a megrendel\u00e9s teljes nett\u00f3 \u00e1ra) automatikusan tartsuk karban: create or alter trigger OrderTotalUpdateTrigger on OrderItem for insert , update , delete as update Order set Total = isnull ( Total , 0 ) + TotalChange from Order inner join ( select i . OrderID , sum ( Amount * Price ) as TotalChange from inserted i group by i . OrderID ) OrderChange on Order . ID = OrderChange . OrderID update Order set Total = isnull ( Total , 0 ) \u2013 TotalChange from Order inner join ( select d . OrderID , sum ( Amount * Price ) as TotalChange from deleted d group by d . OrderID ) OrderChange on Order . ID = OrderChange . OrderID","title":"Trigger"},{"location":"jegyzet/mssql/server-side-programming/#kurzor","text":"Keress\u00fck meg azon term\u00e9keket, amib\u0151l alig van rakt\u00e1ron, \u00e9s ha a legutols\u00f3 elad\u00e1s t\u00f6bb, mint egy \u00e9ve volt, akkor adjunk kedvezm\u00e9nyt a term\u00e9kre: DECLARE @ ProductName nvarchar ( max ) DECLARE @ ProductID int DECLARE @ LastOrder datetime DECLARE products_cur CURSOR FAST_FORWARD READ_ONLY FOR SELECT Id , Name FROM Product WHERE Stock < 3 OPEN products_cur FETCH FROM products_cur INTO @ ProductID , @ ProductName WHILE @@ FETCH_STATUS = 0 BEGIN SELECT @ LastOrder = MAX ([ Order ]. Date ) FROM [ Order ] JOIN OrderItem ON [ Order ]. Id = OrderItem . OrderId WHERE OrderItem . ProductID = @ ProductId PRINT CONCAT ( 'ProductID: ' , convert ( nvarchar , @ ProductID ), ' Last order: ' , ISNULL ( convert ( nvarchar , @ LastOrder ), 'No last order' )) IF @ LastOrder IS NULL OR @ LastOrder < DATEADD ( year , - 1 , GETDATE ()) BEGIN UPDATE Product SET Price = Price * 0 . 75 WHERE Id = @ ProductID END FETCH FROM products_cur INTO @ ProductID , @ ProductName END CLOSE products_cur DEALLOCATE products_cur","title":"Kurzor"},{"location":"jegyzet/mssql/sql/","text":"SQL nyelv, MSSQL platformf\u00fcgg\u0151 SQL utas\u00edt\u00e1sok \u00b6 A p\u00e9ld\u00e1k a minta adatb\u00e1zison futtathat\u00f3ak. Egyszer\u0171 lek\u00e9rdez\u00e9sek \u00b6 Melyik term\u00e9k olcs\u00f3bb mint 2000 \u00e9s kevesebb, mint 50 db van bel\u0151le? select Name , Price , Stock from Product where Price < 2000 and Stock < 50 Melyik term\u00e9khez nincs le\u00edr\u00e1s? select * from Product where Description is null T\u00e1bl\u00e1k \u00f6sszekapcsol\u00e1sa \u00b6 Budapesti k\u00f6zponti telephellyel rendelkez\u0151 vev\u0151k (a k\u00e9t megold\u00e1s ekvivalens) select * from Customer c , CustomerSite s where c . MainCustomerSiteID = s . ID and City = 'Budapest' select * from Customer c inner join CustomerSite s on c . MainCustomerSiteID = s . ID where City = 'Budapest' List\u00e1zza ki az M bet\u0171vel kezd\u0151d\u0151 term\u00e9kek nev\u00e9t \u00e9s a megrendelt mennyis\u00e9geket \u00fagy, hogy azok a term\u00e9kek is benne legyenek a list\u00e1ban melyekb\u0151l nem rendeltek meg semmit select p . Name , oi . Amount from Product p left outer join OrderItem oi on p . id = oi . ProductID left outer join [ Order ] o on o . ID = oi . OrderID where p . Name like 'M%' [Order] Az [Order] az\u00e9rt szerepel sz\u00f6geletes z\u00e1r\u00f3jelben, mert \u00edgy jel\u00f6lj\u00fck, hogy ez egy t\u00e1bla neve, \u00e9s nem az order by parancs kezdete. Rendez\u00e9s \u00b6 select * from Product order by Name Microsoft SQL Server specifikus: collation a rendez\u00e9s szab\u00e1lyait adja meg select * from Product order by Name collate SQL_Latin1_General_Cp1_CI_AI T\u00f6bb mez\u0151 szerinti rendez\u00e9s select * from Product order by Stock desc , Price Allek\u00e9rdez\u00e9sek \u00b6 List\u00e1zzuk ki a megrendel\u00e9sek Statusz\u00e1t hat\u00e1ridej\u00e9t \u00e9s d\u00e1tum\u00e1t select o . Date , o . Deadline , s . Name from [ Order ] o inner join Status s on o . StatusId = s . ID Alternat\u00edv, de nem ekvivalens megold\u00e1s: az allek\u00e9rdez\u00e9s az outer joinnak felel meg! select o . Date , o . Deadline , ( select s . Name from Status s where o . StatusId = s . ID ) from [ Order ] o Duplik\u00e1tum sz\u0171r\u00e9se \u00b6 Melyek azok a term\u00e9kek, melyb\u0151l egyszerre t\u00f6bb, mint 3 db-ot rendeltek? Ugyanabb\u00f3l a term\u00e9kb\u0151l t\u00f6bb alkalommal is el\u0151fordulhatott, de csak egyszer szeretn\u00e9nk a nev\u00e9t l\u00e1tni. select distinct p . Name from Product p inner join OrderItem oi on oi . ProductID = p . ID where oi . Amount > 3 Oszlopf\u00fcggv\u00e9nyek \u00b6 Mennyibe ker\u00fcl a legdr\u00e1g\u00e1bb term\u00e9k? select max ( Price ) from Product Melyek a legdr\u00e1g\u00e1bb term\u00e9kek? select * from Product where Price = ( select max ( Price ) from Product ) Azon term\u00e9keket min, max \u00e9s \u00e1tlag mennyi\u00e9rt adt\u00e1k el, melyek nev\u00e9ben szerepel a Lego \u00e9s az \u00e1tlag elad\u00e1si \u00e1ruk 10.000-n\u00e9l nagyobb select p . Id , p . Name , min ( oi . Price ), max ( oi . Price ), avg ( oi . Price ) from Product p inner join OrderItem oi on p . ID = oi . ProductID Where p . Name like '%Lego%' group by p . Id , p . Name having avg ( oi . Price ) > 10000 order by 2 Rekordok l\u00e9trehoz\u00e1sa \u00b6 Egy rekord l\u00e9trehoz\u00e1sa minden oszlop (kiv\u00e9ve identity ) adat\u00e1nak megad\u00e1s\u00e1val insert into Product values ( 'aa' , 100 , 0 , 3 , 2 , null ) Csak megnevezett oszlopok \u00e9rt\u00e9keinek kit\u00f6lt\u00e9se insert into Product ( Name , Price ) values ( 'aa' , 100 ) Lek\u00e9rdez\u00e9s eredm\u00e9nyeinek besz\u00far\u00e1sa insert into Product ( Name , Price ) select Name , Price from InvoiceItem where Amount > 2 MSSQL specifikus: identity oszlop create table VAT ( ID int identity primary key , Percentage int ) insert into VAT ( Percentage ) values ( 27 ) select @@ identity MSSQL specifikus: \u00e9rt\u00e9kad\u00e1s identity oszlopnak set identity_insert VAT on insert into VAT ( ID , Percentage ) values ( 123 , 27 ) set identity_insert VAT off Rekordok m\u00f3dos\u00edt\u00e1sa \u00b6 A Leg\u00f3k \u00e1r\u00e1t emelj\u00fck meg 10%-kal \u00e9s a raktr\u00e1k\u00e9szlet\u00fcket 5 db-bal update Product set Price = 1 . 1 * Price , Stock = Stock + 5 where Name like '%Lego%' M\u00f3dos\u00edt\u00e1s, ha kapcsol\u00f3d\u00f3 t\u00e1bla alapj\u00e1n kell sz\u0171rni: emelj\u00fck meg 10%-kal azon 20%-os \u00c1FA kulcs\u00fa term\u00e9kek \u00e1r\u00e1t, melyb\u0151l, t\u00f6bb mint 10 db van rakt\u00e1ron update Product set Price = 1 . 1 * Price where Stock > 10 and VATID in ( select ID from VAT where Percentage = 20 ) MSSQL Server specifikus szintaktika az el\u0151z\u0151re update Product set Price = 1 . 1 * Price from Product p inner join VAT v on p . VATID = v . ID where Stock > 10 and Percentage = 20 Rekordok t\u00f6rl\u00e9se \u00b6 delete from Product where ID > 10 Sorsz\u00e1moz\u00e1s \u00b6 Sorsz\u00e1moz\u00e1s egy adott rendez\u00e9s szerint select p . * , rank () over ( order by Name ) as r , dense_rank () over ( order by Name ) as dr from Product p Sorsz\u00e1moz\u00e1s csoportos\u00edt\u00e1sonk\u00e9nt select p . * , rank () over ( partition by CategoryID order by Name ) as r , dense_rank () over ( partition by CategoryID order by Name ) as dr from Product p CTE (Common Table Expression) \u00b6 Motiv\u00e1ci\u00f3: allek\u00e9rdez\u00e9ssel nehezen \u00e1ttekinthet\u0151v\u00e9 v\u00e1lnak a lek\u00e9rdez\u00e9sek ABC sorrendben melyik az els\u0151 h\u00e1rom term\u00e9k select * from ( select p . * , rank () over ( order by Name ) as r , dense_rank () over ( order by Name ) as dr from Product p ) a where a . dr <= 3 Ugyan az a lek\u00e9rdez\u00e9s CTE haszn\u00e1lat\u00e1val with q1 as ( select * , rank () over ( order by Name ) as r , dense_rank () over ( order by Name ) as dr from Product ) select * from q1 where q1 . dr < 3 H\u00e1ny darabot adtak el a m\u00e1sodik legdr\u00e1g\u00e1bb term\u00e9kb\u0151l? with q as ( select * , dense_rank () over ( order by Price desc ) as dr from Product ) select q . ID , q . Name , sum ( Amount ) from q inner join OrderItem oi on oi . ProductID = q . ID where q . dr = 2 group by q . ID , q . Name Lapoz\u00e1s: term\u00e9kek list\u00e1z\u00e1sa ABC sorrendben a 3. rekord\u00f3l a 8. rekordig with q as ( select * , rank () over ( order by Name ) as r from Product ) select * from q where q . r between 3 and 8 Lapoz\u00e1s: MSSQL Server (2012+) specifikus megold\u00e1s select * from Product order by Name offset 2 rows fetch next 6 rows only select top 3 * from Product order by Name","title":"SQL nyelv, MSSQL platformf\u00fcgg\u0151 SQL utas\u00edt\u00e1sok"},{"location":"jegyzet/mssql/sql/#sql-nyelv-mssql-platformfuggo-sql-utasitasok","text":"A p\u00e9ld\u00e1k a minta adatb\u00e1zison futtathat\u00f3ak.","title":"SQL nyelv, MSSQL platformf\u00fcgg\u0151 SQL utas\u00edt\u00e1sok"},{"location":"jegyzet/mssql/sql/#egyszeru-lekerdezesek","text":"Melyik term\u00e9k olcs\u00f3bb mint 2000 \u00e9s kevesebb, mint 50 db van bel\u0151le? select Name , Price , Stock from Product where Price < 2000 and Stock < 50 Melyik term\u00e9khez nincs le\u00edr\u00e1s? select * from Product where Description is null","title":"Egyszer\u0171 lek\u00e9rdez\u00e9sek"},{"location":"jegyzet/mssql/sql/#tablak-osszekapcsolasa","text":"Budapesti k\u00f6zponti telephellyel rendelkez\u0151 vev\u0151k (a k\u00e9t megold\u00e1s ekvivalens) select * from Customer c , CustomerSite s where c . MainCustomerSiteID = s . ID and City = 'Budapest' select * from Customer c inner join CustomerSite s on c . MainCustomerSiteID = s . ID where City = 'Budapest' List\u00e1zza ki az M bet\u0171vel kezd\u0151d\u0151 term\u00e9kek nev\u00e9t \u00e9s a megrendelt mennyis\u00e9geket \u00fagy, hogy azok a term\u00e9kek is benne legyenek a list\u00e1ban melyekb\u0151l nem rendeltek meg semmit select p . Name , oi . Amount from Product p left outer join OrderItem oi on p . id = oi . ProductID left outer join [ Order ] o on o . ID = oi . OrderID where p . Name like 'M%' [Order] Az [Order] az\u00e9rt szerepel sz\u00f6geletes z\u00e1r\u00f3jelben, mert \u00edgy jel\u00f6lj\u00fck, hogy ez egy t\u00e1bla neve, \u00e9s nem az order by parancs kezdete.","title":"T\u00e1bl\u00e1k \u00f6sszekapcsol\u00e1sa"},{"location":"jegyzet/mssql/sql/#rendezes","text":"select * from Product order by Name Microsoft SQL Server specifikus: collation a rendez\u00e9s szab\u00e1lyait adja meg select * from Product order by Name collate SQL_Latin1_General_Cp1_CI_AI T\u00f6bb mez\u0151 szerinti rendez\u00e9s select * from Product order by Stock desc , Price","title":"Rendez\u00e9s"},{"location":"jegyzet/mssql/sql/#allekerdezesek","text":"List\u00e1zzuk ki a megrendel\u00e9sek Statusz\u00e1t hat\u00e1ridej\u00e9t \u00e9s d\u00e1tum\u00e1t select o . Date , o . Deadline , s . Name from [ Order ] o inner join Status s on o . StatusId = s . ID Alternat\u00edv, de nem ekvivalens megold\u00e1s: az allek\u00e9rdez\u00e9s az outer joinnak felel meg! select o . Date , o . Deadline , ( select s . Name from Status s where o . StatusId = s . ID ) from [ Order ] o","title":"Allek\u00e9rdez\u00e9sek"},{"location":"jegyzet/mssql/sql/#duplikatum-szurese","text":"Melyek azok a term\u00e9kek, melyb\u0151l egyszerre t\u00f6bb, mint 3 db-ot rendeltek? Ugyanabb\u00f3l a term\u00e9kb\u0151l t\u00f6bb alkalommal is el\u0151fordulhatott, de csak egyszer szeretn\u00e9nk a nev\u00e9t l\u00e1tni. select distinct p . Name from Product p inner join OrderItem oi on oi . ProductID = p . ID where oi . Amount > 3","title":"Duplik\u00e1tum sz\u0171r\u00e9se"},{"location":"jegyzet/mssql/sql/#oszlopfuggvenyek","text":"Mennyibe ker\u00fcl a legdr\u00e1g\u00e1bb term\u00e9k? select max ( Price ) from Product Melyek a legdr\u00e1g\u00e1bb term\u00e9kek? select * from Product where Price = ( select max ( Price ) from Product ) Azon term\u00e9keket min, max \u00e9s \u00e1tlag mennyi\u00e9rt adt\u00e1k el, melyek nev\u00e9ben szerepel a Lego \u00e9s az \u00e1tlag elad\u00e1si \u00e1ruk 10.000-n\u00e9l nagyobb select p . Id , p . Name , min ( oi . Price ), max ( oi . Price ), avg ( oi . Price ) from Product p inner join OrderItem oi on p . ID = oi . ProductID Where p . Name like '%Lego%' group by p . Id , p . Name having avg ( oi . Price ) > 10000 order by 2","title":"Oszlopf\u00fcggv\u00e9nyek"},{"location":"jegyzet/mssql/sql/#rekordok-letrehozasa","text":"Egy rekord l\u00e9trehoz\u00e1sa minden oszlop (kiv\u00e9ve identity ) adat\u00e1nak megad\u00e1s\u00e1val insert into Product values ( 'aa' , 100 , 0 , 3 , 2 , null ) Csak megnevezett oszlopok \u00e9rt\u00e9keinek kit\u00f6lt\u00e9se insert into Product ( Name , Price ) values ( 'aa' , 100 ) Lek\u00e9rdez\u00e9s eredm\u00e9nyeinek besz\u00far\u00e1sa insert into Product ( Name , Price ) select Name , Price from InvoiceItem where Amount > 2 MSSQL specifikus: identity oszlop create table VAT ( ID int identity primary key , Percentage int ) insert into VAT ( Percentage ) values ( 27 ) select @@ identity MSSQL specifikus: \u00e9rt\u00e9kad\u00e1s identity oszlopnak set identity_insert VAT on insert into VAT ( ID , Percentage ) values ( 123 , 27 ) set identity_insert VAT off","title":"Rekordok l\u00e9trehoz\u00e1sa"},{"location":"jegyzet/mssql/sql/#rekordok-modositasa","text":"A Leg\u00f3k \u00e1r\u00e1t emelj\u00fck meg 10%-kal \u00e9s a raktr\u00e1k\u00e9szlet\u00fcket 5 db-bal update Product set Price = 1 . 1 * Price , Stock = Stock + 5 where Name like '%Lego%' M\u00f3dos\u00edt\u00e1s, ha kapcsol\u00f3d\u00f3 t\u00e1bla alapj\u00e1n kell sz\u0171rni: emelj\u00fck meg 10%-kal azon 20%-os \u00c1FA kulcs\u00fa term\u00e9kek \u00e1r\u00e1t, melyb\u0151l, t\u00f6bb mint 10 db van rakt\u00e1ron update Product set Price = 1 . 1 * Price where Stock > 10 and VATID in ( select ID from VAT where Percentage = 20 ) MSSQL Server specifikus szintaktika az el\u0151z\u0151re update Product set Price = 1 . 1 * Price from Product p inner join VAT v on p . VATID = v . ID where Stock > 10 and Percentage = 20","title":"Rekordok m\u00f3dos\u00edt\u00e1sa"},{"location":"jegyzet/mssql/sql/#rekordok-torlese","text":"delete from Product where ID > 10","title":"Rekordok t\u00f6rl\u00e9se"},{"location":"jegyzet/mssql/sql/#sorszamozas","text":"Sorsz\u00e1moz\u00e1s egy adott rendez\u00e9s szerint select p . * , rank () over ( order by Name ) as r , dense_rank () over ( order by Name ) as dr from Product p Sorsz\u00e1moz\u00e1s csoportos\u00edt\u00e1sonk\u00e9nt select p . * , rank () over ( partition by CategoryID order by Name ) as r , dense_rank () over ( partition by CategoryID order by Name ) as dr from Product p","title":"Sorsz\u00e1moz\u00e1s"},{"location":"jegyzet/mssql/sql/#cte-common-table-expression","text":"Motiv\u00e1ci\u00f3: allek\u00e9rdez\u00e9ssel nehezen \u00e1ttekinthet\u0151v\u00e9 v\u00e1lnak a lek\u00e9rdez\u00e9sek ABC sorrendben melyik az els\u0151 h\u00e1rom term\u00e9k select * from ( select p . * , rank () over ( order by Name ) as r , dense_rank () over ( order by Name ) as dr from Product p ) a where a . dr <= 3 Ugyan az a lek\u00e9rdez\u00e9s CTE haszn\u00e1lat\u00e1val with q1 as ( select * , rank () over ( order by Name ) as r , dense_rank () over ( order by Name ) as dr from Product ) select * from q1 where q1 . dr < 3 H\u00e1ny darabot adtak el a m\u00e1sodik legdr\u00e1g\u00e1bb term\u00e9kb\u0151l? with q as ( select * , dense_rank () over ( order by Price desc ) as dr from Product ) select q . ID , q . Name , sum ( Amount ) from q inner join OrderItem oi on oi . ProductID = q . ID where q . dr = 2 group by q . ID , q . Name Lapoz\u00e1s: term\u00e9kek list\u00e1z\u00e1sa ABC sorrendben a 3. rekord\u00f3l a 8. rekordig with q as ( select * , rank () over ( order by Name ) as r from Product ) select * from q where q . r between 3 and 8 Lapoz\u00e1s: MSSQL Server (2012+) specifikus megold\u00e1s select * from Product order by Name offset 2 rows fetch next 6 rows only select top 3 * from Product order by Name","title":"CTE (Common Table Expression)"},{"location":"jegyzet/transactions/","text":"Tranzakci\u00f3kezel\u00e9s adatb\u00e1zisokban \u00b6 Kontextus Az al\u00e1bbiak alapvet\u0151en rel\u00e1ci\u00f3s adatb\u00e1zisokra vonatkoz\u00f3an ismertetik a tranzakci\u00f3kat. Azonban a probl\u00e9m\u00e1k \u00e9s megold\u00e1sok egy r\u00e9sze \u00e1ltal\u00e1nos, \u00e9s m\u00e1s jelleg\u0171 adatb\u00e1zis rendszerekben is megtal\u00e1lhat\u00f3ak. Konkurens adathozz\u00e1f\u00e9r\u00e9s \u00b6 Az adatb\u00e1zis-kezel\u0151 rendszerek kliens-szerver \u00fczemm\u00f3dban m\u0171k\u00f6dnek. A kliensek (az \u00e1ltalunk \u00edrt szoftverek) csatlakoznak az adatb\u00e1zishoz \u00e9s k\u00e9r\u00e9seket hajtatnak v\u00e9gre. Ebben a fel\u00e1ll\u00e1sban egy adatb\u00e1zis-kezel\u0151 rendszer \u00e9s t\u00f6bb kliens vesz r\u00e9szt. Az adatb\u00e1zis rendszer c\u00e9lja, hogy min\u00e9l t\u00f6bb k\u00e9r\u00e9st szolg\u00e1ljon ki, ez\u00e9rt a k\u00e9r\u00e9seket egym\u00e1ssal p\u00e1rhuzamosan hajtja v\u00e9gre . Egy ilyen rendszerben az al\u00e1bbi konkurens (egy id\u0151ben t\u00f6rt\u00e9n\u0151) adathozz\u00e1f\u00e9r\u00e9si esetek lehets\u00e9gesek. Amennyiben a hozz\u00e1f\u00e9r\u00e9sek, ak\u00e1r \u00edr\u00e1s, ak\u00e1r olvas\u00e1s, elt\u00e9r\u0151 adatra vonatkoznak, nincs probl\u00e9ma, a m\u0171veletek egyszerre is t\u00f6rt\u00e9nhetnek. Amennyiben minden hozz\u00e1f\u00e9r\u00e9s csak olvas\u00e1s, nincs probl\u00e9ma: olvasni egyszerre t\u00f6bben is tudnak. Viszont, ha ugyanazon adathoz egy id\u0151ben t\u00f6bben f\u00e9rnek hozz\u00e1 , \u00e9s legal\u00e1bb egy \u00edr\u00e1s is van k\u00f6zt\u00fck , akkor fell\u00e9phet a konkurencia probl\u00e9m\u00e1ja. Ez a konkurencia probl\u00e9ma nem k\u00fcl\u00f6nb\u00f6zik az oper\u00e1ci\u00f3s rendszerek \u00e9s v\u00e1ltozatos programoz\u00e1si nyelvek eset\u00e9n megismert konkurencia \u00e9s k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s probl\u00e9m\u00e1j\u00e1t\u00f3l. Ott t\u00f6bbnyire mem\u00f3ria hozz\u00e1f\u00e9r\u00e9sr\u0151l, azonos mem\u00f3riater\u00fclet \u00edr\u00e1s-olvas\u00e1s\u00e1r\u00f3l van sz\u00f3, \u00e9s a megold\u00e1s a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s, azaz a programoz\u00f3 v\u00e9delmi vonallal l\u00e1tja el az adat hozz\u00e1f\u00e9r\u00e9s hely\u00e9t. Adatb\u00e1zis-kezel\u0151 rendszerekben a konkurens hozz\u00e1f\u00e9r\u00e9s az adatb\u00e1zisban tal\u00e1lhat\u00f3 rekordokra (sorokra) vonatkozik, \u00e9s a v\u00e9delmi vonalat a tranzakci\u00f3k adj\u00e1k. Tranzakci\u00f3k \u00b6 Defin\u00edci\u00f3 A tranzakci\u00f3 a feldolgoz\u00e1s logikai egys\u00e9ge, olyan m\u0171veletek sorozata, melyek csak egy\u00fcttesen \u00e9rtelmesek. A tranzakci\u00f3kkal teh\u00e1t m\u0171veleteket fogunk \u00f6ssze egy egys\u00e9gbe, amelyekre vonatkoz\u00f3an a rendszer biztos\u00edtja az al\u00e1bbi tulajdons\u00e1gokat: atomi v\u00e9grehajt\u00e1s (atomicity), konzisztencia (consistency), egym\u00e1st\u00f3l val\u00f3 izol\u00e1ci\u00f3 (isolation), \u00e9s tart\u00f3ss\u00e1g (durability). Vizsg\u00e1ljuk meg a tranzakci\u00f3k alaptulajdons\u00e1gait, hogy meg\u00e9rthess\u00fck, hogyan oldhatjuk meg haszn\u00e1latukkal a konkurens adathozz\u00e1f\u00e9r\u00e9s probl\u00e9m\u00e1j\u00e1t. A tranzakci\u00f3 csak eszk\u00f6z A tranzakci\u00f3k (a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s biztos\u00edt\u00e1s\u00e1hoz haszn\u00e1lt mutexekhez hasonl\u00f3an) csak eszk\u00f6zt adnak a programoz\u00f3 kez\u00e9be, de a helyes haszn\u00e1lat a fejleszt\u0151 felel\u0151ss\u00e9ge. Tranzakci\u00f3k alaptulajdons\u00e1gai \u00b6 Atomi v\u00e9grehajt\u00e1s \u00b6 Az atomi v\u00e9grehajt\u00e1s azt jelenti, hogy a m\u0171velet sorozatunk t\u00f6bb utas\u00edt\u00e1st tartalmaz, azonban ezen utas\u00edt\u00e1s sorozat csak egyben \u00e9rtelmes, a r\u00e9szleges v\u00e9grehajt\u00e1st meg kell akad\u00e1lyozni. Erre az\u00e9rt van sz\u00fcks\u00e9g, mert gyakran az adatb\u00e1zisban v\u00e9grehajtott m\u0171veleteinket t\u00f6bb utas\u00edt\u00e1s seg\u00edts\u00e9g\u00e9vel tudjuk csak kifejezni, de az utas\u00edt\u00e1sok k\u00f6z\u00f6tt nem szak\u00edthat\u00f3 meg a m\u0171velet. K\u00e9pzelj\u00fck el egy webshopban a v\u00e1s\u00e1rl\u00e1s v\u00e9g\u00e9t lez\u00e1r\u00f3 m\u0171veletet: R\u00f6gz\u00edtj\u00fck a megrendel\u00e9st, elmentj\u00fck egy rekordban a megrendel\u0151 adatait A megrendelt term\u00e9kn\u00e9l cs\u00f6kkentj\u00fck a rakt\u00e1ron lev\u0151 darabsz\u00e1mot, hiszen egyet eladtunk Ez a m\u0171veletsorozat csak egyben \u00e9rtelmes. Amennyiben a megrendel\u00e9st r\u00f6gz\u00edtett\u00fck, musz\u00e1j a rakt\u00e1rk\u00e9szletet is cs\u00f6kkenteni, k\u00fcl\u00f6nben t\u00f6bbet adhatunk el a term\u00e9kb\u0151l, mint amennyi rendelkez\u00e9sre \u00e1ll. A k\u00e9t l\u00e9p\u00e9s k\u00f6z\u00f6tt teh\u00e1t a m\u0171velet nem szak\u00edthat\u00f3 f\u00e9lbe. Ezt garant\u00e1lja az atomi v\u00e9grehajt\u00e1s: ha a m\u0171veletsorozat v\u00e9grehajt\u00e1sa megkezd\u0151d\u00f6tt, akkor annak vagy teljes eg\u00e9sz\u00e9ben le kell futnia, vegy vissza kell \u00e1llnia a v\u00e9grehajt\u00e1st megel\u0151z\u0151 \u00e1llapotba . Konzisztencia \u00b6 Az adatb\u00e1zis konzisztenci\u00e1j\u00e1nak szab\u00e1lyait r\u00e9szben az integrit\u00e1si krit\u00e9riumokkal \u00edrhatjuk le: p\u00e9ld\u00e1ul egy k\u00fcls\u0151 kulcs \u00e1ltal hivatkozott rekordnak l\u00e9teznie kell. Ezen k\u00edv\u00fcl az adatok k\u00f6z\u00f6tti \u00f6sszef\u00fcgg\u00e9seket is bele\u00e9rtj\u00fck a konzisztenci\u00e1ba: p\u00e9ld\u00e1ul a Neptun rendszerben nem lehet t\u00f6bb jelentkez\u0151 a vizsg\u00e1ra, mint a vizsga l\u00e9tsz\u00e1mkorl\u00e1tja. Tranzakci\u00f3k haszn\u00e1lata biztos\u00edtja sz\u00e1munkra, hogy az adatb\u00e1zisunk mindig konzisztens \u00e1llapotban van. Egy megkezdett tranzakci\u00f3 lefut\u00e1sa sor\u00e1n el\u0151fordulhat ideiglenesen inkonzisztens \u00e1llapot, mint a fenti p\u00e9ld\u00e1ban az egyes l\u00e9p\u00e9sek k\u00f6z\u00f6tt. Azonban a tranzakci\u00f3 v\u00e9g\u00e9re a konzisztenci\u00e1nak helyre kell \u00e1llnia. M\u00e1s sz\u00f3val: a tranzakci\u00f3k az adatb\u00e1zist konzisztens \u00e1llapotb\u00f3l konzisztens \u00e1llapotba viszik . Tart\u00f3ss\u00e1g \u00b6 A tart\u00f3ss\u00e1g tulajdons\u00e1ga azt \u00edrja el\u0151, hogy a tranzakci\u00f3 hat\u00e1sa tart\u00f3san megmarad , azaz a tranzakci\u00f3 \u00e1ltal v\u00e9gzett m\u0171veletek eredm\u00e9nye nem veszhet el. Praktikusan ezt azt jelenti, hogy a tranzakci\u00f3 \u00e1ltal v\u00e9gzett m\u00f3dos\u00edt\u00e1sok nem csak mem\u00f3ri\u00e1ban ker\u00fclnek elv\u00e9gz\u00e9sre, hanem tart\u00f3s t\u00e1rra (merevlemezre) is ki\u00edr\u00e1sra ker\u00fclnek. Az adatb\u00e1zisban k\u00e9t f\u00e9le hib\u00e1t k\u00fcl\u00f6nb\u00f6ztet\u00fcnk meg, amikor adatveszt\u00e9s k\u00f6vetkezhet be: soft crash \u00e9s hard crash. Soft crash eset\u00e9n az adatb\u00e1zis szerver le\u00e1ll, \u00edgy a mem\u00f3ria tartalma elveszik. Ez ellen v\u00e9denek a tranzakci\u00f3k. Hard crash eset\u00e9n a merevlemez is s\u00e9r\u00fcl; ez ellen csak a biztons\u00e1gi ment\u00e9s tud v\u00e9deni. Izol\u00e1ci\u00f3 \u00b6 Az izol\u00e1ci\u00f3 a tranzakci\u00f3k egym\u00e1st\u00f3l val\u00f3 \"elszigetel\u00e9s\u00e9t\" jelenti. A tranzakci\u00f3inkat \u00fagy \u00edrhatjuk meg, hogy annak helyes lefuttat\u00e1s\u00e1r\u00f3l a rendszer fog gondoskodni. A fejleszt\u0151 teh\u00e1t \u00fagy \u00edrhatja meg a tranzakci\u00f3t, mintha az a rendszerben egyed\u00fcl futna, \u00e9s az adatb\u00e1zis rendszer garant\u00e1lja, hogy megadott szab\u00e1lyrendszer szerint nem fog el\u0151fordulni konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9ma . Val\u00f3j\u00e1ban a rendszerben egyszerre sok tranzakci\u00f3 fut, azonban az adatb\u00e1zis-kezel\u0151 rendszer garant\u00e1lja, hogy olyan \u00fctemez\u00e9sben futtatja tranzakci\u00f3kat, amelyek nem s\u00e9rtik a tranzakci\u00f3k \u00e1ltal elv\u00e1rt izol\u00e1ci\u00f3s szintet. Ehhez a tranzakci\u00f3nak specifik\u00e1lnia kell az izol\u00e1ci\u00f3s szintet . Izol\u00e1ci\u00f3s probl\u00e9m\u00e1k \u00e9s izol\u00e1ci\u00f3s szintek \u00b6 Az izol\u00e1ci\u00f3s szintek megismer\u00e9s\u00e9hez el\u0151sz\u00f6r meg kell ismern\u00fcnk, hogy pontosan milyen konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9m\u00e1k mer\u00fclhetnek fel. Probl\u00e9m\u00e1k \u00b6 Piszkos olvas\u00e1s ( dirty read ) \u00b6 A piszkos olvas\u00e1s sor\u00e1n egy tranzakci\u00f3 egy m\u00e1sik tranzakci\u00f3 nem kommit\u00e1lt adatait haszn\u00e1lja: Egy tranzakci\u00f3 fut\u00e1sa sor\u00e1n m\u00f3dos\u00edt egy \u00e9rt\u00e9ket, de m\u00e9g nem kommit\u00e1l. Egy m\u00e1sik tranzakci\u00f3 ugyanezt a (m\u00e1r m\u00f3dos\u00edtott) \u00e9rt\u00e9ket kiolvassa. Az els\u0151 tranzakci\u00f3 megszak\u00edt\u00e1sra ker\u00fcl, \u00e9s a rendszer vissza\u00e1ll\u00edtja a m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9ket. A 2. l\u00e9p\u00e9sben felhaszn\u00e1lt \u00e9rt\u00e9k teh\u00e1t \u00e9rv\u00e9nytelen azt nem lett volna szabad felhaszn\u00e1lni. A k\u00e9pek forr\u00e1sa https://vladmihalcea.com/2014/01/05/a-beginners-guide-to-acid-and-database-transactions/ A piszkos olvas\u00e1st szinte minden esetben el akarjuk ker\u00fclni. Elveszett m\u00f3dos\u00edt\u00e1s ( lost update ) \u00b6 Az elveszett m\u00f3dos\u00edt\u00e1s sor\u00e1n k\u00e9t \u00edr\u00e1s ker\u00fcl konfliktusba: Egy tranzakci\u00f3 megv\u00e1ltoztat egy \u00e9rt\u00e9ket. Egy m\u00e1sik tranzakci\u00f3 ugyanazon \u00e9rt\u00e9ket fel\u00fcl\u00edrja. V\u00e9geredm\u00e9nyben csak a m\u00e1sodik \u00edr\u00e1s eredm\u00e9nye marad meg, mintha az els\u0151 m\u00f3dos\u00edt\u00e1s nem is t\u00f6rt\u00e9nt volna meg. Nem megism\u00e9telhet\u0151 olvas\u00e1s ( nonrepeatable read ) \u00b6 A nem megism\u00e9telhet\u0151 olvas\u00e1s sor\u00e1n a lek\u00e9rdez\u00e9s eredm\u00e9nye f\u00fcgg att\u00f3l, hogy id\u0151ben mikor adt\u00e1k ki egy tranzakci\u00f3ban: Egy tranzakci\u00f3 lek\u00e9rdez egy adatot. Egy m\u00e1sik tranzakci\u00f3 m\u00f3dos\u00edtja ugyanazt az adatelemet. Ha az els\u0151 tranzakci\u00f3 megism\u00e9tli a kor\u00e1bbi lek\u00e9rdez\u00e9st, m\u00e1s eredm\u00e9nyt kap. Fantom rekordok ( phantom records / phantom read ) \u00b6 A fantom rekordok probl\u00e9m\u00e1ja akkor jelentkezik, amikor rekord halmazokkal dolgozunk: Egy tranzakci\u00f3 lek\u00e9rdez egy eredm\u00e9nyhalmazt, amelyben t\u00f6bb rekord van. Ek\u00f6zben egy m\u00e1sik tranzakci\u00f3 t\u00f6r\u00f6l egy rekordot, amely r\u00e9sze a lek\u00e9rdezett eredm\u00e9nyhalmaznak. Az els\u0151 tranzakci\u00f3 elkezdi feldolgozni az eredm\u00e9nyhalmazt, p\u00e9ld\u00e1ul iter\u00e1tor-szer\u0171en egyes\u00e9vel megy v\u00e9gig a rekordhalmazon. A t\u00f6r\u00f6lt rekord ilyenkor r\u00e9sze a lek\u00e9rdezett eredm\u00e9nyhalmaznak, vagy sem? Hasonl\u00f3an elk\u00e9pzelhet\u0151 az is, hogy egy rekord m\u00f3dosul a 2. l\u00e9p\u00e9sben. Ilyenkor a 3. l\u00e9p\u00e9sben a kor\u00e1bbi, vagy a m\u00f3dosult \u00e1llapot\u00e1t kellene l\u00e1tni? Izol\u00e1ci\u00f3s szintek \u00b6 A fenti probl\u00e9m\u00e1k mindegyike elker\u00fclhet\u0151 a megfelel\u0151 izol\u00e1ci\u00f3s szint megv\u00e1laszt\u00e1s\u00e1val. Azonban min\u00e9l \"magasabb\" izol\u00e1ci\u00f3s szintet v\u00e1lasztunk, ann\u00e1l kisebb az adatb\u00e1zis-kezel\u0151 rendszer \u00e1tbocs\u00e1t\u00f3k\u00e9pess\u00e9ge, \u00e9s ann\u00e1l nagyobb a lehet\u0151s\u00e9ge a holtpont kialakul\u00e1s\u00e1nak (l\u00e1sd al\u00e1bb). Ez\u00e9rt a c\u00e9l egy megfelel\u0151 kompromisszum megtal\u00e1l\u00e1sa a lehets\u00e9ges probl\u00e9m\u00e1k \u00e9s a teljes\u00edtm\u00e9ny k\u00f6z\u00f6tt. Az ANSI/ISO SQL szabv\u00e1ny az al\u00e1bbi izol\u00e1ci\u00f3s szinteket k\u00fcl\u00f6nb\u00f6zteti meg. Read uncommitted: nem ny\u00fajt megold\u00e1st egyik probl\u00e9m\u00e1ra se. Read committed: nincs piszkos olvas\u00e1s. Repeatable read: nincs piszkos olvas\u00e1s, se nem megism\u00e9telhet\u0151 olvas\u00e1s. Serializable: egyik probl\u00e9ma sem fordulhat el\u0151. A read uncommitted szintet \u00e1ltal\u00e1ban nem haszn\u00e1ljuk. A serializable-t pedig lehet\u0151s\u00e9g szerint elker\u00fclj\u00fck. Az alap\u00e9rtelmezett szint \u00e1ltal\u00e1ban a read committed . \u00dctemez\u00e9s biztos\u00edt\u00e1sa: z\u00e1rol\u00e1s \u00b6 Az izol\u00e1ci\u00f3 biztos\u00edt\u00e1s\u00e1nak m\u00f3dja a z\u00e1rol\u00e1s: az adatb\u00e1zis-kezel\u0151 rendszer a rekordok olvas\u00e1sa \u00e9s \u00edr\u00e1sa sor\u00e1n megjel\u00f6li (z\u00e1rolja) az \u00e9rintett elemeket. A z\u00e1r elhelyez\u00e9se a hozz\u00e1f\u00e9r\u00e9s idej\u00e9ben t\u00f6rt\u00e9nik, m\u00edg az elenged\u00e9se a tranzakci\u00f3 v\u00e9gezt\u00e9vel. Azt, hogy milyen m\u0171velet eset\u00e9ben milyen z\u00e1rol\u00e1sra van sz\u00fcks\u00e9g (kiz\u00e1r\u00f3lagos, vagy megosztott z\u00e1r), az izol\u00e1ci\u00f3s szint \u00e9s az adott adatb\u00e1zis-kezel\u0151 rendszer implement\u00e1ci\u00f3ja hat\u00e1rozza meg. A z\u00e1rak seg\u00edts\u00e9g\u00e9vel val\u00f3j\u00e1ban a tranzakci\u00f3kat \u00fctemezi a rendszer. Amikor egy z\u00e1r nem \u00e9rhet\u0151 el, mert a m\u00f6g\u00f6ttes adatelemet m\u00e1s tranzakci\u00f3 haszn\u00e1lja \u00e9s a konkurens el\u00e9r\u00e9s a v\u00e1lasztott izol\u00e1ci\u00f3s szint szerint nem engedhet\u0151 meg, a tranzakci\u00f3 v\u00e1rakoztat\u00e1sra ker\u00fcl. Ha egy rendszerben z\u00e1rak vannak, akkor tudjuk, hogy holtpontok ( deadlock ) is el\u0151fordulhatnak. Holtpont akkor alakulhat ki, ha egy id\u0151ben legal\u00e1bb k\u00e9t tranzakci\u00f3 szeretn\u00e9 ugyanazon z\u00e1rakat megszerezni. Az al\u00e1bbi \u00e1br\u00e1n a folytonos ny\u00edl jel\u00f6li a megszerzett z\u00e1rat, a szaggatott vonal pedig a megszerzend\u0151 z\u00e1rat. A megszerzend\u0151 z\u00e1rak egyike se adhat\u00f3 ki, \u00edgy mind a k\u00e9t tranzakci\u00f3 meg\u00e1ll, v\u00e1rakoz\u00e1sra k\u00e9nyszer\u00fcl, de egyik se fog tudni ebb\u0151l az \u00e1llapotb\u00f3l kil\u00e9pni. Adatb\u00e1zis-kezel\u0151 rendszerekben a holtpontok nem el\u0151zhet\u0151ek meg, viszont kezelni sz\u00fcks\u00e9ges az el\u0151fordul\u00e1sukat. A megold\u00e1s, hogy a rendszer akt\u00edvan figyeli a z\u00e1rakat, \u00e9s amikor holtpontot \u00e9rz\u00e9kel, akkor az egyik \u00e9rintett tranzakci\u00f3t megszak\u00edtja \u00e9s m\u00f3dos\u00edt\u00e1sait \u00e9rv\u00e9nytelen\u00edti. Egy adatb\u00e1zist haszn\u00e1l\u00f3 alkalmaz\u00e1snak erre az eshet\u0151s\u00e9gre fel kell k\u00e9sz\u00fclnie. Holtpont ut\u00e1n, ha a tranzakci\u00f3 megszak\u00edt\u00e1sra ker\u00fclt, nem igaz\u00e1n tehet m\u00e1st az alkalmaz\u00e1s vagy felhaszn\u00e1l\u00f3, mint hogy kis id\u0151 eltelt\u00e9vel \u00fajra megpr\u00f3b\u00e1lja a m\u0171veletet. Tranzakci\u00f3s hat\u00e1rok \u00b6 A tranzakci\u00f3kr\u00f3l l\u00e1thattuk, hogy egy m\u0171veletsorozatot fognak egybe. Ehhez sz\u00fcks\u00e9g van a tranzakci\u00f3 elej\u00e9nek \u00e9s v\u00e9g\u00e9nek jel\u00f6l\u00e9s\u00e9hez. A tranzakci\u00f3 hat\u00e1rok platform f\u00fcgg\u0151en jel\u00f6lhet\u0151ek, de alapvet\u0151en \u00e9rv\u00e9nyesek az al\u00e1bbiak. Minden m\u0171velet az adatb\u00e1zisban tranzakci\u00f3ban fut. Ha nem jel\u00f6li a fejleszt\u0151 a tranzakci\u00f3 haszn\u00e1lat\u00e1t, akkor minden SQL utas\u00edt\u00e1s automatikusan \u00f6nmag\u00e1ban egy tranzakci\u00f3. Mivel minden SQL utas\u00edt\u00e1s tranzakci\u00f3ban fut, minden utas\u00edt\u00e1sra \u00f6nmag\u00e1ban is teljes\u00fclnek a tranzakci\u00f3k tulajdons\u00e1gai. P\u00e9ld\u00e1ul, ha egy delete utas\u00edt\u00e1s t\u00f6bb rekordot t\u00f6r\u00f6l, nem lehets\u00e9ges, hogy az utas\u00edt\u00e1s a lefut\u00e1sa k\u00f6zben megszakad, \u00e9s csak a rekordok fele ker\u00fclt t\u00f6rl\u00e9sre. A fejleszt\u0151 a tranzakci\u00f3 megkezd\u00e9shez a begin transaction SQL utas\u00edt\u00e1st, m\u00edg a bejezes\u00e9hez a commit vagy rollback utas\u00edt\u00e1sokat haszn\u00e1lhatja. A commit sikeresen lez\u00e1rja a tranzakci\u00f3t \u00e9s minden v\u00e1ltoz\u00e1st ment, m\u00edg rollback eset\u00e9n a tranzakci\u00f3 eldob\u00e1sra ker\u00fcl, \u00e9s vissza\u00e1ll a tranzakci\u00f3 megkezd\u00e9se el\u0151tti \u00e1llapot. Adatb\u00e1zis-kezel\u0151 rendszer f\u00fcgg\u0151en lehet\u0151s\u00e9g van tranzakci\u00f3ba \u00e1gyazott tranzakci\u00f3ra is. Ilyenkor a z\u00e1r\u00f3jelez\u00e9s szab\u00e1lyainak megfelel\u0151en t\u00f6rt\u00e9nik a tranzakci\u00f3k lez\u00e1r\u00e1sa. Tranzakci\u00f3s napl\u00f3z\u00e1s \u00b6 Eddigiekben csak arr\u00f3l besz\u00e9lt\u00fcnk, mit biztos\u00edt az adatb\u00e1zis-kezel\u0151 rendszer a tranzakci\u00f3k haszn\u00e1lat\u00e1val. Ismerj\u00fck meg ennek m\u0171k\u00f6d\u00e9s\u00e9t is. A tranzakci\u00f3s napl\u00f3z\u00e1s seg\u00edts\u00e9g\u00e9vel az adatb\u00e1zis rendszer nyomon tudja k\u00f6vetni a fut\u00f3 tranzakci\u00f3k \u00e1ltal v\u00e9gzett m\u00f3dos\u00edt\u00e1sokat, vissza tudja \u00e1ll\u00edtani a tranzakci\u00f3 megkezd\u00e9se el\u0151tti \u00e1llapotot, \u00e9s soft crash eset\u00e9n a f\u00e9lbeszakadt tranzakci\u00f3kat visszag\u00f6rgeti (rollback). Ahhoz, hogy meg\u00e9rts\u00fck a tranzakci\u00f3s napl\u00f3z\u00e1st, az al\u00e1bbi koncepcion\u00e1lis rendszermodellel dolgozunk. Ebben a modellben a k\u00f6vetkez\u0151 m\u0171veletek vannak: Begin T(x): Tranzakci\u00f3 kezdete Input(A): Adatelem beolvas\u00e1sa az adatb\u00e1zis tart\u00f3s t\u00e1rb\u00f3l (lemezr\u0151l) Output(A) Adatelem ki\u00edr\u00e1sa az adatb\u00e1zis tart\u00f3s t\u00e1rba (lemezre) Read(A): Tranzakci\u00f3 kiolvassa az adatelemet a mem\u00f3ria bufferb\u0151l Write(A): Tranzakci\u00f3 vissza\u00edrja az adatelemet a mem\u00f3ria bufferbe FLUSH_LOG: Tranzakci\u00f3s napl\u00f3 lemezre \u00edr\u00e1sa A napl\u00f3z\u00e1s m\u0171k\u00f6d\u00e9s\u00e9t egy p\u00e9ld\u00e1n kereszt\u00fck mutatjuk meg. A p\u00e9ld\u00e1ban a tranzakci\u00f3 k\u00e9t adatelemet m\u00f3dos\u00edt: A-t 2-vel cs\u00f6kkenti, \u00e9s B-t 2-vel n\u00f6veli. Undo t\u00edpus\u00fa napl\u00f3z\u00e1s \u00b6 Kezdetben a mem\u00f3ria buffer \u00fcres, az adatok csak az adatb\u00e1zis f\u00e1jlban tal\u00e1lhat\u00f3ak meg. A v\u00e9grehajt\u00e1s ez\u00e9rt az adatok beolvas\u00e1s\u00e1val kezd\u0151dik. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Begin(T1) 10 20 - - Begin T1 Input(A) 10 20 10 - Input(B) 10 20 10 20 A tranzakci\u00f3 sz\u00e1m\u00e1ra el\u0151\u00e1lltak a sz\u00fcks\u00e9ges adatok a mem\u00f3ria bufferben. A m\u00f3dos\u00edt\u00e1s elv\u00e9gz\u00e9s\u00e9hez a tranzakci\u00f3 kiolvassa az adatot, majd a m\u00f3dos\u00edtott \u00e9rt\u00e9ket vissza\u00edrja. Ezzel egy\u00fctt a tranzakci\u00f3s napl\u00f3ban r\u00f6gz\u00edt\u00e9sre ker\u00fcl a m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9k . M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 10 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 20 Ezzel a tranzakci\u00f3 befejezve a m\u0171veleteit, azonban a v\u00e1ltoztat\u00e1sok m\u00e9g nem lettek mentve. Ehhez kommit\u00e1l a tranzakci\u00f3, amely sor\u00e1n el\u0151sz\u00f6r a tranzakci\u00f3s napl\u00f3 bejegyz\u00e9sei a napl\u00f3f\u00e1jlba ki\u00edr\u00e1sra ker\u00fclnek, majd megt\u00f6rt\u00e9nik a m\u00f3dos\u00edt\u00e1s az adatb\u00e1zisban. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Flush_LOG 10 20 8 22 Output(A) 8 20 8 22 Output(B) 8 22 8 22 Commit T1 Gondoljuk v\u00e9gig, hogy soft crash eset\u00e9n hogyan kell helyre\u00e1ll\u00edtani a rendszert. Amennyiben a tranzakci\u00f3 a kommit el\u0151tt lett megszak\u00edtva, nincs dolga a rendszernek, mert az adatb\u00e1zis f\u00e1jlban nem t\u00f6rt\u00e9nt m\u00f3dos\u00edt\u00e1s, a mem\u00f3ria buffer pedig a soft crash hat\u00e1s\u00e1ra elt\u0171nik. Amennyiben a tranzakci\u00f3 elkezdte a kommit proced\u00far\u00e1t, az adatb\u00e1zisba m\u00e1r ki\u00edr\u00e1sra ker\u00fclhetett valamennyi v\u00e1ltoztat\u00e1s. Ezeket vissza kell \u00e1ll\u00edtani. Ilyenkor a tranzakci\u00f3s napl\u00f3t h\u00e1tulr\u00f3l olvasva kell feldolgozni, \u00e9s minden olyan tranzakci\u00f3 eset\u00e9n, amelynek nincs commit bejegyz\u00e9se a napl\u00f3ban, vissza\u00e1ll\u00edthat\u00f3 a napl\u00f3ban tal\u00e1lhat\u00f3 m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9k. R\u00f6viden \u00f6sszefoglalva undo napl\u00f3z\u00e1s eset\u00e9n az adatb\u00e1zis nem \u00edrhat\u00f3 \u00e1t, am\u00edg a tranzakci\u00f3s napl\u00f3 nincs ki\u00edrva, \u00e9s commit jelet csak az adatb\u00e1zis \u00edr\u00e1s ut\u00e1n lehet kitenni a napl\u00f3ba. A m\u0171k\u00f6d\u00e9s kulcsa, hogy a tranzakci\u00f3s napl\u00f3t el\u0151bb kell ki\u00edrni, mint a m\u00f3dos\u00edt\u00e1sokat az adatb\u00e1zis f\u00e1jlban elv\u00e9gezn\u00e9 a rendszer. A megold\u00e1s h\u00e1tr\u00e1nya, hogy k\u00e9tszer is kell a tranzakci\u00f3s napl\u00f3t f\u00e1jlba \u00edrni (amely a diszk \u00edr\u00e1s miatt k\u00f6lts\u00e9ges m\u0171velet). Redo t\u00edpus\u00fa napl\u00f3z\u00e1s \u00b6 A m\u0171veletsorozat a kor\u00e1bban l\u00e1tott beolvas\u00e1sokkal kezd\u0151dik, majd k\u00f6vetkezik a m\u00f3dos\u00edt\u00e1sok elv\u00e9gz\u00e9se, de ez\u00fattal a tranzakci\u00f3s napl\u00f3ban a m\u00f3dos\u00edt\u00e1s ut\u00e1ni \u00e9rt\u00e9k ker\u00fcl r\u00f6gz\u00edt\u00e9sre. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 8 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 22 A m\u00f3dos\u00edt\u00e1sok v\u00e9gleges\u00edt\u00e9s\u00e9hez a tranzakci\u00f3 elkezdni a kommit folyamatot, amely a tranzakci\u00f3s napl\u00f3t ki\u00edrja, \u00e9s r\u00f6gz\u00edti a kommit\u00e1l\u00e1s t\u00e9ny\u00e9t - de az adatb\u00e1zis f\u00e1jlban m\u00e9g nem m\u00f3dosultak az adatok. \u00cdgy a tranzakci\u00f3s napl\u00f3 f\u00e1jlba t\u00f6rt\u00e9n\u0151 \u00edr\u00e1sa egy m\u0171veletre reduk\u00e1l\u00f3dott (szemben az undo t\u00edpus\u00fa napl\u00f3z\u00e1ssal). M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Commit T1 Flush_LOG 10 20 8 22 A tranzakci\u00f3s napl\u00f3 ment\u00e9se ut\u00e1n v\u00e9gezhet\u0151 el a t\u00e9nyleges adat ment\u00e9se az adatb\u00e1zis f\u00e1jlba. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Output(A) 8 20 8 22 Output(B) 8 22 8 22 Gondoljuk v\u00e9gig, hogy soft crash eset\u00e9n hogyan kell helyre\u00e1ll\u00edtani a rendszert. Amennyiben a tranzakci\u00f3 a kommit el\u0151tt lett megszak\u00edtva, nincs dolga a rendszernek, mert az adatb\u00e1zis f\u00e1jlban nem t\u00f6rt\u00e9nt m\u00f3dos\u00edt\u00e1s, a mem\u00f3ria buffer pedig a soft crash hat\u00e1s\u00e1ra elt\u0171nik. Amennyiben a tranzakci\u00f3 elkezdte a kommit proced\u00far\u00e1t, m\u00e1r ki\u00edr\u00e1sra ker\u00fclt a napl\u00f3ba a commit t\u00e9nye, de az adatb\u00e1zis f\u00e1jl m\u00e9g nem m\u00f3dosult. Ha ilyenkor szakad meg a v\u00e9grehajt\u00e1s, akkor a vissza\u00e1ll\u00edt\u00e1s sor\u00e1n a tranzakci\u00f3s napl\u00f3t ez elej\u00e9t\u0151l kezdve kell feldolgozni, \u00e9s minden kommit\u00e1lt tranzakci\u00f3t \u00fajra v\u00e9gre kell hajtani. R\u00f6viden \u00f6sszefoglalva redo napl\u00f3z\u00e1s eset\u00e9n az adatb\u00e1zis nem \u00edrhat\u00f3 \u00e1t, am\u00edg a tranzakci\u00f3s napl\u00f3 nincs ki\u00edrva, \u00e9s commit jelet az adatb\u00e1zis \u00edr\u00e1s el\u0151tt kell kitenni a napl\u00f3ba. Az undo napl\u00f3z\u00e1shoz k\u00e9pest teh\u00e1t kevesebb a tranzakci\u00f3s napl\u00f3 szinkroniz\u00e1l\u00e1sa, de hosszabb a vissza\u00e1ll\u00edt\u00e1si folyamat. Undo/redo napl\u00f3z\u00e1s \u00b6 A nev\u00e9b\u0151l ad\u00f3d\u00f3an ez a megold\u00e1s az el\u0151z\u0151 kett\u0151 kombin\u00e1ci\u00f3ja. A p\u00e9lda m\u0171veletsor ugyan\u00fagy kezd\u0151dik, mint kor\u00e1bban. A k\u00fcl\u00f6nbs\u00e9g a tranzakci\u00f3s napl\u00f3ba val\u00f3 \u00edr\u00e1sn\u00e1l jelentkezik: mind a v\u00e1ltoz\u00e1s el\u0151tti, mind a v\u00e1ltoz\u00e1s ut\u00e1ni \u00e9rt\u00e9k ki\u00edr\u00e1sra ker\u00fcl. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 10, 8 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 20, 22 A kommit folyamat is egyszer\u0171s\u00f6dik. Az adatb\u00e1zis f\u00e1jlba val\u00f3 \u00edr\u00e1s \u00e9s a kommit jel ki\u00edr\u00e1sa a tranzakci\u00f3s napl\u00f3ba tetsz\u0151leges sorrendben elv\u00e9gezhet\u0151 (de mindenk\u00e9ppen meg kell el\u0151zze \u0151ket a tranzakci\u00f3s napl\u00f3 f\u00e1jlba \u00edr\u00e1sa). A v\u00e1ltoz\u00e1s teh\u00e1t, hogy a commit jel helye nem k\u00f6t\u00f6tt. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Flush_LOG 10 20 8 22 Output(A) 8 20 8 22 Commit T1 Output(B) 8 22 8 22 A vissza\u00e1ll\u00edt\u00e1s sor\u00e1n a kor\u00e1bban ismertetett m\u00f3dok kombin\u00e1l\u00e1s\u00e1ra van sz\u00fcks\u00e9g: m\u00e1r kommit\u00e1lt tranzakci\u00f3k eset\u00e9ben a v\u00e1ltoz\u00e1s \u00fajraj\u00e1tsz\u00e1s\u00e1ra van sz\u00fcks\u00e9g (mind a redo eset\u00e9n), m\u00edg a f\u00e9lbeszakadt tranzakci\u00f3k el\u0151tti \u00e1llapot az undo napl\u00f3z\u00e1shoz hasonl\u00f3an \u00e1ll\u00edthat\u00f3 helyre. Ennek a megold\u00e1snak az el\u0151nye, hogy kevesebb szinkroniz\u00e1ci\u00f3 sz\u00fcks\u00e9ges a bels\u0151 m\u0171k\u00f6d\u00e9sben (a tranzakci\u00f3s napl\u00f3 \u00edr\u00e1sa \u00e9s az adatb\u00e1zis f\u00e1jlok \u00edr\u00e1sa tekintet\u00e9ben), valamint a m\u00f3dos\u00edt\u00e1s hamarabb r\u00f6gz\u00edthet\u0151 az adatb\u00e1zis f\u00e1jlban (nem kell a tranzakci\u00f3s napl\u00f3ban megv\u00e1rni a commit jel r\u00f6gz\u00edt\u00e9s\u00e9t). Tranzakci\u00f3s napl\u00f3 m\u00e9ret\u00e9nek cs\u00f6kkent\u00e9se \u00b6 A tranzakci\u00f3s napl\u00f3 f\u00e1jlt id\u0151nk\u00e9nt sz\u00fcks\u00e9ges ki\u00fcr\u00edteni, nem n\u0151het a v\u00e9gtelens\u00e9gig. Olyan tranzakci\u00f3k bejegyz\u00e9sei t\u00f6r\u00f6lhet\u0151ek bel\u0151le, amelyek val\u00f3ban kommit\u00e1l\u00e1sra ker\u00fcltek (az adatb\u00e1zis f\u00e1jlba be\u00edr\u00e1sra ker\u00fclt minden eredm\u00e9ny\u00fck), vagy amelyek megszakadtak, \u00e9s nem kell \u0151ket vissza\u00e1ll\u00edtani. Ez a folyamat \u00e1ltal\u00e1ban automatikus, de kezdem\u00e9nyezhet\u0151 manu\u00e1lisan is. Hosszan fut\u00f3 tranzakci\u00f3k eset\u00e9ben k\u00fcl\u00f6n\u00f6sen \u00e9rdemes figyelni a tranzakci\u00f3s napl\u00f3 m\u00e9ret\u00e9re. Min\u00e9l nagyobbra n\u0151, ann\u00e1l lassabb ut\u00e1na a m\u00e9ret cs\u00f6kkent\u00e9s. Ellen\u0151rz\u0151 k\u00e9rd\u00e9sek \u00b6 Milyen konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9m\u00e1kat ismersz? Milyen izol\u00e1ci\u00f3s szintek vannak? Milyen probl\u00e9m\u00e1kra adnak megold\u00e1st? Mik a tranzakci\u00f3k alaptulajdons\u00e1gai? D\u00f6ntse el, hogy igaz vagy hamis az al\u00e1bbi \u00e1ll\u00edt\u00e1s: A serializable izol\u00e1ci\u00f3s szint egym\u00e1s ut\u00e1n hajtja v\u00e9gre a tranzakci\u00f3kat. A holtpont elker\u00fclhet\u0151 a megfelel\u0151 izol\u00e1ci\u00f3s szint haszn\u00e1lat\u00e1val. A read committed \u00e1ltal\u00e1ban az alap\u00e9rtelmezett izol\u00e1ci\u00f3s szint. Ha nem haszn\u00e1lunk explicit ind\u00edtott tranzakci\u00f3t, akkor (alapesetben) elker\u00fclj\u00fck a piszkos olvas\u00e1st. A tranzakci\u00f3s napl\u00f3 v\u00e9d minden f\u00e9le adatveszt\u00e9ssel szemben. Redo tranzakci\u00f3s napl\u00f3z\u00e1s eset\u00e9n a commit jellel kezd\u0151dik a tranzakci\u00f3s napl\u00f3.","title":"Tranzakci\u00f3kezel\u00e9s adatb\u00e1zisokban"},{"location":"jegyzet/transactions/#tranzakciokezeles-adatbazisokban","text":"Kontextus Az al\u00e1bbiak alapvet\u0151en rel\u00e1ci\u00f3s adatb\u00e1zisokra vonatkoz\u00f3an ismertetik a tranzakci\u00f3kat. Azonban a probl\u00e9m\u00e1k \u00e9s megold\u00e1sok egy r\u00e9sze \u00e1ltal\u00e1nos, \u00e9s m\u00e1s jelleg\u0171 adatb\u00e1zis rendszerekben is megtal\u00e1lhat\u00f3ak.","title":"Tranzakci\u00f3kezel\u00e9s adatb\u00e1zisokban"},{"location":"jegyzet/transactions/#konkurens-adathozzaferes","text":"Az adatb\u00e1zis-kezel\u0151 rendszerek kliens-szerver \u00fczemm\u00f3dban m\u0171k\u00f6dnek. A kliensek (az \u00e1ltalunk \u00edrt szoftverek) csatlakoznak az adatb\u00e1zishoz \u00e9s k\u00e9r\u00e9seket hajtatnak v\u00e9gre. Ebben a fel\u00e1ll\u00e1sban egy adatb\u00e1zis-kezel\u0151 rendszer \u00e9s t\u00f6bb kliens vesz r\u00e9szt. Az adatb\u00e1zis rendszer c\u00e9lja, hogy min\u00e9l t\u00f6bb k\u00e9r\u00e9st szolg\u00e1ljon ki, ez\u00e9rt a k\u00e9r\u00e9seket egym\u00e1ssal p\u00e1rhuzamosan hajtja v\u00e9gre . Egy ilyen rendszerben az al\u00e1bbi konkurens (egy id\u0151ben t\u00f6rt\u00e9n\u0151) adathozz\u00e1f\u00e9r\u00e9si esetek lehets\u00e9gesek. Amennyiben a hozz\u00e1f\u00e9r\u00e9sek, ak\u00e1r \u00edr\u00e1s, ak\u00e1r olvas\u00e1s, elt\u00e9r\u0151 adatra vonatkoznak, nincs probl\u00e9ma, a m\u0171veletek egyszerre is t\u00f6rt\u00e9nhetnek. Amennyiben minden hozz\u00e1f\u00e9r\u00e9s csak olvas\u00e1s, nincs probl\u00e9ma: olvasni egyszerre t\u00f6bben is tudnak. Viszont, ha ugyanazon adathoz egy id\u0151ben t\u00f6bben f\u00e9rnek hozz\u00e1 , \u00e9s legal\u00e1bb egy \u00edr\u00e1s is van k\u00f6zt\u00fck , akkor fell\u00e9phet a konkurencia probl\u00e9m\u00e1ja. Ez a konkurencia probl\u00e9ma nem k\u00fcl\u00f6nb\u00f6zik az oper\u00e1ci\u00f3s rendszerek \u00e9s v\u00e1ltozatos programoz\u00e1si nyelvek eset\u00e9n megismert konkurencia \u00e9s k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s probl\u00e9m\u00e1j\u00e1t\u00f3l. Ott t\u00f6bbnyire mem\u00f3ria hozz\u00e1f\u00e9r\u00e9sr\u0151l, azonos mem\u00f3riater\u00fclet \u00edr\u00e1s-olvas\u00e1s\u00e1r\u00f3l van sz\u00f3, \u00e9s a megold\u00e1s a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s, azaz a programoz\u00f3 v\u00e9delmi vonallal l\u00e1tja el az adat hozz\u00e1f\u00e9r\u00e9s hely\u00e9t. Adatb\u00e1zis-kezel\u0151 rendszerekben a konkurens hozz\u00e1f\u00e9r\u00e9s az adatb\u00e1zisban tal\u00e1lhat\u00f3 rekordokra (sorokra) vonatkozik, \u00e9s a v\u00e9delmi vonalat a tranzakci\u00f3k adj\u00e1k.","title":"Konkurens adathozz\u00e1f\u00e9r\u00e9s"},{"location":"jegyzet/transactions/#tranzakciok","text":"Defin\u00edci\u00f3 A tranzakci\u00f3 a feldolgoz\u00e1s logikai egys\u00e9ge, olyan m\u0171veletek sorozata, melyek csak egy\u00fcttesen \u00e9rtelmesek. A tranzakci\u00f3kkal teh\u00e1t m\u0171veleteket fogunk \u00f6ssze egy egys\u00e9gbe, amelyekre vonatkoz\u00f3an a rendszer biztos\u00edtja az al\u00e1bbi tulajdons\u00e1gokat: atomi v\u00e9grehajt\u00e1s (atomicity), konzisztencia (consistency), egym\u00e1st\u00f3l val\u00f3 izol\u00e1ci\u00f3 (isolation), \u00e9s tart\u00f3ss\u00e1g (durability). Vizsg\u00e1ljuk meg a tranzakci\u00f3k alaptulajdons\u00e1gait, hogy meg\u00e9rthess\u00fck, hogyan oldhatjuk meg haszn\u00e1latukkal a konkurens adathozz\u00e1f\u00e9r\u00e9s probl\u00e9m\u00e1j\u00e1t. A tranzakci\u00f3 csak eszk\u00f6z A tranzakci\u00f3k (a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s biztos\u00edt\u00e1s\u00e1hoz haszn\u00e1lt mutexekhez hasonl\u00f3an) csak eszk\u00f6zt adnak a programoz\u00f3 kez\u00e9be, de a helyes haszn\u00e1lat a fejleszt\u0151 felel\u0151ss\u00e9ge.","title":"Tranzakci\u00f3k"},{"location":"jegyzet/transactions/#tranzakciok-alaptulajdonsagai","text":"","title":"Tranzakci\u00f3k alaptulajdons\u00e1gai"},{"location":"jegyzet/transactions/#atomi-vegrehajtas","text":"Az atomi v\u00e9grehajt\u00e1s azt jelenti, hogy a m\u0171velet sorozatunk t\u00f6bb utas\u00edt\u00e1st tartalmaz, azonban ezen utas\u00edt\u00e1s sorozat csak egyben \u00e9rtelmes, a r\u00e9szleges v\u00e9grehajt\u00e1st meg kell akad\u00e1lyozni. Erre az\u00e9rt van sz\u00fcks\u00e9g, mert gyakran az adatb\u00e1zisban v\u00e9grehajtott m\u0171veleteinket t\u00f6bb utas\u00edt\u00e1s seg\u00edts\u00e9g\u00e9vel tudjuk csak kifejezni, de az utas\u00edt\u00e1sok k\u00f6z\u00f6tt nem szak\u00edthat\u00f3 meg a m\u0171velet. K\u00e9pzelj\u00fck el egy webshopban a v\u00e1s\u00e1rl\u00e1s v\u00e9g\u00e9t lez\u00e1r\u00f3 m\u0171veletet: R\u00f6gz\u00edtj\u00fck a megrendel\u00e9st, elmentj\u00fck egy rekordban a megrendel\u0151 adatait A megrendelt term\u00e9kn\u00e9l cs\u00f6kkentj\u00fck a rakt\u00e1ron lev\u0151 darabsz\u00e1mot, hiszen egyet eladtunk Ez a m\u0171veletsorozat csak egyben \u00e9rtelmes. Amennyiben a megrendel\u00e9st r\u00f6gz\u00edtett\u00fck, musz\u00e1j a rakt\u00e1rk\u00e9szletet is cs\u00f6kkenteni, k\u00fcl\u00f6nben t\u00f6bbet adhatunk el a term\u00e9kb\u0151l, mint amennyi rendelkez\u00e9sre \u00e1ll. A k\u00e9t l\u00e9p\u00e9s k\u00f6z\u00f6tt teh\u00e1t a m\u0171velet nem szak\u00edthat\u00f3 f\u00e9lbe. Ezt garant\u00e1lja az atomi v\u00e9grehajt\u00e1s: ha a m\u0171veletsorozat v\u00e9grehajt\u00e1sa megkezd\u0151d\u00f6tt, akkor annak vagy teljes eg\u00e9sz\u00e9ben le kell futnia, vegy vissza kell \u00e1llnia a v\u00e9grehajt\u00e1st megel\u0151z\u0151 \u00e1llapotba .","title":"Atomi v\u00e9grehajt\u00e1s"},{"location":"jegyzet/transactions/#konzisztencia","text":"Az adatb\u00e1zis konzisztenci\u00e1j\u00e1nak szab\u00e1lyait r\u00e9szben az integrit\u00e1si krit\u00e9riumokkal \u00edrhatjuk le: p\u00e9ld\u00e1ul egy k\u00fcls\u0151 kulcs \u00e1ltal hivatkozott rekordnak l\u00e9teznie kell. Ezen k\u00edv\u00fcl az adatok k\u00f6z\u00f6tti \u00f6sszef\u00fcgg\u00e9seket is bele\u00e9rtj\u00fck a konzisztenci\u00e1ba: p\u00e9ld\u00e1ul a Neptun rendszerben nem lehet t\u00f6bb jelentkez\u0151 a vizsg\u00e1ra, mint a vizsga l\u00e9tsz\u00e1mkorl\u00e1tja. Tranzakci\u00f3k haszn\u00e1lata biztos\u00edtja sz\u00e1munkra, hogy az adatb\u00e1zisunk mindig konzisztens \u00e1llapotban van. Egy megkezdett tranzakci\u00f3 lefut\u00e1sa sor\u00e1n el\u0151fordulhat ideiglenesen inkonzisztens \u00e1llapot, mint a fenti p\u00e9ld\u00e1ban az egyes l\u00e9p\u00e9sek k\u00f6z\u00f6tt. Azonban a tranzakci\u00f3 v\u00e9g\u00e9re a konzisztenci\u00e1nak helyre kell \u00e1llnia. M\u00e1s sz\u00f3val: a tranzakci\u00f3k az adatb\u00e1zist konzisztens \u00e1llapotb\u00f3l konzisztens \u00e1llapotba viszik .","title":"Konzisztencia"},{"location":"jegyzet/transactions/#tartossag","text":"A tart\u00f3ss\u00e1g tulajdons\u00e1ga azt \u00edrja el\u0151, hogy a tranzakci\u00f3 hat\u00e1sa tart\u00f3san megmarad , azaz a tranzakci\u00f3 \u00e1ltal v\u00e9gzett m\u0171veletek eredm\u00e9nye nem veszhet el. Praktikusan ezt azt jelenti, hogy a tranzakci\u00f3 \u00e1ltal v\u00e9gzett m\u00f3dos\u00edt\u00e1sok nem csak mem\u00f3ri\u00e1ban ker\u00fclnek elv\u00e9gz\u00e9sre, hanem tart\u00f3s t\u00e1rra (merevlemezre) is ki\u00edr\u00e1sra ker\u00fclnek. Az adatb\u00e1zisban k\u00e9t f\u00e9le hib\u00e1t k\u00fcl\u00f6nb\u00f6ztet\u00fcnk meg, amikor adatveszt\u00e9s k\u00f6vetkezhet be: soft crash \u00e9s hard crash. Soft crash eset\u00e9n az adatb\u00e1zis szerver le\u00e1ll, \u00edgy a mem\u00f3ria tartalma elveszik. Ez ellen v\u00e9denek a tranzakci\u00f3k. Hard crash eset\u00e9n a merevlemez is s\u00e9r\u00fcl; ez ellen csak a biztons\u00e1gi ment\u00e9s tud v\u00e9deni.","title":"Tart\u00f3ss\u00e1g"},{"location":"jegyzet/transactions/#izolacio","text":"Az izol\u00e1ci\u00f3 a tranzakci\u00f3k egym\u00e1st\u00f3l val\u00f3 \"elszigetel\u00e9s\u00e9t\" jelenti. A tranzakci\u00f3inkat \u00fagy \u00edrhatjuk meg, hogy annak helyes lefuttat\u00e1s\u00e1r\u00f3l a rendszer fog gondoskodni. A fejleszt\u0151 teh\u00e1t \u00fagy \u00edrhatja meg a tranzakci\u00f3t, mintha az a rendszerben egyed\u00fcl futna, \u00e9s az adatb\u00e1zis rendszer garant\u00e1lja, hogy megadott szab\u00e1lyrendszer szerint nem fog el\u0151fordulni konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9ma . Val\u00f3j\u00e1ban a rendszerben egyszerre sok tranzakci\u00f3 fut, azonban az adatb\u00e1zis-kezel\u0151 rendszer garant\u00e1lja, hogy olyan \u00fctemez\u00e9sben futtatja tranzakci\u00f3kat, amelyek nem s\u00e9rtik a tranzakci\u00f3k \u00e1ltal elv\u00e1rt izol\u00e1ci\u00f3s szintet. Ehhez a tranzakci\u00f3nak specifik\u00e1lnia kell az izol\u00e1ci\u00f3s szintet .","title":"Izol\u00e1ci\u00f3"},{"location":"jegyzet/transactions/#izolacios-problemak-es-izolacios-szintek","text":"Az izol\u00e1ci\u00f3s szintek megismer\u00e9s\u00e9hez el\u0151sz\u00f6r meg kell ismern\u00fcnk, hogy pontosan milyen konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9m\u00e1k mer\u00fclhetnek fel.","title":"Izol\u00e1ci\u00f3s probl\u00e9m\u00e1k \u00e9s izol\u00e1ci\u00f3s szintek"},{"location":"jegyzet/transactions/#problemak","text":"","title":"Probl\u00e9m\u00e1k"},{"location":"jegyzet/transactions/#piszkos-olvasas-dirty-read","text":"A piszkos olvas\u00e1s sor\u00e1n egy tranzakci\u00f3 egy m\u00e1sik tranzakci\u00f3 nem kommit\u00e1lt adatait haszn\u00e1lja: Egy tranzakci\u00f3 fut\u00e1sa sor\u00e1n m\u00f3dos\u00edt egy \u00e9rt\u00e9ket, de m\u00e9g nem kommit\u00e1l. Egy m\u00e1sik tranzakci\u00f3 ugyanezt a (m\u00e1r m\u00f3dos\u00edtott) \u00e9rt\u00e9ket kiolvassa. Az els\u0151 tranzakci\u00f3 megszak\u00edt\u00e1sra ker\u00fcl, \u00e9s a rendszer vissza\u00e1ll\u00edtja a m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9ket. A 2. l\u00e9p\u00e9sben felhaszn\u00e1lt \u00e9rt\u00e9k teh\u00e1t \u00e9rv\u00e9nytelen azt nem lett volna szabad felhaszn\u00e1lni. A k\u00e9pek forr\u00e1sa https://vladmihalcea.com/2014/01/05/a-beginners-guide-to-acid-and-database-transactions/ A piszkos olvas\u00e1st szinte minden esetben el akarjuk ker\u00fclni.","title":"Piszkos olvas\u00e1s (dirty read)"},{"location":"jegyzet/transactions/#elveszett-modositas-lost-update","text":"Az elveszett m\u00f3dos\u00edt\u00e1s sor\u00e1n k\u00e9t \u00edr\u00e1s ker\u00fcl konfliktusba: Egy tranzakci\u00f3 megv\u00e1ltoztat egy \u00e9rt\u00e9ket. Egy m\u00e1sik tranzakci\u00f3 ugyanazon \u00e9rt\u00e9ket fel\u00fcl\u00edrja. V\u00e9geredm\u00e9nyben csak a m\u00e1sodik \u00edr\u00e1s eredm\u00e9nye marad meg, mintha az els\u0151 m\u00f3dos\u00edt\u00e1s nem is t\u00f6rt\u00e9nt volna meg.","title":"Elveszett m\u00f3dos\u00edt\u00e1s (lost update)"},{"location":"jegyzet/transactions/#nem-megismetelheto-olvasas-nonrepeatable-read","text":"A nem megism\u00e9telhet\u0151 olvas\u00e1s sor\u00e1n a lek\u00e9rdez\u00e9s eredm\u00e9nye f\u00fcgg att\u00f3l, hogy id\u0151ben mikor adt\u00e1k ki egy tranzakci\u00f3ban: Egy tranzakci\u00f3 lek\u00e9rdez egy adatot. Egy m\u00e1sik tranzakci\u00f3 m\u00f3dos\u00edtja ugyanazt az adatelemet. Ha az els\u0151 tranzakci\u00f3 megism\u00e9tli a kor\u00e1bbi lek\u00e9rdez\u00e9st, m\u00e1s eredm\u00e9nyt kap.","title":"Nem megism\u00e9telhet\u0151 olvas\u00e1s (nonrepeatable read)"},{"location":"jegyzet/transactions/#fantom-rekordok-phantom-recordsphantom-read","text":"A fantom rekordok probl\u00e9m\u00e1ja akkor jelentkezik, amikor rekord halmazokkal dolgozunk: Egy tranzakci\u00f3 lek\u00e9rdez egy eredm\u00e9nyhalmazt, amelyben t\u00f6bb rekord van. Ek\u00f6zben egy m\u00e1sik tranzakci\u00f3 t\u00f6r\u00f6l egy rekordot, amely r\u00e9sze a lek\u00e9rdezett eredm\u00e9nyhalmaznak. Az els\u0151 tranzakci\u00f3 elkezdi feldolgozni az eredm\u00e9nyhalmazt, p\u00e9ld\u00e1ul iter\u00e1tor-szer\u0171en egyes\u00e9vel megy v\u00e9gig a rekordhalmazon. A t\u00f6r\u00f6lt rekord ilyenkor r\u00e9sze a lek\u00e9rdezett eredm\u00e9nyhalmaznak, vagy sem? Hasonl\u00f3an elk\u00e9pzelhet\u0151 az is, hogy egy rekord m\u00f3dosul a 2. l\u00e9p\u00e9sben. Ilyenkor a 3. l\u00e9p\u00e9sben a kor\u00e1bbi, vagy a m\u00f3dosult \u00e1llapot\u00e1t kellene l\u00e1tni?","title":"Fantom rekordok (phantom records/phantom read)"},{"location":"jegyzet/transactions/#izolacios-szintek","text":"A fenti probl\u00e9m\u00e1k mindegyike elker\u00fclhet\u0151 a megfelel\u0151 izol\u00e1ci\u00f3s szint megv\u00e1laszt\u00e1s\u00e1val. Azonban min\u00e9l \"magasabb\" izol\u00e1ci\u00f3s szintet v\u00e1lasztunk, ann\u00e1l kisebb az adatb\u00e1zis-kezel\u0151 rendszer \u00e1tbocs\u00e1t\u00f3k\u00e9pess\u00e9ge, \u00e9s ann\u00e1l nagyobb a lehet\u0151s\u00e9ge a holtpont kialakul\u00e1s\u00e1nak (l\u00e1sd al\u00e1bb). Ez\u00e9rt a c\u00e9l egy megfelel\u0151 kompromisszum megtal\u00e1l\u00e1sa a lehets\u00e9ges probl\u00e9m\u00e1k \u00e9s a teljes\u00edtm\u00e9ny k\u00f6z\u00f6tt. Az ANSI/ISO SQL szabv\u00e1ny az al\u00e1bbi izol\u00e1ci\u00f3s szinteket k\u00fcl\u00f6nb\u00f6zteti meg. Read uncommitted: nem ny\u00fajt megold\u00e1st egyik probl\u00e9m\u00e1ra se. Read committed: nincs piszkos olvas\u00e1s. Repeatable read: nincs piszkos olvas\u00e1s, se nem megism\u00e9telhet\u0151 olvas\u00e1s. Serializable: egyik probl\u00e9ma sem fordulhat el\u0151. A read uncommitted szintet \u00e1ltal\u00e1ban nem haszn\u00e1ljuk. A serializable-t pedig lehet\u0151s\u00e9g szerint elker\u00fclj\u00fck. Az alap\u00e9rtelmezett szint \u00e1ltal\u00e1ban a read committed .","title":"Izol\u00e1ci\u00f3s szintek"},{"location":"jegyzet/transactions/#utemezes-biztositasa-zarolas","text":"Az izol\u00e1ci\u00f3 biztos\u00edt\u00e1s\u00e1nak m\u00f3dja a z\u00e1rol\u00e1s: az adatb\u00e1zis-kezel\u0151 rendszer a rekordok olvas\u00e1sa \u00e9s \u00edr\u00e1sa sor\u00e1n megjel\u00f6li (z\u00e1rolja) az \u00e9rintett elemeket. A z\u00e1r elhelyez\u00e9se a hozz\u00e1f\u00e9r\u00e9s idej\u00e9ben t\u00f6rt\u00e9nik, m\u00edg az elenged\u00e9se a tranzakci\u00f3 v\u00e9gezt\u00e9vel. Azt, hogy milyen m\u0171velet eset\u00e9ben milyen z\u00e1rol\u00e1sra van sz\u00fcks\u00e9g (kiz\u00e1r\u00f3lagos, vagy megosztott z\u00e1r), az izol\u00e1ci\u00f3s szint \u00e9s az adott adatb\u00e1zis-kezel\u0151 rendszer implement\u00e1ci\u00f3ja hat\u00e1rozza meg. A z\u00e1rak seg\u00edts\u00e9g\u00e9vel val\u00f3j\u00e1ban a tranzakci\u00f3kat \u00fctemezi a rendszer. Amikor egy z\u00e1r nem \u00e9rhet\u0151 el, mert a m\u00f6g\u00f6ttes adatelemet m\u00e1s tranzakci\u00f3 haszn\u00e1lja \u00e9s a konkurens el\u00e9r\u00e9s a v\u00e1lasztott izol\u00e1ci\u00f3s szint szerint nem engedhet\u0151 meg, a tranzakci\u00f3 v\u00e1rakoztat\u00e1sra ker\u00fcl. Ha egy rendszerben z\u00e1rak vannak, akkor tudjuk, hogy holtpontok ( deadlock ) is el\u0151fordulhatnak. Holtpont akkor alakulhat ki, ha egy id\u0151ben legal\u00e1bb k\u00e9t tranzakci\u00f3 szeretn\u00e9 ugyanazon z\u00e1rakat megszerezni. Az al\u00e1bbi \u00e1br\u00e1n a folytonos ny\u00edl jel\u00f6li a megszerzett z\u00e1rat, a szaggatott vonal pedig a megszerzend\u0151 z\u00e1rat. A megszerzend\u0151 z\u00e1rak egyike se adhat\u00f3 ki, \u00edgy mind a k\u00e9t tranzakci\u00f3 meg\u00e1ll, v\u00e1rakoz\u00e1sra k\u00e9nyszer\u00fcl, de egyik se fog tudni ebb\u0151l az \u00e1llapotb\u00f3l kil\u00e9pni. Adatb\u00e1zis-kezel\u0151 rendszerekben a holtpontok nem el\u0151zhet\u0151ek meg, viszont kezelni sz\u00fcks\u00e9ges az el\u0151fordul\u00e1sukat. A megold\u00e1s, hogy a rendszer akt\u00edvan figyeli a z\u00e1rakat, \u00e9s amikor holtpontot \u00e9rz\u00e9kel, akkor az egyik \u00e9rintett tranzakci\u00f3t megszak\u00edtja \u00e9s m\u00f3dos\u00edt\u00e1sait \u00e9rv\u00e9nytelen\u00edti. Egy adatb\u00e1zist haszn\u00e1l\u00f3 alkalmaz\u00e1snak erre az eshet\u0151s\u00e9gre fel kell k\u00e9sz\u00fclnie. Holtpont ut\u00e1n, ha a tranzakci\u00f3 megszak\u00edt\u00e1sra ker\u00fclt, nem igaz\u00e1n tehet m\u00e1st az alkalmaz\u00e1s vagy felhaszn\u00e1l\u00f3, mint hogy kis id\u0151 eltelt\u00e9vel \u00fajra megpr\u00f3b\u00e1lja a m\u0171veletet.","title":"\u00dctemez\u00e9s biztos\u00edt\u00e1sa: z\u00e1rol\u00e1s"},{"location":"jegyzet/transactions/#tranzakcios-hatarok","text":"A tranzakci\u00f3kr\u00f3l l\u00e1thattuk, hogy egy m\u0171veletsorozatot fognak egybe. Ehhez sz\u00fcks\u00e9g van a tranzakci\u00f3 elej\u00e9nek \u00e9s v\u00e9g\u00e9nek jel\u00f6l\u00e9s\u00e9hez. A tranzakci\u00f3 hat\u00e1rok platform f\u00fcgg\u0151en jel\u00f6lhet\u0151ek, de alapvet\u0151en \u00e9rv\u00e9nyesek az al\u00e1bbiak. Minden m\u0171velet az adatb\u00e1zisban tranzakci\u00f3ban fut. Ha nem jel\u00f6li a fejleszt\u0151 a tranzakci\u00f3 haszn\u00e1lat\u00e1t, akkor minden SQL utas\u00edt\u00e1s automatikusan \u00f6nmag\u00e1ban egy tranzakci\u00f3. Mivel minden SQL utas\u00edt\u00e1s tranzakci\u00f3ban fut, minden utas\u00edt\u00e1sra \u00f6nmag\u00e1ban is teljes\u00fclnek a tranzakci\u00f3k tulajdons\u00e1gai. P\u00e9ld\u00e1ul, ha egy delete utas\u00edt\u00e1s t\u00f6bb rekordot t\u00f6r\u00f6l, nem lehets\u00e9ges, hogy az utas\u00edt\u00e1s a lefut\u00e1sa k\u00f6zben megszakad, \u00e9s csak a rekordok fele ker\u00fclt t\u00f6rl\u00e9sre. A fejleszt\u0151 a tranzakci\u00f3 megkezd\u00e9shez a begin transaction SQL utas\u00edt\u00e1st, m\u00edg a bejezes\u00e9hez a commit vagy rollback utas\u00edt\u00e1sokat haszn\u00e1lhatja. A commit sikeresen lez\u00e1rja a tranzakci\u00f3t \u00e9s minden v\u00e1ltoz\u00e1st ment, m\u00edg rollback eset\u00e9n a tranzakci\u00f3 eldob\u00e1sra ker\u00fcl, \u00e9s vissza\u00e1ll a tranzakci\u00f3 megkezd\u00e9se el\u0151tti \u00e1llapot. Adatb\u00e1zis-kezel\u0151 rendszer f\u00fcgg\u0151en lehet\u0151s\u00e9g van tranzakci\u00f3ba \u00e1gyazott tranzakci\u00f3ra is. Ilyenkor a z\u00e1r\u00f3jelez\u00e9s szab\u00e1lyainak megfelel\u0151en t\u00f6rt\u00e9nik a tranzakci\u00f3k lez\u00e1r\u00e1sa.","title":"Tranzakci\u00f3s hat\u00e1rok"},{"location":"jegyzet/transactions/#tranzakcios-naplozas","text":"Eddigiekben csak arr\u00f3l besz\u00e9lt\u00fcnk, mit biztos\u00edt az adatb\u00e1zis-kezel\u0151 rendszer a tranzakci\u00f3k haszn\u00e1lat\u00e1val. Ismerj\u00fck meg ennek m\u0171k\u00f6d\u00e9s\u00e9t is. A tranzakci\u00f3s napl\u00f3z\u00e1s seg\u00edts\u00e9g\u00e9vel az adatb\u00e1zis rendszer nyomon tudja k\u00f6vetni a fut\u00f3 tranzakci\u00f3k \u00e1ltal v\u00e9gzett m\u00f3dos\u00edt\u00e1sokat, vissza tudja \u00e1ll\u00edtani a tranzakci\u00f3 megkezd\u00e9se el\u0151tti \u00e1llapotot, \u00e9s soft crash eset\u00e9n a f\u00e9lbeszakadt tranzakci\u00f3kat visszag\u00f6rgeti (rollback). Ahhoz, hogy meg\u00e9rts\u00fck a tranzakci\u00f3s napl\u00f3z\u00e1st, az al\u00e1bbi koncepcion\u00e1lis rendszermodellel dolgozunk. Ebben a modellben a k\u00f6vetkez\u0151 m\u0171veletek vannak: Begin T(x): Tranzakci\u00f3 kezdete Input(A): Adatelem beolvas\u00e1sa az adatb\u00e1zis tart\u00f3s t\u00e1rb\u00f3l (lemezr\u0151l) Output(A) Adatelem ki\u00edr\u00e1sa az adatb\u00e1zis tart\u00f3s t\u00e1rba (lemezre) Read(A): Tranzakci\u00f3 kiolvassa az adatelemet a mem\u00f3ria bufferb\u0151l Write(A): Tranzakci\u00f3 vissza\u00edrja az adatelemet a mem\u00f3ria bufferbe FLUSH_LOG: Tranzakci\u00f3s napl\u00f3 lemezre \u00edr\u00e1sa A napl\u00f3z\u00e1s m\u0171k\u00f6d\u00e9s\u00e9t egy p\u00e9ld\u00e1n kereszt\u00fck mutatjuk meg. A p\u00e9ld\u00e1ban a tranzakci\u00f3 k\u00e9t adatelemet m\u00f3dos\u00edt: A-t 2-vel cs\u00f6kkenti, \u00e9s B-t 2-vel n\u00f6veli.","title":"Tranzakci\u00f3s napl\u00f3z\u00e1s"},{"location":"jegyzet/transactions/#undo-tipusu-naplozas","text":"Kezdetben a mem\u00f3ria buffer \u00fcres, az adatok csak az adatb\u00e1zis f\u00e1jlban tal\u00e1lhat\u00f3ak meg. A v\u00e9grehajt\u00e1s ez\u00e9rt az adatok beolvas\u00e1s\u00e1val kezd\u0151dik. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Begin(T1) 10 20 - - Begin T1 Input(A) 10 20 10 - Input(B) 10 20 10 20 A tranzakci\u00f3 sz\u00e1m\u00e1ra el\u0151\u00e1lltak a sz\u00fcks\u00e9ges adatok a mem\u00f3ria bufferben. A m\u00f3dos\u00edt\u00e1s elv\u00e9gz\u00e9s\u00e9hez a tranzakci\u00f3 kiolvassa az adatot, majd a m\u00f3dos\u00edtott \u00e9rt\u00e9ket vissza\u00edrja. Ezzel egy\u00fctt a tranzakci\u00f3s napl\u00f3ban r\u00f6gz\u00edt\u00e9sre ker\u00fcl a m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9k . M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 10 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 20 Ezzel a tranzakci\u00f3 befejezve a m\u0171veleteit, azonban a v\u00e1ltoztat\u00e1sok m\u00e9g nem lettek mentve. Ehhez kommit\u00e1l a tranzakci\u00f3, amely sor\u00e1n el\u0151sz\u00f6r a tranzakci\u00f3s napl\u00f3 bejegyz\u00e9sei a napl\u00f3f\u00e1jlba ki\u00edr\u00e1sra ker\u00fclnek, majd megt\u00f6rt\u00e9nik a m\u00f3dos\u00edt\u00e1s az adatb\u00e1zisban. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Flush_LOG 10 20 8 22 Output(A) 8 20 8 22 Output(B) 8 22 8 22 Commit T1 Gondoljuk v\u00e9gig, hogy soft crash eset\u00e9n hogyan kell helyre\u00e1ll\u00edtani a rendszert. Amennyiben a tranzakci\u00f3 a kommit el\u0151tt lett megszak\u00edtva, nincs dolga a rendszernek, mert az adatb\u00e1zis f\u00e1jlban nem t\u00f6rt\u00e9nt m\u00f3dos\u00edt\u00e1s, a mem\u00f3ria buffer pedig a soft crash hat\u00e1s\u00e1ra elt\u0171nik. Amennyiben a tranzakci\u00f3 elkezdte a kommit proced\u00far\u00e1t, az adatb\u00e1zisba m\u00e1r ki\u00edr\u00e1sra ker\u00fclhetett valamennyi v\u00e1ltoztat\u00e1s. Ezeket vissza kell \u00e1ll\u00edtani. Ilyenkor a tranzakci\u00f3s napl\u00f3t h\u00e1tulr\u00f3l olvasva kell feldolgozni, \u00e9s minden olyan tranzakci\u00f3 eset\u00e9n, amelynek nincs commit bejegyz\u00e9se a napl\u00f3ban, vissza\u00e1ll\u00edthat\u00f3 a napl\u00f3ban tal\u00e1lhat\u00f3 m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9k. R\u00f6viden \u00f6sszefoglalva undo napl\u00f3z\u00e1s eset\u00e9n az adatb\u00e1zis nem \u00edrhat\u00f3 \u00e1t, am\u00edg a tranzakci\u00f3s napl\u00f3 nincs ki\u00edrva, \u00e9s commit jelet csak az adatb\u00e1zis \u00edr\u00e1s ut\u00e1n lehet kitenni a napl\u00f3ba. A m\u0171k\u00f6d\u00e9s kulcsa, hogy a tranzakci\u00f3s napl\u00f3t el\u0151bb kell ki\u00edrni, mint a m\u00f3dos\u00edt\u00e1sokat az adatb\u00e1zis f\u00e1jlban elv\u00e9gezn\u00e9 a rendszer. A megold\u00e1s h\u00e1tr\u00e1nya, hogy k\u00e9tszer is kell a tranzakci\u00f3s napl\u00f3t f\u00e1jlba \u00edrni (amely a diszk \u00edr\u00e1s miatt k\u00f6lts\u00e9ges m\u0171velet).","title":"Undo t\u00edpus\u00fa napl\u00f3z\u00e1s"},{"location":"jegyzet/transactions/#redo-tipusu-naplozas","text":"A m\u0171veletsorozat a kor\u00e1bban l\u00e1tott beolvas\u00e1sokkal kezd\u0151dik, majd k\u00f6vetkezik a m\u00f3dos\u00edt\u00e1sok elv\u00e9gz\u00e9se, de ez\u00fattal a tranzakci\u00f3s napl\u00f3ban a m\u00f3dos\u00edt\u00e1s ut\u00e1ni \u00e9rt\u00e9k ker\u00fcl r\u00f6gz\u00edt\u00e9sre. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 8 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 22 A m\u00f3dos\u00edt\u00e1sok v\u00e9gleges\u00edt\u00e9s\u00e9hez a tranzakci\u00f3 elkezdni a kommit folyamatot, amely a tranzakci\u00f3s napl\u00f3t ki\u00edrja, \u00e9s r\u00f6gz\u00edti a kommit\u00e1l\u00e1s t\u00e9ny\u00e9t - de az adatb\u00e1zis f\u00e1jlban m\u00e9g nem m\u00f3dosultak az adatok. \u00cdgy a tranzakci\u00f3s napl\u00f3 f\u00e1jlba t\u00f6rt\u00e9n\u0151 \u00edr\u00e1sa egy m\u0171veletre reduk\u00e1l\u00f3dott (szemben az undo t\u00edpus\u00fa napl\u00f3z\u00e1ssal). M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Commit T1 Flush_LOG 10 20 8 22 A tranzakci\u00f3s napl\u00f3 ment\u00e9se ut\u00e1n v\u00e9gezhet\u0151 el a t\u00e9nyleges adat ment\u00e9se az adatb\u00e1zis f\u00e1jlba. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Output(A) 8 20 8 22 Output(B) 8 22 8 22 Gondoljuk v\u00e9gig, hogy soft crash eset\u00e9n hogyan kell helyre\u00e1ll\u00edtani a rendszert. Amennyiben a tranzakci\u00f3 a kommit el\u0151tt lett megszak\u00edtva, nincs dolga a rendszernek, mert az adatb\u00e1zis f\u00e1jlban nem t\u00f6rt\u00e9nt m\u00f3dos\u00edt\u00e1s, a mem\u00f3ria buffer pedig a soft crash hat\u00e1s\u00e1ra elt\u0171nik. Amennyiben a tranzakci\u00f3 elkezdte a kommit proced\u00far\u00e1t, m\u00e1r ki\u00edr\u00e1sra ker\u00fclt a napl\u00f3ba a commit t\u00e9nye, de az adatb\u00e1zis f\u00e1jl m\u00e9g nem m\u00f3dosult. Ha ilyenkor szakad meg a v\u00e9grehajt\u00e1s, akkor a vissza\u00e1ll\u00edt\u00e1s sor\u00e1n a tranzakci\u00f3s napl\u00f3t ez elej\u00e9t\u0151l kezdve kell feldolgozni, \u00e9s minden kommit\u00e1lt tranzakci\u00f3t \u00fajra v\u00e9gre kell hajtani. R\u00f6viden \u00f6sszefoglalva redo napl\u00f3z\u00e1s eset\u00e9n az adatb\u00e1zis nem \u00edrhat\u00f3 \u00e1t, am\u00edg a tranzakci\u00f3s napl\u00f3 nincs ki\u00edrva, \u00e9s commit jelet az adatb\u00e1zis \u00edr\u00e1s el\u0151tt kell kitenni a napl\u00f3ba. Az undo napl\u00f3z\u00e1shoz k\u00e9pest teh\u00e1t kevesebb a tranzakci\u00f3s napl\u00f3 szinkroniz\u00e1l\u00e1sa, de hosszabb a vissza\u00e1ll\u00edt\u00e1si folyamat.","title":"Redo t\u00edpus\u00fa napl\u00f3z\u00e1s"},{"location":"jegyzet/transactions/#undoredo-naplozas","text":"A nev\u00e9b\u0151l ad\u00f3d\u00f3an ez a megold\u00e1s az el\u0151z\u0151 kett\u0151 kombin\u00e1ci\u00f3ja. A p\u00e9lda m\u0171veletsor ugyan\u00fagy kezd\u0151dik, mint kor\u00e1bban. A k\u00fcl\u00f6nbs\u00e9g a tranzakci\u00f3s napl\u00f3ba val\u00f3 \u00edr\u00e1sn\u00e1l jelentkezik: mind a v\u00e1ltoz\u00e1s el\u0151tti, mind a v\u00e1ltoz\u00e1s ut\u00e1ni \u00e9rt\u00e9k ki\u00edr\u00e1sra ker\u00fcl. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 10, 8 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 20, 22 A kommit folyamat is egyszer\u0171s\u00f6dik. Az adatb\u00e1zis f\u00e1jlba val\u00f3 \u00edr\u00e1s \u00e9s a kommit jel ki\u00edr\u00e1sa a tranzakci\u00f3s napl\u00f3ba tetsz\u0151leges sorrendben elv\u00e9gezhet\u0151 (de mindenk\u00e9ppen meg kell el\u0151zze \u0151ket a tranzakci\u00f3s napl\u00f3 f\u00e1jlba \u00edr\u00e1sa). A v\u00e1ltoz\u00e1s teh\u00e1t, hogy a commit jel helye nem k\u00f6t\u00f6tt. M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Flush_LOG 10 20 8 22 Output(A) 8 20 8 22 Commit T1 Output(B) 8 22 8 22 A vissza\u00e1ll\u00edt\u00e1s sor\u00e1n a kor\u00e1bban ismertetett m\u00f3dok kombin\u00e1l\u00e1s\u00e1ra van sz\u00fcks\u00e9g: m\u00e1r kommit\u00e1lt tranzakci\u00f3k eset\u00e9ben a v\u00e1ltoz\u00e1s \u00fajraj\u00e1tsz\u00e1s\u00e1ra van sz\u00fcks\u00e9g (mind a redo eset\u00e9n), m\u00edg a f\u00e9lbeszakadt tranzakci\u00f3k el\u0151tti \u00e1llapot az undo napl\u00f3z\u00e1shoz hasonl\u00f3an \u00e1ll\u00edthat\u00f3 helyre. Ennek a megold\u00e1snak az el\u0151nye, hogy kevesebb szinkroniz\u00e1ci\u00f3 sz\u00fcks\u00e9ges a bels\u0151 m\u0171k\u00f6d\u00e9sben (a tranzakci\u00f3s napl\u00f3 \u00edr\u00e1sa \u00e9s az adatb\u00e1zis f\u00e1jlok \u00edr\u00e1sa tekintet\u00e9ben), valamint a m\u00f3dos\u00edt\u00e1s hamarabb r\u00f6gz\u00edthet\u0151 az adatb\u00e1zis f\u00e1jlban (nem kell a tranzakci\u00f3s napl\u00f3ban megv\u00e1rni a commit jel r\u00f6gz\u00edt\u00e9s\u00e9t).","title":"Undo/redo napl\u00f3z\u00e1s"},{"location":"jegyzet/transactions/#tranzakcios-naplo-meretenek-csokkentese","text":"A tranzakci\u00f3s napl\u00f3 f\u00e1jlt id\u0151nk\u00e9nt sz\u00fcks\u00e9ges ki\u00fcr\u00edteni, nem n\u0151het a v\u00e9gtelens\u00e9gig. Olyan tranzakci\u00f3k bejegyz\u00e9sei t\u00f6r\u00f6lhet\u0151ek bel\u0151le, amelyek val\u00f3ban kommit\u00e1l\u00e1sra ker\u00fcltek (az adatb\u00e1zis f\u00e1jlba be\u00edr\u00e1sra ker\u00fclt minden eredm\u00e9ny\u00fck), vagy amelyek megszakadtak, \u00e9s nem kell \u0151ket vissza\u00e1ll\u00edtani. Ez a folyamat \u00e1ltal\u00e1ban automatikus, de kezdem\u00e9nyezhet\u0151 manu\u00e1lisan is. Hosszan fut\u00f3 tranzakci\u00f3k eset\u00e9ben k\u00fcl\u00f6n\u00f6sen \u00e9rdemes figyelni a tranzakci\u00f3s napl\u00f3 m\u00e9ret\u00e9re. Min\u00e9l nagyobbra n\u0151, ann\u00e1l lassabb ut\u00e1na a m\u00e9ret cs\u00f6kkent\u00e9s.","title":"Tranzakci\u00f3s napl\u00f3 m\u00e9ret\u00e9nek cs\u00f6kkent\u00e9se"},{"location":"jegyzet/transactions/#ellenorzo-kerdesek","text":"Milyen konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9m\u00e1kat ismersz? Milyen izol\u00e1ci\u00f3s szintek vannak? Milyen probl\u00e9m\u00e1kra adnak megold\u00e1st? Mik a tranzakci\u00f3k alaptulajdons\u00e1gai? D\u00f6ntse el, hogy igaz vagy hamis az al\u00e1bbi \u00e1ll\u00edt\u00e1s: A serializable izol\u00e1ci\u00f3s szint egym\u00e1s ut\u00e1n hajtja v\u00e9gre a tranzakci\u00f3kat. A holtpont elker\u00fclhet\u0151 a megfelel\u0151 izol\u00e1ci\u00f3s szint haszn\u00e1lat\u00e1val. A read committed \u00e1ltal\u00e1ban az alap\u00e9rtelmezett izol\u00e1ci\u00f3s szint. Ha nem haszn\u00e1lunk explicit ind\u00edtott tranzakci\u00f3t, akkor (alapesetben) elker\u00fclj\u00fck a piszkos olvas\u00e1st. A tranzakci\u00f3s napl\u00f3 v\u00e9d minden f\u00e9le adatveszt\u00e9ssel szemben. Redo tranzakci\u00f3s napl\u00f3z\u00e1s eset\u00e9n a commit jellel kezd\u0151dik a tranzakci\u00f3s napl\u00f3.","title":"Ellen\u0151rz\u0151 k\u00e9rd\u00e9sek"}]}