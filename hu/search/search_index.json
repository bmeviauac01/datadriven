{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Adatvez\u00e9relt rendszerek","text":"<p>Jegyzetek, gyakorlati anyagok \u00e9s h\u00e1zi feladatok a BMEVIAUAC01 Adatvez\u00e9relt rendszerek c. t\u00e1rgyhoz.</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC01 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p>"},{"location":"db/","title":"Minta adatb\u00e1zis s\u00e9m\u00e1ja","text":"<p>A f\u00e9l\u00e9v sor\u00e1n a gyakorlati p\u00e9ld\u00e1kat egy egys\u00e9ges mintap\u00e9ld\u00e1n kereszt\u00fcl szeml\u00e9ltetj\u00fck. A mintap\u00e9lda egy egyszer\u0171 vev\u0151-megrendel\u00e9snyilv\u00e1ntart\u00e1si rendszer. Az al\u00e1bbi le\u00edr\u00e1s a Microsoft SQL Server rel\u00e1ci\u00f3s s\u00e9m\u00e1j\u00e1t ismerteti, a MongoDB \"s\u00e9ma\" ennek \u00e1t\u00fcltet\u00e9se.</p>"},{"location":"db/#az-adatbazis-kontextusa","title":"Az adatb\u00e1zis kontextusa","text":"<p>A rendszer term\u00e9kek \u00e9rt\u00e9kes\u00edt\u00e9si folyamat\u00e1nak a k\u00f6vet\u00e9s\u00e9re szolg\u00e1l. A term\u00e9keket (product) kateg\u00f3ri\u00e1kba (category) lehet sorolni, mely kateg\u00f3ri\u00e1k hierarchikusan egym\u00e1sra \u00e9p\u00fclhetnek. A vev\u0151k (customer) megrendel\u00e9seiket (order) \u00e9s azok st\u00e1tusz\u00e1t (status) nyomon tudj\u00e1k k\u00f6vetni.</p> <p>Az \u00fcgyfeleknek t\u00f6bb telephely\u00fck (customer site) is lehet, az egyes megrendel\u00e9sek (order) felad\u00e1sakor, tiszt\u00e1zni kell, hogy az \u00fcgyf\u00e9l mely telephely\u00e9re t\u00f6rt\u00e9nik meg a kisz\u00e1ll\u00edt\u00e1s. Minden vev\u0151nek kell rendelkeznie k\u00f6zponti telephellyel, mely a sz\u00e1ml\u00e1z\u00e1si c\u00edm\u00fcl is szolg\u00e1l. Term\u00e9szetesen egy megrendel\u00e9shez t\u00f6bb t\u00e9tel (order item) is tartozhat, az egyes t\u00e9telek st\u00e1tusza k\u00fcl\u00f6n-k\u00fcl\u00f6n is k\u00f6vethet\u0151, ez\u00e1ltal a vev\u0151 l\u00e1tja, hogy esetleg mely term\u00e9kre kell v\u00e1rnia. A k\u00e9sz megrendel\u00e9sekr\u0151l sz\u00e1ml\u00e1t (invoice) kell k\u00e9sz\u00edteni.</p> <p>A sz\u00e1mla (invoice) olyan bizonylat, melynek az adatai k\u00e9s\u0151bb nem v\u00e1ltoztathat\u00f3k, valamint az els\u0151 nyomtat\u00e1st k\u00f6vet\u0151en sz\u00e1mlam\u00e1solatot lehet csak ki\u00e1ll\u00edtani. Figyelembe kell venni azt is, hogy az egyes term\u00e9kek \u00c1FA besorol\u00e1sa (VAT = value added tax) ill. \u00c1FA kulcsa megv\u00e1ltozhat az id\u0151k sor\u00e1n, viszont a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1kon term\u00e9szetesen m\u00e1r ez az inform\u00e1ci\u00f3 sem v\u00e1ltozhat meg.</p>"},{"location":"db/#adatmodell","title":"Adatmodell","text":"<p>Az al\u00e1bbi \u00e1bra szeml\u00e9lteti a nyilv\u00e1ntart\u00f3rendszer adatmodellj\u00e9t.</p> <p></p>"},{"location":"db/#tablak-es-attributumok","title":"T\u00e1bl\u00e1k \u00e9s attrib\u00fatumok","text":"T\u00e1bla Oszlop Le\u00edr\u00e1s VAT ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Percentage \u00c1FA kulcs \u00e9rt\u00e9ke sz\u00e1zal\u00e9kban megadva. PaymentMethod ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Method Fizet\u00e9si m\u00f3d megnevez\u00e9se (pl.: K\u00e9szp\u00e9nz, \u00c1tutal\u00e1s 8 napon bel\u00fcl). Deadline A fizet\u00e9si m\u00f3dhoz tartoz\u00f3 hat\u00e1rid\u0151, azaz a sz\u00e1mla teljes\u00edt\u00e9si d\u00e1tum\u00e1hoz k\u00e9pest, h\u00e1ny nappal van k\u00e9s\u0151bb a fizet\u00e9si hat\u00e1rid\u0151. Status ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Megrendel\u00e9s st\u00e1tusz megnevez\u00e9se (pl.: \u00faj, feldolgozva, \u00e1rura v\u00e1r, csomagolva,\u2026). Category ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name Term\u00e9kkateg\u00f3ria megnevez\u00e9se (pl.: \u00e9lelmiszer, tejterm\u00e9k, \u2026). ParentCategoryID Kateg\u00f3ria hierarchi\u00e1t le\u00edr\u00f3 idegen kulcs, egy adott kateg\u00f3ria sz\u00fcl\u0151j\u00e9re mutat. A gy\u00f6k\u00e9relemekn\u00e9l, a sz\u00fcl\u0151kateg\u00f3ria azonos\u00edt\u00f3ja NULL. Product ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Term\u00e9k neve Price Term\u00e9k nett\u00f3 \u00e1ra Stock A term\u00e9kb\u0151l a rakt\u00e1rban tal\u00e1lhat\u00f3 mennyis\u00e9g. VATID Idegen kulcs a term\u00e9k \u00c1FA kulcs\u00e1ra (VAT t\u00e1bla). CategoryID Idegen kulcs a term\u00e9k kateg\u00f3ri\u00e1j\u00e1ra (Category t\u00e1bla). Description A term\u00e9khez tartoz\u00f3 XML form\u00e1tum\u00fa le\u00edr\u00e1s Customer ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Name Vev\u0151 megnevez\u00e9se. BankAccount Vev\u0151 banksz\u00e1mla sz\u00e1ma. Login Vev\u0151 login neve a webes rendszerhez. Password Vev\u0151 jelszava a webes rendszerhez. Email Vev\u0151 email c\u00edme. MainCustomerSiteID A vev\u0151 k\u00f6zponti telephely\u00e9nek azonos\u00edt\u00f3ja, k\u00fcls\u0151 kulcs a CustomerSite t\u00e1bl\u00e1ra. CustomerSite ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. ZipCode A c\u00edm ir\u00e1ny\u00edt\u00f3sz\u00e1m r\u00e9sze. City A c\u00edm v\u00e1ros r\u00e9sze. Street A c\u00edm utca \u00e9s h\u00e1zsz\u00e1m r\u00e9sze. Tel A telephelyhez kapcsol\u00f3d\u00f3 telefonsz\u00e1m. Fax A telephelyhez kapcsol\u00f3d\u00f3 fax sz\u00e1m. CustomerID K\u00fcls\u0151 kulcs a vev\u0151re (Customer t\u00e1bla). Order ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Date Megrendel\u00e9s d\u00e1tuma. Deadline V\u00e1llalt sz\u00e1ll\u00edt\u00e1si hat\u00e1rid\u0151. CustomerSiteID K\u00fcls\u0151 kulcs a vev\u0151 telephely\u00e9re, ide kell kisz\u00e1ll\u00edtani a megrendelt \u00e1rukat (CustomerSite t\u00e1bla). StatusID K\u00fcls\u0151 kulcs a st\u00e1tuszra, ez mutatja, hogy mi a teljes st\u00e1tusza a megrendel\u00e9snek (Status t\u00e1bla). PaymentMethodID K\u00fcls\u0151 kulcs a fizet\u00e9si m\u00f3dra. A megrendel\u00e9shez tartoz\u00f3 sz\u00e1ml\u00e1t az itt megadott m\u00f3don fogj\u00e1k kiegyenl\u00edteni (PaymentMethod t\u00e1bla). OrderItem ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs. Amount Mennyis\u00e9g, azaz az adott \u00e1rub\u00f3l ennyi darabot rendeltek meg. Price Egy egys\u00e9g nett\u00f3 \u00e1ra. Alap\u00e9rtelmez\u00e9sk\u00e9nt a term\u00e9kben tal\u00e1lhat\u00f3 nett\u00f3 \u00e1r m\u00e1sol\u00f3dik ide, de ett\u0151l elt\u00e9rhet az \u00e9rt\u00e9kes\u00edt\u0151. OrderID Idegen kulcs a megrendel\u00e9sre, azaz ez azonos\u00edtja, hogy az adott t\u00e9tel mely megrendel\u00e9shez tartozik (Order t\u00e1bla). ProductID Idegen kulcs a Product t\u00e1bl\u00e1ra, ez azonos\u00edtja a megrendelt term\u00e9ket. StatusID Idegen kulcs a Status t\u00e1bl\u00e1ra, ezzel lehet le\u00edrni a megrendel\u00e9s t\u00e9tel st\u00e1tusz\u00e1t. InvoiceIssuer ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name C\u00e9gn\u00e9v, aki a keresked\u00e9st folytatja, ez szerepel a sz\u00e1ml\u00e1n. ZipCode A c\u00edm ir\u00e1ny\u00edt\u00f3sz\u00e1m r\u00e9sze. City A c\u00edm v\u00e1ros r\u00e9sze. Street A c\u00edm utca r\u00e9sze. TaxIdentifier A c\u00e9g ad\u00f3sz\u00e1ma. BankAccount A c\u00e9g banksz\u00e1mlasz\u00e1ma. Invoice ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs CustomerName Megrendel\u0151 neve, ez az inform\u00e1ci\u00f3 fog a sz\u00e1mla vev\u0151 r\u00e9sz\u00e9n megjelenni. CustomerZipCode A vev\u0151 c\u00edm\u00e9nek ir\u00e1ny\u00edt\u00f3sz\u00e1ma. CustomerCity A vev\u0151 c\u00edm\u00e9nek v\u00e1ros r\u00e9sze. CustomerStreet A vev\u0151 c\u00edm\u00e9nek utca r\u00e9sze. PrintedCopies A sz\u00e1mla h\u00e1nyszor lett kinyomtatva. Cancelled A sz\u00e1mla sztorn\u00f3zva lett-e? PaymentMethod A sz\u00e1mla fizet\u00e9si m\u00f3dja. CreationDate A sz\u00e1mla ki\u00e1ll\u00edt\u00e1s\u00e1nak kelte. DeliveryDate A sz\u00e1mla teljes\u00edt\u00e9si d\u00e1tuma. PaymentDeadline A sz\u00e1mla fizet\u00e9si hat\u00e1rideje. InvoiceIssuerID Idegen kulcs a sz\u00e1mla ki\u00e1ll\u00edt\u00f3ra (InvoiceIssuer t\u00e1ba). OrderID Idegen kulcs a megrendel\u00e9sre, a sz\u00e1mla ezen megrendel\u00e9s alapj\u00e1n ker\u00fclt ki\u00e1ll\u00edt\u00e1sra (Order t\u00e1bla). InvoiceItem ID Automatikusan gener\u00e1lt azonos\u00edt\u00f3, els\u0151dleges kulcs Name Term\u00e9k neve, mely a sz\u00e1mlat\u00e9telben szerepel. Amount A v\u00e1s\u00e1rolt mennyis\u00e9g. Price A t\u00e9tel nett\u00f3 egys\u00e9g\u00e1ra. VATPercentage A t\u00e9tel \u00c1FA kulcsa InvoiceID Idegen kulcs a sz\u00e1ml\u00e1ra, melyhez a sz\u00e1mlat\u00e9tel tartozik (Order t\u00e1bla). OrderItemID Idegen kulcs a megrendel\u00e9s t\u00e9telre (OrderItem t\u00e1bla), melyb\u0151l a sz\u00e1mlat\u00e9tel keletkezett."},{"location":"db/#sajatossagok","title":"Saj\u00e1toss\u00e1gok","text":""},{"location":"db/#szamlazas","title":"Sz\u00e1ml\u00e1z\u00e1s","text":"<p>Adatmodell saj\u00e1toss\u00e1ga, a sz\u00e1ml\u00e1z\u00e1si adatok t\u00e1rol\u00e1sa. A sz\u00e1mla adatait nem lehet megv\u00e1ltoztatni kinyomtat\u00e1s ut\u00e1n, sz\u00e1ml\u00e1t nem lehet t\u00f6r\u00f6lni csak sztorn\u00f3zni. Ebb\u0151l ad\u00f3d\u00f3n a sz\u00e1ml\u00e1hoz tartoz\u00f3 \u00f6sszes inform\u00e1ci\u00f3t az <code>Invoice</code> \u00e9s az <code>InvoiceItem</code> t\u00e1bl\u00e1k tartalmazz\u00e1k, a sz\u00e1mlaki\u00e1ll\u00edt\u00e1s sor\u00e1n minden inform\u00e1ci\u00f3t le kell m\u00e1solni a vonatkoz\u00f3 megrendel\u00e9sb\u0151l. Valamint az els\u0151 nyomtat\u00e1st k\u00f6vet\u0151en a sz\u00e1ml\u00e1b\u00f3l m\u00e1r csak m\u00e1solatot lehet nyomtatni, eredeti p\u00e9ld\u00e1nyt nem.</p>"},{"location":"db/#szamla-kiallito","title":"Sz\u00e1mla ki\u00e1ll\u00edt\u00f3","text":"<p>Speci\u00e1lis a <code>InvoiceIssuerID</code> attrib\u00fatum az <code>Invoice</code> t\u00e1bl\u00e1ban, mivel a c\u00e9g saj\u00e1t adatai ritk\u00e1n v\u00e1ltoznak. Viszont a v\u00e1ltoztathatatlans\u00e1g k\u00f6vetelm\u00e9nye miatt a sz\u00e1mla ki\u00e1ll\u00edt\u00f3 adatait nem lehet m\u00f3dos\u00edtani, ha m\u00e1r van hozz\u00e1 sz\u00e1mla. Ebben az esetben a sz\u00e1mla ki\u00e1ll\u00edt\u00f3 t\u00e1bl\u00e1ba \u00faj rekordot kell felvenni, ebb\u0151l ad\u00f3d\u00f3an az aktu\u00e1lis c\u00e9gadatokat mindig a legmagasabb ID-vel rendelkez\u0151 sz\u00e1mla ki\u00e1ll\u00edt\u00f3 rekord tartalmazza.</p>"},{"location":"db/#afa","title":"\u00c1FA","text":"<p>Egy term\u00e9k \u00c1FA kulcsa (<code>VAT</code>) b\u00e1rmikor megv\u00e1ltozhat, de ez a megrendel\u00e9s sor\u00e1n teljesen term\u00e9szetes, de a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1k \u00c1FA tartalma m\u00e1r nem v\u00e1ltozhat meg. Ez\u00e9rt a megrendel\u00e9s sor\u00e1n az \u00c1F\u00c1-ra idegen kulccsal kell hivatkozni, hogy a v\u00e1ltoz\u00e1st k\u00f6vetni lehessen, viszont a ki\u00e1ll\u00edtott sz\u00e1ml\u00e1ban le kell t\u00e1rolni a ki\u00e1ll\u00edt\u00e1s pillanat\u00e1ban az aktu\u00e1lis \u00c1FA kulcsot.</p>"},{"location":"db/#termek-leiras","title":"Term\u00e9k le\u00edr\u00e1s","text":"<p>A term\u00e9kekhez tartozhat egy XML form\u00e1tum\u00fa le\u00edr\u00e1s, ennek tartalm\u00e1t szeml\u00e9lteti az al\u00e1bbi p\u00e9lda. Ezen le\u00edr\u00e1s a term\u00e9khez tartoz\u00f3 egy\u00e9b extra inform\u00e1ci\u00f3kat tartalmazza, amelyeket nem fejtett\u00fcnk ki a rel\u00e1ci\u00f3s modellben</p> <pre><code>&lt;product&gt;\n  &lt;product_size&gt;\n    &lt;unit&gt;cm&lt;/unit&gt;\n    &lt;width&gt;150&lt;/width&gt;\n    &lt;height&gt;50&lt;/height&gt;\n    &lt;depth&gt;150&lt;/depth&gt;\n  &lt;/product_size&gt;\n  &lt;package_parameters&gt;\n    &lt;number_of_packages&gt;1&lt;/number_of_packages&gt;\n    &lt;package_size&gt;\n      &lt;unit&gt;cm&lt;/unit&gt;\n      &lt;width&gt;150&lt;/width&gt;\n      &lt;height&gt;20&lt;/height&gt;\n      &lt;depth&gt;20&lt;/depth&gt;\n    &lt;/package_size&gt;\n  &lt;/package_parameters&gt;\n  &lt;description&gt;\n    Requires battery (not part of the package).\n  &lt;/description&gt;\n  &lt;recommended_age&gt;0-18 m&lt;/recommended_age&gt;\n&lt;/product&gt;\n</code></pre>"},{"location":"db/mongodb/","title":"MongoDB haszn\u00e1lata","text":"<p>A MongoDB ingyenes, open-source adatb\u00e1zis kiszolg\u00e1l\u00f3. Mi az \u00fan. community v\u00e1ltozat\u00e1t haszn\u00e1ljuk, kliens szoftvernek pedig a VSCode MongoDB for VSCode kieg\u00e9sz\u00edt\u0151j\u00e9t.</p> <p>Let\u00f6lt\u00e9si linkek:</p> <ul> <li>https://www.mongodb.com/download-center/community</li> <li>https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode</li> </ul> <p>Telep\u00edt\u00e9si \u00fatmutat\u00f3: https://docs.mongodb.com/manual/administration/install-community/</p>"},{"location":"db/mongodb/#mongodb-szerver-elinditasa","title":"MongoDB szerver elind\u00edt\u00e1sa","text":"<p>A telep\u00edt\u00e9si modell f\u00fcggv\u00e9ny\u00e9ben lehet, hogy a MongoDB szerver automatikusan elindul. Ha nem k\u00e9rt\u00fck ezt a telep\u00edt\u00e9skor, akkor a telep\u00edt\u00e9si k\u00f6nyvt\u00e1rban az al\u00e1bbi paranccsal tudjuk elind\u00edtani a szervert. (\u00dcgyelj\u00fcnk r\u00e1, hogy a szerver a mongo\u200bd exe.)</p> <pre><code>mongod.exe --dbpath=\"&lt;munkak\u00f6nyvt\u00e1r&gt;\"\n</code></pre> <p>A munkak\u00f6nyvt\u00e1rban fog t\u00e1rol\u00f3dni az adatb\u00e1zis. Ha ilyen m\u00f3don, konzolb\u00f3l ind\u00edtottuk a szervert, akkor addig fut, am\u00edg a konzolt be nem z\u00e1rjuk. Le\u00e1ll\u00edtani a Ctrl+C billenty\u0171kombin\u00e1ci\u00f3val kell.</p> <p>Mongo Dockerrel</p> <p>Alternat\u00edvak\u00e9nt futtathatjuk a mongo szervert docker kont\u00e9ner form\u00e1j\u00e1ban az al\u00e1bbi paranccsal:</p> <pre><code>docker run --name datadriven-mongo -p 27017:27017 -d mongo\n</code></pre> <p>\u00cdgy futtatva a <code>-p 27017:27017</code> kapcsol\u00f3 lek\u00e9pzi a kont\u00e9ner bels\u0151 27017-es portj\u00e1t a localhost 27017-es portj\u00e1ra, \u00edgy ugyan\u00fagy haszn\u00e1lhat\u00f3 mint egy telep\u00edtett verzi\u00f3.</p>"},{"location":"db/mongodb/#mongo-shell","title":"Mongo shell","text":"<p>A Mongo shell egy egyszer\u0171 konzolos kliens alkalmaz\u00e1s. A hivatalos dokument\u00e1ci\u00f3ban szerepl\u0151 p\u00e9ld\u00e1k \u00e1ltal\u00e1ban ezt haszn\u00e1lj\u00e1k. Mi nem fogjuk ezt a programot haszn\u00e1lni.</p>"},{"location":"db/mongodb/#mongodb-for-vscode","title":"MongoDB for VSCode","text":"<p>A MongoDB for VSCode egy egyszer\u0171 \u00e9s ingyenes kieg\u00e9sz\u00edt\u0151 VSCode-ban MongoDB adatb\u00e1zis haszn\u00e1lat\u00e1hoz.</p> <p>A kieg\u00e9sz\u00edt\u0151 megnyit\u00e1sakor kiv\u00e1laszthatjuk a m\u00e1r kor\u00e1bban l\u00e9trehozott kapcsolatunkat, vagy k\u00e9sz\u00edthet\u00fcnk egy \u00fajat. Alap\u00e9rtelmez\u00e9sk\u00e9nt a helyben fut\u00f3 szervert a <code>localhost</code> c\u00edmen \u00e9s a <code>27017</code> porton \u00e9rhetj\u00fck el.</p> <p></p> <p></p> <p>A sikeres kapcsol\u00f3d\u00e1s ut\u00e1n az kieg\u00e9sz\u00edt\u0151 bal oldal\u00e1n a faszerkezetben l\u00e1tjuk a kapcsol\u00f3dott kiszolg\u00e1l\u00f3t, az adatb\u00e1zisokat \u00e9s a gy\u0171jtem\u00e9nyeket. Kezdetben se adatb\u00e1zisunk, se gy\u0171jtem\u00e9nyeink nem lesznek. (Ezeket l\u00e9trehozhatjuk k\u00e9zzel is: jobb eg\u00e9rrel kattintva a szerver nev\u00e9n tal\u00e1ljuk p\u00e9ld\u00e1ul a Create Database parancsot, ahol tetsz\u0151leges parancsot tudunk futtatni.)</p> <p></p> <p>A gy\u0171jtem\u00e9nyek tartalm\u00e1t jobb gomb / View Documents m\u0171velettel tekinthetj\u00fck meg, amit egy \u00faj tab f\u00fclet nyit. Ha keresni szeretn\u00e9nk, akkor a jobb gomb / Search For Documents... m\u0171velettel \u00edrhatunk JavaScript k\u00f3dot egy playground ablakban.</p> <p>A dokumentumot t\u00f6r\u00f6lni, szerkeszteni a rekordra val\u00f3 jobb eg\u00e9r kattint\u00e1ssal tudjuk. A szerkeszt\u00e9s sor\u00e1n a JSON dokumentumot szerkesztj\u00fck.</p> <p></p> <p>\u00daj dokumentumot besz\u00farni szint\u00e9n jobb eg\u00e9rrel kattintva tudunk. Itt egy \u00fcres szerkeszt\u0151t kapunk. Ha \u00faj rekordot akarunk l\u00e9trehozni, c\u00e9lszer\u0171 egy meglev\u0151 dokumentum JSON-j\u00e9t lem\u00e1solni \u00e9s \u00fagy hozni l\u00e9tre az \u00fajat, hogy a kulcsok nevei biztosan j\u00f3k legyenek.</p>"},{"location":"db/mongodb/#studio-3t","title":"Studio 3T","text":"<p>Studio 3T egy b\u0151vebb funkci\u00f3kkal rendelkez\u0151 mongo kliens, aminek van ingyenes verzi\u00f3ja is, de az regisztr\u00e1ci\u00f3hoz k\u00f6t\u00f6tt. A tansz\u00e9ki laborokban nincs feltelep\u00edtve, de otthon haszn\u00e1lhatj\u00e1tok.</p>"},{"location":"db/mssql/","title":"Microsoft SQL Server haszn\u00e1lata","text":"<p>A Microsoft SQL Server kiszolg\u00e1l\u00f3hoz az SQL Server Management Studio szoftverrel kapcsol\u00f3dunk. Fejleszt\u00e9s k\u00f6zben a kiszolg\u00e1l\u00f3 helyben fut, az \u00fan. LocalDB verzi\u00f3t haszn\u00e1ljuk, de otthoni haszn\u00e1latra megfelel az Express v\u00e1ltozat is (b\u00e1rmely verzi\u00f3).</p> <p>Let\u00f6lt\u00e9si linkek:</p> <ul> <li>A LocalDB Visual Studio-val telep\u00fcl</li> <li>https://www.microsoft.com/en-us/sql-server/sql-server-editions-express</li> <li>https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms</li> </ul> <p>Eszk\u00f6z haszn\u00e1lata vide\u00f3</p> <p>Az eszk\u00f6z haszn\u00e1lat\u00e1nak bemutat\u00e1sa: https://web.microsoftstream.com/video/e3a83d16-b5c4-4fe9-b027-703347951621</p>"},{"location":"db/mssql/#sql-server-management-studio-hasznalata","title":"SQL Server Management Studio haszn\u00e1lata","text":"<p>A tansz\u00e9ki laborokban a programot a start men\u00fcb\u0151l ind\u00edthatjuk. A program indul\u00e1sa ut\u00e1n kapcsol\u00f3dhatunk az adatb\u00e1zishoz a felugr\u00f3 ablakban. LocalDB haszn\u00e1lata eset\u00e9n a Server name <code>(localdb)\\mssqllocaldb</code>, Express Edition haszn\u00e1lata eset\u00e9n <code>.\\sqlexpress</code> (alapbe\u00e1ll\u00edt\u00e1sokkal val\u00f3 telep\u00edt\u00e9s eset\u00e9n). Mindk\u00e9t esetben Windows Authentication-t haszn\u00e1lunk.</p> <p>A sikeres kapcsol\u00f3d\u00e1st k\u00f6vet\u0151en a f\u0151ablak bal oldal\u00e1n az Object Explorer-ben kibonthat\u00f3 a Databases elem, \u00e9s ha m\u00e1r l\u00e9trehoztunk adatb\u00e1zist, azt is kibontva l\u00e1that\u00f3ak a t\u00e1bl\u00e1ink \u00e9s egy\u00e9b s\u00e9ma elemek.</p> <p>SQL k\u00f3d futtat\u00e1s\u00e1hoz egy \u00faj Query ablakra van sz\u00fcks\u00e9g\u00fcnk, amelyet az eszk\u00f6zt\u00e1ron tal\u00e1lhat\u00f3  ikonnal nyithatunk. A Query ablak parancsai az aktu\u00e1lisan kiv\u00e1lasztott adatb\u00e1zison fognak lefutni, ezt az adatb\u00e1zist az eszk\u00f6zt\u00e1ron a leg\u00f6rd\u00fcl\u0151 men\u00fcben tudjuk megv\u00e1ltoztatni (l\u00e1sd az al\u00e1bbi k\u00e9pen s\u00e1rg\u00e1val). T\u00f6bb Query ablak is lehet nyitva egyszerre.</p> <p>Az SQL utas\u00edt\u00e1sokat lefuttatni az  gombbal tudjuk. Ha van kijel\u00f6lt utas\u00edt\u00e1s, csak azt futtatja, ellenkez\u0151 esetben az ablak teljes tartalm\u00e1t v\u00e9grehajtja. Az eredm\u00e9ny, vagy a hiba\u00fczenet a script alatt l\u00e1that\u00f3.</p> <p></p>"},{"location":"db/mssql/#uj-adatbazis-letrehozasa","title":"\u00daj adatb\u00e1zis l\u00e9trehoz\u00e1sa","text":"<p>Ha m\u00e9g nincs adatb\u00e1zisunk, el\u0151sz\u00f6r l\u00e9tre kell hozni egyet. Ezt az Object Explorer-ben a Databases-en jobb kattint\u00e1ssal tehetj\u00fck meg. Az adatb\u00e1zisnak csak nevet kell adni, m\u00e1s be\u00e1ll\u00edt\u00e1sra nincs sz\u00fcks\u00e9g. Az adatb\u00e1zis l\u00e9trehoz\u00e1sa ut\u00e1n a Query ablakban ne felejts\u00fck \u00e1t\u00e1ll\u00edtani az aktu\u00e1lis adatb\u00e1zist!</p> <p></p>"},{"location":"db/mssql/#parhuzamos-tranzakciok","title":"P\u00e1rhuzamos tranzakci\u00f3k","text":"<p>P\u00e1rhuzamos tranzakci\u00f3k szimul\u00e1l\u00e1s\u00e1hoz k\u00e9t Query ablakra van sz\u00fcks\u00e9g a New Query gomb k\u00e9tszeri megnyom\u00e1s\u00e1val. \u00c9rdemes az ablakokat egym\u00e1s mell\u00e9 tenni: a Query f\u00fcl fejl\u00e9c\u00e9re jobb eg\u00e9rrel kattintva v\u00e1lasszuk a New Vertical Tab Group opci\u00f3t.</p> <p></p>"},{"location":"db/mssql/#tablak-tartalmanak-listazasa-egyszerusitett-modositas","title":"T\u00e1bl\u00e1k tartalm\u00e1nak list\u00e1z\u00e1sa, egyszer\u0171s\u00edtett m\u00f3dos\u00edt\u00e1s","text":"<p>A t\u00e1bl\u00e1k tartalm\u00e1nak list\u00e1z\u00e1s\u00e1hoz az Object Explorer-ben bontsuk ki az adatb\u00e1zisunk alatt a Tables mapp\u00e1t. B\u00e1rmely t\u00e1bl\u00e1ra jobb eg\u00e9rrel kattintva haszn\u00e1ljuk a Select Top 1000 Rows elemet. Hasonl\u00f3 m\u00f3don lehet\u0151s\u00e9g van a t\u00e1bla tartalm\u00e1nak szerkeszt\u00e9s\u00e9re is (az els\u0151 200 sorra, amely a minta adatb\u00e1zisban pont elegend\u0151) az Edit Top 200 Rows men\u00fcelemmel.</p> <p></p>"},{"location":"db/mssql/#intellisense-ujratoltese","title":"Intellisense \u00fajrat\u00f6lt\u00e9se","text":"<p>Az SQL Management Studio query ablakban az intellisense els\u0151 k\u00f6rben sosem m\u0171k\u00f6dik mag\u00e1t\u00f3l, haszn\u00e1lni kell a Control+Shift+R-t az intellisense cache friss\u00edt\u00e9s\u00e9re. Akkor is, ha \u00faj objektumot (pl. t\u00e1rolt elj\u00e1r\u00e1st) hozunk l\u00e9tre.</p>"},{"location":"db/mssql/#tarolt-eljarasok-es-triggerek-keszitese","title":"T\u00e1rolt elj\u00e1r\u00e1sok \u00e9s triggerek k\u00e9sz\u00edt\u00e9se","text":"<p>T\u00e1rolt elj\u00e1r\u00e1s \u00e9s trigger l\u00e9trehoz\u00e1s\u00e1ra a Query ablak haszn\u00e1lhat\u00f3, amelyben a megfelel\u0151 l\u00e9trehoz\u00f3-m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st futtatjuk. \u00dcgyelj\u00fcnk r\u00e1, hogy ha m\u00e1r l\u00e9trej\u00f6tt egyszer a trigger vagy t\u00e1rolt elj\u00e1r\u00e1s, ut\u00e1na m\u00e1r csak m\u00f3dos\u00edtani tudjuk.</p> <p>A m\u00e1r l\u00e9tez\u0151 t\u00e1rolt elj\u00e1r\u00e1sok az Object Explorer-ben az adatb\u00e1zisunk alatti a Programmability/Stored Procedures mapp\u00e1ban l\u00e1that\u00f3ak. (Az \u00fajonnan l\u00e9trehozott elemek nem jelennek meg automatikusan a m\u00e1r kibontott mapp\u00e1ban. A friss\u00edt\u00e9shez a Stored Procedures mapp\u00e1n jobb eg\u00e9rrel kattintva v\u00e1lasszuk a Refresh-t.)</p> <p></p> <p>A triggerek az Object Explorer-ben megkereshet\u0151ek, a t\u00e1bl\u00e1ra defini\u00e1lt triggerek a t\u00e1bla kibont\u00e1s\u00e1val a Triggers mapp\u00e1ban l\u00e1that\u00f3ak (a rendszer szint\u0171 triggerek pedig az adatb\u00e1zis alatti Programmability mapp\u00e1ban).</p> <p></p> <p>A t\u00e1rolt elj\u00e1r\u00e1saink \u00e9s triggereink k\u00f3dj\u00e1t megtekinthetj\u00fck, ha a fentebb ismertetett m\u00f3don megkeress\u00fck \u0151ket, \u00e9s jobb eg\u00e9rrel kattintva a Modify men\u00fct v\u00e1lasztjuk. Ez a m\u0171velet egy \u00faj Query ablakot nyit, amelybe gener\u00e1l egy alter utas\u00edt\u00e1st az aktu\u00e1lis programk\u00f3ddal.</p>"},{"location":"gyakorlatvezetoknek/","title":"Gyakorlatvezet\u0151knek","text":"<p>Gyakorlatvezet\u0151/demonstr\u00e1tor lenn\u00e9l? Az al\u00e1bbiakat \u00e9rdemes tudnod.</p>"},{"location":"gyakorlatvezetoknek/#gyakorlatvezeto-feladatai","title":"Gyakorlatvezet\u0151 feladatai","text":"<p>A gyakorlatvezet\u0151 a t\u00e1rgy oktat\u00e1s\u00e1ban seg\u00edt a gyakorlatok megtart\u00e1sa \u00e9s a sz\u00e1monk\u00e9r\u00e9sek sor\u00e1n. A feladat az al\u00e1bbiakb\u00f3l \u00e1ll.</p> <p>F\u00e9l\u00e9v sor\u00e1n 12 gyakorlat megtart\u00e1sa. A gyakorlatok a 2. oktat\u00e1si h\u00e9ten kezd\u0151dnek \u00e9s a 13. oktat\u00e1si h\u00e9ten \u00e9rnek v\u00e9get. Egy gyakorlatvezet\u0151 \u00e1ltal\u00e1ban 2 gyakorlati csoport oktat\u00e1s\u00e1\u00e9rt felel \u00e9s mindk\u00e9t csoportnak 6-6 gyakorlatot tart meg. A gyakorlat fix \u00f3rarendi id\u0151ben van, 90 perces, \u00e9s sz\u00e1m\u00edt\u00f3g\u00e9p laborban tartjuk. Sz\u00fcnetek miatt elmarad\u00f3 laborokat nem p\u00f3tlunk, \u00edgy n\u00e9ha egy-kett\u0151vel kevesebb \u00f3ra lehet. Lehet\u0151s\u00e9g van t\u00f6bbet is v\u00e1llalni, teh\u00e1t ak\u00e1r 4 csoportot is (4*6 gyakorlat a f\u00e9l\u00e9v sor\u00e1n).</p> <p>A gyakorlat kiadott seg\u00e9dlet alapj\u00e1n ker\u00fcl megtart\u00e1sra. A gyakorlatvezet\u0151 feladata a gyakorlatra val\u00f3 felk\u00e9sz\u00fcl\u00e9s, a gyakorlat megtart\u00e1sa, ennek sor\u00e1n a sz\u00fcks\u00e9ges h\u00e1tt\u00e9rismeretek r\u00f6vid \u00e1tism\u00e9tl\u00e9se, a fontos r\u00e9szek kiemel\u00e9se, \u00e9s a hallgat\u00f3k seg\u00edt\u00e9se a gyakorlat sor\u00e1n. Egy gyakorlati \u00f3r\u00e1n 20 hallgat\u00f3 van a teremben.</p> <p>2021 \u0151szi f\u00e9l\u00e9v sor\u00e1n a gyakorlatok \u00f3rarendi id\u0151pontjai:</p> <ul> <li>kedd 8-10</li> <li>kedd 10-12</li> <li>cs\u00fct\u00f6rt\u00f6k 8-10</li> </ul> <p>Sz\u00e1monk\u00e9r\u00e9sek lebonyol\u00edt\u00e1s\u00e1ban seg\u00edts\u00e9g. A t\u00e1rgyban ZH, PZH, \u00e9s 4 vizsga van. Mindegyik sz\u00e1monk\u00e9r\u00e9s \u00edr\u00e1sban t\u00f6rt\u00e9nik. A gyakorlatvezet\u0151 feladata a sz\u00e1monk\u00e9r\u00e9sek fel\u00fcgyel\u00e9se majd a jav\u00edt\u00e1sban t\u00f6rt\u00e9n\u0151 r\u00e9szv\u00e9tel. A fel\u00fcgyel\u00e9s ideje alkalmank\u00e9nt k\u00f6r\u00fclbel\u00fcl 1 \u00f3ra, a jav\u00edt\u00e1s ideje l\u00e9tsz\u00e1m f\u00fcgg\u0151en 0.5-2 \u00f3ra alkalmank\u00e9nt. Gyakorlatvezet\u0151k\u00e9nt k\u00f6r\u00fclbel\u00fcl a sz\u00e1monk\u00e9r\u00e9sek fel\u00e9ben kell r\u00e9szt venni.</p> <p>H\u00e1zi feladatok \u00e9rt\u00e9kel\u00e9se. A f\u00e9l\u00e9v sor\u00e1n 5 kis h\u00e1zi feladatot hirdet\u00fcnk meg. Ezeket a hallgat\u00f3k otthon, \u00f6n\u00e1ll\u00f3an oldj\u00e1k meg \u00e9s adj\u00e1k be GitHub pull request-ek form\u00e1j\u00e1ban. A h\u00e1zi feladatok ki\u00e9rt\u00e9kel\u00e9se r\u00e9szben automatikusan t\u00f6rt\u00e9nik: egy szoftver lefuttatja \u00e9s ellen\u0151rzi a beadott munk\u00e1t. A gyakorlatvezet\u0151 feladata a beadott h\u00e1zi feladat formai ellen\u0151rz\u00e9se: k\u00e9rt k\u00e9perny\u0151k\u00e9pek megfelelnek-e az el\u0151\u00edr\u00e1soknak \u00e9s konzisztensek-e a beadott forr\u00e1sk\u00f3ddal. A h\u00e1zi feladat nem k\u00f6telez\u0151, nem minden hallgat\u00f3 szokta elk\u00e9sz\u00edteni, \u00edgy h\u00e1zi feladatonk\u00e9nt k\u00f6r\u00fclbel\u00fcl 1 \u00f3ra id\u0151 r\u00e1ford\u00edt\u00e1st jelent.</p>"},{"location":"gyakorlatvezetoknek/#demonstratorsag","title":"Demonstr\u00e1tors\u00e1g","text":"<p>Hallgat\u00f3 vagy de szeretn\u00e9l bekapcsol\u00f3dni az oktat\u00e1sba? Szeretn\u00e9d kipr\u00f3b\u00e1lni magad gyakorlatvezet\u0151k\u00e9nt? Elv\u00e9gezted ezt a t\u00e1rgyat \u00f6t\u00f6ssel? V\u00e1runk demonstr\u00e1tork\u00e9nt!</p> <p>A TVSZ p\u00e1r k\u00f6vetelm\u00e9nyt szab demonstr\u00e1toroknak: (l\u00e1sd aktu\u00e1lis TVSZ 165.\u00a7):</p> <p>(5) A demonstr\u00e1tori p\u00e1ly\u00e1zat beny\u00fajt\u00e1s\u00e1nak felt\u00e9tele, hogy a p\u00e1ly\u00e1z\u00f3</p> <p>a) a demonstr\u00e1tori jogviszonnyal \u00e9rintett f\u00e9l\u00e9vben rendelkezzen akt\u00edv hallgat\u00f3i jogviszonnyal;</p> <p>b) rendelkezzen alapk\u00e9pz\u00e9sben vagy osztatlan k\u00e9pz\u00e9sben szerzett oklev\u00e9llel;</p> <p>c) alapk\u00e9pz\u00e9sben vagy osztatlan k\u00e9pz\u00e9sben szerzett oklev\u00e9l hi\u00e1ny\u00e1ban rendelkezzen legal\u00e1bb annyiszor huszon\u00f6t teljes\u00edtett kredittel, ah\u00e1ny lez\u00e1rt akt\u00edv f\u00e9l\u00e9ve van \u00e9s halmozott s\u00falyozott tanulm\u00e1nyi \u00e1tlageredm\u00e9nye haladja meg a 3,50 \u00e9rt\u00e9ket; \u00e9s</p> <p>d) ne \u00e1lljon fegyelmi b\u00fcntet\u00e9s hat\u00e1lya alatt.</p> <p>Ha \u00e9rdekel a lehet\u0151s\u00e9g, megfelelsz a fenti k\u00f6vetelm\u00e9nyeknek, \u00e9s az \u00f3rarendedbe belef\u00e9r a gyakorlat (l\u00e1sd az id\u0151pontokat fentebb), keresd a t\u00e1rgyfelel\u0151st.</p>"},{"location":"gyakorlatvezetoknek/#tudnivalok-a-gyakorlatok-megtartasahoz","title":"Tudnival\u00f3k a gyakorlatok megtart\u00e1s\u00e1hoz","text":"<p>A t\u00e1rgy alapk\u00e9pz\u00e9s (BSc) 5. f\u00e9l\u00e9v\u00e9ben specializ\u00e1ci\u00f3s t\u00e1rgy. Ezt azt jelenti, hogy a hallgat\u00f3k szoftverfejleszt\u00e9si alapismeretekkel \u00e9s adatb\u00e1zis alapismeretekkel rendelkeznek. A t\u00e1rgyunk c\u00e9lja a tud\u00e1s elm\u00e9ly\u00edt\u00e9se \u00e9s \u00faj technol\u00f3gi\u00e1kba val\u00f3 \"belek\u00f3stol\u00e1s\". Az \u00faj ismeretek \u00e1tad\u00e1sa az el\u0151ad\u00e1sokon t\u00f6rt\u00e9nik, a gyakorlatokon a technol\u00f3gi\u00e1k els\u0151 k\u00e9zb\u0151l val\u00f3 kipr\u00f3b\u00e1l\u00e1sa a l\u00e9nyeg. A c\u00e9lunk, hogy mindenki maga is l\u00e1ssa \u00e9s kipr\u00f3b\u00e1lja az adott eszk\u00f6z\u00f6ket, technol\u00f3gi\u00e1kat, \u00e9s l\u00e1ssa a m\u0171k\u00f6d\u00e9s\u00fcket. A gyakorlatokon v\u00e1ltozatos technol\u00f3gi\u00e1kkal foglalkozunk, \u00e9s ennek megfelel\u0151en t\u00f6bb f\u00e9le szoftvert is haszn\u00e1lunk. Ezek egy r\u00e9sze \u00fajdons\u00e1g lesz a hallgat\u00f3knak, \u00edgy a gyakorlatokon a szoftverek alapvet\u0151 haszn\u00e1lat\u00e1t is megmutatjuk.</p>"},{"location":"gyakorlatvezetoknek/#oktatas-modja","title":"Oktat\u00e1s m\u00f3dja","text":"<p>A gyakorlatokon elv\u00e1rt a r\u00e9szv\u00e9tel, viszont nincs sz\u00e1monk\u00e9r\u00e9s (se beugr\u00f3, se egy\u00e9b). Az el\u0151ad\u00e1sokon minden sz\u00fcks\u00e9ges alapismeret elhangzik, de a gyakorlatokon c\u00e9lszer\u0171 sz\u00f3ban elism\u00e9telni mivel foglalkozunk az adott gyakorlaton \u00e9s az mi\u00e9rt fontos. Emellett \u00e9rdemes kiemelni a feladatok megold\u00e1sa sor\u00e1n az \u00e9rdekes, avagy felt\u00e9tlen\u00fcl megjegyzend\u0151 r\u00e9szeket. (Mindemellett a gyakorlat nem el\u0151ad\u00e1s, nem kell mindent \u00fajb\u00f3l elism\u00e9telni.)</p> <p>A gyakorlatokon \u00f6n\u00e1ll\u00f3 munk\u00e1t csak kis m\u00e9rt\u00e9kben v\u00e1runk el. A gyakorlatok anyaga jelzi, mit lehet \u00f6n\u00e1ll\u00f3 munk\u00e1nak feladni. A gyakorlat nagy r\u00e9sz\u00e9ben teh\u00e1t a gyakorlatvezet\u0151 projektoron csin\u00e1lja a feladatokat, a hallgat\u00f3k k\u00f6vetik \u00e9s maguk is v\u00e9gzik a feladatokat. A bemeleg\u00edt\u0151 feladatok ut\u00e1n (amikor a szoftver k\u00f6rnyezet m\u00e1r ismert), lehet adni gondolkod\u00e1si id\u0151t a hallgat\u00f3knak. A megold\u00e1st viszont mindig besz\u00e9lj\u00e9tek meg k\u00f6z\u00f6sen.</p> <p>A gyakorlati anyagban benne van a megold\u00e1s. Ha valaki lemarad, vagy otthon meg akarja n\u00e9zni, \u00edgy el\u00e9rheti a megold\u00e1sokat. A gyakorlatok sor\u00e1n ne csak \u00e1tm\u00e1soljuk az \u00f3r\u00e1n, hanem g\u00e9pelj\u00fck be a megold\u00e1st, a gondolatmenetet magyar\u00e1zva k\u00f6zben! Ha lehet, vegy\u00fck r\u00e1 a hallgat\u00f3kat is erre.</p>"},{"location":"gyakorlatvezetoknek/#adminisztrativ-tudnivalok","title":"Adminisztrat\u00edv tudnival\u00f3k","text":"<ul> <li>A gyakorlatokat \u00f3ra 15-kor kezdj\u00fck pontosan \u00e9s 90 percet egyben, sz\u00fcnet n\u00e9lk\u00fcl tartjuk. A k\u00e9s\u0151 hallgat\u00f3kat els\u0151 alkalommal figyelmeztess\u00fck. Ha t\u00f6bbsz\u00f6r el\u0151fordul vagy zavar\u00f3an sokat k\u00e9sik (&gt;5 perc), akkor k\u00fcldj\u00e9tek el (TVSZ erre jogot ad!).</li> <li>A gyakorlat teljes\u00edt\u00e9s\u00e9nek adminisztr\u00e1l\u00e1sa Moodle-ben t\u00f6rt\u00e9nik. A teljes\u00edt\u00e9s a gyakorlaton val\u00f3 megjelen\u00e9st, \u00e9s a munka veletek t\u00f6rt\u00e9n\u0151 elv\u00e9gz\u00e9s\u00e9t jelenti. (Teh\u00e1t a hallgat\u00f3 nem s\u00e9t\u00e1lhat ki a gyakorlat k\u00f6zep\u00e9n \u00e9s nem foglalkozhat m\u00e1ssal, csak a gyakorlattal. Eseti probl\u00e9m\u00e1kat az\u00e9rt kezelj\u00fcnk le, pl. ZH-ja van m\u00e1shol, stb. Egy-egy kiv\u00e9tel belef\u00e9r.) \u00c9rdemes a jelenl\u00e9tet a gyakorlat elej\u00e9n k\u00f6nyvelni.</li> <li>Ha az \u00f3r\u00e1n t\u00f6bb ember jelenne meg, mint ah\u00e1ny g\u00e9p van (hi\u00e1nyz\u00e1s p\u00f3tl\u00e1sa pl.), vagy egy g\u00e9p nem m\u0171k\u00f6dik, akkor akinek nem jut hely, le\u00fcl valaki mell\u00e9.</li> <li>A csoportok k\u00f6z\u00f6tt nincs ad-hoc \u00e1tj\u00e1r\u00e1s. Ha valaki jelzi, hogy nem tud r\u00e9szt venni egy gyakorlaton, akkor el\u0151re/ut\u00f3lag/ugyanazon a h\u00e9ten egy m\u00e1sik csoportban p\u00f3tolhat (ha van r\u00e1 m\u00f3d). Ennek a megszervez\u00e9s\u00e9t alapvet\u0151en a hallgat\u00f3 bonyol\u00edtsa (n\u00e9zze meg, mikor van m\u00e9g labor azonos anyagb\u00f3l, \u00e9s egyeztessen a t\u00e1rgyfelel\u0151ssel, vagy a gyakorlatvezet\u0151kkel), de seg\u00edts\u00fck, ha kell.</li> <li>2021 \u0151sz\u00e9n a tan\u00e9v els\u0151 2 het\u00e9ben nem minden hallgat\u00f3nak lesz koll\u00e9giumi helye. Rektori utas\u00edt\u00e1s szerint a hallgat\u00f3k felment\u00e9st kapnak ezen alkalmak al\u00f3l. Ezt k\u00f6zpontilag int\u00e9zz\u00fck, az els\u0151 gyakorlatn\u00e1l is kell k\u00f6nyvelni a jelenl\u00e9tet, de a hi\u00e1nyz\u00e1st nem vessz\u00fck figyelembe.</li> </ul>"},{"location":"gyakorlatvezetoknek/#gyakorlat-jelenlet-konyvelese","title":"Gyakorlat jelenl\u00e9t k\u00f6nyvel\u00e9se","text":"<p>A jelenl\u00e9tet Moodle-ben kell k\u00f6nyvelni a \"Gyakorlat jelenl\u00e9t\" elemre kattintva.</p> <p></p> <p>Csoportonk\u00e9nt k\u00fcl\u00f6n jelenl\u00e9ti alkalom van. \u00c9rdemes a heti n\u00e9zetet v\u00e1lasztani \u00e9s az aktu\u00e1lis h\u00e9thez menni. Az alkalom d\u00e1tuma nem a csoport \u00f3rarendi idej\u00e9ben van (h\u00e9tf\u0151 mindig), azt kell v\u00e1lasztani, amelyik aktu\u00e1lis heti \u00e9s a megfelel\u0151 csoporthoz tartozik. A \"lej\u00e1tsz\u00e1s\" gombra kattintva vihet\u0151 fel a jelentl\u00e9t.</p> <p></p> <p>A jelenl\u00e9t be\u00edr\u00e1s\u00e1n\u00e1l a \"J\" a jelenl\u00e9t, a \"H\" a hi\u00e1nyz\u00e1s. F\u0171zhet\u0151 mellette megjegyz\u00e9s is hozz\u00e1 (pl. \"k\u00e9sett\".)</p> <p></p>"},{"location":"gyakorlatvezetoknek/#anyagok-elerhetosege","title":"Anyagok el\u00e9rhet\u0151s\u00e9ge","text":"<ul> <li>A t\u00e1rgy el\u0151ad\u00e1s anyagai, az id\u0151pontok \u00e9s hat\u00e1rid\u0151k \u00e9s hivatalos k\u00f6vetelm\u00e9nyek Moodle-ben lesznek. (Ehhez a t\u00e1rgy indul\u00e1s\u00e1val kapsz hozz\u00e1f\u00e9r\u00e9st.)</li> <li> <p>Gyakorlatok anyagai: l\u00e1sd a fenti men\u00fcben. A gyakorlati anyag minden r\u00e9sze teljesen publikus.</p> <p>A gyakorlatok anyaga GitHub repository-ban van. Ha hib\u00e1t, elg\u00e9pel\u00e9st tal\u00e1lsz benne, arra k\u00e9r\u00fcnk, hogy jav\u00edtsd: minden anyag jobb fels\u0151 sark\u00e1ban van egy kis ceruza ikon, jav\u00edtsd a hib\u00e1t, \u00e9s k\u00fcldj PR-t.</p> </li> </ul>"},{"location":"gyakorlatvezetoknek/#belepesek","title":"Bel\u00e9p\u00e9sek","text":"<p>A labor termekhez kulcsra \u00e9s/vagy k\u00e1rty\u00e1ra van sz\u00fcks\u00e9g. Ezeket a titk\u00e1rs\u00e1gon (QB207) kell k\u00e9rni. I \u00e9p\u00fclethez kell a teremkulcs, ill. a folyos\u00f3hoz sz\u00fcks\u00e9g van k\u00e1rty\u00e1ra is (kiv\u00e9ve, akinek van ilyenje). Q \u00e9p\u00fclet laborjaihoz hozz\u00e1f\u00e9r\u00e9st k\u00fcl\u00f6n szervezz\u00fck. Demonstr\u00e1torok: mindezt megmutatom els\u0151 alkalommal.</p> <p>G\u00e9pekre: emailben k\u00fcld\u00f6m f\u00e9l\u00e9v elej\u00e9n. Kis- \u00e9s nagybet\u0171 sz\u00e1m\u00edt! P\u00e1r elg\u00e9pel\u00e9s ut\u00e1n le lesz tiltva az account!</p> <p>MS SQL szerver:</p> <ul> <li>localdb: nincs jelsz\u00f3, Windows Authentication-t haszn\u00e1ljunk</li> <li>JPA laborn\u00e1l sqlexpress van, SQL Server Authentication kell: <code>sa</code> / <code>sa</code></li> </ul> <p>MongoDB: nincs autentik\u00e1ci\u00f3</p>"},{"location":"gyakorlatvezetoknek/#tudnivalok-a-hazi-feladatokkal-kapcsolatban","title":"Tudnival\u00f3k a h\u00e1zi feladatokkal kapcsolatban","text":"<p>A f\u00e9l\u00e9v sor\u00e1n a h\u00e1zi feladatok vannak meghirdetve, amiket adott hat\u00e1rid\u0151ig kell beadni GitHub-on. Ennek pontos menete a hallgat\u00f3 szemsz\u00f6g\u00e9b\u0151l itt elolvashat\u00f3.</p> <p>Ahhoz, hogy hozz\u00e1f\u00e9rj a GitHub-on a beadott megold\u00e1sokhoz (\u00e9s ahhoz, hogy a hallgat\u00f3k ezt hozz\u00e1d tudj\u00e1k rendelni), kell egy GitHub account. A GitHub nevedet \u00edrd meg a t\u00e1rgyfelel\u0151snek, \u00e9s felvesz GitHub-on a https://www.github.com/bmeviauac01 organization-be.</p>"},{"location":"gyakorlatvezetoknek/#mikor-kell-ertekelni-a-hazit","title":"Mikor kell \u00e9rt\u00e9kelni a h\u00e1zit?","text":"<p>A h\u00e1zikat a hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n kell \u00e9rt\u00e9kelni. A hat\u00e1rid\u0151 el\u0151tt a megold\u00e1sokra nem kell r\u00e1n\u00e9zni, kiv\u00e9ve, ha ezt a hallgat\u00f3 k\u00e9ri. K\u00e9rd\u00e9ssel a hallgat\u00f3 direktben kell megkeressen (pl. emailben vagy GitHub-on).</p>"},{"location":"gyakorlatvezetoknek/#hol-kell-ertekelni-a-hazit","title":"Hol kell \u00e9rt\u00e9kelni a h\u00e1zit?","text":"<p>A hat\u00e1rid\u0151 lej\u00e1rta ut\u00e1n a feladatod a hozz\u00e1d rendelt pull request-ek \u00e9rt\u00e9kel\u00e9se. A hallgat\u00f3 azzal adja be a h\u00e1zit, hogy a pull request-et a gyakorlatvezet\u0151j\u00e9hez rendeli. Ezeket a GitHub keres\u0151j\u00e9vel a legegyszer\u0171bb megtal\u00e1lni: https://github.com/pulls?q=is%3Aopen+is%3Apr+org%3Abmeviauac01+assignee%3A%40me+.</p> <p>Alternat\u00edvak\u00e9nt a GitHub \u00e9rtes\u00edt\u0151 fel\u00fclet\u00e9t is lehet haszn\u00e1lni a https://github.com/notifications c\u00edmen, itt minden hozz\u00e1d rendelt, vagy review-ra v\u00e1r\u00f3 PR megjelenik.</p>"},{"location":"gyakorlatvezetoknek/#hogyan-kell-ertekelni-a-hazit","title":"Hogyan kell \u00e9rt\u00e9kelni a h\u00e1zit?","text":"<p>A PR-eket egyes\u00e9vel kell megnyitni, \u00e9s meg kell n\u00e9zni a PR komment fel\u00fclet\u00e9n az eredm\u00e9nyt. Itt l\u00e1that\u00f3 lesz a lefuttatott \u00e9rt\u00e9kel\u00e9s eredm\u00e9nye, valamint a k\u00e9perny\u0151k\u00e9pek. Emellett meg kell n\u00e9zni a forr\u00e1sk\u00f3dot is.</p> <p></p> <p>A forr\u00e1sk\u00f3dot nem sz\u00fcks\u00e9ges bet\u0171r\u0151l bet\u0171re megn\u00e9zni - a r\u00e9szletes ellen\u0151rz\u00e9st elv\u00e9gzi az automata. A gyakorlatvezet\u0151 feladata a k\u00e9perny\u0151k\u00e9pek ellen\u0151rz\u00e9se, valamint annak eld\u00f6nt\u00e9se, hogy a forr\u00e1sk\u00f3d konzisztens-e a kapott eredm\u00e9nnyel.</p> <p>A feladatok minta megold\u00e1sa itt \u00e9rhet\u0151 el: https://github.com/bmeviauac01?q=hazi-megoldas. Ezek csak lehets\u00e9ges megold\u00e1sok, a hallgat\u00f3 megold\u00e1sa nem kell ezzel egyezzen.</p> <p>Az \u00e9rt\u00e9kel\u00e9s v\u00e9gezt\u00e9vel:</p> <ul> <li>Ha az automata \u00e9rt\u00e9kel\u00e9s hely\u00e9nval\u00f3 volt, akkor le kell z\u00e1rni a PR-t a <code>/ahk ok</code> parancs be\u00edr\u00e1s\u00e1val egy kommentbe. Ennek hat\u00e1s\u00e1ra a PR j\u00f3v\u00e1hagy\u00e1sra ker\u00fcl \u00e9s merge-elve lesz.</li> <li>Ha az automata \u00e9rt\u00e9kel\u00e9st fel\u00fclb\u00edr\u00e1lod pontsz\u00e1mban, akkor az <code>/ahk ok 1.5 2</code> parancsot kell kiadni, ahol is a sz\u00e1mok a feladatokra kapott pontsz\u00e1mok. Az els\u0151 sz\u00e1m a nem iMsc feladat pontsz\u00e1ma, a m\u00e1sodik az iMsc pontsz\u00e1m - ez ut\u00f3bbi elhagyhat\u00f3 0 eset\u00e9n.</li> <li>Ha a beadott megold\u00e1s nem fogadhat\u00f3 el (hat\u00e1rid\u0151n t\u00fal \u00e9rkezett, a k\u00e9pek nem t\u00e1masztj\u00e1k al\u00e1 a megold\u00e1st, a forr\u00e1sk\u00f3d elfogadhatatlan, stb.), akkor ki kell adni a <code>/ahk ok 0 0</code> parancsot. Ezzel fogjuk r\u00f6gz\u00edteni, hogy az automata \u00e9rt\u00e9kel\u0151 \u00e1ltal adott pontsz\u00e1mokat fel\u00fcl\u00edrjuk.</li> </ul> <p>A fenti parancs egy kommentben tetsz\u0151leges helyen szerepelhet, amennyiben egy sorban csak ez a parancs szerepel. \u00cdrhatunk teh\u00e1t a hallgat\u00f3nak megjegyz\u00e9st, majd utols\u00f3 sorba \u00edrjuk ezt a parancsot. \u00c9rdemes a hallgat\u00f3nak legal\u00e1bb egy mondatot \u00edrni, hogy l\u00e1ssa, elfogadtuk a megold\u00e1st. Ha m\u00e9g sincs megjegyz\u00e9s\u00fcnk a hallgat\u00f3 fel\u00e9, akkor csak egysoros komment kell ezzel a paranccsal.</p> <p></p> <p>A parancs t\u00f6bbsz\u00f6r is kiadhat\u00f3, teh\u00e1t elrontott pontsz\u00e1mot lehet jav\u00edtani az \u00fajb\u00f3li kiad\u00e1ssal.</p> <p>A parancs hat\u00e1s\u00e1t l\u00e1tjuk is ut\u00e1na PR-ben:</p> <ul> <li>a kommentre a parancs felismer\u00e9s\u00e9nek meger\u0151s\u00edt\u00e9s\u00e9re \u00e9rkezik egy reakci\u00f3,</li> <li>a PR v\u00e1ltoztat\u00e1sai j\u00f3v\u00e1hagy\u00e1sra ker\u00fclnek (ez sz\u00fcks\u00e9ges a mergel\u00e9shez a protected branch miatt),</li> <li>a PR mergel\u00e9sre ker\u00fcl - ezzel lez\u00e1rt \u00e1llapotba ker\u00fcl a PR \u00e9s \u00edgy elt\u0171nik a teend\u0151k list\u00e1j\u00e1r\u00f3l,</li> <li>\u00e9s v\u00e9g\u00fcl elment\u00e9sre ker\u00fcl az eredm\u00e9ny a h\u00e1tt\u00e9rben - ezt m\u00e1r k\u00f6zvetlen\u00fcl nem l\u00e1tjuk.</li> </ul> <p></p>"},{"location":"gyakorlatvezetoknek/#problemak-es-megoldasuk","title":"Probl\u00e9m\u00e1k \u00e9s megold\u00e1suk","text":"<p>Nem futott le az automata \u00e9rt\u00e9kel\u00e9s.</p> <ul> <li>Lehet, hogy a hallgat\u00f3 draft m\u00f3dban hagyta a PR-t, ezt vissza kell \u00e1ll\u00edtani. A PR alj\u00e1n megjelenik ilyenkor egy Ready for review gomb.</li> <li>Ha sikertelen volt a ki\u00e9rt\u00e9kel\u00e9s, meg lehet ism\u00e9telni. Ez seg\u00edt a tranziens hib\u00e1kon (ritka eset). Ehhez tegy\u00e9l egy eval nev\u0171 label-t a PR-re (\u00faj label-k\u00e9nt kell l\u00e9trehozni).</li> </ul> <p>T\u00f6bb, mint 5-sz\u00f6r futott a ki\u00e9rt\u00e9kel\u00e9s. Ezt pontlevon\u00e1ssal szankcion\u00e1ljuk. Els\u0151 alkalommal eltekinthet\u00fcnk t\u0151le, de mindenk\u00e9ppen t\u00e1j\u00e9koztassuk a hallgat\u00f3t.</p> <p>Hiba van a ki\u00e9rt\u00e9kel\u0151 alkalmaz\u00e1sban. El\u0151fordulhat. Keresd a t\u00e1rgyfelel\u0151st, vagy jav\u00edtsd a hib\u00e1t (a ki\u00e9rt\u00e9kel\u0151 programok itt vannak: https://github.com/bmeviauac01/hazi-ahk/).</p> <p>Az \u00e9rt\u00e9kel\u00e9si folyamat sikertelen. Ha elesik az \u00e9rt\u00e9kel\u0151 folyamat, azt a PR-ben l\u00e1tjuk. Ennek t\u00f6bb oka is lehet.</p> <ul> <li>A hallgat\u00f3 kifelejtett valamit. K\u00f6telez\u0151 elemek hi\u00e1nya sz\u00e1nd\u00e9kosan blokkolja a folyamatot. Az ilyen h\u00e1zit nem \u00e9rt\u00e9kelj\u00fck (amennyiben val\u00f3ban a hallgat\u00f3 t\u00e9vedett).</li> <li>Tranziens hiba, pl. nem siker\u00fcl egy kont\u00e9ner pull, vagy egy .NET SDK setup. L\u00e1sd az \u00fajrafuttat\u00e1st fentebb.</li> <li>Hiba van a ki\u00e9rt\u00e9kel\u0151, avagy a feldolgoz\u00f3 alkalmaz\u00e1sban. A ki\u00e9rt\u00e9kel\u0151 alkalmaz\u00e1sok el\u00e9g stabilak, hib\u00e1s megold\u00e1sra nem szabad elessenek. Az\u00e9rt megt\u00f6rt\u00e9nhet. A feldolgoz\u00f3 alkalmaz\u00e1s is sokat futott m\u00e1r, de term\u00e9szetesen lehet benne nem v\u00e1rt eset. Sz\u00f3lj err\u0151l, az ilyet meg kell n\u00e9zz\u00fck.</li> </ul>"},{"location":"homework/","title":"Kis h\u00e1zi feladatok","text":"<p>A h\u00e1zi feladatok k\u00f6telez\u0151ek (l\u00e1sd k\u00f6vetelm\u00e9ynek), vizsgapont \u00e9s iMsc pont szerezhet\u0151 vel\u00fck. A feladatok le\u00edr\u00e1sa tal\u00e1lhat\u00f3 itt; a megold\u00e1sok bead\u00e1sa GitHub Classroom seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik.</p> <p>M\u0171k\u00f6d\u0151 k\u00f3d</p> <p>A feladatok sor\u00e1n m\u0171k\u00f6d\u0151 k\u00f3dot, k\u00f3dr\u00e9szleteteket kell k\u00e9sz\u00edteni. A feladat l\u00e9nyege a val\u00f3s\u00e1gban m\u0171k\u00f6d\u0151 \u00e9s a k\u00edv\u00e1nt funkci\u00f3t ell\u00e1t\u00f3 k\u00f3d k\u00e9sz\u00edt\u00e9se.</p>"},{"location":"homework/#a-feladatok","title":"A feladatok","text":"<ol> <li>MSSQL szerveroldali programoz\u00e1s</li> <li>Entity Framework</li> <li>MongoDB</li> <li>REST API Web API technol\u00f3gi\u00e1val</li> <li>GraphQL</li> </ol>"},{"location":"homework/#a-feladatok-beadasa","title":"A feladatok bead\u00e1sa","text":"<p>Minden h\u00e1zi feladat megold\u00e1s\u00e1t egy szem\u00e9lyre sz\u00f3l\u00f3 git repository-ban kell beadni. Ennek pontos folyamat\u00e1t l\u00e1sd itt. K\u00e9r\u00fcnk, hogy alaposan olvasd v\u00e9gig a le\u00edr\u00e1st!</p> <p>FONTOS</p> <p>A h\u00e1zik elk\u00e9sz\u00edt\u00e9se \u00e9s bead\u00e1s sor\u00e1n az itt le\u00edrtak szerint kell elj\u00e1rnod. A nem ilyen form\u00e1ban beadott h\u00e1zikat nem \u00e9rt\u00e9kelj\u00fck.</p> <p>A bead\u00e1s sor\u00e1n a munkafolyamati hib\u00e1k\u00e9rt (pl. nem megfelel\u0151 emberhez hozz\u00e1rendel\u00e9se, hozz\u00e1rendel\u00e9s elfelejt\u00e9se) pontot vonunk le.</p>"},{"location":"homework/#kepernyokepek","title":"K\u00e9perny\u0151k\u00e9pek","text":"<p>A feladatok k\u00e9rik, hogy k\u00e9sz\u00edts k\u00e9perny\u0151k\u00e9pet a megold\u00e1s egy-egy r\u00e9sz\u00e9r\u0151l, mert ezzel bizony\u00edtod, hogy a megold\u00e1sod saj\u00e1t magad k\u00e9sz\u00edtetted. A k\u00e9perny\u0151k\u00e9pek elv\u00e1rt tartalm\u00e1t a feladat minden esetben pontosan megnevezi. A k\u00e9perny\u0151k\u00e9p k\u00e9sz\u00fclhet a teljes desktopr\u00f3l is, de lehet csak a k\u00e9rt alkalmaz\u00e1sr\u00f3l k\u00e9sz\u00edteni.</p> <p>A k\u00e9perny\u0151k\u00e9peket a megold\u00e1s r\u00e9szek\u00e9nt kell beadni, \u00edgy felker\u00fclnek a git repository tartalm\u00e1val egy\u00fctt. Mivel a repository priv\u00e1t, azt az oktat\u00f3kon k\u00edv\u00fcl m\u00e1s nem l\u00e1tja. Amennyiben olyan tartalom ker\u00fcl a k\u00e9perny\u0151k\u00e9pre, amit nem szeretn\u00e9l felt\u00f6lteni, kitakarhatod a k\u00e9pr\u0151l.</p>"},{"location":"homework/#szukseges-eszkozok","title":"Sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k","text":"<ul> <li>Windows, Linux vagy MacOS: Minden sz\u00fcks\u00e9ges program platform f\u00fcggetlen, vagy van platformf\u00fcggetlen alternat\u00edv\u00e1ja.</li> <li>GitHub account \u00e9s egy git kliens.</li> <li>MSSQL adatb\u00e1zist haszn\u00e1l\u00f3 feladatokhoz:<ul> <li>Microsoft SQL Server. Az Express v\u00e1ltozat ingyenesen haszn\u00e1lhat\u00f3, avagy Visual Studio mellett feltelep\u00fcl\u0151 localdb v\u00e1ltozat is megfelel\u0151. Van Linux v\u00e1ltozata is. MacOS-en Docker-rel futtathat\u00f3.</li> <li>SQL Server Management Studio, vagy kipr\u00f3b\u00e1lhat\u00f3 a platformf\u00fcggetlen Azure Data Studio is.</li> <li>Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql</li> </ul> </li> <li>MongoDB adatb\u00e1zist haszn\u00e1l\u00f3 feladathoz:<ul> <li>MongoDB Community Server</li> <li>VSCode</li> <li>MongoDB for VSCode</li> <li>Minta adatb\u00e1zis k\u00f3dja: mongo.js</li> </ul> </li> <li>REST API feladatokhoz: Postman</li> <li>Az els\u0151 h\u00e1zi kiv\u00e9tel\u00e9vel a C# programoz\u00f3s feladatokhoz:<ul> <li>Microsoft Visual Studio 2022 az itt tal\u00e1lhat\u00f3 be\u00e1ll\u00edt\u00e1sokkal. Linux \u00e9s MacOS eset\u00e9n Visual Studio Code \u00e9s a .NET SDK-val telep\u00fcl\u0151 dotnet CLI haszn\u00e1lhat\u00f3.</li> <li> <p>.NET 8.0 SDK</p> <p>.NET 8.0</p> <p>A feladat megold\u00e1s\u00e1hoz 8.0 .NET SDK telep\u00edt\u00e9se sz\u00fcks\u00e9ges.</p> <p>Windows-on Visual Studio verzi\u00f3 f\u00fcggv\u00e9ny\u00e9ben lehet, hogy telep\u00edtve van (l\u00e1sd itt az ellen\u0151rz\u00e9s m\u00f3dj\u00e1t); ha nem, akkor a fenti linkr\u0151l kell telep\u00edteni (az SDK-t \u00e9s nem a runtime-ot.) Linux \u00e9s MacOS eset\u00e9n telep\u00edteni sz\u00fcks\u00e9ges.</p> </li> </ul> </li> </ul>"},{"location":"homework/#a-feladatok-kiertekelese","title":"A feladatok ki\u00e9rt\u00e9kel\u00e9se","text":"<p>A feladatok ki\u00e9rt\u00e9kel\u00e9se r\u00e9szben automatikusan t\u00f6rt\u00e9nik. A futtathat\u00f3 k\u00f3dokat val\u00f3ban le fogjuk futtatni, ez\u00e9rt minden esetben fontos a feladatle\u00edr\u00e1sok pontos k\u00f6vet\u00e9se (kiindul\u00f3 k\u00f3d v\u00e1z haszn\u00e1lata, csak a megengedett f\u00e1jlok v\u00e1ltoztat\u00e1sa, stb.)!</p> <p>A ki\u00e9rt\u00e9kel\u00e9s eredm\u00e9ny\u00e9r\u0151l a GitHub-on kapsz sz\u00f6veges visszajelz\u00e9st (l\u00e1sd itt). Ha enn\u00e9l t\u00f6bb inform\u00e1ci\u00f3ra van sz\u00fcks\u00e9ged, a GitHub Actions webes fel\u00fclete seg\u00edts\u00e9g\u00fcl szolg\u00e1lhat. Err\u0151l itt tal\u00e1lsz egy r\u00f6vid ismertet\u0151t.</p> <p>Ellen\u0151rz\u00e9s</p> <p>Egyes h\u00e1zikban (ahol a technol\u00f3gia ezt k\u00e9nyelmess\u00e9 teszi) tal\u00e1lsz unit teszteket. Ezen tesztek seg\u00edtenek ellen\u0151rizni a munk\u00e1dat, de nem helyettes\u00edtik saj\u00e1t ellen\u0151rz\u00e9sed. Amikor felt\u00f6lt\u00f6d a munk\u00e1dat, alaposabb tesztel\u00e9sen fog \u00e1tesni a k\u00f3dod.</p>"},{"location":"homework/GitHub-Actions/","title":"GitHub Actions ismertet\u0151","text":"<p>A feladatok ki\u00e9rt\u00e9kel\u00e9s\u00e9ben a GitHub Actions-re t\u00e1maszkodunk. Seg\u00edts\u00e9g\u00e9vel a git repository-kon m\u0171veleteket \u00e9s programokat tudunk futtatni. Ilyen m\u0171velet p\u00e9ld\u00e1ul a C# k\u00f3d leford\u00edt\u00e1sa, vagy a beadott k\u00f3d tesztel\u00e9se.</p> <p>A lefutott ki\u00e9rt\u00e9kel\u00e9sr\u0151l a pull request-ben fogsz \u00e9rtes\u00edt\u00e9st kapni. Ha meg szeretn\u00e9d n\u00e9zni r\u00e9szletesebben a h\u00e1tt\u00e9rben t\u00f6rt\u00e9nteket, vagy p\u00e9ld\u00e1ul az alkalmaz\u00e1s napl\u00f3kat, a GitHub fel\u00fclet\u00e9n az Actions alatt indulhatsz el.</p> <p></p> <p>Az Actions fel\u00fclet\u00e9n \u00fan. Workflow-kat l\u00e1tsz; minden egyes ki\u00e9rt\u00e9kel\u00e9s futtat\u00e1s egy-egy elem lesz itt (teh\u00e1t historikusan is visszakereshet\u0151ek).</p> <p></p> <p>Ezek k\u00f6z\u00fcl egyet kiv\u00e1lasztva (pl. a legfels\u0151 mindig a legutols\u00f3) l\u00e1thatod a workflow fut\u00e1s\u00e1nak r\u00e9szleteit. A fut\u00e1s napl\u00f3j\u00e1hoz a bal oldali list\u00e1ban m\u00e9g kattintani kell egyet. Jobb oldalon l\u00e1that\u00f3 a folyamat teljes napl\u00f3ja.</p> <p></p> <p>Minden z\u00f6ld pipa egy-egy sikeres l\u00e9p\u00e9st jelent. Ezen l\u00e9p\u00e9sek nem azonosak a feladatokokkal, hanem a ki\u00e9rt\u00e9kel\u00e9s folyamat\u00e1nak l\u00e9p\u00e9sei lesznek. Ilyen l\u00e9p\u00e9s p\u00e9ld\u00e1ul a k\u00f6rnyezet el\u0151k\u00e9sz\u00edt\u00e9se, pl. a .NET SDK telep\u00edt\u00e9se (minden ki\u00e9rt\u00e9kel\u00e9s egy vadi\u00faj k\u00f6rnyezetben indul, \u00edgy mindent el\u0151 kell k\u00e9sz\u00edteni).</p> <p>Alapvet\u0151en a l\u00e9p\u00e9sek mindig sikeresek, akkor is, ha a megold\u00e1sodban hiba van, mert a ki\u00e9rt\u00e9kel\u00e9s erre fel van k\u00e9sz\u00edtve. Kiv\u00e9telt ez al\u00f3l csak a <code>neptun.txt</code> hi\u00e1nya ill. a C# k\u00f3d leford\u00edt\u00e1sa jelent. El\u0151bbi felt\u00e9tlen\u00fcl sz\u00fcks\u00e9ges, ez\u00e9rt semmilyen folyamatot nem hajtunk v\u00e9gre n\u00e9lk\u00fcle. Ut\u00f3bbi eset\u00e9ben a C# k\u00f3d ford\u00edt\u00e1sa szint\u00e9n sz\u00fcks\u00e9ges a tov\u00e1bbl\u00e9p\u00e9shez, ez\u00e9rt sikertelens\u00e9g eset\u00e9n le\u00e1ll a folyamat.</p> <p>N\u00e9ha el\u0151fordulhat azonban tranziens, id\u0151szakos hiba is. P\u00e9ld\u00e1ul a .NET k\u00f6rnyezet let\u00f6lt\u00e9se nem siker\u00fcl h\u00e1l\u00f3zati hiba miatt. Ilyen esetben a futtat\u00e1st k\u00e9zzel meg lehet ism\u00e9telni. Ez persze csak akkor seg\u00edt, ha t\u00e9nyleg \u00e1tmeneti hib\u00e1r\u00f3l van sz\u00f3, teh\u00e1t pl. egy C# ford\u00edt\u00e1si hib\u00e1n nem fog seg\u00edteni. (Ezt a hiba\u00fczenetb\u0151l illetve a l\u00e9p\u00e9s nev\u00e9b\u0151l tudod kider\u00edteni, vagy legal\u00e1bb is megtippelni kell\u0151 bizonyoss\u00e1ggal.)</p> <p></p> <p>A feladat f\u00fcggv\u00e9ny\u00e9ben ak\u00e1r az alkalmaz\u00e1s napl\u00f3kat is meg tudod n\u00e9zni itt. Pl. amikor .NET alkalmaz\u00e1st k\u00e9sz\u00edtesz, az alkalmaz\u00e1st elind\u00edtjuk, \u00e9s minden, amit napl\u00f3z, itt megtekinthet\u0151.</p> <p>Az al\u00e1bbi p\u00e9ld\u00e1ul egy Entity Framework-\u00f6t haszn\u00e1l\u00f3 alkalmaz\u00e1s inicializ\u00e1l\u00e1s\u00e1t mutatja, k\u00f6zt\u00fck p\u00e9ld\u00e1ul a kiadott SQL parancsokat is. Debuggol\u00e1s k\u00f6zben a Visual Studio Output ablak\u00e1ban is hasonl\u00f3kat l\u00e1thatsz. Ez term\u00e9szetesen nagyban f\u00fcgg a konkr\u00e9t feladatt\u00f3l.</p> <p></p>"},{"location":"homework/GitHub/","title":"Feladatok bead\u00e1sa (GitHub)","text":"<p>A feladatok bead\u00e1s\u00e1hoz a GitHub platformot haszn\u00e1ljuk. Minden h\u00e1zi bead\u00e1sa egy-egy GitHub repository-ban t\u00f6rt\u00e9nik, melyet a feladatle\u00edr\u00e1sban tal\u00e1lhat\u00f3 linken kereszt\u00fcl kapsz meg. A h\u00e1zi feladatainak megold\u00e1s\u00e1t ezen repository-ban kell elk\u00e9sz\u00edtened, \u00e9s ide kell felt\u00f6ltened. A k\u00e9sz megold\u00e1s bead\u00e1sa a repository-ba val\u00f3 felt\u00f6lt\u00e9s ut\u00e1n egy \u00fan. pull request form\u00e1j\u00e1ban t\u00f6rt\u00e9nik, amelyet a gyakorlatvezet\u0151dh\u00f6z rendelsz.</p> <p>FONTOS</p> <p>Az itt le\u00edrt formai el\u0151\u00edr\u00e1sok betart\u00e1sa elv\u00e1r\u00e1s. A nem ilyen form\u00e1ban beadott megold\u00e1sokat nem \u00e9rt\u00e9kelj\u00fck.</p>"},{"location":"homework/GitHub/#roviditett-verzio","title":"R\u00f6vid\u00edtett verzi\u00f3","text":"<p>Al\u00e1bb r\u00e9szletesen bemutatjuk a bead\u00e1s menet\u00e9t. Itt egy r\u00f6vid \u00f6sszefoglal\u00f3 az \u00e1ttekint\u00e9shez, illetve a helyes bead\u00e1s ellen\u0151rz\u00e9s\u00e9hez.</p> <ol> <li> <p>A munk\u00e1dat Moodle-ben tal\u00e1lhat\u00f3 GitHub Classroom megh\u00edv\u00f3 linken kereszt\u00fcl l\u00e9trehozott GitHub repository-ban kell elk\u00e9sz\u00edtsd.</p> </li> <li> <p>A megold\u00e1shoz k\u00e9sz\u00edts egy k\u00fcl\u00f6n \u00e1gat, ne a master-en dolgozz. Erre az \u00e1gra ak\u00e1rh\u00e1ny kommitot tehetsz. Mindenk\u00e9ppen pushold a megold\u00e1st.</p> </li> <li> <p>A bead\u00e1st egy pull request jelzi, amely pull request-et a gyakorlatvezet\u0151dh\u00f6z kell rendelned.</p> </li> <li> <p>Ha az eredm\u00e9nnyel vagy \u00e9rt\u00e9kel\u00e9ssel kapcsolatban k\u00e9rd\u00e9sed van, pull request kommentben k\u00e9rdezhetsz. A gyakorlatvezet\u0151 \u00e9rtes\u00edt\u00e9s\u00e9hez haszn\u00e1ld a <code>@n\u00e9v</code> c\u00edmz\u00e9st a komment sz\u00f6veg\u00e9ben.</p> </li> </ol>"},{"location":"homework/GitHub/#a-munka-elkezdese-git-checkout","title":"A munka elkezd\u00e9se: git checkout","text":"<ol> <li> <p>Regisztr\u00e1lj egy GitHub accountot, ha m\u00e9g nincs.</p> </li> <li> <p>Moodle-ben a kurzus oldal\u00e1n keresd meg a h\u00e1zihoz tartoz\u00f3 megh\u00edv\u00f3 URL-t. Ez minden feladathoz m\u00e1s lesz, \u00fcgyelj r\u00e1, hogy a megfelel\u0151 linket haszn\u00e1ld.</p> </li> <li> <p>Ha k\u00e9ri, adj enged\u00e9lyt a GitHub Classroom alkalmaz\u00e1snak, hogy haszn\u00e1lja az account adataidat.</p> <p></p> </li> <li> <p>L\u00e1tni fogsz egy oldalt, ahol elfogadhatod a feladatot (\"Accept the ... assignment\"). Kattints a gombra.</p> <p></p> </li> <li> <p>V\u00e1rd meg, am\u00edg elk\u00e9sz\u00fcl a repository. A repository linkj\u00e9t itt kapod meg.</p> <p>Megjegyz\u00e9s</p> <p>A repository priv\u00e1t lesz, azaz azt senki nem l\u00e1tja, csak te, \u00e9s az oktat\u00f3k.</p> <p></p> </li> <li> <p>Nyisd meg a repository-t a webes fel\u00fcleten a linkre kattintva. Ezt az URL-t \u00edrd fel, vagy mentsd el.</p> <p></p> </li> <li> <p>Kl\u00f3nozd le a repository-t. Ehhez sz\u00fcks\u00e9ges lesz a repository c\u00edm\u00e9re, amit a repository webes fel\u00fclet\u00e9n a Clone or download alatt tal\u00e1lsz.</p> <p>A git repository kezel\u00e9s\u00e9hez tetsz\u0151leges klienst haszn\u00e1lhatsz. Ha nincs kedvenced m\u00e9g, akkor legegyszer\u0171bb a GitHub Desktop. Ebben az alkalmaz\u00e1sban k\u00f6zvetlen\u00fcl tudod list\u00e1zni a repository-kat GitHub-r\u00f3l, vagy haszn\u00e1lhatod az URL-t is a kl\u00f3noz\u00e1shoz.</p> <p></p> <p>Ha konzolt haszn\u00e1ln\u00e1l, az al\u00e1bbi parancs kl\u00f3nozza a repository-t (ha a <code>git</code> parancs el\u00e9rhet\u0151): <code>git clone &lt;repository link&gt;</code></p> </li> <li> <p>Ha siker\u00fclt a kl\u00f3noz\u00e1s, M\u00c9G NE KEZDJ EL DOLGOZNI! A megold\u00e1st ne a repository <code>master</code> \u00e1g\u00e1n k\u00e9sz\u00edtsd el. Hozz l\u00e9tre egy \u00faj \u00e1gat (branch) <code>megoldas</code> n\u00e9ven.</p> <p>GitHub Desktop-ban a Branch men\u00fcben teheted ezt meg.</p> <p></p> <p>Ha konzolt haszn\u00e1lsz, az \u00faj \u00e1g elk\u00e9sz\u00edthet\u0151 ezzel a paranccsal: <code>git checkout -b megoldas</code></p> </li> <li> <p>Ezen a megold\u00e1s \u00e1gon dolgozva k\u00e9sz\u00edtsd el a beadand\u00f3kat. Ak\u00e1rh\u00e1nyszor kommitolhatsz \u00e9s pusholhatsz.</p> <p>Kommit n\u00e9v ellen\u0151rz\u00e9se</p> <p>Miel\u0151tt a git repository-val dolgozol, ellen\u0151rizd, hogy a megfelel\u0151 n\u00e9vvel \u00e9s email c\u00edmmel kommitolsz-e. Ezt a k\u00f6vetkez\u0151 command line paranccsal tudod megtenni.</p> <pre><code>git config user.name\ngit config user.email\n</code></pre> <p>Ha ez nem megfelel\u0151 lenne, akkor add ki az al\u00e1bbi parancsokat a git repository mapp\u00e1j\u00e1ban. Ezzel az adott repository-ra fogod be\u00e1ll\u00edtani a k\u00edv\u00e1nt nevet \u00e9s email c\u00edmet. (\u00c9rdemes olyan email c\u00edmet, megadni ami a github useretekhez van rendelve)</p> <pre><code>git config user.name \"John Doe\"\ngit config user.email \"john@doe.org\"\n</code></pre> <p>Ha nem akarod minden repository-re k\u00fcl\u00f6n \u00e1ll\u00edtani a fentieket, akkor \u00e9rdemes lehet a glob\u00e1lisan vizsg\u00e1lni \u00e9s fel\u00fcl\u00edrni a <code>--global</code> kapcsol\u00f3val.</p> <p>GitHub Desktop-ban \u00edgy tudsz kommitolni. Mindig ellen\u0151rizd, hogy j\u00f3 \u00e1gon vagy-e. Els\u0151 alkalommal a megoldas \u00e1g csak helyben l\u00e9tezik, ez\u00e9rt publik\u00e1lni kell: Publish this branch.</p> <p></p> <p>A tov\u00e1bbi kommitokn\u00e1l is mindig ellen\u0151rizd a megfelel\u0151 \u00e1gat. Ha egy kommit m\u00e9g nincs fel\u00f6ltve, azt a Push origin gombbal teheted meg. A kis sz\u00e1m a gombon jelzi, hogy h\u00e1ny, m\u00e9g nem pusholt kommit van.</p> <p></p> <p>Ha konzolt haszn\u00e1lsz, akkor az al\u00e1bbi parancsokat haszn\u00e1ld (felt\u00e9ve, hogy a j\u00f3 \u00e1gon vagy):</p> <pre><code># Ellen\u0151rizd az \u00e1gat, \u00e9s hogy milyen f\u00e1jlok m\u00f3dosultak\ngit status\n\n# Minden v\u00e1ltoztat\u00e1st el\u0151k\u00e9sz\u00edt kommitol\u00e1sra\ngit add .\n\n# Kommit\ngit commit -m \"f1\"\n\n# Push els\u0151 alkalommal az \u00faj \u00e1g publik\u00e1l\u00e1s\u00e1hoz\ngit push --set-upstream origin megoldas\n\n# Push a tov\u00e1bbiakban, amikor az \u00e1g m\u00e1r nem \u00faj\ngit push\n</code></pre> </li> </ol>"},{"location":"homework/GitHub/#a-megoldas-beadasa","title":"A megold\u00e1s bead\u00e1sa","text":"<ol> <li> <p>Ha v\u00e9gezt\u00e9l a megold\u00e1ssal, ellen\u0151rizd a GitHub webes fel\u00fclet\u00e9n, hogy mindent felt\u00f6lt\u00f6tt\u00e9l-e. Ehhez a webes fel\u00fcleten v\u00e1ltanod kell az \u00e1gak k\u00f6z\u00f6tt.</p> <p></p> <p>Felt\u00f6lt\u00e9s a webes fel\u00fcleten</p> <p>Azt javasoljuk, hogy ne haszn\u00e1ld a GitHub f\u00e1jl felt\u00f6lt\u00e9s funkci\u00f3j\u00e1t. Ha valami hi\u00e1nyzik, a helyi git repository-ban p\u00f3told, \u00e9s kommitold majd pushold.</p> </li> <li> <p>Ha t\u00e9nyleg k\u00e9sz vagy, akkor nyiss egy pull request-et.</p> <p>Minek a pull request?</p> <p>Ez a pull request fogja \u00f6ssze a megold\u00e1sodat, \u00e9s annak \"v\u00e9geredm\u00e9ny\u00e9t\" mutatja. \u00cdgy a gyakorlatvezet\u0151nek nem az egyes kommitjaidat vagy f\u00e1jljaidat kell n\u00e9znie, hanem csak a relev\u00e1ns, v\u00e1ltozott r\u00e9szeket l\u00e1tja egyben. A pull request jelenti a feladatod bead\u00e1s\u00e1t is, \u00edgy ez a l\u00e9p\u00e9s nem hagyhat\u00f3 ki.</p> <p>A pull request nyit\u00e1s\u00e1hoz a GitHub webes fel\u00fclet\u00e9re kell menj. Itt, ha nem r\u00e9g pusholt\u00e1l, a GitHub fel is aj\u00e1nlja a pull request l\u00e9trehoz\u00e1s\u00e1t.</p> <p></p> <p>A pull request-et a fenti men\u00fcben is l\u00e9trehozhatod. Fontos, hogy a megfelel\u0151 brancheket v\u00e1laszd ki: <code>master</code>-be megy a <code>megoldas</code> \u00e1g.</p> <p></p> <p>Ha minden rendben siker\u00fclt, a men\u00fcben fent l\u00e1tod a kis \"1\" sz\u00e1mot a Pull request elem mellett, jelezve, hogy van egy nyitott pull request. DE M\u00c9G NEM V\u00c9GEZT\u00c9L!</p> <p></p> </li> <li> <p>A pull request hat\u00e1s\u00e1ra le fog futni egy \u00e9rt\u00e9kel\u00e9s. Ennek eredm\u00e9ny\u00e9t a pull request alatt kommentben fogod l\u00e1tni.</p> <p>Ez az \u00e9rt\u00e9kel\u00e9s minden h\u00e1zi eset\u00e9ben m\u00e1s lesz. A programodat minden esetben lefuttatjuk, \u00e9s el\u0151zetes pontsz\u00e1mot is kapsz.</p> <p></p> <p>Ha a ki\u00e9rt\u00e9kel\u00e9s eredm\u00e9ny\u00e9vel kapcsolatban t\u00f6bb inform\u00e1ci\u00f3ra van sz\u00fcks\u00e9ged, mint amit itt l\u00e1tsz, a GitHub Actions webes fel\u00fclete seg\u00edts\u00e9g\u00fcl szolg\u00e1lhat. Err\u0151l itt tal\u00e1lsz egy r\u00f6vid ismertet\u0151t.</p> </li> <li> <p>Ha nem vagy megel\u00e9gedve a munk\u00e1ddal, akkor m\u00e9g jav\u00edthatsz rajta. Ehhez kommitolj \u00e9s pusholj \u00fajra. Ha tov\u00e1bbra is a megfelel\u0151 \u00e1gon dolgozol, akkor a pull request \u00fajb\u00f3l le fogja futtatni a ki\u00e9rt\u00e9kel\u00e9st. Arra k\u00e9r\u00fcnk, hogy MAXIMUM 5 alkalommal futtasd le a ki\u00e9rt\u00e9kel\u00e9st!</p> <p>Megold\u00e1s jav\u00edt\u00e1sa ki\u00e9rt\u00e9kel\u00e9s n\u00e9lk\u00fcl</p> <p>Ha \u00fagy l\u00e1tod, hogy a megold\u00e1sodat m\u00e9g jav\u00edtani akarod, \u00e9s nem szeretn\u00e9d, hogy mindig lefusson az \u00e9rt\u00e9kel\u00e9s, akkor \u00e1ll\u00edtsd \u00e1t a pull request-et a webes fel\u00fcleten draft \u00e1llapotra.</p> <p></p> <p>Ezzel az \u00e1llapottal jelzed, hogy m\u00e9g dolgozol. Kommitolj \u00e9s pusholj. Ilyenkor nem fog futni ki\u00e9rt\u00e9kel\u00e9s. Ha v\u00e9gezt\u00e9l, akkor vissza kell \u00e1ll\u00edtanod a pull request-et: menj a PR alj\u00e1ra \u00e9s kattints a \"Ready for review\" gombra. Ennek hat\u00e1s\u00e1ra vissza\u00e1ll a PR \u00e9s le fog futni az automata \u00e9rt\u00e9kel\u00e9s.</p> <p></p> <p>Maximum 5</p> <p>A maximum 5 alkalomba nem sz\u00e1moljuk bele az esetlegesen megszakadt, vagy tranziens hiba miatt sikertelen futtat\u00e1sokat. Ha viszont figyelmetlens\u00e9gb\u0151l, vagy sz\u00e1nd\u00e9kosan t\u00fall\u00e9ped az \u00f6t\u00f6t, akkor pontlevon\u00e1ssal szankcion\u00e1lunk. Arra k\u00e9r\u00fcnk, hogy bead\u00e1s el\u0151tt teszteld a megold\u00e1sod, ne a GitHub platformot \"dolgoztasd\" magad helyett!</p> </li> <li> <p>V\u00c9GEZET\u00dcL, ha k\u00e9sz vagy, a pull request-et rendeld a gyakorlatvezet\u0151dh\u00f6z. Ez a l\u00e9p\u00e9s felt\u00e9tlen\u00fcl fontos, ez jelzi a bead\u00e1st.</p> <p></p> <p>Pull request n\u00e9lk\u00fcl</p> <p>Ha nincs pull request-ed, vagy nincs a gyakorlatvezet\u0151h\u00f6z rendelve, akkor \u00fagy tekintj\u00fck, hogy m\u00e9g nem vagy k\u00e9szen, \u00e9s nem adtad be a megold\u00e1st.</p> <p>V\u00e9gezt\u00e9l</p> <p>Miut\u00e1n a gyakorlatvezet\u0151h\u00f6z rendelted a pull request-et, m\u00e1r ne m\u00f3dos\u00edts semmin. A gyakorlatvezet\u0151 \u00e9rt\u00e9kelni fogja a munk\u00e1dat, \u00e9s a pull request lez\u00e1r\u00e1s\u00e1val kommentben jelzi a v\u00e9geredm\u00e9nyt.</p> </li> </ol>"},{"location":"homework/GitHub/#kapott-eredmennyel-kapcsolatban-kerdes-vagy-reklamacio","title":"Kapott eredm\u00e9nnyel kapcsolatban k\u00e9rd\u00e9s vagy reklam\u00e1ci\u00f3","text":"<p>Ha a feladatok \u00e9rt\u00e9kel\u00e9s\u00e9vel vagy az eredm\u00e9nnyel kapcsolatban k\u00e9rd\u00e9st tenn\u00e9l fel, vagy reklam\u00e1ln\u00e1l, haszn\u00e1ld a Pull Request kommentel\u00e9si lehet\u0151s\u00e9g\u00e9t erre. Annak \u00e9rdek\u00e9ben, hogy a gyakorlatvezet\u0151 biztosan \u00e9rtes\u00fclj\u00f6n a k\u00e9rd\u00e9sr\u0151l haszn\u00e1ld a <code>@n\u00e9v</code> mention funkci\u00f3t a gyakorlatvezet\u0151d megnevez\u00e9s\u00e9hez. Err\u0151l automatikusan kapni fog egy email \u00e9rtes\u00edt\u00e9st.</p> <p></p> <p>Reklam\u00e1ci\u00f3 csak indokl\u00e1ssal</p> <p>Ha nem \u00e9rtesz egyet az \u00e9rt\u00e9kel\u00e9ssel, a bizony\u00edt\u00e1s t\u00e9ged terhel, azaz al\u00e1 kell t\u00e1masztanod a reklam\u00e1ci\u00f3d (pl. annak le\u00edr\u00e1s\u00e1val, hogyan tesztelted a megold\u00e1sod, \u00e9s mi bizony\u00edtja a helyess\u00e9g\u00e9t).</p>"},{"location":"homework/VisualStudio/","title":"Visual Studio &amp; .NET SDK telep\u00edt\u00e9se","text":"<p>Egyes h\u00e1zikhoz a Microsoft Visual Studio 2022 verzi\u00f3ja sz\u00fcks\u00e9ges. Az ingyenes, Community v\u00e1ltozata is elegend\u0151 a feladatok megold\u00e1s\u00e1hoz.</p> <p>VS Code</p> <p>A feladatok Visual Studio n\u00e9lk\u00fcl, Visual Studio Code-dal is megoldhat\u00f3ak. A kiadott k\u00f3d v\u00e1z Visual Studio-hoz k\u00e9sz\u00fclt, annak konfigur\u00e1ci\u00f3it tartalmazza. Ha VS Code-dal dolgozol, magadnak kell konfigur\u00e1lni a k\u00f6rnyezetet.</p>"},{"location":"homework/VisualStudio/#visual-studio-workload-ok-telepitese","title":"Visual Studio Workload-ok telep\u00edt\u00e9se","text":"<p>A Visual Studio telep\u00edt\u00e9sekor ki kell pip\u00e1lni a ASP.NET and web development workloadot.</p> <p></p> <p>Meglev\u0151 telep\u00edt\u00e9s a Visual Studio Installer-ben a Modify gombbal m\u00f3dos\u00edthat\u00f3, ill. ellen\u0151rizhet\u0151.</p>"},{"location":"homework/VisualStudio/#net-sdk-ellenorzese-es-telepitese","title":".NET SDK ellen\u0151rz\u00e9se \u00e9s telep\u00edt\u00e9se","text":"<p>Visual Studio mellett bizonyos .NET SDK-k telep\u00edt\u00e9sre ker\u00fclnek. A megfelel\u0151 verzi\u00f3 ellen\u0151rz\u00e9s\u00e9hez legegyszer\u0171bb a <code>dotnet</code> CLI-t haszn\u00e1lni: konzolban add ki a <code>dotnet --list-sdks</code> parancsot. Ez a parancs Linux \u00e9s Mac eset\u00e9n is m\u0171k\u00f6dik. A kimenete hasonl\u00f3 lesz:</p> <pre><code>C:\\&gt;dotnet --list-sdks\n8.0.400 [C:\\Program Files\\dotnet\\sdk]\n</code></pre> <p>Ha ebben a list\u00e1ban l\u00e1tsz 8.0-\u00e1s verzi\u00f3t, akkor j\u00f3. Ha nem, akkor telep\u00edteni kell az SDK-t innen.</p>"},{"location":"homework/adonet/","title":"Feladat: ADO.NET adatel\u00e9r\u00e9s","text":"<p>2024-t\u0151l kifutott</p> <p>FIGYELEM: Ez a feladat 2024-t\u0151l m\u00e1r nem akt\u00edv.</p> <p>A h\u00e1zi feladat opcion\u00e1lis. A teljes\u00edt\u00e9ssel 2 pluszpont \u00e9s 2 iMsc pont szerezhet\u0151.</p> <p>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod. Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. Hozz l\u00e9tre egy <code>megoldas</code> nev\u0171 branchet, \u00e9s arra dolgozz. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.</p> <p>A megold\u00e1shoz sz\u00fcks\u00e9ges szoftvereket \u00e9s eszk\u00f6z\u00f6ket l\u00e1sd itt. A feladat MSSQL adatb\u00e1zist haszn\u00e1l.</p>"},{"location":"homework/adonet/#feladat-0-neptun-kod","title":"Feladat 0: Neptun k\u00f3d","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 <code>neptun.txt</code> f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!</p>"},{"location":"homework/adonet/#feladat-1-termek-repository-2-pluszpont","title":"Feladat 1: Term\u00e9k repository (2 pluszpont)","text":"<p>K\u00e9sz\u00edts a term\u00e9kek (<code>Product</code>) kezel\u00e9s\u00e9hez egy repository oszt\u00e1lyt ADO.NET Connection technol\u00f3gi\u00e1t haszn\u00e1lva. Nyisd meg a kiindul\u00f3 k\u00f3dban az sln f\u00e1jlt Visual Studio-val. Keresd meg a <code>Repository.ProductRepository</code> \u00e9s <code>Model.Product</code> oszt\u00e1lyokat. Implement\u00e1ld a <code>ProductRepository</code> oszt\u00e1ly al\u00e1bbi funkci\u00f3it:</p> <ul> <li>A <code>Search(string name)</code> f\u00fcggv\u00e9ny keresse meg az adatb\u00e1zisban a param\u00e9terben kapott term\u00e9kn\u00e9vre illeszked\u0151 tal\u00e1latokat, \u00e9s adja \u0151ket vissza C# oszt\u00e1ly p\u00e9ld\u00e1nyak\u00e9nt. Ha a kapott sz\u0171r\u00e9si param\u00e9ter <code>null</code>, akkor minden term\u00e9ket adjon vissza, ellenkez\u0151 esetben case-insensitive m\u00f3don a n\u00e9vben b\u00e1rhol keressen!</li> <li>A <code>FindById(int id)</code> adja vissza az ID alapj\u00e1n megtal\u00e1lt term\u00e9ket, vagy <code>null</code> \u00e9rt\u00e9ket, ha nem tal\u00e1lhat\u00f3 ilyen.</li> <li>Az <code>Update(Product p)</code> egy l\u00e9tez\u0151 term\u00e9k adatait friss\u00edtse az adatb\u00e1zisban a kapott param\u00e9ter alapj\u00e1n. Csak a <code>Name</code>, <code>Price</code> \u00e9s <code>Stock</code> v\u00e1ltozhat, a t\u00f6bbi tulajdons\u00e1got itt nem kell figyelembe venni.</li> <li>A <code>Delete(int id)</code> t\u00f6r\u00f6lje az ID alapj\u00e1n meghat\u00e1rozott term\u00e9ket az adatb\u00e1zisb\u00f3l, amennyiben az l\u00e9tezik. A visszat\u00e9r\u00e9si \u00e9rt\u00e9k jelzi, hogy sikeres volt-e a t\u00f6rl\u00e9s. (Csak a term\u00e9k rekordot kell t\u00f6r\u00f6lni, semmilyen kapcsol\u00f3d\u00f3 rekordot nem! Ha k\u00fcls\u0151 kulcs miatt nem t\u00f6r\u00f6lhet\u0151 a rekord, a hib\u00e1t ne kezeld le, hanem engedd tov\u00e1bb a h\u00edv\u00f3nak.)</li> </ul> <p>\u00dcgyelj az al\u00e1bbiakra:</p> <ul> <li>A megold\u00e1sban csak adatb\u00e1zis-szerver oldali sz\u0171r\u00e9st alkalmazz!</li> <li>Csak a <code>ProductRepository</code> oszt\u00e1ly k\u00f3dj\u00e1t m\u00f3dos\u00edtsd!</li> <li>A repository k\u00f3dj\u00e1ban az ADO.NET kapcsolat megnyit\u00e1s\u00e1hoz a <code>connectionString</code> v\u00e1ltoz\u00f3t haszn\u00e1ld (\u00e9s ne a <code>TestConnectionStringHelper</code>-t).</li> <li>A term\u00e9k \u00e1fakulcs\u00e1t is ki kell keresni, teh\u00e1t nem a kapcsol\u00f3d\u00f3 rekord id-j\u00e1t kell a <code>Model.Product</code> oszt\u00e1lynak \u00e1tadni, hanem az \u00e1fakulcs sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t! A term\u00e9k kateg\u00f3ri\u00e1j\u00e1nak nev\u00e9t hasonl\u00f3an ki kell keresni.</li> <li>Csak ADO.NET technol\u00f3gi\u00e1t haszn\u00e1lhatsz!</li> <li>V\u00e9dekezz SQL injectionnel szemben!</li> <li>A <code>Model.Product</code> oszt\u00e1ly k\u00f3dj\u00e1t ezen feladathoz ne m\u00f3dos\u00edtsd!</li> <li>A <code>ProductRepository</code> oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9nyek t\u00f6rzs\u00e9t \u00edrd meg.</li> </ul> <p>A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. Ezeket a teszteket Visual Studio-ban egyszer\u0171en tudod futtatni, de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy <code>dotnet cli</code>), akkor is tudsz teszteket futtatni. Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a <code>TestConnectionStringHelper</code> seg\u00e9doszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet.</p> <p>Tesztek</p> <p>A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz.</p> <p>A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod.</p> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p> <p>Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Visual Studio-b\u00f3l (vagy m\u00e1sik, a fejleszt\u00e9shez haszn\u00e1lt eszk\u00f6zb\u0151l, ami ak\u00e1r <code>dotnet cli</code> is lehet), amelyben a vonatkoz\u00f3 teszteket lefuttattad. L\u00e1tsz\u00f3djon a repository k\u00f3dja (a relev\u00e1ns r\u00e9sze, amennyi kif\u00e9r) \u00e9s a tesztek fut\u00e1s\u00e1nak eredm\u00e9nye! A k\u00e9pet <code>f1.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p> <p>Ha <code>dotnet test</code>-et haszn\u00e1lsz a teszt futtat\u00e1s\u00e1hoz, a k\u00e9perny\u0151k\u00e9pen l\u00e1tsz\u00f3djon az \u00f6sszes teszt neve. Ehhez haszn\u00e1ld a <code>-v n</code> kapcsol\u00f3t a r\u00e9szletesebb napl\u00f3z\u00e1shoz.</p> <p>A k\u00e9perny\u0151k\u00e9pen lev\u0151 forr\u00e1sk\u00f3d tekintet\u00e9ben nem sz\u00fcks\u00e9ges, hogy a v\u00e9gs\u0151 megold\u00e1sban szerepl\u0151 k\u00f3d bet\u0171r\u0151l bet\u0171re megegyezzen a k\u00e9pen \u00e9s a felt\u00f6lt\u00f6tt v\u00e1ltozatban. Teh\u00e1t a tesztek sikeres lefut\u00e1sa ut\u00e1n elk\u00e9sz\u00edtett k\u00e9perny\u0151k\u00e9pet nem sz\u00fcks\u00e9ges friss\u00edteni, ha a forr\u00e1sk\u00f3dban kisebb v\u00e1ltoztat\u00e1st eszk\u00f6z\u00f6lsz.</p> <p>M\u00c9G NEM V\u00c9GEZT\u00c9L</p> <p>Ha push-oltad a k\u00f3dodat, k\u00e9sz\u00edts egy PR-t, amihez rendeld hozz\u00e1 a gyakorlatvezet\u0151det! (r\u00e9szletek: a h\u00e1zi feladat lead\u00e1sa oldalon)</p>"},{"location":"homework/adonet/#feladat-2-optimista-konkurenciakezeles-2-imsc-pont","title":"Feladat 2: Optimista konkurenciakezel\u00e9s (2 iMsc pont)","text":"<p>Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g.</p> <p>A term\u00e9kek adatb\u00e1zisban t\u00f6rt\u00e9n\u0151 friss\u00edt\u00e9se eset\u00e9n vegy\u00fck \u00e9szre, \u00e9s ne engedj\u00fck a m\u00f3dos\u00edt\u00e1st, ha a friss\u00edt\u00e9ssel fel\u00fcl\u00edrn\u00e1nk egy nem l\u00e1tott m\u00f3dos\u00edt\u00e1st. A <code>ProductRepository.UpdateWithConcurrencyCheck</code> f\u00fcggv\u00e9nye legyen felel\u0151s a helyes viselked\u00e9s\u00e9rt, \u00e9s ne v\u00e9gezze el a k\u00e9rt m\u00f3dos\u00edt\u00e1st, ha elveszett m\u00f3dos\u00edt\u00e1s jelleg\u0171 konkurenciaprobl\u00e9m\u00e1t \u00e9szlel.</p> <p>A konkr\u00e9t eset, amit el szeretn\u00e9nk ker\u00fclni:</p> <ol> <li>A felhaszn\u00e1l\u00f3 lek\u00e9rdez egy term\u00e9ket.</li> <li>B felhaszn\u00e1l\u00f3 lek\u00e9rdezi ugyanazt a term\u00e9ket.</li> <li>A felhaszn\u00e1l\u00f3 m\u00f3dos\u00edtja a term\u00e9k \u00e1r\u00e1t (vagy m\u00e1s tulajdons\u00e1g\u00e1t), visszamenti az adatb\u00e1zisba.</li> <li>B felhaszn\u00e1l\u00f3 is m\u00f3dos\u00edtja a term\u00e9k \u00e1r\u00e1t (vagy m\u00e1s tulajdons\u00e1g\u00e1t), \u00e9s fel\u00fcl\u00edrja ezzel A m\u00f3dos\u00edt\u00e1s\u00e1t figyelmeztet\u00e9s n\u00e9lk\u00fcl.</li> </ol> <p>Optimista konkurenciakezel\u00e9s</p> <p>A megold\u00e1shoz az optimista konkurenciakezel\u00e9s koncepci\u00f3j\u00e1t alkalmazd. Ne haszn\u00e1lj tranzakci\u00f3t, mert a lek\u00e9rdez\u00e9s \u00e9s m\u00f3dos\u00edt\u00e1s id\u0151ben eltolva t\u00f6rt\u00e9nik, k\u00f6zben az adatb\u00e1zis kapcsolat megsz\u0171nik. Ne haszn\u00e1lj t\u00f6bb SQL utas\u00edt\u00e1st se, mert a lefut\u00e1suk k\u00f6z\u00f6tt m\u00e1s adatb\u00e1zis hozz\u00e1f\u00e9r\u00e9sek t\u00f6rt\u00e9nhetnek, elrontva a v\u00e1rt viselked\u00e9st. A megold\u00e1st a <code>ProductRepository.UpdateWithConcurrencyCheck</code> f\u00fcggv\u00e9nyben \u00edrd meg, valamint adapt\u00e1ld a <code>Model.Product</code> oszt\u00e1lyt is. Az adatb\u00e1zisba nem vehetsz fel \u00faj oszlopot.</p> <p>\u00dcgyelj az al\u00e1bbiakra:</p> <ul> <li>Csak a <code>ProductRepository.UpdateWithConcurrencyCheck</code> f\u00fcggv\u00e9ny \u00e9s a <code>Model.Product</code> oszt\u00e1ly k\u00f3dj\u00e1t m\u00f3dos\u00edtsd!</li> <li>A f\u00fcggv\u00e9ny visszat\u00e9r\u00e9si \u00e9rt\u00e9kben jelezze, hogy sikeres volt-e a m\u00f3dos\u00edt\u00e1s (vagyis, hogy nem volt konkurenciaprobl\u00e9ma).</li> <li>Magyar\u00e1zd el a viselked\u00e9st az <code>UpdateWithConcurrencyCheck</code> f\u00fcggv\u00e9nyben egy kommentben (2-3 mondatban).</li> <li>Egyetlen SQL parancs haszn\u00e1lat\u00e1val oldd meg a feladatot!</li> <li>Csak ADO.NET technol\u00f3gi\u00e1t haszn\u00e1lhatsz!</li> <li>V\u00e9dekezz SQL injectionnel szemben!</li> <li>A <code>ProductRepository</code> oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9t \u00edrd meg.</li> <li>A <code>Model.Product</code> oszt\u00e1ly konstruktor\u00e1nak defin\u00edci\u00f3j\u00e1t (param\u00e9terek darabsz\u00e1ma, sorrendje, nevei) ne v\u00e1ltoztasd meg, de a k\u00f3dj\u00e1t \u00e1t\u00edrhatod. A meglev\u0151 property-ket ne v\u00e1ltoztasd meg, de \u00fajakat felvehetsz.</li> </ul> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel. Ne felejtsd el meg\u00edrni a magyar\u00e1zatot a C# k\u00f3dban!</p>"},{"location":"homework/ef/","title":"2. Entity Framework","text":"<p>A h\u00e1zi feladat teljes\u00edt\u00e9s\u00e9vel 4 pont \u00e9s 3 iMsc pont szerezhet\u0151.</p> <p>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod. Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. Hozz l\u00e9tre egy <code>megoldas</code> nev\u0171 branchet, \u00e9s arra dolgozz. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.</p> <p>A megold\u00e1shoz sz\u00fcks\u00e9ges szoftvereket \u00e9s eszk\u00f6z\u00f6ket l\u00e1sd itt. A feladat MSSQL adatb\u00e1zist haszn\u00e1l.</p> <p>Entity Framework Core</p> <p>A feladatban Entity Framework Core-t haszn\u00e1lunk. A gyakorlaton haszn\u00e1lt Entity Framework-t\u0151l elt\u00e9r\u0151en ez egy platformf\u00fcggetlen technol\u00f3gia.</p>"},{"location":"homework/ef/#feladat-0-neptun-kod","title":"Feladat 0: Neptun k\u00f3d","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 <code>neptun.txt</code> f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!</p>"},{"location":"homework/ef/#feladat-1-adatbazis-lekepzes-code-first-modellel-es-lekerdezesek-2-pont","title":"Feladat 1: Adatb\u00e1zis lek\u00e9pz\u00e9s Code First modellel \u00e9s lek\u00e9rdez\u00e9sek (2 pont)","text":"<p>K\u00e9sz\u00edtsd el az adatb\u00e1zisunk (egy r\u00e9sz\u00e9nek) Entity Framework lek\u00e9pz\u00e9s\u00e9t Code First megold\u00e1ssal. Az Entity Framework Core csomag m\u00e1r r\u00e9sze a kiindul\u00f3 projekt\u00fcnknek, \u00edgy r\u00f6gt\u00f6n k\u00f3dolhatunk is. Az adatel\u00e9r\u00e9s k\u00f6zponti eleme a DbContext. Ez az oszt\u00e1ly m\u00e1r l\u00e9tezik <code>ProductDbContext</code> n\u00e9ven.</p> <ol> <li> <p>K\u00e9pezd le a term\u00e9keket. Hozz l\u00e9tre egy \u00faj oszt\u00e1lyt <code>DbProduct</code> n\u00e9ven az al\u00e1bbi k\u00f3ddal. (A Db prefix egy\u00e9rtelm\u0171v\u00e9 teszi, hogy az oszt\u00e1ly az adatb\u00e1zis kontextus\u00e1ban \u00e9rtelmezett. Ez a k\u00e9s\u0151bbi feladatn\u00e1l lesz \u00e9rdekes.) A lek\u00e9pz\u00e9sn\u00e9l t\u00f6bbnyire hagyatkozzunk a konvenci\u00f3kra, azaz a property-k nev\u00e9n\u00e9l haszn\u00e1ljuk az adatb\u00e1zis oszlopok nev\u00e9t, \u00edgy automatikus lesz a lek\u00e9pz\u00e9s.</p> <pre><code>using System.ComponentModel.DataAnnotations.Schema;\n\nnamespace ef\n{\n    [Table(\"Product\")]\n    public class DbProduct\n    {\n        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]\n        public int ID { get; set; }\n        public string Name { get; set; }\n        public double Price { get; set; }\n        public int Stock { get; set; }\n    }\n}\n</code></pre> <p>Menj a <code>ProductDbContext</code> oszt\u00e1lyhoz \u00e9s t\u00f6r\u00f6ld a kommentet a <code>Products</code> property el\u0151l.</p> </li> <li> <p>K\u00e9sz\u00edts egy <code>DbVat</code> oszt\u00e1lyt a <code>VAT</code> t\u00e1bla lek\u00e9pz\u00e9s\u00e9re az <code>ef</code> n\u00e9vt\u00e9rbe a <code>DbProduct</code>-hoz hasonl\u00f3an. Ne felejtsd el felvenni a DbSet property-t a <code>ProductDbContext</code>-be <code>Vat</code> n\u00e9ven.</p> </li> <li> <p>K\u00e9pezd le a Product - VAT kapcsolatot.</p> <p>A <code>DbProduct</code> oszt\u00e1lyba vegy\u00e9l fel egy <code>DbVat</code> t\u00edpus\u00fa <code>Vat</code> nev\u0171 get-set property-t, ez lesz a navigation property. Haszn\u00e1ld a <code>ForeignKey</code> attrib\u00fatumot a property felett, ami meghat\u00e1rozza a k\u00fcls\u0151 kulcs adatb\u00e1zis mez\u0151j\u00e9t (\"VatID\").</p> <p>Vedd fel ennek az egy-t\u00f6bb kapcsolatnak a m\u00e1sik oldal\u00e1t a <code>DbVat</code> oszt\u00e1lyba. Ez a <code>Products</code> nev\u0171 property <code>System.Collections.Generic.List</code> t\u00edpus\u00fa legyen. (L\u00e1sd a p\u00e9ld\u00e1ban is az el\u0151bbi linken.)</p> </li> </ol> <p>A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. A tesztek k\u00f3dja ki van kommentezve, mert nem fordul, am\u00edg nem \u00edrod meg a fentieket. Jel\u00f6ld ki a teljes k\u00f3dot, \u00e9s haszn\u00e1ld az Edit / Advanced / Uncomment Selection parancsot. Ezut\u00e1n a teszteket Visual Studio-ban egyszer\u0171en tudod futtatni, de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy <code>dotnet cli</code>), akkor is tudsz teszteket futtatni. Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a <code>TestConnectionStringHelper</code> seg\u00e9doszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet.</p> <p>Tesztek</p> <p>A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz.</p> <p>A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod.</p> <p>Ha a teszt nem fordul</p> <p>Ha nem fordulna le a teszt k\u00f3d, lehet, hogy egy-egy property n\u00e9vnek m\u00e1st haszn\u00e1lt\u00e1l. A saj\u00e1t k\u00f3dodban jav\u00edtsd a nevet, ne a tesztekben!</p> <p><code>OnConfiguring</code></p> <p>A DbContext k\u00f3dj\u00e1ban nincs sz\u00fcks\u00e9ged connection stringre. A konstruktor int\u00e9zi a kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9t. Ne \u00edrj <code>OnConfiguring</code> f\u00fcggv\u00e9nyt az oszt\u00e1lyba!</p> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p> <p>Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Visual Studio-b\u00f3l (vagy m\u00e1sik, a fejleszt\u00e9shez haszn\u00e1lt eszk\u00f6zb\u0151l, ami ak\u00e1r <code>dotnet cli</code> is lehet), amelyben a vonatkoz\u00f3 teszteket lefuttattad. L\u00e1tsz\u00f3djon a DbContext k\u00f3dja \u00e9s a tesztek fut\u00e1s\u00e1nak eredm\u00e9nye! A k\u00e9pet <code>f1.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p> <p>Ha <code>dotnet test</code>-et haszn\u00e1lsz a teszt futtat\u00e1s\u00e1hoz, a k\u00e9perny\u0151k\u00e9pen l\u00e1tsz\u00f3djon az \u00f6sszes teszt neve. Ehhez haszn\u00e1ld a <code>-v n</code> kapcsol\u00f3t a r\u00e9szletesebb napl\u00f3z\u00e1shoz.</p> <p>A k\u00e9perny\u0151k\u00e9pen lev\u0151 forr\u00e1sk\u00f3d tekintet\u00e9ben nem sz\u00fcks\u00e9ges, hogy a v\u00e9gs\u0151 megold\u00e1sban szerepl\u0151 k\u00f3d bet\u0171r\u0151l bet\u0171re megegyezzen a k\u00e9pen \u00e9s a felt\u00f6lt\u00f6tt v\u00e1ltozatban. Teh\u00e1t a tesztek sikeres lefut\u00e1sa ut\u00e1n elk\u00e9sz\u00edtett k\u00e9perny\u0151k\u00e9pet nem sz\u00fcks\u00e9ges friss\u00edteni, ha a forr\u00e1sk\u00f3dban kisebb v\u00e1ltoztat\u00e1st eszk\u00f6z\u00f6lsz.</p>"},{"location":"homework/ef/#feladat-2-repository-megvalositas-entity-framework-kel-2-pont","title":"Feladat 2: Repository megval\u00f3s\u00edt\u00e1s Entity Framework-kel (2 pont)","text":"<p>A pont megszerz\u00e9s\u00e9re az els\u0151 feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g.</p> <p>Az Entity Framework DbContext-je az el\u0151z\u0151ekben meg\u00edrt m\u00f3don nem haszn\u00e1lhat\u00f3 k\u00e9nyelmesen. P\u00e9ld\u00e1ul a kapcsolatok bet\u00f6lt\u00e9s\u00e9t (<code>Include</code>) k\u00e9zzel kell kezdem\u00e9nyezni, \u00e9s a lek\u00e9pzett entit\u00e1sok t\u00fals\u00e1gosan k\u00f6t\u0151dnek az adatb\u00e1zis s\u00e9m\u00e1j\u00e1hoz. Egy komplex alkalmaz\u00e1s eset\u00e9ben ez\u00e9rt c\u00e9lszer\u0171 a DbContext-et a repository minta szerint becsomagolni, \u00e9s ily m\u00f3don ny\u00fajtani az adatel\u00e9r\u00e9si r\u00e9teget.</p> <p>Implement\u00e1ld a <code>ProductRepository</code> oszt\u00e1lyt, amely megval\u00f3s\u00edtja a term\u00e9kek list\u00e1z\u00e1s\u00e1t \u00e9s besz\u00far\u00e1s\u00e1t. Ehhez m\u00e1r rendelkez\u00e9sre \u00e1ll egy \u00faj, \u00fan. modell oszt\u00e1ly, ami a term\u00e9ket reprezent\u00e1lja, de k\u00f6zvetlen\u00fcl tartalmazza az \u00e1fa kulcs sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t is. Ez az oszt\u00e1ly az adatb\u00e1zis adataib\u00f3l \u00e9p\u00edtkezik, de egys\u00e9gbe z\u00e1rja az adatokat an\u00e9lk\u00fcl, hogy az adatb\u00e1zishoz kellene fordulni a kapcsol\u00f3d\u00f3 \u00e1fa rekord lek\u00e9rdez\u00e9s\u00e9hez. Ez a <code>Model.Product</code> nev\u0171 oszt\u00e1ly, ami tartalmazza a <code>DbProduct</code> lek\u00e9pzett tulajdons\u00e1gait, de a <code>DbVat</code>-ra mutat\u00f3 navigation property helyett az int t\u00edpus\u00fa \u00e1fakulcs (<code>VAT.Percentage</code>) sz\u00e1zal\u00e9kos \u00e9rt\u00e9k\u00e9t tartalmazza.</p> <p>Implement\u00e1ld a <code>ProductRepository</code> oszt\u00e1ly f\u00fcggv\u00e9nyeit.</p> <ul> <li>A <code>List</code> az \u00f6sszes term\u00e9ket adja vissza <code>Model.Product</code> t\u00edpusra lek\u00e9pezve.</li> <li>Az <code>Insert</code> sz\u00farjon be egy \u00faj term\u00e9ket. A kapott \u00c1FA kulcs \u00e9rt\u00e9knek megfelel\u0151en keresse ki az adatb\u00e1zisb\u00f3l a kapcsol\u00f3d\u00f3 <code>VAT</code> rekordot, vagy ha nem l\u00e9tezik ilyen kulcs m\u00e9g, akkor sz\u00farjon be egy \u00faj <code>VAT</code> rekordot is! A met\u00f3dus visszat\u00e9r\u00e9si \u00e9rt\u00e9ke az \u00faj elem ID-ja legyen (amit term\u00e9szetesen az adatb\u00e1zis gener\u00e1l).</li> <li>A <code>Delete</code> t\u00f6r\u00f6lje a term\u00e9k rekordot a megadott id alapj\u00e1n. Csak a term\u00e9k rekordot kell t\u00f6r\u00f6lni, kapcsol\u00f3d\u00f3 sorokat nem. Ha a t\u00f6rl\u00e9s k\u00fcls\u0151 kulcsok miatt nem hajthat\u00f3 v\u00e9gre, engedd a h\u00edv\u00f3t \u00e9rtes\u00fclni a hib\u00e1r\u00f3l. Ha a term\u00e9k nem l\u00e9tezik, a f\u00fcggv\u00e9ny hamis visszat\u00e9r\u00e9si \u00e9rt\u00e9kkel jelezze, a sikeres t\u00f6rl\u00e9st pedig igazzal.</li> <li>A <code>ProductRepository</code> oszt\u00e1ly defin\u00edci\u00f3j\u00e1t (pl. oszt\u00e1ly neve, konstruktor, f\u00fcggv\u00e9nyek defin\u00edci\u00f3ja) ne v\u00e1ltoztasd meg, csak a f\u00fcggv\u00e9nyek t\u00f6rzs\u00e9t \u00edrd meg.</li> <li>A k\u00f3dban a <code>ProductRepository.createDbContext()</code>-et haszn\u00e1ld a DbContext l\u00e9trehoz\u00e1s\u00e1hoz (\u00e9s ne a <code>TestConnectionStringHelper</code>-t).</li> </ul> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p> <p>M\u00c9G NEM V\u00c9GEZT\u00c9L</p> <p>Ha push-oltad a k\u00f3dodat, k\u00e9sz\u00edts egy PR-t, amihez rendeld hozz\u00e1 a gyakorlatvezet\u0151det! (r\u00e9szletek: a h\u00e1zi feladat lead\u00e1sa oldalon)</p>"},{"location":"homework/ef/#feladat-3-logikai-torles-entity-framework-kel-3-imsc-pont","title":"Feladat 3: Logikai t\u00f6rl\u00e9s Entity Framework-kel (3 iMSc pont)","text":"<p>A pont megszerz\u00e9s\u00e9re az els\u0151 k\u00e9t feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g.</p> <p>Az adatb\u00e1zisb\u00f3l val\u00f3 t\u00f6rl\u00e9s egy olyan m\u0171velet, ami sz\u00e1mos nemk\u00edv\u00e1nt hat\u00e1ssal rendelkezik. Egy t\u00f6r\u00f6lt adatot vissza\u00e1ll\u00edtani sokkal nehezebb, n\u00e9ha nem is lehets\u00e9ges k\u00f6vetkezm\u00e9nyek n\u00e9lk\u00fcl. Az adat t\u00f6rl\u00e9s\u00e9vel ak\u00e1r a teljes adatt\u00f6rt\u00e9net elveszhet, nem tudunk a t\u00f6rl\u00e9s el\u0151tti \u00e1llapotr\u00f3l, k\u00fcl\u00f6nb\u00f6z\u0151 statisztik\u00e1kban nem tudjuk felhaszn\u00e1lni. R\u00e1ad\u00e1sul el\u0151fordulnak olyan esetek, p\u00e9ld\u00e1ul amikor olyan m\u00e1s t\u00e1bl\u00e1kkal val\u00f3 kapcsolatok \u00e9s k\u00fcls\u0151 kulcs k\u00e9nyszerek vannak, hogy a t\u00f6rl\u00e9s kihat\u00e1ssal van azokra a t\u00e1bl\u00e1kra is.</p> <p>Ezen probl\u00e9m\u00e1k \u00e1thidal\u00e1s\u00e1ra a leggyakoribb megold\u00e1s, hogy egy nem v\u00e9gleges t\u00f6rl\u00e9st, hanem egy \u00fagynevezett logikai t\u00f6rl\u00e9st (soft delete) vezet\u00fcnk be. Ebben az esetben egy mez\u0151 (tipikusan <code>IsDeleted</code> n\u00e9vvel) \u00e1t\u00e1ll\u00edt\u00e1s\u00e1val jelezz\u00fck, hogy az adott adat m\u00e1r t\u00f6r\u00f6lve van. \u00cdgy az megmarad az adatb\u00e1zisban is, de tudjuk sz\u0171rni, hogy t\u00f6r\u00f6ltek-e.</p> <p>A sz\u0171r\u00e9s naiv implement\u00e1ci\u00f3ja azonban nem k\u00e9nyelmes. K\u00e9pzelj\u00fck el, hogy minden lek\u00e9rdez\u00e9s vagy ment\u00e9s eset\u00e9n oda kell \u00edrni a kifejez\u00e9sbe, hogy ne hasson ezekre a t\u00f6r\u00f6lt elemekre. Ennek \u00e9rdek\u00e9ben az Entity Framework egyik funkci\u00f3j\u00e1t \u00e9rdemes kihaszn\u00e1lni, a Global Query Filter-t. Ennek a seg\u00edts\u00e9g\u00e9vel olyan sz\u0171r\u0151felt\u00e9teleket hat\u00e1rozhatunk meg, amiket glob\u00e1lisan, minden egyes lek\u00e9rdez\u00e9sn\u00e9l automatikusan alkalmaz az Entity Framework. </p> <p>Implement\u00e1ld a logikai t\u00f6rl\u00e9st az el\u0151bbiekben elk\u00e9sz\u00edtett <code>DbProduct</code> oszt\u00e1lyhoz (t\u00f6bb megold\u00e1si lehet\u0151s\u00e9g is van, tetsz\u0151legesen v\u00e1laszthatod b\u00e1rmelyiket):</p> <p>M\u00f3dos\u00edthat\u00f3s\u00e1g</p> <p>B\u00e1r az el\u0151z\u0151 feladatban volt megk\u00f6t\u00e9s, hogy ne legyen az <code>OnConfiguring</code> f\u00fcggv\u00e9ny fel\u00fcldefini\u00e1lva, amennyiben sz\u00fcks\u00e9gesnek l\u00e1tod, itt nyugodtan lehet (illetve m\u00e1s f\u00fcggv\u00e9nyeket is fel\u00fcldefini\u00e1lhatsz a DBContext megval\u00f3s\u00edt\u00e1sban)!</p> <ol> <li> <p>Vegy\u00e9l fel egy <code>IsDeleted</code> v\u00e1ltoz\u00f3t, ami jelzi az alkalmaz\u00e1sunk sz\u00e1m\u00e1ra, hogy az adott entit\u00e1s t\u00f6r\u00f6lt \u00e1llapotban van!</p> </li> <li> <p>Vegy\u00e9l fel egy QueryFilter-t, ami minden lek\u00e9rdez\u00e9skor kisz\u0171ri azokat a term\u00e9keket, amiket m\u00e1r t\u00f6r\u00f6lt\u00fcnk, \u00edgy azokat nem kapjuk vissza! </p> </li> <li> <p>Az adatb\u00e1zisb\u00f3l val\u00f3 t\u00f6rl\u00e9s viselked\u00e9s\u00e9t v\u00e1ltoztasd meg \u00e1ltal\u00e1nosan a <code>DbContext</code> ment\u00e9s m\u0171veleteit kib\u0151v\u00edtve (erre t\u00f6bb kiterjeszt\u00e9si pontot is ny\u00fajt az EFCore), hogy az igazi t\u00f6rl\u00e9s helyett csak \u00e1tv\u00e1ltoztassa az <code>IsDeleted</code> v\u00e1ltoz\u00f3t! Ne v\u00e1ltoztasd meg a t\u00f6rl\u00e9s m\u0171veletet a repositoryban m\u00f3dos\u00edt\u00e1sra!</p> </li> </ol> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p>"},{"location":"homework/graphql/","title":"5. GraphQL","text":"<p>GraphQL h\u00e1zi feladat, a teljes\u00edt\u00e9ssel 4 pont \u00e9s 3 iMsc pont szerezhet\u0151.</p> <p>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod. Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. Hozz l\u00e9tre egy <code>megoldas</code> nev\u0171 branchet, \u00e9s arra dolgozz. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.</p> <p>A megold\u00e1shoz sz\u00fcks\u00e9ges szoftvereket \u00e9s eszk\u00f6z\u00f6ket l\u00e1sd itt.</p> <p>El\u0151k\u00e9sz\u00fcletk\u00e9nt hozz l\u00e9tre egy \u00faj adatb\u00e1zist, a gyakorlatanyagban le\u00edrt m\u00f3don.</p>"},{"location":"homework/graphql/#feladat-0-neptun-kod","title":"Feladat 0: Neptun k\u00f3d","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 <code>neptun.txt</code> f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!</p>"},{"location":"homework/graphql/#feladat-1-projekt-kiegeszitese-es-lekerdezesek-2-pont","title":"Feladat 1: Projekt kieg\u00e9sz\u00edt\u00e9se \u00e9s lek\u00e9rdez\u00e9sek (2 pont)","text":"<p>A h\u00e1zi feladat feladat c\u00e9lja, hogy gyakorlati tapasztalatot szerezzetek a GraphQL haszn\u00e1lat\u00e1ban egy saj\u00e1t API l\u00e9trehoz\u00e1s\u00e1val. A GraphQL egy er\u0151teljes eszk\u00f6z, amely lehet\u0151v\u00e9 teszi az adatok lek\u00e9rdez\u00e9s\u00e9t \u00e9s m\u00f3dos\u00edt\u00e1s\u00e1t egyetlen, j\u00f3l struktur\u00e1lt k\u00e9r\u00e9sben, rugalmasabb\u00e1 \u00e9s hat\u00e9konyabb\u00e1 t\u00e9ve az API-k haszn\u00e1lat\u00e1t. A GraphQL API m\u0171k\u00f6d\u00e9se kiss\u00e9 elt\u00e9r a hagyom\u00e1nyos REST API-t\u00f3l: a v\u00e9gponton rugalmas, szab\u00e1lyozott lek\u00e9rdez\u00e9sekkel pontosan megadhatja a kliens, hogy milyen adatokat szeretne visszakapni. A gyakorlat c\u00e9lja, hogy megmutassa, hogyan \u00e9rhet\u0151k el komplex adatok egyszer\u0171en.</p> <p>Ebben a h\u00e1zi feladatban a megszokott adatmodell lesz haszn\u00e1lva, megrendel\u00e9sek, term\u00e9kek, kateg\u00f3ri\u00e1k \u00e9s hozz\u00e1juk kapcsol\u00f3d\u00f3 inform\u00e1ci\u00f3k lek\u00e9rdez\u00e9s\u00e9vel. Az adatmodell, a DBContext \u00e9s az entit\u00e1sok m\u00e1r megtal\u00e1lhat\u00f3ak a kiindul\u00f3 projektben.</p>"},{"location":"homework/graphql/#graphql-vegpontok-letrehozasa","title":"GraphQL v\u00e9gpontok l\u00e9trehoz\u00e1sa","text":"<p>Az els\u0151 feladatban megn\u00e9zz\u00fck hogyan lehet egy m\u00e1r l\u00e9tez\u0151 projekthez felvenni GraphQL v\u00e9gpontokat a Hot Chocolate szerver oldali k\u00f6nyvt\u00e1r seg\u00edts\u00e9g\u00e9vel. Ehhez el\u0151sz\u00f6r felvessz\u00fck a sz\u00fcks\u00e9ges csomagokat, kiaj\u00e1nlunk v\u00e9gpontokat, \u00e9s elk\u00e9sz\u00edtj\u00fck azt az oszt\u00e1lyt, ami visszaadja a sz\u00fcks\u00e9ges adatokat.</p> <ol> <li> <p>Vegy\u00e9l fel egy <code>Query</code> oszt\u00e1lyt, amibe tegy\u00e9l egy <code>GetProducts</code> f\u00fcggv\u00e9nyt egy <code>AdatvezDbContext</code> param\u00e9terrel. Ez a f\u00fcggv\u00e9ny fog a <code>products</code> query v\u00e9gpontjak\u00e9nt szolg\u00e1lni. A param\u00e9ter DBContext t\u00edpust a DI container fogja majd injekt\u00e1lni a met\u00f3dus h\u00edv\u00e1sakor. Implement\u00e1ld is a met\u00f3dust, hogy visszaadja a term\u00e9keket \u00e9s a hozz\u00e1juk tartoz\u00f3 kateg\u00f3ri\u00e1kat.</p> </li> <li> <p>Vedd fel a k\u00f6vetkez\u0151 NuGet csomagokat a z\u00e1r\u00f3jelben l\u00e1that\u00f3 verzi\u00f3kkal:</p> </li> <li> <p>HotChocolate.AspNetCore (14.1.0)</p> </li> <li>HotChocolate.Data (14.1.0)</li> <li> <p>HotChocolate.Data.EntityFramework (14.1.0)</p> </li> <li> <p>A bel\u00e9p\u00e9si pontba (<code>Program.cs</code>) regisztr\u00e1ld be a GraphQLServer szolg\u00e1ltat\u00e1st az al\u00e1bbi k\u00f3d seg\u00edts\u00e9g\u00e9vel: (itt h\u00e1rom dolog t\u00f6rt\u00e9nik: beregisztr\u00e1ljuk a GraphQLServer szolg\u00e1ltat\u00e1st, az <code>AdatvezDBContext</code>-t, hogy injekt\u00e1lhat\u00f3 legyen, valamint a <code>Query</code> oszt\u00e1lyt, mint lek\u00e9rdez\u00e9sek v\u00e9gpontjaik\u00e9nt funkcion\u00e1l\u00f3 oszt\u00e1lyt)</p> <pre><code>builder.Services\n    .AddGraphQLServer()\n    .RegisterDbContextFactory&lt;AdatvezDbContext&gt;()\n    .AddQueryType&lt;Query&gt;();\n</code></pre> </li> <li> <p>Add hozz\u00e1 az \u00fatv\u00e1laszt\u00e1st (v\u00e9gpontok kezel\u00e9s\u00e9nek k\u00e9pess\u00e9g\u00e9t) \u00e9s hozz l\u00e9tre egy alap\u00e9rtelmezett v\u00e9gpontot a k\u00f6vetkez\u0151 k\u00f3dsorok seg\u00edts\u00e9g\u00e9vel:</p> <pre><code>app.UseRouting();\napp.UseEndpoints(endpoints =&gt;\n{\n    endpoints.MapGraphQL();\n});\n</code></pre> </li> <li> <p>Ind\u00edtsd el az alkalmaz\u00e1st \u00e9s navig\u00e1lj a <code>http://localhost:5000/graphql/</code> oldalra. Itt l\u00e1thatod a Banana Cake Pop nev\u0171 interakt\u00edv eszk\u00f6zt, amivel lehets\u00e9ges lek\u00e9rdez\u00e9sek \u00e9s mut\u00e1ci\u00f3k futtat\u00e1s, a s\u00e9ma megtekint\u00e9se, valamint az API-hoz tartoz\u00f3 dokument\u00e1ci\u00f3t is lehet b\u00f6ng\u00e9szni. A lek\u00e9rdez\u00e9sek tabon a k\u00f6vetkez\u0151 k\u00f3ddal ki tudod pr\u00f3b\u00e1lni a fenti f\u00fcggv\u00e9ny fut\u00e1s\u00e1t:</p> <pre><code>query {\n    products {\n        name\n        category {\n            name\n        }\n    }\n}\n</code></pre> </li> </ol> <p>Vizsg\u00e1ljuk meg, hogy mi t\u00f6rt\u00e9nik.</p> <ul> <li> <p>Amikor a Hot Chocolate vagy m\u00e1s GraphQL szerver egy k\u00e9r\u00e9st kap, minden mez\u0151t egy resolver kezel, amely felel\u0151s az adott adat lek\u00e9r\u00e9s\u00e9\u00e9rt, el\u0151\u00e1ll\u00edt\u00e1s\u00e1\u00e9rt.</p> </li> <li> <p>A products mez\u0151h\u00f6z implicit m\u00f3don kapcsol\u00f3dik a GetProducts met\u00f3dus, a Hot Chocolate automatikusan \u00f6sszek\u00f6ti \u0151ket.</p> </li> <li> <p>A Hot Chocolate \u00e9s az Entity Framework (EF) integr\u00e1ci\u00f3ja lehet\u0151v\u00e9 teszi, hogy a GraphQL API k\u00f6zvetlen\u00fcl adatokat k\u00e9rjen le az adatb\u00e1zisb\u00f3l az EF-en kereszt\u00fcl, ami leegyszer\u0171s\u00edti a GraphQL v\u00e9gpontok implement\u00e1l\u00e1s\u00e1t \u00e9s m\u0171k\u00f6d\u00e9s\u00e9t.</p> </li> </ul> <p>Connection string</p> <p>Ha nem LocalDB-t haszn\u00e1lsz, az <code>appsettings.json</code>-ban a connection stringet lehet, hogy m\u00f3dos\u00edtanod kell.</p>"},{"location":"homework/graphql/#lekerdezesek","title":"Lek\u00e9rdez\u00e9sek","text":"<ol> <li> <p>K\u00e9sz\u00edts az el\u0151z\u0151 feladat alapj\u00e1n egy olyan lek\u00e9rdez\u00e9st, amely k\u00e9pes a term\u00e9keket visszaadni valamilyen sz\u0171r\u00e9s elv\u00e9gz\u00e9se ut\u00e1n. A <code>Query</code> oszt\u00e1lyba vedd fel a <code>ProductsByCategory</code> f\u00fcggv\u00e9nyt ami az <code>AdatvezDBContext</code>-en k\u00edv\u00fcl egy <code>categoryName</code> nev\u0171 <code>string</code> param\u00e9terrel rendelkezik. Az implement\u00e1ci\u00f3ban sz\u0171rj a kateg\u00f3ria nev\u00e9re: azokat a term\u00e9ket add vissza, amelyek kateg\u00f3ri\u00e1j\u00e1nak neve megegyezik a kapott param\u00e9terrel. A tesztel\u00e9shez haszn\u00e1ld az al\u00e1bbi lek\u00e9rdez\u00e9st:</p> <pre><code>query {\n    productsByCategory(categoryName: \"Months 0-6\") {\n        id\n        name\n        price\n    }\n}\n</code></pre> </li> <li> <p>A k\u00f6vetkez\u0151 feladatban l\u00e1thatjuk a GraphQL erej\u00e9t. Amennyiben sok t\u00e1bl\u00e1b\u00f3l kell \u00f6sszev\u00e1logatni a sz\u00fcks\u00e9ges inform\u00e1ci\u00f3t, sok felesleges adat is kereszt\u00fcl mehetne a h\u00e1l\u00f3zaton. Ehhez k\u00e9pest, ha tudjuk mik fognak kelleni, el\u00e9g csup\u00e1n a sz\u00fcks\u00e9ges adatokat lek\u00e9rdezni \u00e9s elk\u00fcldeni. K\u00e9sz\u00edts egy lek\u00e9rdez\u00e9st, ami megrendel\u00e9seket ad vissza \u00e9s a k\u00f6vetkez\u0151 adatokat szedi \u00f6ssze:</p> <ul> <li> <p>A megrendel\u0151 nev\u00e9t</p> </li> <li> <p>A megrendel\u00e9sben szerepl\u0151 term\u00e9kek neveit</p> </li> <li> <p>A term\u00e9kek kateg\u00f3ri\u00e1it</p> </li> <li> <p>H\u00e1ny darabot rendeltek az adott term\u00e9kb\u0151l.</p> </li> </ul> <pre><code>query {\n    orders {\n        customerSite {\n            customer {\n                name\n            }\n        }\n        orderItems {\n            amount\n            product\n            {\n                name\n                category\n                {\n                    name\n                }\n            }\n        }\n    }\n}\n</code></pre> </li> <li> <p>Lek\u00e9rdez\u00e9s optimaliz\u00e1l\u00e1sa: az alkalmaz\u00e1s ind\u00edt\u00e1sakor megny\u00edl\u00f3 konzolon megtekintheted a lek\u00e9rdez\u00e9st is, amit a Hot Chocolate gener\u00e1l Entity Framework seg\u00edts\u00e9g\u00e9vel. L\u00e1thatod, hogy a select utas\u00edt\u00e1sban el\u00e9g sok olyan mez\u0151 is lek\u00e9rdez\u00e9sre ker\u00fcl, ami egy\u00e9bk\u00e9nt nem k\u00e9ne, pedig a lek\u00e9r\u00e9sben egy\u00e9rtelm\u0171en megfogalmaztuk, hogy mik kellenek. A Hot Chocolate a <code>[UseProjection]</code> annot\u00e1ci\u00f3val ell\u00e1tott f\u00fcggv\u00e9nyek eset\u00e9n a be\u00e9rkez\u0151 k\u00e9r\u00e9seket az adatb\u00e1zis sz\u00e1m\u00e1ra k\u00f6zvetlen transzform\u00e1lja. A haszn\u00e1lat\u00e1hoz az annot\u00e1ci\u00f3 hozz\u00e1ad\u00e1s\u00e1n k\u00edv\u00fcl k\u00e9t m\u00f3dos\u00edt\u00e1s sz\u00fcks\u00e9ges. Az els\u0151, hogy a f\u00fcggv\u00e9ny visszat\u00e9r\u00e9si \u00e9rt\u00e9ke <code>IQuryable&lt;Order&gt;</code> legyen. A m\u00e1sodik pedig, hogy a k\u00f6vetkez\u0151 h\u00edv\u00e1ssal beregisztr\u00e1ld a projection el\u00e9rhet\u0151s\u00e9g\u00e9t:</p> <pre><code>builder.Services\n    .AddGraphQLServer()\n    .RegisterDbContextFactory&lt;AdatvezDbContext&gt;()\n    .AddQueryType&lt;Query&gt;()\n    //\u00faj sor:\n    .AddProjections(); \n</code></pre> </li> </ol> <p>N\u00e9zd meg konzolon az SQL lek\u00e9rdez\u00e9s megv\u00e1ltoz\u00e1s\u00e1t. Az implement\u00e1ci\u00f3 is cs\u00f6kkenthet, innent\u0151l kezdve az explicit <code>Include</code> h\u00edv\u00e1sok sem lesznek sz\u00fcks\u00e9gesek.</p> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p> <p>Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a Banana Cake Pop fel\u00fclet\u00e9n k\u00e9sz\u00edtett lek\u00e9rdez\u00e9sr\u0151l \u00e9s a v\u00e1laszr\u00f3l, amiben szerepelnek a sz\u00fcks\u00e9ges adatok. A k\u00e9pet <code>f1.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p>"},{"location":"homework/graphql/#feladat-2-modositasok-grapql-segitsegevel-2-pont","title":"Feladat 2: M\u00f3dos\u00edt\u00e1sok GrapQL seg\u00edts\u00e9g\u00e9vel  (2 pont)","text":"<p>Term\u00e9szetesen a GraphQL nem csak adatok lek\u00e9rdez\u00e9s\u00e9re, hanem m\u00f3dos\u00edt\u00e1sokra is haszn\u00e1lhat\u00f3. A k\u00f6vetkez\u0151 feladatokban a c\u00e9l, hogy adatmanipul\u00e1ci\u00f3kat gyakoroljunk. Az adatmanipul\u00e1ci\u00f3t \u00fagynevezett Mutation hajtja v\u00e9gre, ami egy olyan m\u0171velet, amely adatokat m\u00f3dos\u00edt, p\u00e9ld\u00e1ul rekordokat hoz l\u00e9tre, friss\u00edt, vagy t\u00f6r\u00f6l az adatb\u00e1zisban.</p>"},{"location":"homework/graphql/#termek-modositasa","title":"Term\u00e9k m\u00f3dos\u00edt\u00e1sa","text":"<p>Az els\u0151 m\u00f3dos\u00edt\u00e1s a megl\u00e9v\u0151 term\u00e9kek \u00e1r\u00e1t fogja m\u00f3dos\u00edtani. N\u00f6velj\u00fck meg amennyiben a param\u00e9terben kapott kateg\u00f3ri\u00e1ba tartoznak a term\u00e9kek.</p> <ol> <li> <p>Vegy\u00e9l fel egy Mutation oszt\u00e1lyt <code>ProductMutation</code> n\u00e9ven.</p> </li> <li> <p>Regisztr\u00e1ld be a szolg\u00e1ltat\u00e1st az els\u0151 feladatban tal\u00e1lhat\u00f3 <code>Query</code> regisztr\u00e1l\u00e1s\u00e1hoz hasonl\u00f3an az <code>.AddMutationType&lt;ProductMutation&gt;()</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s seg\u00edts\u00e9g\u00e9vel.</p> </li> <li> <p>A <code>ProductMutation</code> rendelkezzen egy <code>IncreaseProductPricesByCategory</code> f\u00fcggv\u00e9nnyel, ami elv\u00e9gzi a sz\u00fcks\u00e9ges m\u00f3dos\u00edt\u00e1sokat \u00e9s visszat\u00e9r egy <code>IQueryable&lt;Product&gt;</code> t\u00edpussal, amiben l\u00e1thatjuk az \u00faj \u00e1rakat. A f\u00fcggv\u00e9ny h\u00e1rom param\u00e9terrel rendelkezzen: 1) az <code>AdatvezDBContext</code>, 2) egy <code>categoryName</code> stringgel, \u00e9s 3) egy <code>priceIncrease</code> double \u00e9rt\u00e9kkel, ami megmondja, hogy h\u00e1nyszoros\u00e1ra dr\u00e1guljon a term\u00e9k. A visszat\u00e9r\u00e9si \u00e9rt\u00e9ke a m\u00f3dos\u00edtott term\u00e9kek kollekci\u00f3ja legyen. Figyelj r\u00e1, hogy a m\u00f3dos\u00edt\u00e1sokat az adatb\u00e1zisba is \u00e1tvezesd.</p> </li> <li> <p>Tesztelni az al\u00e1bbi p\u00e9lda paranccsal tudod (a param\u00e9ter neve meg kell egyezzen a lenti h\u00edv\u00e1sban megadott v\u00e1ltoz\u00f3n\u00e9vvel: categoryName/priceIncrease):</p> <pre><code>mutation {\n    increaseProductPricesByCategory(categoryName: \"LEGO\", priceIncrease: 1.1) {\n        name\n        price\n        category {\n                name\n            }\n        }\n}\n</code></pre> <p>A lek\u00e9rdez\u00e9s k\u00e9t r\u00e9szb\u0151l \u00e1ll. Az els\u0151 maga a mutation h\u00edv\u00e1sa lesz megfelel\u0151en param\u00e9terezve:</p> <pre><code>increaseProductPricesByCategory(categoryName: \"LEGO\", priceIncrease: 1.1)\n</code></pre> <p>A m\u00e1sodik r\u00e9sze pedig azt mondja meg, hogy a h\u00edv\u00e1s ut\u00e1ni adatot milyen form\u00e1ban szeretn\u00e9nk l\u00e1tni. Ez megegyezik a fenti lek\u00e9rdez\u00e9sekben l\u00e1tott szintaktik\u00e1val. Jelen esetben p\u00e9ld\u00e1ul a m\u00f3dos\u00edtott term\u00e9kek nev\u00e9t \u00e1r\u00e1t \u00e9s kateg\u00f3ri\u00e1j\u00e1t szeretn\u00e9nk ki\u00edrni:</p> <pre><code>{\n    name\n    price\n    category {\n        name\n    }\n}\n</code></pre> </li> </ol>"},{"location":"homework/graphql/#megrendeles-beszurasa","title":"Megrendel\u00e9s besz\u00far\u00e1sa","text":"<p>A k\u00f6vetkez\u0151 feladatban egy \u00faj megrendel\u00e9s besz\u00far\u00e1s\u00e1ra szeretn\u00e9nk lehet\u0151s\u00e9get biztos\u00edtani. A megrendel\u00e9s csak a term\u00e9kek neveit \u00e9s a k\u00edv\u00e1nt darabsz\u00e1mait fogja majd v\u00e1rni param\u00e9terben \u00e9s az alapj\u00e1n hozza l\u00e9tre a megrendel\u00e9st.</p> <ol> <li> <p>Vegy\u00e9l fel egy f\u00fcggv\u00e9nyt a <code>ProductMutation</code> oszt\u00e1lyba <code>CreateOrder</code> n\u00e9ven. A szok\u00e1sos <code>AdatvezDbContext</code>-en k\u00edv\u00fcl legyen k\u00e9t list\u00e1t v\u00e1r\u00f3 param\u00e9tere: az els\u0151 egy string list\u00e1t a term\u00e9knevekkel <code>productNames</code> n\u00e9vvel, a m\u00e1sodik pedig egy int list\u00e1t v\u00e1r a darabsz\u00e1mokkal <code>quantities</code> n\u00e9ven.</p> </li> <li> <p>A f\u00fcggv\u00e9nybe vegy\u00e9l fel egy \u00faj <code>Order</code> p\u00e9ld\u00e1nyt, amiben minden egyes param\u00e9terben kapott term\u00e9kn\u00e9vhez egy \u00faj <code>OrderItem</code> ker\u00fclj\u00f6n be. Az <code>OrderItem</code>-hez pedig keresd meg a n\u00e9v alapj\u00e1n \u00e9s \u00e1ll\u00edtsd be a megfelel\u0151 <code>Product</code>-ot \u00e9s darabsz\u00e1mot (a t\u00f6bbi \u00e9rt\u00e9ket figyelmen k\u00edv\u00fcl hagyhatod). A f\u00fcggv\u00e9ny visszat\u00e9r\u00e9si \u00e9rt\u00e9ke az \u00fajonnan elk\u00e9sz\u00edtett <code>Order</code> p\u00e9ld\u00e1ny legyen.</p> </li> <li> <p>A f\u00fcggv\u00e9ny dobjon hib\u00e1t amennyiben a kapott term\u00e9kek sz\u00e1ma nem egyezik meg a mennyis\u00e9gekkel, valamint ha b\u00e1rmelyik term\u00e9k neve nem tal\u00e1lhat\u00f3 meg az adatb\u00e1zisban.</p> </li> <li> <p>A k\u00f6vetkez\u0151 lek\u00e9rdez\u00e9ssel fogod tudni kipr\u00f3b\u00e1lni. A lek\u00e9rdez\u00e9s besz\u00farja a megrendel\u00e9st k\u00e9t term\u00e9kre, majd az ut\u00e1na megadott strukt\u00far\u00e1ban ki\u00edrja az elk\u00e9sz\u00edtett megrendel\u00e9st.</p> <pre><code>mutation {\n    createOrder(\n        productNames: [\"Lego City harbour\", \"Activity playgim\"],\n        quantities: [2, 4]\n    ) {\n        id\n        orderItems {\n        product {\n            name\n        }\n        amount\n        }\n    }\n}\n</code></pre> </li> </ol> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p> <p>Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet, amelyben a m\u00f3dos\u00edt\u00e1sokat futtattad a Banana Cake Pop fel\u00fclet\u00e9n. A k\u00e9pet <code>f2.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p> <p>M\u00c9G NEM V\u00c9GEZT\u00c9L</p> <p>Ha push-oltad a k\u00f3dodat, k\u00e9sz\u00edts egy PR-t, amihez rendeld hozz\u00e1 a gyakorlatvezet\u0151det! (r\u00e9szletek: a h\u00e1zi feladat lead\u00e1sa oldalon)</p>"},{"location":"homework/graphql/#feladat-3-halado-graphql-funkciok-3-imsc-pont","title":"Feladat 3: Halad\u00f3 GraphQL funkci\u00f3k (3 iMSc pont)","text":"<p>A pont megszerz\u00e9s\u00e9re az els\u0151 k\u00e9t feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g.</p> <p>A k\u00f6vetkez\u0151 feladatokban a Hot Chocolate \u00e1ltal biztos\u00edtott GraphQL szerver halad\u00f3bb funkci\u00f3it haszn\u00e1ljuk ki, \u00fagy mint a sz\u0171r\u00e9st, rendez\u00e9st, lapozhat\u00f3s\u00e1got. A Hot Chocolate be\u00e9p\u00edtett sz\u0171r\u00e9s lehet\u0151s\u00e9g\u00e9nek haszn\u00e1lat\u00e1hoz a <code>Service</code> regisztr\u00e1l\u00e1sakor az <code>AddFiltering()</code> h\u00edv\u00e1st kell elv\u00e9gezn\u00fcnk, majd a k\u00edv\u00e1nt v\u00e9gpontot kiszolg\u00e1l\u00f3 met\u00f3dust a <code>[UseFiltering]</code> attrib\u00fatummal kell ell\u00e1tni.</p> <p>A k\u00f6vetkez\u0151 feladatokban neked kell kital\u00e1lnod a lek\u00e9rdez\u00e9st is \u00e9s a funkci\u00f3hoz tartoz\u00f3 .NET implement\u00e1ci\u00f3t is. A lead\u00e1skor ezeket is mell\u00e9kelned kell.</p> <ol> <li> <p>Az els\u0151 feladatban tal\u00e1lhat\u00f3 <code>productsByCategory</code> h\u00edv\u00e1s kiv\u00e1lthat\u00f3, ha a <code>GetProducts</code> f\u00fcggv\u00e9ny\u00fcnkre enged\u00e9lyezz\u00fck a be\u00e9p\u00edtett sz\u0171r\u00e9st. Tedd meg, majd teszteld egy olyan lek\u00e9rdez\u00e9ssel, ami kateg\u00f3ri\u00e1k nev\u00e9re sz\u0171r. A lek\u00e9rdez\u00e9s elk\u00e9sz\u00edt\u00e9s\u00e9ben nagy seg\u00edts\u00e9gedre lesz a k\u00f3dkieg\u00e9sz\u00edt\u00e9s. A megold\u00e1s lead\u00e1sakor a lek\u00e9rdez\u00e9st is le kell adnod <code>q3_1.txt</code> f\u00e1jlban, ahol a <code>\"Building Items\"</code> kateg\u00f3ri\u00e1ra kell sz\u0171rn\u00f6d. A visszat\u00e9r\u00e9si adatok el\u0151\u00e1ll\u00edt\u00e1sakor az 1. Feladat 8-as pontja szerinti m\u00f3don kell el\u0151\u00e1ll\u00edtani a v\u00e1laszt.</p> <p>A sz\u0171r\u00e9snek egyedi szintaxisa van. A lek\u00e9rdez\u00e9sben a k\u00edv\u00e1nt elem ut\u00e1n egy where kifejez\u00e9sben adjuk meg, hogy milyen sz\u0171r\u0151felt\u00e9teleket szeretn\u00e9nk \u00e9rv\u00e9nyes\u00edteni. Itt a s\u00e9ma szerint kell megadni, hogy melyik \u00e9rt\u00e9kekre sz\u0171r\u00fcnk, szeretn\u00e9nk-e kombin\u00e1lt felt\u00e9telek ment\u00e9n sz\u0171rni, stb.</p> <p><pre><code>query {\n    products (where .. ) {\n        name\n        category {\n            name\n        }\n    }\n}\n</code></pre> Ennek nagyon nagy el\u0151nye, hogy nem kell implement\u00e1lni az \u00f6sszes fajta sz\u0171r\u00e9st, ami el\u0151j\u00f6het az API haszn\u00e1l\u00f3i k\u00f6zt. Ehelyett r\u00e1juk van b\u00edzva, hogy mi szerint szeretn\u00e9nek sz\u0171rni a GraphQL nyelv ezt t\u00e1mogatja, a Hot Chocolate pedig a kliens \u00e1ltal k\u00e9rt form\u00e1tum \u00e9s felt\u00e9telekkel sz\u0171rve fogja el\u0151\u00e1ll\u00edtani a v\u00e1laszt.</p> <p>Lehet\u0151s\u00e9g van tov\u00e1bb\u00e1 egyedi sz\u0171r\u0151felt\u00e9teleket is l\u00e9trehozni, melyekr\u0151l b\u0151vebben itt olvashatsz: https://chillicream.com/docs/hotchocolate/v14/fetching-data/filtering</p> </li> <li> <p>A m\u00e1sodik feladatod a rendez\u00e9s \u00e9s a lapozhat\u00f3s\u00e1g hozz\u00e1ad\u00e1sa a <code>GetOrders</code> f\u00fcggv\u00e9nyhez. A <code>GetOrders</code> f\u00fcggv\u00e9nyt annot\u00e1ld a megfelel\u0151 attrib\u00fatumokkal, majd a GraphQL regisztr\u00e1l\u00e1sakor \u00e1ll\u00edtsd be a sorbarendez\u00e9s \u00e9s rendez\u00e9s lehet\u0151s\u00e9geit. A kipr\u00f3b\u00e1l\u00e1shoz a lek\u00e9rdez\u00e9st m\u00f3dos\u00edtani kell, a lek\u00e9rdez\u00e9s \u00f6ssze\u00e1ll\u00edt\u00e1sa is a feladat r\u00e9sze. A megold\u00e1s lead\u00e1sakor a lek\u00e9rdez\u00e9st is le kell adnod <code>q3_2.txt</code> f\u00e1jlban, ahol a lek\u00e9rdez\u00e9s 2 darab <code>Order</code>-t tartalmaz (lapoz\u00e1s k\u00f6vetkezt\u00e9ben) \u00e9s <code>id</code> alapj\u00e1n cs\u00f6kken\u0151 sorrendben tenned \u0151ket. Figyelj r\u00e1, hogy a v\u00e1lasz a lentebb megadott form\u00e1tumban \u00e9rkezzen!</p> <p>A lapozhat\u00f3s\u00e1g rendk\u00edv\u00fcl fontos tulajdons\u00e1g lesz, amikor nagym\u00e9ret\u0171 adatb\u00e1zisokb\u00f3l k\u00e9r\u00fcnk le adatokat, hiszen teljes t\u00e1bl\u00e1k elk\u00fcld\u00e9se \u00e9s feldolgoz\u00e1sa sem szerencs\u00e9s. Ehelyett gyakori megold\u00e1s, hogy p\u00e9ld\u00e1ul 10-es\u00e9vel k\u00e9ri le a kliens az adatokat \u00e9s a k\u00f6vetkez\u0151 oldalra navig\u00e1lva k\u00e9ri csak le a k\u00f6vetkez\u0151 10-et.</p> <p>A lapozhat\u00f3 eredm\u00e9nyek viszont m\u00e1r nem az adott entit\u00e1sb\u00f3l \u00e1ll\u00f3 list\u00e1ik\u00e9nt j\u00f6nnek le, hanem \u00fagynevezett kollekci\u00f3kban. Ezekr\u0151l t\u00f6bbet itt olvashatsz: https://chillicream.com/docs/hotchocolate/v14/fetching-data/pagination</p> <p>A sorbarendez\u00e9s dokument\u00e1ci\u00f3j\u00e1t pedig ott tal\u00e1lod: https://chillicream.com/docs/hotchocolate/v14/fetching-data/sorting</p> <p>A v\u00e1lasz form\u00e1tuma az al\u00e1bbi legyen: </p> <pre><code>{\n    \"data\": {\n        \"orders\": {\n            \"edges\": [\n                {\n                    \"node\": {\n                        \"id\": 5,\n                        \"orderItems\": [\n                            {\n                                \"amount\": 2,\n                                \"product\": {\n                                \"name\": \"Lego City harbour\",\n                                \"price\": 172268.75,\n                                \"stock\": 12\n                                }\n                            },\n                            {\n                                \"amount\": 1,\n                                \"product\": {\n                                \"name\": \"Activity playgim\",\n                                \"price\": 7488,\n                                \"stock\": 21\n                                }\n                            }\n                        ]\n                    }\n                }\n            ]\n        }\n    }\n}\n</code></pre> </li> </ol> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel. Az 3. feladat els\u0151 \u00e9s m\u00e1sodik r\u00e9sz\u00e9ben tal\u00e1lhat\u00f3 lek\u00e9rdez\u00e9seket mentsd le a <code>q3_1.txt</code> \u00e9s <code>q3_2.txt</code> n\u00e9ven, tedd a k\u00e9pek mell\u00e9 a gy\u00f6k\u00e9r mapp\u00e1ba, \u00e9s add le.</p> <p>Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet, amelyben a vonatkoz\u00f3 lek\u00e9rdez\u00e9seket lefuttattad. A k\u00e9pet <code>f3.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p>"},{"location":"homework/mongodb/","title":"3. MongoDB","text":"<p>MongoDB h\u00e1zi feladat, a teljes\u00edt\u00e9ssel 4 pont \u00e9s 3 iMsc pont szerezhet\u0151.</p> <p>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod. Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. Hozz l\u00e9tre egy <code>megoldas</code> nev\u0171 branchet, \u00e9s arra dolgozz. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.</p> <p>A megold\u00e1shoz sz\u00fcks\u00e9ges szoftvereket \u00e9s eszk\u00f6z\u00f6ket l\u00e1sd itt.</p> <p>El\u0151k\u00e9sz\u00fcletk\u00e9nt hozz l\u00e9tre egy \u00faj adatb\u00e1zist, a gyakorlatanyagban le\u00edrt m\u00f3don.</p>"},{"location":"homework/mongodb/#feladat-0-neptun-kod","title":"Feladat 0: Neptun k\u00f3d","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 <code>neptun.txt</code> f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!</p>"},{"location":"homework/mongodb/#feladat-1-legnagyobb-osszerteku-termek-a-raktarban-2-pont","title":"Feladat 1: Legnagyobb \u00f6ssz\u00e9rt\u00e9k\u0171 term\u00e9k a rakt\u00e1rban (2 pont)","text":"<p>A feladat meghat\u00e1rozni, hogy a rakt\u00e1runkban egy adott kateg\u00f3ri\u00e1ba tartoz\u00f3 term\u00e9kek k\u00f6z\u00fcl melyik k\u00e9pviseli a legnagyobb \u00f6ssz\u00e9rt\u00e9ket \u2014 teh\u00e1t melyik term\u00e9k az, amelyiknek az \u00e1ra szorozva a rakt\u00e1rban l\u00e9v\u0151 mennyis\u00e9g\u00e9vel a legnagyobb. Ehhez a <code>ProductRepository</code> oszt\u00e1lyban a k\u00f6vetkez\u0151 met\u00f3dust kell implement\u00e1lnunk.</p> <pre><code>(string, double?) ProductWithLargestTotalValue(ObjectId categoryId)\n</code></pre> <ol> <li> <p>A pontos specifik\u00e1ci\u00f3 meg\u00e9rt\u00e9s\u00e9hez vizsg\u00e1ljuk meg el\u0151sz\u00f6r a feladathoz tartoz\u00f3 teszteket a <code>TestExercise1.cs</code> f\u00e1jlban.</p> <ul> <li>A f\u00fcggv\u00e9ny bemeneti param\u00e9tere a kateg\u00f3ria ID-ja, amelyhez tartoz\u00f3 term\u00e9kekre \u00e9ppen k\u00edv\u00e1ncsiak vagyunk.</li> <li>Amennyiben tartozik term\u00e9k a megadott kateg\u00f3ri\u00e1hoz, akkor a legnagyobb \u00f6ssz\u00e9rt\u00e9k\u0171 term\u00e9k nev\u00e9t \u00e9s az \u00f6ssz\u00e9rt\u00e9ket kell visszaadnunk.</li> <li>Amennyiben nem tartozik term\u00e9k a kateg\u00f3ri\u00e1hoz, mind a k\u00e9t \u00e9rt\u00e9kre <code>null</code>-t kell visszaadnunk.</li> </ul> </li> <li> <p>A lek\u00e9rdez\u00e9s elv\u00e9gz\u00e9s\u00e9hez a MongoDB aggreg\u00e1ci\u00f3s pipeline-j\u00e1t \u00e9rdemes haszn\u00e1lni. Ennek m\u0171k\u00f6d\u00e9s\u00e9nek feleleven\u00edt\u00e9s\u00e9hez n\u00e9zd meg a gyakorlatfeladatok megold\u00e1s\u00e1t.</p> <p>A lek\u00e9rdez\u00e9shez a k\u00f6vetkez\u0151 pipeline l\u00e9p\u00e9sek sz\u00fcks\u00e9gesek:</p> <ul> <li> <p>Sz\u0171rj\u00fck le a term\u00e9keket a megadott kateg\u00f3ri\u00e1hoz tartoz\u00f3kra. Ehhez egy $match (<code>Match</code>) l\u00e9p\u00e9sre lesz sz\u00fcks\u00e9g\u00fcnk, ahol megadhatjuk a megfelel\u0151 filter kifejez\u00e9st.</p> </li> <li> <p>Sz\u00e1moljuk ki minden megmaradt term\u00e9k eset\u00e9n az \u00f6ssz\u00e9rt\u00e9ket egy $project (<code>Project</code>) l\u00e9p\u00e9s seg\u00edts\u00e9g\u00e9vel. Ne felejtsd el, hogy az \u00f6ssz\u00e9rt\u00e9k mellett a term\u00e9k nev\u00e9re is sz\u00fcks\u00e9g\u00fcnk lesz!</p> </li> <li> <p>Rendezz\u00fck az \u00edgy kapott dokumentumokat cs\u00f6kken\u0151 sorrendbe az \u00f6ssz\u00e9rt\u00e9k alapj\u00e1n. Ehhez a $sort (<code>SortByDescending</code>) l\u00e9p\u00e9st tudjuk alkalmazni.</p> </li> <li> <p>A legnagyobb \u00e9rt\u00e9kre vagyunk k\u00edv\u00e1ncsiak, azaz az eredm\u00e9nyek k\u00f6z\u00fcl csup\u00e1n az els\u0151 \u00e9rdekel minket. Azonban akkor sem szeretn\u00e9nk hib\u00e1t kapni, ha egy\u00e1ltal\u00e1n nem tartozott term\u00e9k ehhez a kateg\u00f3ri\u00e1hoz. Ez\u00e9rt a <code>FirstOrDefault</code> ki\u00e9rt\u00e9kel\u0151 utas\u00edt\u00e1st \u00e9rdemes haszn\u00e1lni.</p> </li> </ul> <p>Ha esetleg ismeretlen lenne a <code>(string, double?)</code> szintaktika:</p> <pre><code>return (\"test\", 0.0);\n</code></pre> <p>utas\u00edt\u00e1s seg\u00edts\u00e9g\u00e9vel egyszerre k\u00e9t visszat\u00e9r\u00e9si \u00e9rt\u00e9ket tudunk adni a f\u00fcggv\u00e9nynek.</p> </li> <li> <p>K\u00e9sz\u00edtsd el a f\u00fcggv\u00e9ny implement\u00e1ci\u00f3j\u00e1t. A repository oszt\u00e1ly konstruktorban megkapja az adatb\u00e1zist \u00e9s elmenti mag\u00e1nak a haszn\u00e1land\u00f3 gy\u0171jtem\u00e9nyt, ezen kereszt\u00fcl \u00e9rheted el az adatb\u00e1zist.</p> </li> </ol> <p>A tesztel\u00e9shez tal\u00e1lsz unit teszteket a solution-ben. A teszteket Visual Studio-ban egyszer\u0171en tudod futtatni, de ha m\u00e1st haszn\u00e1lsz fejleszt\u00e9shez (pl. VS Code \u00e9s/vagy <code>dotnet cli</code>), akkor is tudsz teszteket futtatni. Az adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez a <code>TestDbFactory</code> oszt\u00e1lyban m\u00f3dos\u00edthatod a connection stringet.</p> <p>Tesztek</p> <p>A tesztek az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezik. Futtasd le az adatb\u00e1zis scriptet a kiindul\u00f3 \u00e1llapot vissza\u00e1ll\u00edt\u00e1s\u00e1hoz.</p> <p>A tesztek k\u00f3dj\u00e1t NE m\u00f3dos\u00edtsd. Ha a tesztel\u00e9shez sz\u00fcks\u00e9ges, ideiglenesen beleszerkeszthetsz, de \u00fcgyelj r\u00e1, hogy az eredeti \u00e1llapottal kommitold a megold\u00e1sod.</p> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p> <p>Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Visual Studio-b\u00f3l (vagy a fejleszt\u00e9shez haszn\u00e1lt eszk\u00f6zb\u0151l, ak\u00e1r <code>dotnet cli</code> is lehet), amelyben a vonatkoz\u00f3 teszteket lefuttattad. L\u00e1tsz\u00f3djon a repository oszt\u00e1ly k\u00f3dja \u00e9s a tesztek fut\u00e1s\u00e1nak eredm\u00e9nye! A k\u00e9pet <code>f1.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p> <p>Ha <code>dotnet test</code>-et haszn\u00e1lsz a teszt futtat\u00e1s\u00e1hoz, a k\u00e9perny\u0151k\u00e9pen l\u00e1tsz\u00f3djon az \u00f6sszes teszt neve. Ehhez haszn\u00e1ld a <code>-v n</code> kapcsol\u00f3t a r\u00e9szletesebb napl\u00f3z\u00e1shoz.</p> <p>A k\u00e9perny\u0151k\u00e9pen lev\u0151 forr\u00e1sk\u00f3d tekintet\u00e9ben nem sz\u00fcks\u00e9ges, hogy a v\u00e9gs\u0151 megold\u00e1sban szerepl\u0151 k\u00f3d bet\u0171r\u0151l bet\u0171re megegyezzen a k\u00e9pen \u00e9s a felt\u00f6lt\u00f6tt v\u00e1ltozatban. Teh\u00e1t a tesztek sikeres lefut\u00e1sa ut\u00e1n elk\u00e9sz\u00edtett k\u00e9perny\u0151k\u00e9pet nem sz\u00fcks\u00e9ges friss\u00edteni, ha a forr\u00e1sk\u00f3dban kisebb v\u00e1ltoztat\u00e1st eszk\u00f6z\u00f6lsz.</p>"},{"location":"homework/mongodb/#feladat-2-uj-termek-beszurasa-2-pont","title":"Feladat 2: \u00daj term\u00e9k besz\u00far\u00e1sa (2 pont)","text":"<p>A feladat egy \u00faj term\u00e9k besz\u00far\u00e1s\u00e1hoz egy f\u00fcggv\u00e9ny k\u00e9sz\u00edt\u00e9se. A besz\u00far\u00e1skor t\u00f6bb felt\u00e9telnek is meg kell felelni, amiket ellen\u0151rizni kell a besz\u00far\u00e1s el\u0151tt. Ehhez implement\u00e1ld az <code>InsertProduct(string name, string category, int vat)</code> f\u00fcggv\u00e9nyt</p> <p>A k\u00f6vetkez\u0151kre kell figyelni a besz\u00far\u00e1skor: - Amennyiben adott n\u00e9vvel m\u00e1r van term\u00e9k, dobj kiv\u00e9telt (<code>ArgumentException</code>) - Amennyiben a megadott <code>category</code> nev\u0171 kateg\u00f3ria m\u00e9g nincsen, dobj kiv\u00e9telt (<code>ArgumentException</code>) - Amennyiben a megadott <code>vat</code> \u00e9rt\u00e9khez tartozik m\u00e1r n\u00e9v egy m\u00e1sik <code>Product</code> p\u00e9ld\u00e1ny eset\u00e9n, akkor haszn\u00e1ld annak a nev\u00e9t, egy\u00e9bk\u00e9nt vedd fel <code>\"VAT\"</code> n\u00e9vvel a besz\u00farand\u00f3 term\u00e9khez.</p> <ol> <li> <p>A repository oszt\u00e1ly konstruktor\u00e1t eg\u00e9sz\u00edtsd ki, hogy legyenek kateg\u00f3ri\u00e1k is el\u00e9rhet\u0151ek. Ehhez vedd fel a kateg\u00f3ri\u00e1hoz tartoz\u00f3 oszt\u00e1lyt!</p> </li> <li> <p>K\u00e9sz\u00edtsd el a f\u00fcggv\u00e9ny implement\u00e1ci\u00f3j\u00e1t, a param\u00e9terekkel kapcsolatos kik\u00f6t\u00e9seket ellen\u0151rizd miel\u0151tt a besz\u00far\u00e1st v\u00e9grehajtod! Seg\u00edts\u00e9gedre vannak a <code>TestExercise2.cs</code> f\u00e1jlban tal\u00e1lhat\u00f3 tesztek.</p> </li> </ol> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel! Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet az els\u0151 feladathoz hasonl\u00f3an, amelyben a vonatkoz\u00f3 teszteket lefuttattad! A k\u00e9pet <code>f2.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p> <p>M\u00c9G NEM V\u00c9GEZT\u00c9L</p> <p>Ha push-oltad a k\u00f3dodat, k\u00e9sz\u00edts egy PR-t, amihez rendeld hozz\u00e1 a gyakorlatvezet\u0151det! (r\u00e9szletek: a h\u00e1zi feladat lead\u00e1sa oldalon)</p>"},{"location":"homework/mongodb/#feladat-3-raktar-meret-becsles-3-imsc-pont","title":"Feladat 3: Rakt\u00e1r m\u00e9ret becsl\u00e9s (3 iMsc pont)","text":"<p>Egy c\u00e9g \u00faj telephelyre k\u00f6lt\u00f6zik. A vezet\u00e9snek sz\u00fcks\u00e9ge van arra az inform\u00e1ci\u00f3ra, hogy \u00e1t tudj\u00e1k-e k\u00f6lt\u00f6ztetni a m\u00e1r megl\u00e9v\u0151 rakt\u00e1rk\u00e9szletet az \u00faj rakt\u00e1rba. Implement\u00e1ld a f\u00fcggv\u00e9nyt, amely kisz\u00e1molja a teljes rakt\u00e1rk\u00e9szletre a csomagok t\u00e9rfogat\u00e1t!</p> <p>A term\u00e9keink egy r\u00e9sz\u00e9n\u00e9l van m\u00e9ret inform\u00e1ci\u00f3 a <code>description.product.package_parameters</code> alatt:</p> <p></p> <p>Ebb\u0151l kell kisz\u00e1molni a teljes rakt\u00e1rk\u00e9szlet t\u00e9rfogat\u00e1t:</p> <ul> <li>Az adatot a <code>package_parameters</code>-b\u0151l vedd (\u00e9s ne a <code>product_size</code>-b\u00f3l).</li> <li>Egy term\u00e9k lehet, hogy t\u00f6bb csomagb\u00f3l \u00e1ll, ezt a <code>package_parameters.number_of_packages</code>-ben tal\u00e1lod. Ez csak egy szorz\u00f3, teh\u00e1t egyetlen m\u00e9rete van minden term\u00e9knek, legfeljebb t\u00f6bb, ugyanakkora csomagb\u00f3l \u00e1ll.</li> <li>A v\u00e9geredm\u00e9ny: minden term\u00e9kre \u03a3 (term\u00e9k rakt\u00e1rk\u00e9szlet * csomag darabsz\u00e1m * sz\u00e9less\u00e9g * hossz\u00fass\u00e1g * m\u00e9lys\u00e9g).</li> <li>Amely term\u00e9kn\u00e9l nincs meg ez az inform\u00e1ci\u00f3, ott 0 t\u00e9rfogattal sz\u00e1molj.</li> <li>\u00dcgyelj r\u00e1, hogy a t\u00e9rfogat sz\u00e1m\u00edt\u00e1s m\u00e9rt\u00e9kegys\u00e9g helyes legyen: a term\u00e9kek m\u00e9rete vagy cm vagy m m\u00e9rt\u00e9kegys\u00e9gben lehet megadva, de a v\u00e9geredm\u00e9nyben a t\u00e9rfogat k\u00f6bm\u00e9terben kell!</li> </ul> <p>K\u00e9sz\u00edtsd el a <code>double GetAllProductsCumulativeVolume()</code> f\u00fcggv\u00e9ny implement\u00e1ci\u00f3j\u00e1t, amely a teljes t\u00e9rfogatot visszaadja m^3-ben. A sz\u00e1m\u00edt\u00e1st adatb\u00e1zisban v\u00e9gezd (\u00e9s ne C#-ban), ehhez haszn\u00e1ld az aggreg\u00e1ci\u00f3s pipeline-t.</p> <p>Sum aggreg\u00e1ci\u00f3</p> <p>Az aggreg\u00e1l\u00e1shoz a <code>$group</code> pipeline stage-re lesz sz\u00fcks\u00e9ged. B\u00e1r nem akarunk csoportos\u00edtani, m\u00e9gis, \u00edgy van lehet\u0151s\u00e9g a teljes gy\u0171jtem\u00e9nyen aggreg\u00e1l\u00e1sra. Minden term\u00e9k elemet ugyanabba a csoportba k\u00e9pezz le (teh\u00e1t, a <code>$group</code>-ban az <code>id</code>-hoz egy konstanst rendelj), majd a projekci\u00f3 r\u00e9szben v\u00e9gezheted el a <code>$sum</code> t\u00edpus\u00fa aggreg\u00e1l\u00e1st a fenti k\u00e9pletnek megfelel\u0151en.</p> <p>A cm \u00e9s m m\u00e9rt\u00e9kegys\u00e9g kezel\u00e9s csak egy szorz\u00f3t jelent, a <code>sum</code> \u00f6sszegz\u00e9sben meg tudod oldani egy felt\u00e9teles szorz\u00e1ssal. Ha ez nem siker\u00fcl, megoldhatod k\u00e9t k\u00fcl\u00f6n aggreg\u00e1ci\u00f3val is, amelyekben sz\u0171rsz a m\u00e9rt\u00e9kegys\u00e9gre majd ut\u00e1na j\u00f6n az aggreg\u00e1ci\u00f3.</p> <p>A sz\u00fcks\u00e9ges adatok nincsenek lek\u00e9pezve C# entit\u00e1sra, ezeket neked kell elk\u00e9sz\u00edtened. \u00dcgyelj r\u00e1, hogy a BSON dokumentumban az elemek neve elt\u00e9r a szok\u00e1sost\u00f3l, \u00edgy amikor C# property-re k\u00e9pezed le, vagy ennek megfelel\u0151en kell elnevezni a property-ket, vagy haszn\u00e1lhatod a <code>[BsonElement(elementName: \"...\")]</code> attrib\u00fatumot.</p> <p>Figyelj oda, hogy a m\u00f3dos\u00edt\u00e1said ne ronts\u00e1k el a 2. feladat megold\u00e1s\u00e1t, \u00edgy ha kell a besz\u00far\u00e1st m\u00f3dos\u00edtsd \u00fagy, hogy a term\u00e9k m\u00e9retei 1x1x1 cm-esek legyenek, a t\u00f6bbi nem megadott v\u00e1ltoz\u00f3t vedd fel \u00e1ltalad v\u00e1lasztott \u00e9rt\u00e9kekkel!</p> <p>Fluent Api-t haszn\u00e1lj</p> <p>Mindenk\u00e9ppen C#-os Fluent Api-t haszn\u00e1lj! Ne <code>BsonDocument</code>-ben \u00edrd meg a lek\u00e9rdez\u00e9st!</p> <p>Ha siker\u00fclt implement\u00e1lni a met\u00f3dust, akkor a kor\u00e1bban m\u00e1r l\u00e1tott m\u00f3don a <code>TestExercise3</code> oszt\u00e1lyban tal\u00e1lhat\u00f3 teszt met\u00f3dussal ellen\u0151rizni tudod a m\u0171k\u00f6d\u00e9st. A teszt az adatb\u00e1zis kiindul\u00f3 \u00e1llapot\u00e1t felt\u00e9telezi.</p> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott C# forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p>"},{"location":"homework/mssql/","title":"1. MSSQL szerveroldali programoz\u00e1s","text":"<p>MSSQL h\u00e1zi feladat, a teljes\u00edt\u00e9ssel 4 pont \u00e9s 3 iMsc pont szerezhet\u0151.</p> <p>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod. Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. Hozz l\u00e9tre egy <code>megoldas</code> nev\u0171 branchet, \u00e9s arra dolgozz. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.</p> <p>A megold\u00e1shoz sz\u00fcks\u00e9ges szoftvereket \u00e9s eszk\u00f6z\u00f6ket l\u00e1sd itt.</p>"},{"location":"homework/mssql/#adatbazis-elokeszitese","title":"Adatb\u00e1zis el\u0151k\u00e9sz\u00edt\u00e9se","text":"<p>Hozz l\u00e9tre egy \u00faj adatb\u00e1zist, amelynek neve megegyezik a Neptun k\u00f3doddal. Ebben az adatb\u00e1zisban futtasd le a t\u00e1bl\u00e1kat l\u00e9trehoz\u00f3 szkriptet.</p> <p>Neptun k\u00f3d fontos</p> <p>A feladatok al\u00e1bb k\u00e9rnek k\u00e9perny\u0151k\u00e9pet, amelyen szerepelnie kell az adatb\u00e1zis nev\u00e9nek, amely megegyezik a Neptun k\u00f3doddal!</p>"},{"location":"homework/mssql/#feladat-0-neptun-kod","title":"Feladat 0: Neptun k\u00f3d","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 <code>neptun.txt</code> f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!</p>"},{"location":"homework/mssql/#feladat-1-jelszo-lejarat-es-karbantartasa-2-pont","title":"Feladat 1: Jelsz\u00f3 lej\u00e1rat \u00e9s karbantart\u00e1sa (2 pont)","text":"<p>Biztons\u00e1gi megfontol\u00e1sb\u00f3l szeretn\u00e9nk k\u00f6telez\u0151v\u00e9 tenni a jelsz\u00f3 id\u0151nk\u00e9nti meg\u00faj\u00edt\u00e1s\u00e1t. Ehhez r\u00f6gz\u00edteni fogjuk, \u00e9s karbantartjuk a jelsz\u00f3 utols\u00f3 m\u00f3dos\u00edt\u00e1s\u00e1nak idej\u00e9t.</p> <ol> <li> <p>Adj hozz\u00e1 egy \u00faj oszlopot a <code>Customer</code> t\u00e1bl\u00e1hoz <code>PasswordExpiry</code> n\u00e9ven, ami egy d\u00e1tumot tartalmaz: <code>alter table [Customer] add [PasswordExpiry] datetime</code>.</p> </li> <li> <p>K\u00e9sz\u00edts egy triggert, amellyel jelsz\u00f3 v\u00e1ltoztat\u00e1s eset\u00e9n automatikusan kit\u00f6lt\u00e9sre ker\u00fcl a <code>PasswordExpiry</code> mez\u0151 \u00e9rt\u00e9ke. Az \u00faj \u00e9rt\u00e9ke a mai d\u00e1tum plusz egy \u00e9v legyen. Az \u00e9rt\u00e9ket a szerver sz\u00e1m\u00edtsa ki. \u00dcgyelj arra, hogy \u00faj vev\u0151 regisztr\u00e1l\u00e1sakor (insert) mindig kit\u00f6lt\u00e9sre ker\u00fclj\u00f6n a mez\u0151, viszont a vev\u0151 adatainak szerkeszt\u00e9sekor (update) csak akkor v\u00e1ltozzon a lej\u00e1rat d\u00e1tuma, ha v\u00e1ltozott a jelsz\u00f3. (Teh\u00e1t pl. ha az email c\u00edmet v\u00e1ltoztatt\u00e1k csak, akkor a lej\u00e1rat ne v\u00e1ltozzon.) A trigger csak a besz\u00fart/friss\u00edtett rekorddal t\u00f6r\u0151dj\u00f6n (teh\u00e1t nem a t\u00e1bla teljes tartalm\u00e1ra kell friss\u00edteni a d\u00e1tum oszlopot)! A feladatban k\u00e9sz\u00fcln\u00f6d kell arra is, hogy egyszerre t\u00f6bb rekord m\u00f3dosul.</p> </li> </ol> <p>Ellen\u0151rizd a trigger viselked\u00e9s\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 esetekre is!</p> <p>BEADAND\u00d3</p> <p>A trigger k\u00f3dj\u00e1t az <code>f1.sql</code> f\u00e1jlban add be. Az sql f\u00e1jl egyetlen utas\u00edt\u00e1st tartalmazzon csak (egyetlen <code>create trigger</code>), ne legyen benne se <code>use</code> se <code>go</code> parancs!</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a <code>Customer</code> t\u00e1bla tartalm\u00e1r\u00f3l, amiben l\u00e1that\u00f3 az \u00faj oszlop \u00e9s annak kit\u00f6lt\u00f6tt \u00e9rt\u00e9kei (a tesztel\u00e9s ut\u00e1ni \u00e1llapottal). A k\u00e9pen legyen l\u00e1that\u00f3 az adatb\u00e1zisod neve (a Neptun k\u00f3dod). A k\u00e9pet <code>f1.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p>"},{"location":"homework/mssql/#feladat-2-szamla-ervenytelenitese-2-pont","title":"Feladat 2: Sz\u00e1mla \u00e9rv\u00e9nytelen\u00edt\u00e9se (2 pont)","text":"<p>Szeretn\u00e9nk lehet\u0151s\u00e9get biztos\u00edtani rendel\u00e9sek lemond\u00e1s\u00e1ra is egy t\u00e1rolt elj\u00e1r\u00e1s seg\u00edts\u00e9g\u00e9vel. Az elj\u00e1r\u00e1s a vev\u0151 nev\u00e9vel \u00e9s a rendel\u00e9s azonos\u00edt\u00f3j\u00e1val rendelkez\u0151 sz\u00e1ml\u00e1t fogja \u00e9rv\u00e9nytelen\u00edteni, majd a hozz\u00e1 tartoz\u00f3 rendel\u00e9s t\u00e9telein v\u00e9gigmenve vissza\u00e1ll\u00edtja a rakt\u00e1rk\u00e9szletet.</p> <ol> <li> <p>Hozz l\u00e9tre egy t\u00e1rolt elj\u00e1r\u00e1st <code>cancel_invoice</code> mely k\u00e9t param\u00e9tert fogad: a vev\u0151 nev\u00e9t <code>name</code> n\u00e9ven, \u00e9s a megrendel\u00e9s azonos\u00edt\u00f3j\u00e1t <code>orderId</code> n\u00e9ven.</p> </li> <li> <p>A t\u00e1rolt elj\u00e1r\u00e1s ellen\u0151rizze le, hogy van-e a megadott adatokkal sz\u00e1mla, ha nincs, dobjon kiv\u00e9telt. A kiv\u00e9tel <code>error_number</code> \u00e9rt\u00e9ke legyen 51000.</p> </li> <li> <p>Ha az adatok j\u00f3k, akkor a t\u00e1rolt elj\u00e1r\u00e1s vegye az \u00f6sszes sz\u00e1ml\u00e1n szerepl\u0151 term\u00e9ket, n\u00e9zze meg, hogy mennyit vettek bel\u0151l\u00fck, \u00e9s a megrendelt mennyis\u00e9get adja hozz\u00e1 a rakt\u00e1rk\u00e9szlethez. (TIPP: az adatok \u00f6sszeszed\u00e9s\u00e9hez t\u00f6bb t\u00e1bla, esetleg kurzor is kellhet).</p> </li> </ol> <p>Ellen\u0151rizd az elj\u00e1r\u00e1s m\u0171k\u00f6d\u00e9s\u00e9t!</p> <p>BEADAND\u00d3</p> <p>A t\u00e1rolt elj\u00e1r\u00e1s k\u00f3dj\u00e1t az <code>f2.sql</code> f\u00e1jlban add be. Az sql f\u00e1jl egyetlen utas\u00edt\u00e1st tartalmazzon csak (egyetlen <code>create procedure cancel_invoice</code>), ne legyen benne se <code>use</code> se <code>go</code> parancs!</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet amin l\u00e1that\u00f3 a t\u00e1rolt elj\u00e1r\u00e1s lefut\u00e1sa \u00e9s annak hat\u00e1sa, illetve mi t\u00f6rt\u00e9nik, ha hib\u00e1s adatokat adunk meg (lehet egy ablakban k\u00e9t tabbal p\u00e9ld\u00e1ul). A k\u00e9pen legyen l\u00e1that\u00f3 az adatb\u00e1zisod neve (a Neptun k\u00f3dod). A k\u00e9pet <code>f2.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p> <p>M\u00c9G NEM V\u00c9GEZT\u00c9L</p> <p>Ha push-oltad a k\u00f3dodat, k\u00e9sz\u00edts egy PR-t, amihez rendeld hozz\u00e1 a gyakorlatvezet\u0151det! (r\u00e9szletek: a h\u00e1zi feladat lead\u00e1sa oldalon)</p>"},{"location":"homework/mssql/#feladat-3-termek-ajanlott-korhatara-3-imsc-pont","title":"Feladat 3: Term\u00e9k aj\u00e1nlott korhat\u00e1ra (3 iMsc pont)","text":"<p>Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 k\u00e9t feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g.</p> <p>A minta adatb\u00e1zisban a term\u00e9kek (<code>Product</code>) rekordjaiban van egy xml t\u00edpus\u00fa <code>Description</code> nev\u0171 oszlop. Ez n\u00e9h\u00e1ny term\u00e9kn\u00e9l van csak kit\u00f6ltve.</p> <p>Egy p\u00e9lda a tartalm\u00e1ra:</p> <pre><code>&lt;product&gt;\n  &lt;product_size&gt;\n    &lt;unit&gt;cm&lt;/unit&gt;\n    &lt;width&gt;150&lt;/width&gt;\n    &lt;height&gt;50&lt;/height&gt;\n    &lt;depth&gt;150&lt;/depth&gt;\n  &lt;/product_size&gt;\n  &lt;description&gt;Requires battery (not part of the package).&lt;/description&gt;\n  &lt;recommended_age&gt;0-18 m&lt;/recommended_age&gt;\n&lt;/product&gt;\n</code></pre> <p>Szeretn\u00e9nk a <code>recommended_age</code> tag tartalm\u00e1t k\u00f6nnyebb el\u00e9rhet\u0151s\u00e9g v\u00e9gett egy saj\u00e1t oszlopba helyezni.</p> <ol> <li> <p>Adj hozz\u00e1 egy \u00faj oszlopot a <code>Product</code> t\u00e1bl\u00e1hoz <code>RecommendedAge</code> n\u00e9ven, ami egy sz\u00f6veget tartalmaz: <code>alter table [Product] add [RecommendedAge] nvarchar(200)</code>. (Ezt a k\u00f3dot nem kell beadni a megold\u00e1sban.)</p> </li> <li> <p>\u00cdrj T-SQL szkriptet, amely minden term\u00e9k eset\u00e9n az xml le\u00edr\u00e1sb\u00f3l az <code>&lt;recommended_age&gt;</code> elemet kiemelve felt\u00f6lti az el\u0151bb l\u00e9trehozott <code>RecommendedAge</code> oszlopot. Ha az xml le\u00edr\u00e1s \u00fcres, vagy nincs benne a keresett elem, akkor maradjon <code>NULL</code> az \u00faj oszlop tartalma. Ellenkez\u0151 esetben az xml tag sz\u00f6veges tartalma ker\u00fclj\u00f6n \u00e1tm\u00e1sol\u00e1sra, \u00e9s az xml dokumentumb\u00f3l t\u00f6r\u00f6ld ezt az elemet. Felt\u00e9telezheted, hogy csak egyetlen <code>&lt;recommended_age&gt;</code> elem van az xml-ben.</p> </li> </ol> <p>BEADAND\u00d3</p> <p>A scriptet az <code>f3.sql</code> f\u00e1jlban add be. Ne haszn\u00e1lj se t\u00e1rolt elj\u00e1r\u00e1st, se triggert, csak egy T-SQL k\u00f3d blokkot k\u00e9sz\u00edts. Az sql f\u00e1jl \u00f6nmag\u00e1ban futtathat\u00f3 legyen, ne legyen benne se <code>use</code> se <code>go</code> parancs!</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a <code>Product</code> t\u00e1bla tartalm\u00e1r\u00f3l a kit\u00f6lt\u00e9s ut\u00e1n. Legyen l\u00e1that\u00f3 az \u00faj oszlop \u00e9s annak tartalma. A k\u00e9pen legyen l\u00e1that\u00f3 az adatb\u00e1zisod neve (a Neptun k\u00f3dod). A k\u00e9pet <code>f3.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p>"},{"location":"homework/rest/","title":"4. REST API Web API technol\u00f3gi\u00e1val","text":"<p>A h\u00e1zi feladat teljes\u00edt\u00e9s\u00e9vel 4 pont \u00e9s 3 iMsc pont szerezhet\u0151.</p> <p>GitHub Classroom seg\u00edts\u00e9g\u00e9vel hozz l\u00e9tre magadnak egy repository-t. A megh\u00edv\u00f3 URL-t Moodle-ben tal\u00e1lod. Kl\u00f3nozd le az \u00edgy elk\u00e9sz\u00fclt repository-t. Ez tartalmazni fogja a megold\u00e1s elv\u00e1rt szerkezet\u00e9t. Hozz l\u00e9tre egy <code>megoldas</code> nev\u0171 branchet, \u00e9s arra dolgozz. A feladatok elk\u00e9sz\u00edt\u00e9se ut\u00e1n kommitold \u00e9s pushold a megold\u00e1sod.</p> <p>A megold\u00e1shoz sz\u00fcks\u00e9ges szoftvereket \u00e9s eszk\u00f6z\u00f6ket l\u00e1sd itt.</p>"},{"location":"homework/rest/#feladat-0-neptun-kod","title":"Feladat 0: Neptun k\u00f3d","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt a gy\u00f6k\u00e9rben tal\u00e1lhat\u00f3 <code>neptun.txt</code> f\u00e1jlba \u00edrd bele a Neptun k\u00f3dodat!</p>"},{"location":"homework/rest/#feladat-1-egyszeru-lekerdezes-es-openapi-dokumentacio-2-pont","title":"Feladat 1: Egyszer\u0171 lek\u00e9rdez\u00e9s \u00e9s OpenAPI dokument\u00e1ci\u00f3 (2 pont)","text":"<p>A l\u00e9trehozott \u00e9s kl\u00f3nozott repository-ban megtal\u00e1lhat\u00f3 a kiindul\u00f3 k\u00f3d v\u00e1z. Nyisd meg Visual Studio-val \u00e9s ind\u00edtsd el. Egy konzol alkalmaz\u00e1snak kell elindulnia, amely hosztolja a web alkalmaz\u00e1st. Pr\u00f3b\u00e1ld ki (mik\u00f6zben fut a program): b\u00f6ng\u00e9sz\u0151ben nyisd meg a http://localhost:5000/api/product oldalt, ahol a term\u00e9kek list\u00e1j\u00e1t kell l\u00e1sd JSON form\u00e1ban.</p> <p>N\u00e9zd meg a rendelkez\u00e9sre \u00e1ll\u00f3 k\u00f3dot.</p> <ul> <li>A <code>Program.cs</code> inicializ\u00e1lja az alkalmaz\u00e1st. Ez egy ASP.NET Core webalkalmaz\u00e1s.</li> <li>Az alkalmaz\u00e1sban nincs adatb\u00e1zis el\u00e9r\u00e9s az egyszer\u0171s\u00e9g v\u00e9gett. A <code>ProductRepository</code> oszt\u00e1ly tesztel\u00e9shez haszn\u00e1land\u00f3 adatokat ad.</li> <li>A <code>ProductsController</code> dependency injection seg\u00edts\u00e9g\u00e9vel p\u00e9ld\u00e1nyos\u00edtja az <code>IProductRepository</code>-t.</li> </ul> <p>Feladatok:</p>"},{"location":"homework/rest/#egyszeru-lekerdezes","title":"Egyszer\u0171 lek\u00e9rdez\u00e9s","text":"<ol> <li> <p>A <code>DAL.ProductRepository</code> oszt\u00e1lyban a <code>Neptun</code> nev\u0171 mez\u0151 \u00e9rt\u00e9k\u00e9ben cser\u00e9ld le a Neptun k\u00f3dod. A string \u00e9rt\u00e9ke a Neptun k\u00f3dod 6 karaktere legyen.</p> <p>FONTOS</p> <p>Az \u00edgy m\u00f3dos\u00edtott adatokr\u00f3l kell k\u00e9perny\u0151k\u00e9pet k\u00e9sz\u00edteni, \u00edgy ez a l\u00e9p\u00e9s fontos.</p> </li> <li> <p>K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, amivel ellen\u0151rizhet\u0151, hogy l\u00e9tezik-e egy adott id-j\u00fa term\u00e9k. A lek\u00e9rdez\u00e9shez egy <code>HEAD</code> t\u00edpus\u00fa HTTP k\u00e9r\u00e9st fogunk k\u00fcldeni a <code>/api/product/{id}</code> URL-re. A v\u00e1lasz HTTP 200 vagy 404 legyen (extra tartalom/body n\u00e9lk\u00fcl, csak a v\u00e1laszk\u00f3d sz\u00fcks\u00e9ges).</p> </li> </ol>"},{"location":"homework/rest/#openapi-dokumentacio","title":"OpenAPI dokument\u00e1ci\u00f3","text":"<p>Az OpenAPI (kor\u00e1bbi nev\u00e9n Swagger) egy REST API dokument\u00e1ci\u00f3s eszk\u00f6z. C\u00e9lja hasonl\u00f3 a Web Service-ek eset\u00e9ben haszn\u00e1lt WSDL-hez: le\u00edrni az API szolg\u00e1ltat\u00e1sait egy standardiz\u00e1lt form\u00e1ban. A kor\u00e1bbi feladatok megold\u00e1sa ut\u00e1n k\u00e9sz\u00edts OpenAPI specifik\u00e1ci\u00f3t \u00e9s dokument\u00e1ci\u00f3t a REST API le\u00edr\u00e1s\u00e1hoz.</p> <ol> <li> <p>A megold\u00e1shoz k\u00f6vesd a Microsoft hivatalos dokument\u00e1ci\u00f3j\u00e1t: https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle</p> <ul> <li>Mindenk\u00e9ppen a Swashbuckle opci\u00f3t haszn\u00e1ld.</li> <li>A <code>swagger.json</code>-t az alkalmaz\u00e1s maga gener\u00e1lja (nem k\u00e9zzel kell meg\u00edrnod), \u00e9s a <code>/swagger/v1/swagger.json</code> c\u00edmen legyen el\u00e9rhet\u0151.</li> <li>\u00c1ll\u00edtsd be a Swagger UI-t is, ez a <code>/neptun</code> c\u00edmen legyen el\u00e9rhet\u0151. Ezt a <code>UseSwaggerUI</code> be\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l a <code>RoutePrefix</code> konfigur\u00e1l\u00e1s\u00e1val fogod tudni el\u00e9rni. A saj\u00e1t Neptun k\u00f3dod legyen a prefix csupa kisbet\u0171vel.</li> <li>Figyelj oda, hogy eset\u00fcnkben nem csak Development m\u00f3dban ind\u00edtva kell a swagger komponens az automata ellen\u0151rz\u0151 miatt.</li> <li>(A \"Customize and extend\" r\u00e9sszel \u00e9s egy\u00e9b testreszab\u00e1ssal nem kell foglalkoznod.)</li> </ul> </li> <li> <p>Ind\u00edtsd el a webalkalmaz\u00e1st, \u00e9s n\u00e9zd meg a <code>swagger.json</code>-t http://localhost:5000/swagger/v1/swagger.json c\u00edmen, \u00e9s pr\u00f3b\u00e1ld ki a SwaggerUI-t a http://localhost:5000/neptun c\u00edmen.</p> </li> <li> <p>Pr\u00f3b\u00e1ld ki a SwaggerUI \"Try it out\" szolg\u00e1ltat\u00e1s\u00e1t: t\u00e9nyleg kik\u00fcldi a k\u00e9r\u00e9st a webalkalmaz\u00e1snak, \u00e9s l\u00e1tod a val\u00f3di v\u00e1laszt.</p> <p></p> </li> <li> <p>K\u00e9sz\u00edtd el azt az API v\u00e9gpontot, ami vissza is adja a k\u00edv\u00e1nt term\u00e9ket (<code>Product</code>) az id-ja alapj\u00e1n; a k\u00e9r\u00e9s <code>GET</code> t\u00edpus\u00fa legyen a <code>/api/product/{id}</code> c\u00edmre, \u00e9s a v\u00e1lasz vagy 200 legyen az adattal, vagy 404, ha nincs ilyen elem. Ellen\u0151rizd a SwaggerUI seg\u00edts\u00e9g\u00e9vel.</p> </li> </ol> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott forr\u00e1sk\u00f3dot t\u00f6ltsd fel. \u00dcgyelj r\u00e1, hogy a <code>csproj</code> f\u00e1jl is m\u00f3dosult a hozz\u00e1adott NuGet csomaggal!</p> <p>K\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet a b\u00f6ng\u00e9sz\u0151ben megjelen\u0151 Swagger UI-r\u00f3l. \u00dcgyelj r\u00e1, hogy az URL-ben l\u00e1that\u00f3 legyen, hogy a SwaggerUI-t a <code>/neptun</code> c\u00edmen szolg\u00e1lja ki a rendszer a saj\u00e1t Neptun k\u00f3doddal. A k\u00e9pet <code>f1.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p>"},{"location":"homework/rest/#feladat-2-termek-muveletek-2-pont","title":"Feladat 2: Term\u00e9k m\u0171veletek (2 pont)","text":"<p>A term\u00e9kekkel kapcsolatos leggyakoribb adatb\u00e1zism\u0171veletek az \u00faj besz\u00far\u00e1sa, megl\u00e9v\u0151 term\u00e9k lek\u00e9rdez\u00e9se, m\u00f3dos\u00edt\u00e1sa vagy t\u00f6rl\u00e9se, vagyis a CRUD (create, read, update \u00e9s delete) m\u0171veletek. Ezekhez dedik\u00e1lt v\u00e9gpontokat k\u00e9sz\u00edt\u00fcnk, amiken kereszt\u00fcl a m\u0171veletek v\u00e9grehajt\u00e1s\u00e1t el tudja v\u00e9gezni az API haszn\u00e1l\u00f3ja. Ebben a feladatban a leggyakoribb v\u00e9gpontokat kell implement\u00e1lni a m\u00e1r megl\u00e9v\u0151 lek\u00e9rdez\u00e9s mell\u00e9.</p> <ol> <li> <p>K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, ami besz\u00far egy \u00faj term\u00e9ket (<code>Product</code>) az id-ja alapj\u00e1n; a k\u00e9r\u00e9s <code>POST</code> t\u00edpus\u00fa legyen a <code>/api/product</code> c\u00edmre, a k\u00e9r\u00e9s t\u00f6rzs\u00e9ben v\u00e1rja az \u00faj <code>Product</code> \u00e9rt\u00e9ket, \u00e9s a v\u00e1lasz vagy 201 legyen, vagy 409, ha m\u00e1r van ilyen nev\u0171 elem.</p> </li> <li> <p>K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, ami m\u00f3dos\u00edt egy term\u00e9ket (<code>Product</code>) az id-ja alapj\u00e1n; a k\u00e9r\u00e9s <code>PUT</code> t\u00edpus\u00fa legyen a <code>/api/product/{id}</code> c\u00edmre, a k\u00e9r\u00e9s t\u00f6rzs\u00e9ben v\u00e1rja a v\u00e1ltoztatott <code>Product</code> \u00e9rt\u00e9ket, \u00e9s a v\u00e1lasz vagy 204 legyen tartalom n\u00e9lk\u00fcl, vagy 404, ha nincs ilyen elem.</p> </li> <li> <p>K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, ami t\u00f6r\u00f6l egy term\u00e9ket (<code>Product</code>) az id-ja alapj\u00e1n; a k\u00e9r\u00e9s <code>DELETE</code> t\u00edpus\u00fa legyen a <code>/api/product/{id}</code> c\u00edmre, \u00e9s a v\u00e1lasz vagy 204 legyen tartalom n\u00e9lk\u00fcl, vagy 404, ha nincs ilyen elem.</p> </li> <li> <p>K\u00e9sz\u00edts egy olyan API v\u00e9gpontot, amivel lek\u00e9rdezhet\u0151, h\u00e1ny f\u00e9le term\u00e9k van \u00f6sszesen. (P\u00e9ld\u00e1ul a lapoz\u00e1st el\u0151seg\u00edtend\u0151 kisz\u00e1molhatja a frontend, hogy h\u00e1ny lap lesz.) Ez is egy <code>GET</code> t\u00edpus\u00fa k\u00e9r\u00e9s legyen a <code>/api/product/-/count</code> c\u00edmre. A visszaadott adat a <code>CountResult</code> oszt\u00e1ly p\u00e9ld\u00e1nya legyen kit\u00f6ltve a darabsz\u00e1mmal (term\u00e9szetesen JSON form\u00e1ban).</p> Mi\u00e9rt van a <code>/-</code> r\u00e9sz az URL-ben? <p>Ahhoz, hogy ezt meg\u00e9rts\u00fck, gondoljuk \u00e1t, mi lehetne az URL: term\u00e9kek darabsz\u00e1m\u00e1ra vagyunk k\u00edv\u00e1ncsiak, teh\u00e1t <code>/api/product/</code>, de ut\u00e1na mi? Lehetne <code>/api/product/count</code>. Viszont ez \"\u00f6sszekeveredik\" a <code>/api/product/123</code> jelleg\u0171 URL-lel, ami egy konkr\u00e9t term\u00e9k lek\u00e9rdez\u00e9s\u00e9re szolg\u00e1l. A gyakorlatban a k\u00e9t URL egy\u00fctt tudna m\u0171k\u00f6dni, mert a term\u00e9k azonos\u00edt\u00f3 most sz\u00e1m, \u00edgy a keretrendszer felismeri, hogy ha <code>/123</code> az URL v\u00e9ge, akkor a term\u00e9k ID-t v\u00e1r\u00f3 v\u00e9gpontot kell v\u00e9grehajtani, ha pedig <code>/count</code> az URL v\u00e9ge, akkor a sz\u00e1moss\u00e1got megad\u00f3t. De ez csak akkor m\u0171k\u00f6dik, ha az ID int. Ha sz\u00f6veg lenne a term\u00e9k azonos\u00edt\u00f3ja, probl\u00e9ma lenne. Ilyen esetekben olyan URL-t kell \"kital\u00e1lni\", ami nem \u00fctk\u00f6zik. A <code>/-</code> r\u00e9sz azt jelzi, hogy ott nem term\u00e9k azonos\u00edt\u00f3 utazik.</p> <p>Megjegyz\u00e9s: az URL - controller met\u00f3dus azonos\u00edt\u00e1s a fent le\u00edrtakn\u00e1l bonyolultabb a val\u00f3s\u00e1gban. Az ASP.NET Core keretrendszer priorit\u00e1s sorrendben illeszti a controller met\u00f3dusokat a be\u00e9rkez\u0151 k\u00e9r\u00e9sek URL-jeire. Ezt a priorit\u00e1st lehet\u0151s\u00e9g\u00fcnk van befoly\u00e1solni a <code>[Http*]</code> attrib\u00fatumok <code>Order</code> tulajdons\u00e1g\u00e1val.</p> </li> </ol> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p> <p>Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Postman-b\u0151l (vagy m\u00e1s tesztel\u00e9shez haszn\u00e1lt eszk\u00f6zb\u0151l), amely egy sikeres term\u00e9k lek\u00e9r\u00e9s eredm\u00e9ny\u00e9t mutatja. A k\u00e9pen legyen l\u00e1that\u00f3 a k\u00e9r\u00e9s \u00e9s a v\u00e1lasz minden r\u00e9szlete (k\u00e9r\u00e9s t\u00edpusa, URL, v\u00e1lasz k\u00f3dja, v\u00e1lasz tartalma). A v\u00e1laszban a n\u00e9vben szerepelnie kell a Neptun k\u00f3dodnak. A k\u00e9pet <code>f2.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p> <p>M\u00c9G NEM V\u00c9GEZT\u00c9L</p> <p>Ha push-oltad a k\u00f3dodat, k\u00e9sz\u00edts egy PR-t, amihez rendeld hozz\u00e1 a gyakorlatvezet\u0151det! (r\u00e9szletek: a h\u00e1zi feladat lead\u00e1sa oldalon)</p>"},{"location":"homework/rest/#feladat-3-termek-reszleges-frissitese-3-imsc-pont","title":"Feladat 3: Term\u00e9k r\u00e9szleges friss\u00edt\u00e9se (3 iMsc pont)","text":"<p>Az iMsc pont megszerz\u00e9s\u00e9re az els\u0151 k\u00e9t feladat megold\u00e1s\u00e1val egy\u00fctt van lehet\u0151s\u00e9g.</p> <p>A term\u00e9kek m\u00f3dos\u00edt\u00e1sa eset\u00e9n az eddig haszn\u00e1lt <code>PUT</code> h\u00edv\u00e1snak sz\u00e1mos h\u00e1tr\u00e1nya van. A <code>PUT</code> a teljes er\u0151forr\u00e1s friss\u00edt\u00e9s\u00e9re lett kital\u00e1lva, azaz egy term\u00e9k m\u00f3dos\u00edt\u00e1s\u00e1hoz a teljes term\u00e9ket el kell k\u00fcldeni. Ez egyr\u00e9szt kev\u00e9ss\u00e9 hat\u00e9kony (p\u00e9ld\u00e1ul h\u00e1l\u00f3zaton le kell k\u00e9rni \u00e9s \u00e1tk\u00fcldeni minden megl\u00e9v\u0151 tulajdons\u00e1g\u00e1t, ak\u00e1rmilyen nagyok is azok), illetve ezek feldolgoz\u00e1sa is plusz feladatokat jelenthet. A <code>PATCH</code> ige arra lett kital\u00e1lva, hogy r\u00e9szleges friss\u00edt\u00e9si lehet\u0151s\u00e9get biztos\u00edtson, azaz el\u00e9g legyen elk\u00fcldeni azokat a tulajdons\u00e1gokat amiket m\u00f3dos\u00edtani szeretn\u00e9nk.</p> <p>Ebben a feladatban l\u00e9tre kell hoznod egy v\u00e9gpontot, ami biztos\u00edtja a term\u00e9kek r\u00e9szleges friss\u00edt\u00e9s\u00e9t:</p> <ol> <li> <p>A k\u00e9r\u00e9s <code>PATCH</code> t\u00edpus\u00fa legyen a <code>/api/product/{id}</code> c\u00edmre, \u00e9s a v\u00e1lasz vagy 204 legyen, ha siker\u00fcl, vagy 404, ha nincs ilyen elem.</p> </li> <li> <p>A <code>ProductController</code> oszt\u00e1lyban val\u00f3s\u00edtsd meg a v\u00e9gpontot, ami elv\u00e9gzi a r\u00e9szleges friss\u00edt\u00e9st. A v\u00e9gpont \u00e1ltal kapott param\u00e9ter t\u00edpusa <code>JsonPatchDocument</code> er\u0151sen t\u00edpusos v\u00e1ltozata legyen. Tesztel\u00e9s sor\u00e1n figyelj r\u00e1, hogy csak a k\u00fcld\u00f6tt \u00e9rt\u00e9kek v\u00e1ltozzanak meg (p\u00e9ld\u00e1ul, ha nincs felk\u00fcld\u00f6tt objektumban rakt\u00e1rk\u00e9szlet, az ne v\u00e1ltozzon).</p> </li> </ol> <p>JsonPatchDocument</p> <p>A <code>JsonPatchDocument</code> az ASP.NET Core \u00e1ltal ny\u00fajtott oszt\u00e1ly \u00e9s tartozik hozz\u00e1 be\u00e9p\u00edtett mechanizmus is.</p> <p>BEADAND\u00d3</p> <p>A m\u00f3dos\u00edtott forr\u00e1sk\u00f3dot t\u00f6ltsd fel.</p> <p>Emellett k\u00e9sz\u00edts egy k\u00e9perny\u0151k\u00e9pet Postman-b\u0151l (vagy m\u00e1s tesztel\u00e9shez haszn\u00e1lt eszk\u00f6zb\u0151l), amely egy sikeres r\u00e9szleges m\u00f3dos\u00edt\u00e1s eredm\u00e9ny\u00e9t mutatja. A k\u00e9pen legyen l\u00e1that\u00f3 a k\u00e9r\u00e9s \u00e9s a v\u00e1lasz minden r\u00e9szlete (k\u00e9r\u00e9s t\u00edpusa, URL, v\u00e1lasz k\u00f3dja, v\u00e1lasz tartalma). A v\u00e1laszban a n\u00e9vben szerepelnie kell a Neptun k\u00f3dodnak. A k\u00e9pet <code>f3.png</code> n\u00e9ven mentsd el \u00e9s add be a megold\u00e1sod r\u00e9szek\u00e9nt!</p>"},{"location":"lecture-notes/SQL_Cheat_Sheet/","title":"Lek\u00e9rdez\u00e9s szintaktitka cheat-sheet","text":"<p>Ebben a cheat-sheet-ben a k\u00fcl\u00f6nb\u00f6z\u0151 tanult nyelvek lek\u00e9rdez\u00e9si szintaktik\u00e1ja ker\u00fcl \u00f6sszehasonl\u00edt\u00e1sra.</p> <p>Warning</p> <p>C# LINQ haszn\u00e1latakor ne felejts\u00fck el p\u00e9ld\u00e1nyos\u00edtani az adatb\u00e1zis kontextust egy <code>using</code> block-ban.</p> <pre><code>using (var db = new AdatvezDbContext())\n{\n    //lek\u00e9rdez\u00e9sek, stb...\n}\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#select","title":"SELECT","text":"<p>SQL:</p> <pre><code>SELECT column1, column2\nFROM table\nWHERE condition;\n</code></pre> <p>C# LINQ:</p> <pre><code>// fluent szintaktika\nvar query = context.Table\n    .Where(item =&gt; condition)\n    .Select(item =&gt; new { item.Column1, item.Column2 });\n\n// Query szintaktika           \nvar query = from item in context.Table\n            where condition\n            select new { item.Column1, item.Column2 };\n</code></pre> <p>Megjegyz\u00e9s</p> <p><code>Select()</code>-ben n\u00e9vtelen objektumot hoztunk l\u00e9tre, ennek property-jei szabadon v\u00e1laszthat\u00f3ak, a vet\u00edt\u00e9si m\u0171velet elv\u00e9gz\u00e9s\u00e9hez.</p> <p>Warning</p> <p>Ha sz\u00fcks\u00e9g\u00fcnk van a navigation propertykkel hivatkozott entit\u00e1sokra, akkor a fejleszt\u0151 a k\u00f3dban ezt specifik\u00e1lja az <code>Include</code> haszn\u00e1lat\u00e1val, \u00e9s a rendszer bet\u00f6lti a k\u00e9rt hivatkoz\u00e1sokat is.</p> <pre><code>var prod = db.Products\n    .Include(p =&gt; p.VAT)\n    .Where(p =&gt; p.ID == 23)\n    .SingleOrDefault();\nif(prod is not null)\n{\n    Console.WriteLine(prod.VAT.ID);\n}\n</code></pre> <p>C# MongoDb:</p> <p>MongoDb-beli <code>Project()</code>-et hasonl\u00f3k\u00e9ppen haszn\u00e1ljuk a LINQ-beli <code>Select()</code>-hez, amennyiben vagy vet\u00edteni akarunk bizonyos attrib\u00fatumokra.</p> <pre><code>collection\n    .Find(item=&gt;item.Column1 == value)\n    .Project(item =&gt; new\n    {\n        Attr1 = item.Coloumn1,\n        Attr2 = item.Coloumn2\n    })\n    .ToList();\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#where","title":"WHERE","text":"<p>SQL:</p> <pre><code>SELECT *\nFROM table_name\nWHERE column_name = \"Example\";\n</code></pre> <p>Lek\u00e9rdez\u00e9s melyben egy mez\u0151 <code>NULL</code> \u00e9rt\u00e9k\u0171:</p> <pre><code>SELECT *\nFROM table_name\nWHERE column_name IS NULL;\n-- Ha ellenkez\u0151j\u00e9re lenn\u00e9nk k\u00edv\u00e1ncsiak, IS NOT NULL kellene\n</code></pre> <p><code>ISNULL</code> f\u00fcggv\u00e9ny: Ha van \u00e9rt\u00e9k a <code>salary</code> oszlopban, akkor annak az \u00e9rt\u00e9k\u00e9vel dolgozik tov\u00e1bb a lek\u00e9rdez\u00e9s, ha nem akkor a m\u00e1sodik param\u00e9terk\u00e9nt kapott \u00e9rt\u00e9kkel (ebben az esetben 0).</p> <pre><code>SELECT employee_id, employee_name, ISNULL(salary, 0) AS modified_salary\nFROM employees;\n</code></pre> <p>Allek\u00e9rdez\u00e9st el lehet nevezni, eredm\u00e9nyeire lehet hivatkozni. L\u00e1that\u00f3 az al\u00e1bbi feladatbeli p\u00e9ld\u00e1ban (feladat a Microsoft SQL gyakorlatr\u00f3l).</p> <p>Feladat: Melyik term\u00e9k kateg\u00f3ri\u00e1ban van a legt\u00f6bb term\u00e9k?</p> <pre><code>SELECT TOP 1 Name, (SELECT COUNT(*) FROM Product WHERE Product.CategoryID = c.ID) AS cnt\nFROM Category c\nORDER BY cnt DESC\n</code></pre> <p>C# LINQ:</p> <p>Feladat: Hol kisebb az \u00e1r mint 1000?</p> <pre><code>//Fluent szintaktika\ndb.Products.Where(p =&gt; p.Price &lt; 1000)\n\n//Query szintaktika\nfrom p in db.Products\nwhere p.Price &lt; 1000\n</code></pre> <p>C# MongoDb:</p> <p>Warning</p> <p>MongoDb-n\u00e9l a <code>Find</code>-ban olyan felt\u00e9tel lehet csak, ami a dokumentumra vonatkozik, nem lehet csatolt (joinolt) m\u00e1sik gy\u0171jtem\u00e9nyre hivatkozni!</p> <p>Warning</p> <p>MongoDb-n\u00e9l mindig oda kell \u00edrni egy <code>.Find()</code>-ot a parancsokba (amennyiben nem haszn\u00e1lunk <code>Aggregate()</code>-et), \u00edgy gyakori a <code>.Find(_=&gt;true)</code> param\u00e9terez\u00e9s\u0171 <code>Find()</code> parancs.</p> <p>Note</p> <p>A <code>Find()</code> f\u00fcggv\u00e9ny eredm\u00e9nye m\u00e9g nem az eredm\u00e9nyhalmaz, hanem csak egy le\u00edr\u00f3 a lek\u00e9rdez\u00e9s v\u00e9grehajt\u00e1s\u00e1hoz. A <code>ToList()</code> k\u00e9ri le a teljes eredm\u00e9nyhalmazt listak\u00e9nt. (Amennyiben egyetlen elemet szeretn\u00e9nk visszaadni nem ezt a f\u00fcggv\u00e9nyt kell haszn\u00e1lni, l\u00e1sd lentebb)</p> <pre><code>collection.Find(item =&gt; item.Column == value).ToList();\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#egy-elemu-eredmenyhalmaz-es-eredmenyhalmaz-szamossaga","title":"Egy elem\u0171 eredm\u00e9nyhalmaz \u00e9s eredm\u00e9nyhalmaz sz\u00e1moss\u00e1ga","text":"<p>SQL:</p> <p>Azokban az esetekben, amikor csak egyetlen sort szeretn\u00e9nk visszakapni lek\u00e9rdez\u00e9seinkb\u0151l.</p> <pre><code>SELECT TOP 1 *\nFROM Product\nORDER BY Name\n</code></pre> <p>C# (LINQ \u00e9s MongoDb):</p> <p>Amennyiben csak az els\u0151 elemre van sz\u00fcks\u00e9g\u00fcnk, vagy tudjuk, hogy csak egy elem lesz, akkor haszn\u00e1lhatjuk a <code>.First()</code>, <code>.FirstOrDefault()</code>, vagy <code>.Single()</code>, <code>.SingleOrDefault()</code> f\u00fcggv\u00e9nyeket. Fontos, hogy <code>.Single()</code> vagy <code>.SingleOrDefault()</code> f\u00fcggv\u00e9nyek haszn\u00e1lata eset\u00e9n gondoskodjunk arr\u00f3l, hogy a megel\u0151z\u0151 lek\u00e9rdez\u00e9s val\u00f3ban egyetlen adatelemet adjon vissza. (K\u00fcl\u00f6nben kiv\u00e9telt fog dobni)</p> <p>Lehet\u0151s\u00e9g\u00fcnk ny\u00edlik lapoz\u00e1s haszn\u00e1lat\u00e1ra is <code>.Skip()</code> haszn\u00e1lat\u00e1val</p> <p>C# LINQ:</p> <p><code>Take()</code> haszn\u00e1lat\u00e1val korl\u00e1tozhatjuk h\u00e1ny eredm\u00e9nyt ad vissza a lek\u00e9rdez\u00e9s.</p> <pre><code>// 10-et olvas ki\ndb.Products.Take(10)\n\n// Skippel 10-et majd kiolvas 10-et\ndb.Products.Skip(10).Take(10)\n</code></pre> <p>C# MongoDb:</p> <p><code>Limit()</code> haszn\u00e1lat\u00e1val korl\u00e1tozhatjuk h\u00e1ny eredm\u00e9nyt ad vissza a lek\u00e9rdez\u00e9s.</p> <pre><code>//10-et olvas ki\ncollection.Find(...).Limit(10);\n//Skippel 10et majd kiolvas 10-et\ncollection.Find(...).Skip(10).Limit(10);\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#group-by","title":"Group By","text":"<p>SQL:</p> <p>List\u00e1zza ki az M bet\u0171vel kezd\u0151d\u0151 term\u00e9kek nev\u00e9t \u00e9s a megrendelt mennyis\u00e9geket \u00fagy, hogy azok a term\u00e9kek is benne legyenek a list\u00e1ban melyekb\u0151l nem rendeltek meg semmit</p> <pre><code>SELECT p.Name, SUM(oi.Amount)\nFROM Product p\n     LEFT OUTER JOIN OrderItem oi ON p.id = oi.ProductID\nWHERE p.Name LIKE 'M%'\nGROUP BY p.Name\n</code></pre> <p>C# LINQ:</p> <p>List\u00e1zzuk ki a term\u00e9keket <code>VATID</code> szerint csoportos\u00edtva.</p> <pre><code>// Fluent szintaktika\ndb.Products.GroupBy(p =&gt; p.VATID)\n\n// Query szintaktika\nfrom p in db.Products\ngroup p by p.VATID\n</code></pre> <p>C# MongoDb:</p> <pre><code>collection.Aggregate()\n    .Match(Builders&lt;Product&gt;.Filter.AnyEq(x =&gt; x.Categories, \"Labd\u00e1k\")) // sz\u0171r\u00e9s\n    .Group(x =&gt; x.VAT.Percentage, x =&gt; x) // csoportos\u00edt\u00e1s\n    .ToList()\n</code></pre> <p>A <code>Match()</code>-en bel\u00fcl lambda helyett a felt\u00e9telnek, egy alternat\u00edv megad\u00e1s\u00e1t l\u00e1thatjuk. Ide t\u00f6bb k\u00fcl\u00f6nb\u00f6z\u0151 kulcssz\u00f3t lehet \u00edrni \u00e9s egym\u00e1sba lehet \u00e1gyazni a Filtereket.</p> <pre><code>collection.Find(x =&gt; x.Price == 123);\ncollection.Find(Builders&lt;Product&gt;.Filter.Eq(x =&gt; x.Price, 123)); //Eq, mint equals\n\ncollection.Find(x =&gt; x.Price != 123);\ncollection.Find(Builders&lt;Product&gt;.Filter.Ne(x =&gt; x.Price, 123)); // Ne, mint not equals\n\ncollection.Find(x =&gt; x.Price &gt;= 123);\ncollection.Find(Builders&lt;Product&gt;.Filter.Gte(x =&gt; x.Price, 123)); // Gte, mint greater than or equal to\n\ncollection.Find(x =&gt; x.Price &lt; 123);\ncollection.Find(Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Price, 123)); // Lt, mint less than\n\ncollection.Find(x =&gt; x.Price &lt; 500 || x.Stock &lt; 10);\ncollection.Find(\n    Builders&lt;Product&gt;.Filter.Or(\n        Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Price, 500),\n        Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Stock, 10)\n    )\n);\n\ncollection.Find(x =&gt; !(x.Price &lt; 500 || x.Stock &lt; 10));\ncollection.Find(\n    Builders&lt;Product&gt;.Filter.Not(\n        Builders&lt;Product&gt;.Filter.Or(\n            Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Price, 500),\n            Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Stock, 10)\n        )\n    )\n);\n</code></pre> <p>P\u00e9lda <code>.Group()</code> m\u00e1sodik param\u00e9ter\u00e9ben lehet vet\u00edt\u00e9seket megadni hasonl\u00f3an a <code>.Project()</code> f\u00fcggv\u00e9nyhez.</p> <pre><code>var r = productsCollection\n    .Aggregate()\n    .Group(\n        // csoportos\u00edt\u00e1s r\u00e9sz\n        p =&gt; p.VAT.Percentage,\n        // projekcios r\u00e9sz\n        p =&gt; new\n        {\n            VatPercentage = p.Key\n            SumPrice = p.Sum(s =&gt; s.Price)\n        })\n    .ToList();\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#order-by","title":"Order By","text":"<p>SQL:</p> <pre><code>ORDER BY column1 ASC, column2 DESC;\n</code></pre> <p>C# LINQ:</p> <p>K\u00e9tszint\u0171 rendez\u00e9s</p> <pre><code>items.OrderBy(item =&gt; item.Column1)\n     .ThenByDescending(item =&gt; item.Column2)\n</code></pre> <p>C# MongoDb:</p> <pre><code>itemcollection.Sort(\n    Builders&lt;CollectionItem&gt;.Sort.Ascending(item =&gt; item.Coloumn))\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#join","title":"JOIN","text":"<p>SQL:</p> <pre><code>SELECT table1.column, table2.column\nFROM table1\nJOIN table2 ON table1.column = table2.column;\n</code></pre> <p>C# LINQ:</p> <p>Mivel navigation property-k seg\u00edts\u00e9g\u00e9vel \u00e1ltal\u00e1ban el\u00e9rhet\u0151ek az asszoci\u00e1lt oszt\u00e1lyok, explicit illeszteni csak akkor kell, ha a feladat megold\u00e1si logik\u00e1ja megk\u00edv\u00e1nja vagy nincs navigation property az egyik oszt\u00e1lyban a m\u00e1sikra.</p> <pre><code>// Fluent szintaktika\nvar query = context\n    .Table1\n    .Join(context.Table2,\n        item1 =&gt; item1.Column,\n        item2 =&gt; item2.Column,\n        (item1, item2) =&gt; new { item1.Column, item2.Column });\n\n// Query szintaktika\nvar query = from item1 in context.Table1\n            join item2 in context.Table2\n            on item1.Column equals item2.Column\n            select new { item1.Column, item2.Column };\n</code></pre> <p>C# MongoDb:</p> <p>MongoDb-ben nem tanultunk szerver oldali joinra m\u00f3dszert. LINQ seg\u00edts\u00e9g\u00e9vel van az ut\u00e1n, hogy a teljes illesztend\u0151 adathalmazokat kiolvastuk az adatb\u00e1zisb\u00f3l. Az adatok lek\u00e9rdez\u00e9se ut\u00e1n \u00e1ltal\u00e1ban a <code>.ToHashSet()</code> \u00e9s a <code>.Contains()</code> met\u00f3dusok seg\u00edts\u00e9g\u00e9vel, kliens oldali dictionary k\u00e9sz\u00edt\u00e9ssel v\u00e9gezz\u00fck el az illeszt\u00e9st. (L\u00e1sd MongoDb gyakorlat 1. Feladat 5. pontja)</p>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#distinct","title":"Distinct","text":"<p>SQL:</p> <pre><code>SELECT DISTINCT p.Name\nFROM Product p\n</code></pre> <p>C# LINQ:</p> <p>Feladat: Minden k\u00fcl\u00f6nb\u00f6z\u0151 term\u00e9k n\u00e9v</p> <pre><code>db.Products.Select(p =&gt; p.Name).Distinct();\n</code></pre> <p>C# MongoDb: Feladat: Minden <code>CategoryID</code>, melyhez tartozik term\u00e9k, melynek \u00e1ra nagyobb mint 3000.</p> <pre><code>var xd = productsCollection\n    .Distinct(p =&gt; p.CategoryID, p =&gt; p.Price &gt; 3000)\n    .ToList();\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#oszlopfuggvenyek","title":"Oszlopf\u00fcggv\u00e9nyek","text":"<p>SQL:</p> <p>Feladat: Mennyibe ker\u00fcl a legdr\u00e1g\u00e1bb term\u00e9k?</p> <pre><code>SELECT MAX(Price)\nFROM Product\n</code></pre> <p>Feladat: Melyek a legdr\u00e1g\u00e1bb term\u00e9kek?</p> <pre><code>SELECT *\nFROM Product\nWHERE Price = (SELECT MAX(Price) FROM Product)\n</code></pre> <p>C# LINQ:</p> <pre><code>db.Products.Count()\n\n// Al\u00e1bbihoz hasonl\u00f3 k\u00e9ppen Max, Min, Sum\ndb.Products.Select(p =&gt; p.Price).Average()\n</code></pre> <p>C# MongoDb:</p> <p>Az \u00e1ltal\u00e1nos aggreg\u00e1ci\u00f3khoz k\u00e9sz\u00edthet\u00fcnk pipeline-okat. Egy pipeline k\u00e9pes t\u00f6bb eredm\u00e9nyt is visszaadni egy dokumentumhalmazr\u00f3l (pl. total, average, maximum vagy minimum \u00e9rt\u00e9keket).</p> <p>Maximum f\u00fcggv\u00e9ny:</p> <p>Tip</p> <p>Figyelj\u00fck meg a <code>Group</code>-on bel\u00fcli konstans szerinti csoportos\u00edt\u00e1st, mely az\u00e9rt van hogy a teljes collectionre sz\u00e1m\u00edtsuk ki az oszlopf\u00fcggv\u00e9ny \u00e9rt\u00e9k\u00e9t.</p> <pre><code>collection\n    .Aggregate()\n    .Group(p =&gt; 1, p =&gt; p.Max(x =&gt; x.Stock))\n    .Single();\n</code></pre> <p>N\u00e9zz\u00fck ezt a csoportos\u00edt\u00e1s p\u00e9ld\u00e1j\u00e1n kereszt\u00fcl. Al\u00e1bbi lek\u00e9rdez\u00e9s kilist\u00e1zza, hogy mely rendel\u00e9shez, mekkora \u00f6ssz\u00e9rt\u00e9kben tartoznak <code>OrderItem</code> rekordok ha azok \u00f6ssz\u00e9rt\u00e9ke meghaladja a 30000-et.</p> <pre><code>var q = ordersCollection\n    .Aggregate()\n    .Project(order =&gt; new\n    {\n        CustomerID = order.CustomerID,\n        Total = order.OrderItems.Sum(oi =&gt; oi.Amount * oi.Price)\n    })\n    .Match(order =&gt; order.Total &gt; 30000)\n    .ToList();\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#delete","title":"Delete","text":"<p>SQL:</p> <pre><code>DELETE\nFROM Product\nWHERE ID = 23\n</code></pre> <p>C# LINQ:</p> <pre><code>using (var db = new AdatvezDbContext())\n{\n    var deleteThis = db.Products\n        .Select(p =&gt; p.ID == 23)\n        .SingleOrDefault();\n    if(deleteThis is not null)\n    {\n        db.Products.Remove(deleteThis);\n        db.SaveChanges();\n    }\n}\n</code></pre> <p>C# MongoDb:</p> <pre><code>var deleteResult = collection.DeleteOne(x =&gt; x.Id == new ObjectId(\"...\"));\n</code></pre> <p>Haszn\u00e1ld a <code>DeleteMany</code> parancsot ha t\u00f6bb rekordot szeretn\u00e9l t\u00f6r\u00f6lni.</p>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#insert","title":"Insert","text":"<p>SQL:</p> <pre><code>INSERT INTO Product\nVALUES ('aa', 100, 0, 3, 2, null)\n</code></pre> <p>Amikor m\u00e1sik lek\u00e9rdez\u00e9s eredm\u00e9ny\u00e9t szeretn\u00e9nk beilleszteni:</p> <pre><code>INSERT INTO Product (Name, Price)\nSELECT Name, Price\nFROM InvoiceItem\nWHERE Amount&gt;2\n</code></pre> <p>C# LINQ:</p> <pre><code>using (var db = new AdatvezDbContext())\n{\n    db.Table.Add(new dataItem { Name = \"Example\" });\n    db.SaveChanges();\n}\n</code></pre> <p>C# MongoDb:</p> <pre><code>var newProduct = new Product\n{\n    Name = \"Alma\",\n    Price = 890,\n    Categories = new[] { \"Gy\u00fcm\u00f6lcs\u00f6k\" }\n};\ncollection.InsertOne(newProduct);\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#update","title":"Update","text":"<p>SQL:</p> <p>Feladat: Emelje meg azon term\u00e9kek \u00e1r\u00e1t 10%-al, melyek nev\u00e9ben szerepel a \"Lego\" sz\u00f3!</p> <pre><code>UPDATE Product\nSET Price=1.1 * Price\nWHERE Name LIKE '%Lego%'\n</code></pre> <p>Ha olyan \u00e9rt\u00e9keket szeretn\u00e9nk adni a <code>SET</code> parancsban, melyek m\u00e1sik t\u00e1bl\u00e1kb\u00f3l nyerhet\u0151k ki, az al\u00e1bbi k\u00e9ppen lehets\u00e9ges. A p\u00e9lda az MS SQL gyakorlat anyag\u00e1b\u00f3l van.</p> <p>Feladat: A 9-es azonos\u00edt\u00f3j\u00fa sz\u00e1m\u00fa megrendel\u00e9s st\u00e1tusz \u00e1llapot\u00e1t m\u00e1soljuk be minden olyan <code>OrderItem</code>-be, mely hozz\u00e1 tartozik.</p> <pre><code>UPDATE OrderItem\nSET StatusID = o.StatusID\nFROM OrderItem oi\nINNER JOIN Order o ON o.Id = oi.OrderID\nWHERE o.ID = 9;\n</code></pre> <p>C# LINQ:</p> <p>Warning</p> <p>Az Entity Framework gyakorlat 3. feladat\u00e1nak megold\u00e1sa</p> <p>Feladat: \u00cdrj olyan LINQ-ra \u00e9p\u00fcl\u0151 C# k\u00f3dot, amely az \"LEGO\" kateg\u00f3ri\u00e1s term\u00e9kek \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal!</p> <pre><code>using (var db = new AdatvezDbContext())\n{\n    var legoProductsQuery = db.Products\n        .Where(p =&gt; p.Category.Name == \"LEGO\")\n        .ToList();\n    foreach (var p in legoProductsQuery)\n    {\n        p.Price = 1.1m * p.Price;\n    }\n    db.SaveChanges();\n}\n</code></pre> <p>C# MongoDb:</p> <p>Egy elem friss\u00edt\u00e9se:</p> <pre><code>collection.UpdateOne(\n    filter: x =&gt; x.Id == new ObjectId(\"...\"),\n    update: Builders&lt;Product&gt;.Update.Set(x =&gt; x.Stock, 5));\n</code></pre> <p>J\u00f3l l\u00e1that\u00f3, hogy az <code>Update</code> ut\u00e1n a Filterhez hasonl\u00f3an t\u00f6bb k\u00fcl\u00f6nb\u00f6z\u0151 oper\u00e1tor \u00edrhat\u00f3. Ilyenek a: <code>Set</code>, <code>UnSet</code>, <code>SetOnInsert</code>, <code>CurrentDate</code>, <code>Mul</code>, <code>Min</code>, <code>Max</code>, <code>AddToSet</code> (Teljes, r\u00e9szletes le\u00edr\u00e1s a jegyzetben)</p> <p>Minden 13-as kateg\u00f3ria <code>Id</code>-j\u00fa kateg\u00f3riab\u00e9li elem friss\u00edt\u00e9se:</p> <pre><code>productsCollection.UpdateMany(\n    filter: p =&gt; p.CategoryID == 13,\n    update: Builders&lt;Product&gt;.Update.Mul(p =&gt; p.Price, 1.1));\n</code></pre> <p>Amennyiben \u00fagy akarunk keresni, hogy vagy updatelunk egy bizonyos filterre illeszked\u0151 elemet vagy ha nincs ilyen beillesztj\u00fck, haszn\u00e1lhatjuk az al\u00e1bbi <code>IsUpsert</code> f\u00fcggv\u00e9nyt.</p> <pre><code>var catExpensiveToys = categoriesCollection.FindOneAndUpdate&lt;Category&gt;(\n    filter: c =&gt; c.Name == \"Expensive toys\",\n    update: Builders&lt;Category&gt;.Update.SetOnInsert(c =&gt; c.Name, \"Expensive toys\"),\n    options: new FindOneAndUpdateOptions&lt;Category, Category&gt; { IsUpsert = true, ReturnDocument = ReturnDocument.After });\n</code></pre>"},{"location":"lecture-notes/SQL_Cheat_Sheet/#osszefoglalo-tablazat","title":"\u00d6sszefoglal\u00f3 t\u00e1bl\u00e1zat","text":"SQL C# LINQ C# MongoDb <code>SELECT</code> <code>Select()</code> <code>Project()</code> <code>WHERE</code> <code>Where()</code> <code>Find()</code> <code>GROUP BY</code> <code>GroupBy()</code> <code>Group()</code> <code>ORDER BY</code> <code>OrderBy()</code> <code>Sort()</code> <code>JOIN</code> Haszn\u00e1lj navig\u00e1ci\u00f3s propertyket, ha lehets\u00e9ges, k\u00fcl\u00f6nben: <code>Join()</code> <code>Join()</code> <code>DISTINCT</code> <code>Distinct()</code> <code>Distinct()</code> <code>Count()</code>, <code>Max()</code>, <code>Average()</code> <code>Count()</code>, <code>Max()</code>, <code>Average()</code> El\u0151sz\u00f6r <code>.Aggregate()</code>, majd: <code>Count()</code>, <code>Max()</code>, <code>Average()</code> <code>DELETE FROM</code> <code>.Remove()</code>, \u00e9s <code>db.SaveChanges()</code> ment\u00e9shez <code>.DeleteOne()</code>, <code>.DeleteMany()</code> <code>UPDATE ... SET</code> M\u00f3dos\u00edtsd az adatokat, majd <code>db.SaveChanges()</code> <code>.UpdateOne()</code>, <code>.UpdateMany()</code> <code>INSERT INTO</code> <code>.Add()</code> \u00e9s azt\u00e1n <code>db.SaveChanges()</code> <code>.InsertOne()</code>, <code>.InsertMany()</code>"},{"location":"lecture-notes/adonet/","title":"ADO.NET adatel\u00e9r\u00e9s","text":""},{"location":"lecture-notes/adonet/#mi-is-az-az-adonet","title":"Mi is az az ADO.NET?","text":"<p>Adatvez\u00e9relt alkalmaz\u00e1sokban fontos, hogy az adatel\u00e9r\u00e9si r\u00e9teg k\u00e9nyelmes, egyszer\u0171 metodik\u00e1kat biztos\u00edtson az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3ra, \u00f6sszetett lek\u00e9rdez\u00e9sek k\u00f6nnyebb megfogalmaz\u00e1s\u00e1ra, mindezt mag\u00e1t\u00f3l az adatb\u00e1zismotort\u00f3l min\u00e9l f\u00fcggetlenebb\u00fcl.</p> <p>A Microsoft \u00e1ltal fejlesztett ADO.NET (ActiveX Data Object) egy adatel\u00e9r\u00e9si oszt\u00e1lyk\u00f6nyvt\u00e1r, mely pont ezeket az ig\u00e9nyeket hivatott kiel\u00e9g\u00edteni. A .NET r\u00e9szek\u00e9nt gazdag eszk\u00f6zt\u00e1rat szolg\u00e1ltat adatvez\u00e9relt alkalmaz\u00e1sok k\u00e9sz\u00edt\u00e9s\u00e9hez, egyszer\u0171 hozz\u00e1f\u00e9r\u00e9st biztos\u00edtva az alkalmaz\u00e1sb\u00f3l rel\u00e1ci\u00f3s adatb\u00e1zisokhoz, f\u00fcggetlen\u00fcl az adatb\u00e1zis konkr\u00e9t p\u00e9ld\u00e1ny\u00e1t\u00f3l \u00e9s t\u00edpus\u00e1t\u00f3l.</p> <p>Az ADO.NET mindezek mellett az\u00e9rt er\u0151s eszk\u00f6z, mert egys\u00e9ges, adatb\u00e1zismotor-f\u00fcggetlen k\u00f3dol\u00e1st tesz lehet\u0151v\u00e9. A k\u00f6nyvt\u00e1r interf\u00e9szeket \u00e9s absztrakt oszt\u00e1lyokat tartalmaz, amiknek t\u00f6bbf\u00e9le implement\u00e1ci\u00f3ja (pl. Microsoft SQL Server-hez, vagy OleDB-hez) l\u00e9tezik. Ezen implement\u00e1ci\u00f3k megval\u00f3s\u00edtj\u00e1k az alap funkci\u00f3kat, de ki is b\u0151v\u00edthetik azokat.</p> <p>Az Entity Framework is a h\u00e1tt\u00e9rben ADO.NET-re \u00e9p\u00fcl.</p> <p>Az ADO.NET oszt\u00e1lyk\u00f6nyvt\u00e1r elhelyezked\u00e9se az adatvez\u00e9relt alkalmaz\u00e1s strukt\u00far\u00e1j\u00e1ban:</p> <p></p> <p>Az ADO.NET teh\u00e1t az adatel\u00e9r\u00e9si r\u00e9tegben ny\u00fajt szolg\u00e1ltat\u00e1sokat, \u00e9s a h\u00e1tt\u00e9rben kezeli az adatb\u00e1zismotor kommunik\u00e1ci\u00f3t a rendszerre telep\u00edtett driverek \u00e9s az oper\u00e1ci\u00f3s rendszer szolg\u00e1ltat\u00e1sainak (pl. h\u00e1l\u00f3zati kapcsolat) ig\u00e9nybev\u00e9tel\u00e9vel.</p> <p>Az adatel\u00e9r\u00e9si k\u00f6nyvt\u00e1rak tipikus elemei:</p> <ul> <li>Connection - adatb\u00e1zis meghajt\u00f3k, maga a kapcsolat</li> <li>Command - param\u00e9ter-biztos utas\u00edt\u00e1s</li> <li>ResultSet - eredm\u00e9ny halmaz</li> <li>Exception - kiv\u00e9telek, melyek a lek\u00e9rdez\u00e9sek, v\u00e9grehajt\u00e1sok sor\u00e1n dob\u00f3dhatnak</li> </ul> <p>Az elemeket a k\u00f6vetkez\u0151 fejezetekben r\u00e9szletesebben is t\u00e1rgyaljuk.</p>"},{"location":"lecture-notes/adonet/#connection","title":"Connection","text":"<p>Az ADO.NET k\u00f6nyvt\u00e1r az <code>IDbConnection</code> interf\u00e9szt biztos\u00edtja adatb\u00e1zis kapcsolatok reprezent\u00e1l\u00e1s\u00e1ra. Ebben tal\u00e1lhat\u00f3ak azok a f\u00fcggv\u00e9nyek, amik sz\u00fcks\u00e9gesek valamilyen adatb\u00e1zissal val\u00f3 kapcsolat l\u00e9trehoz\u00e1s\u00e1hoz, mint p\u00e9ld\u00e1ul az <code>Open()</code>, a <code>Close()</code>, vagy a <code>BeginTransaction()</code>. Ezt az interf\u00e9szt implement\u00e1lj\u00e1k az adatb\u00e1zismotor-specifikus kapcsolatok, mint p\u00e9ld\u00e1ul az <code>SqlConnection</code>, amely a Microsoft SQL Server fel\u00e9 t\u00f6rt\u00e9n\u0151 kapcsolatot val\u00f3s\u00edtja meg.</p> <p>Az adatb\u00e1zissal t\u00f6rt\u00e9n\u0151 kapcsolat fel\u00e9p\u00edt\u00e9s\u00e9r\u0151l tudunk kell, hogy relat\u00edve k\u00f6lts\u00e9ges (\u00faj h\u00e1l\u00f3zati kapcsolatot kell nyitni, egyeztetni a szerverrel a protokollokat, bejelentkezni, stb.). Ez\u00e9rt haszn\u00e1ljuk a connection pooling-ot, ahol is egy kapcsolat l\u00e9trehoz\u00e1sa, haszn\u00e1l\u00e1sa, majd bez\u00e1r\u00e1sa ut\u00e1n a kapcsolatot nem eldobjuk, hanem egy gy\u0171jt\u0151be, egy \"pool\"-ba helyezz\u00fck vissza, hogy k\u00e9s\u0151bb \u00fajra fel tudjuk haszn\u00e1lni, ha az adatb\u00e1zishoz szeretn\u00e9nk sz\u00f3lni.</p> <p>A connection pool el\u00e9rhet\u0151s\u00e9ge implement\u00e1ci\u00f3f\u00fcgg\u0151, de az MS SQL Server \u00e9s OleDD implement\u00e1ci\u00f3k is automatikusan t\u00e1mogatj\u00e1k. A connection pool-ok connection string-enk\u00e9nt j\u00f6nnek l\u00e9tre (teh\u00e1t nem adatb\u00e1zisonk\u00e9nt). Ennek akkor van jelent\u0151s\u00e9ge, ha az alkalmaz\u00e1s nem egy connection string-et haszn\u00e1l (hanem pl. felhaszn\u00e1l\u00f3nk\u00e9nt k\u00fcl\u00f6n-k\u00fcl\u00f6n kapcsol\u00f3dik a felhaszn\u00e1l\u00f3 nev\u00e9ben).</p> <p>Ezen kontextushoz tartozik m\u00e9g a connection leak fogalma is, ami azt jelenti, hogy egy kapcsolatot haszn\u00e1lat ut\u00e1n nyitva hagyunk (nem h\u00edvunk <code>Close()</code>-t), ez\u00e1ltal az nem ker\u00fcl vissza a pool-ba, \u00e9s nem tudjuk \u00fajrafelhaszn\u00e1lni. Amennyiben nem figyel\u00fcnk erre, akkor hamar elfogynak a felhaszn\u00e1lhat\u00f3 kapcsolatok (a pool ki\u00fcr\u00fcl), aminek hat\u00e1s\u00e1ra az eg\u00e9sz alkalmaz\u00e1sunk haszn\u00e1lhatatlann\u00e1 v\u00e1lik, l\u00e9v\u00e9n, hogy nem tud az adatb\u00e1zissal kommunik\u00e1lni.</p> <p>Az adatb\u00e1zissal val\u00f3 kapcsolat l\u00e9trehoz\u00e1s\u00e1hoz sz\u00fcks\u00e9g\u00fcnk van egy az el\u0151bb eml\u00edtett connection string-re. Ez a sz\u00f6veges v\u00e1ltoz\u00f3 \u00edrja le, hogy milyen param\u00e9terekkel szeretn\u00e9nk az adatb\u00e1zishoz csatlakozni! Ilyen p\u00e9ld\u00e1ul a felhaszn\u00e1l\u00f3n\u00e9v, jelsz\u00f3, vagy \u00e9ppen a szerver c\u00edme! A connection string-eknek adatb\u00e1zis szerver t\u00edpusonk\u00e9nt elt\u00e9r\u0151 szintaktik\u00e1juk lehet, \u00e9s vesz\u00e9lyforr\u00e1sokat is rejthetnek magukban.</p> <p>A connection string t\u00e1rolhat\u00f3 konfigur\u00e1ci\u00f3s f\u00e1jlban sz\u00f6vegesen, avagy az alkalmaz\u00e1s k\u00f3dja is \u00f6ssze tudja \u00e1ll\u00edtani. P\u00e9lda kapcsolat l\u00e9trehoz\u00e1s\u00e1ra \u00e9s a <code>ConnectionStringBuilder</code> haszn\u00e1lat\u00e1ra:</p> <pre><code>var builder = new SqlConnectionStringBuilder();\nbuilder.UserID = \"User\";\nbuilder.Password = \"Pw\";\nbuilder.DataSource = \"database.server.hu\";\nbuilder.InitialCatalog = \"Adatvez\";\n\nvar conn = new SqlConnection(builder.ConnectionString);\n// connectionstring j\u00f6het konfigur\u00e1ci\u00f3s f\u00e1jlb\u00f3l is\n\nconn.Open();\n... // lek\u00e9rdez\u00e9sek, elj\u00e1r\u00e1sok v\u00e9grehajt\u00e1sa\nconn.Close(); // nem felejtj\u00fck el bez\u00e1rni - jobb megold\u00e1st l\u00e1sd k\u00e9s\u0151bb\n</code></pre>"},{"location":"lecture-notes/adonet/#command","title":"Command","text":"<p>Az adatb\u00e1zis kapcsolat l\u00e9trehoz\u00e1sa ut\u00e1n szeretn\u00e9nk az adatb\u00e1zissal kommunik\u00e1lni, lek\u00e9rdez\u00e9seket, elj\u00e1r\u00e1sokat futtatni. Ehhez az ADO.NET az <code>IDbCommand</code> interf\u00e9szt biztos\u00edtja, ami egy utas\u00edt\u00e1st reprezent\u00e1l. A kapcsolathoz hasonl\u00f3an az interf\u00e9szt specifikus oszt\u00e1lyok val\u00f3s\u00edtj\u00e1k meg, mint amilyen az <code>SqlCommand</code> az MSSQL szerverhez.</p>"},{"location":"lecture-notes/adonet/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>Az <code>IDbCommand</code> al\u00e1bbi f\u0151bb property-jeit be\u00e1ll\u00edtva tudjuk megmondani, hogy a megadott parancs, hogyan legyen \u00e9rtelmezve, \u00e9s mik\u00e9nt viselkedjen az utas\u00edt\u00e1s:</p> <ul> <li><code>CommandType</code>:  h\u00e1romf\u00e9le lehet<ul> <li>T\u00e1rolt elj\u00e1r\u00e1s (StoredProcedure)</li> <li>T\u00e1bla teljes tartalm\u00e1hoz hozz\u00e1f\u00e9r\u00e9s (TableDirect, nem minden implement\u00e1ci\u00f3 haszn\u00e1lja, pl. OleDB igen)</li> <li>SQL query (Text) - alap\u00e9rtelmezett</li> </ul> </li> <li><code>CommandText</code>: a parancs sz\u00f6vege, avagy t\u00e1rolt elj\u00e1r\u00e1st neve</li> <li><code>Connection</code>: az adatb\u00e1zis kapcsolat</li> <li><code>Transaction</code>: a tranzakci\u00f3</li> <li><code>CommandTimeout</code>: parancs eredm\u00e9ny\u00e9re val\u00f3 v\u00e1rakoz\u00e1s maxim\u00e1lis ideje (alap\u00e9rtelmezetten 30s)</li> <li><code>Parameters</code>: param\u00e9terek, az SQL injection t\u00e1mad\u00e1s kiv\u00e9d\u00e9s\u00e9hez</li> </ul> <p>Figyelj\u00fck meg, hogy a parancsnak meg kell adnunk, milyen kapcsolaton kereszt\u00fcl tud lefutni. Tov\u00e1bb\u00e1 a tranzakci\u00f3 is a parancs tulajdons\u00e1ga, hiszen a fejleszt\u0151 feladata eld\u00f6nteni, hogy egy adott parancsot egy tranzakci\u00f3 r\u00e9sz\u00e9nek sz\u00e1n-e.</p>"},{"location":"lecture-notes/adonet/#vegrehajtas","title":"V\u00e9grehajt\u00e1s","text":"<p>Miut\u00e1n el\u0151k\u00e9sz\u00edtett\u00fck a <code>Command</code>-ot, v\u00e9gre is hajthatjuk azt. Ehhez t\u00f6bbf\u00e9le lehet\u0151s\u00e9g k\u00f6z\u00fcl is v\u00e1laszthatunk, att\u00f3l f\u00fcgg\u0151en, hogy mit v\u00e1runk visszat\u00e9r\u00e9si \u00e9rt\u00e9knek.</p> <ul> <li><code>ExecuteReader</code>: t\u00f6bb rekord lek\u00e9rdez\u00e9se</li> <li><code>ExecuteScalar</code>: egyetlen skal\u00e1r \u00e9rt\u00e9k lek\u00e9rdez\u00e9se</li> <li><code>ExecuteNonQuery</code>: olyan lek\u00e9rdez\u00e9s, ami nem eredm\u00e9nyhalmazt ad vissza (pl. <code>INSERT</code>) - az \u00e9rintett sorok sz\u00e1m\u00e1t adja vissza, pl. t\u00f6rl\u00e9s eset\u00e9n ebb\u0151l d\u00f6nthet\u0151 el, hogy sikeres volt-e a m\u0171velet (megtal\u00e1lta-e a t\u00f6rlend\u0151 rekordot)</li> <li><code>ExecuteXmlReader</code> (MS SQL Server): XML dokumentumot (<code>XmlReader</code> objektum) ad vissza, az eredm\u00e9ny egy rekord egyetlen XML oszlopa</li> </ul> <p>Parancsokat \u00fajrafelhaszn\u00e1lni is tudunk, a <code>Command.Prepare()</code> (szerver oldalon el\u0151k\u00e9sz\u00edti a parancs futtat\u00e1s\u00e1t) h\u00edv\u00e1s ut\u00e1n, \u00e1m ez csak akkor \u00e9ri meg, ha elegend\u0151en sokszor futtatjuk az utas\u00edt\u00e1st (esetleg m\u00e1s-m\u00e1s param\u00e9terekkel), mivel az el\u0151k\u00e9sz\u00edt\u00e9s \u00e9s el\u0151k\u00e9sz\u00fclten tart\u00e1s id\u0151- \u00e9s er\u0151forr\u00e1sig\u00e9nyes.</p> <p>P\u00e9lda parancs haszn\u00e1lat\u00e1ra:</p> <pre><code>// kapcsolatot l\u00e9trehoz\u00e1sa, megnyit\u00e1sa\n...\nvar command = new SqlCommand();\ncommand.Connection = connection;\n// a command.Connection be\u00e1ll\u00edt\u00e1s nem sz\u00fcks\u00e9ges, ha a connection-\u00f6n\n// hozzuk l\u00e9tre a parancsot: command = connection.CreateCommand()\ncommand.CommandType = CommandType.StoredProcedure;\ncommand.CommandText = \"SalesByCategory\"; // t\u00e1rolt elj\u00e1r\u00e1s neve\n\n/* egyen\u00e9rt\u00e9k\u0171, de \"C#-osabb\" szintaxis:\nvar command = new SqlCommand()\n{\n    Connection = connection,\n    CommandType = CommandType.StoredProcedure,\n    CommandText = \"SalesByCategory\"\n}*/\n\n// SQL injection elleni v\u00e9delem\nvar parameter = new SqlParameter();\nparameter.ParameterName = \"@CategoryName\"; // ilyen n\u00e9ven ker\u00fcl bele a lek\u00e9rdez\u00e9sbe\nparameter.SqlDbType = SqlDbType.NVarChar;\nparameter.Value = categoryName; // C# v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke\ncommand.Parameters.Add(parameter);\n\nvar reader = command.ExecuteReader();\n// ennek feldogloz\u00e1s\u00e1t l\u00e1sd k\u00e9s\u0151bb\n</code></pre>"},{"location":"lecture-notes/adonet/#tranzakciok","title":"Tranzakci\u00f3k","text":"<p>Tranzakci\u00f3kat ADO.NET-ben nem a <code>begin tran</code> SQL utas\u00edt\u00e1ssal kell kezdem\u00e9nyezni. Az ADO.NET objektumokat biztos\u00edt a tranzakci\u00f3 ind\u00edt\u00e1s\u00e1ra \u00e9s kezel\u00e9s\u00e9re, erre az al\u00e1bbi k\u00f3dr\u00e9szlet mutat p\u00e9ld\u00e1t. Figyelj\u00fck meg a <code>using</code> blokkok haszn\u00e1lat\u00e1t is az er\u0151forr\u00e1sok megfelel\u0151 \u00e9s biztons\u00e1gos lez\u00e1r\u00e1sa \u00e9rdek\u00e9ben.</p> <pre><code>// Connection string megalkot\u00e1sa\n...\nusing (var connection = new SqlConnection(connectionString))\n{\n    connection.Open(); // ne felejts\u00fck, a new nem nyitja meg a kapcsolatot\n\n    var transaction = connection.BeginTransaction();\n    // param\u00e9ter az indul\u00f3 tranzakci\u00f3 neve \u00e9s/vagy az izol\u00e1ci\u00f3s szint\n\n    var command = new SqlCommand()\n    {\n        Connection = connection,\n        CommandText = \"INSERT into CarTable (Description) VALUES('...')\",\n        Transaction = transaction\n    }\n\n    try\n    {\n        command.ExecuteNonQuery();\n        // a sikeres tranzakci\u00f3s kommitolni KELL\n        transaction.Commit();\n\n        Console.WriteLine(\"Sikeres tranzakci\u00f3!\");\n    }\n    catch(Exception commitException)\n    {\n        Console.WriteLine(\"Commit Exception: \", commitException.ToString());\n\n        // A rollback nem felt\u00e9tlen\u00fcl sz\u00fcks\u00e9ges, a rendszer automatikusan elv\u00e9gzi\n        // a nem kommit\u00e1lt tranzakci\u00f3n. Az al\u00e1bbi szeml\u00e9ltet\u0151 p\u00e9lda csup\u00e1n.\n        try\n        {\n            transaction.RollBack();\n        }\n        catch(Exception rollBackException)\n        {\n            Console.WriteLine(\"Rollback Exception: \", rollBackException.ToString());\n        }\n    }\n}\n</code></pre> <p>Tranzakci\u00f3 timeout</p> <p>Minden ADO.NET tranzakci\u00f3 fut\u00e1si ideje limit\u00e1lva van a MachineConfig-ban r\u00f6gz\u00edtett id\u0151intervallummal. Ez egy olyan rendszerszint\u0171 be\u00e1ll\u00edt\u00e1s, amely minden, a rendszeren fut\u00f3 .NET alkalmaz\u00e1sra \u00e9rv\u00e9nyes, ez\u00e9rt az \u00e9rt\u00e9k\u00e9t nem c\u00e9lszer\u0171 \u00e1ll\u00edtani. A hosszan fut\u00f3 tranzakci\u00f3k egy\u00e9bk\u00e9nt is probl\u00e9m\u00e1sak, ez\u00e9rt ker\u00fclj\u00fck haszn\u00e1latukat.</p> <p>Egy tranzakci\u00f3 \u00e1ltal\u00e1ban egy <code>Connection</code> objektumhoz tartozik, de k\u00e9sz\u00edthet\u0151 olyan tranzakci\u00f3 is, melyben t\u00f6bb perzisztens er\u0151forr\u00e1skezel\u0151 (m\u00e1s adatb\u00e1zisok, \u00fczenetsorok, b\u00e1rmi, ami t\u00e1mogat tranzakci\u00f3kat) is \u00e9rintett lehet. Innent\u0151l elosztott tranzakci\u00f3kezel\u00e9sr\u0151l besz\u00e9l\u00fcnk, amihez valamif\u00e9le k\u00fcls\u0151 tranzakci\u00f3kezel\u0151, mint p\u00e9ld\u00e1ul Microsoft Distributed Transaction Coordinator (MS DTC) sz\u00fcks\u00e9ges. Az ilyen esetek szint\u00e9n ker\u00fclend\u0151k, hacsak nem komplex esetr\u0151l \u00e9s j\u00f3l \u00e1tgondolt rendszerr\u0151l van sz\u00f3.</p>"},{"location":"lecture-notes/adonet/#null-ertekek","title":"NULL \u00e9rt\u00e9kek","text":"<p>Honnan tudjuk meg, hogy a lek\u00e9rdez\u00e9s\u00fcnk eredm\u00e9nye \u00fcres halmaz? \u00c9s honnan tudjuk meg, hogy egy visszaadott eredm\u00e9ny halmaz valamely rekordj\u00e1nak oszlop\u00e1ban nem szerepel adat? .NET-ben a <code>null</code> \u00e9rt\u00e9ket szoktuk vizsg\u00e1lni, de egy adatb\u00e1zis <code>NULL</code> elt\u00e9r\u0151 \u00e9rt\u00e9ket vehet fel az oszlop t\u00edpus\u00e1t\u00f3l (int, string, stb.) f\u00fcgg\u0151en. Teh\u00e1t, hogyan ellen\u0151rizz\u00fck, hogy van-e \u00e9rt\u00e9k a lek\u00e9rdez\u00e9s eredm\u00e9ny\u00e9ben?</p> <ul> <li>Ha azt akarjuk megvizsg\u00e1lni, hogy a lek\u00e9rdez\u00e9s eredm\u00e9nyhalmaza tartalmaz-e rekordokat, akkor a <code>DataReader.HasRows</code> <code>bool</code> property-j\u00e9nek vizsg\u00e1lat\u00e1val tehetj\u00fck ezt meg.</li> <li>Ha az eredm\u00e9nyhalmaz adott oszlop\u00e1nak \u00e9rt\u00e9k\u00e9t szeretn\u00e9nk vizsg\u00e1lni: <code>reader[\"oszlopnev\"].IsNull;</code> vagy <code>reader.IsDbNull(index)</code>.</li> <li>Ha <code>NULL</code> \u00e9rt\u00e9ket akarunk manu\u00e1lisan besz\u00farni egy \u00faj rekordba: pl. <code>SqlString.Null</code> vagy <code>DBNull.Value</code>.</li> </ul>"},{"location":"lecture-notes/adonet/#a-lekerdezes-eredmenye","title":"A lek\u00e9rdez\u00e9s eredm\u00e9nye","text":"<p>Az ADO.NET k\u00e9tf\u00e9le m\u00f3dot is biztos\u00edt az adatok adatb\u00e1zisb\u00f3l val\u00f3 olvas\u00e1s\u00e1ra: <code>DataReader</code> \u00e9s <code>DataSet</code>. A k\u00e9t megold\u00e1s k\u00f6zti f\u0151 k\u00fcl\u00f6nbs\u00e9g a kapcsolat haszn\u00e1lat\u00e1ban \u00e9s az adatokkal val\u00f3 b\u00e1n\u00e1sm\u00f3dban van. Ennek megfelel\u0151en k\u00e9t modellt k\u00fcl\u00f6nb\u00f6ztet\u00fcnk meg: kapcsolat alap\u00fat (<code>DataReader</code>) \u00e9s kapcsolat n\u00e9lk\u00fclit (<code>DataSet</code>). A kapcsolat alap\u00fa modellben a kapcsolat az adatb\u00e1zissal v\u00e9gig fennmarad, mik\u00f6zben lek\u00e9rdez\u00e9seket hajtunk v\u00e9gre, m\u00edg a kapcsolat n\u00e9lk\u00fcli modellben egy <code>DataSet</code>-en v\u00e9gz\u00fcnk m\u00f3dos\u00edt\u00e1sokat \u00e9s ezt szinkroniz\u00e1ljuk id\u0151nk\u00e9nt az adatb\u00e1zissal, de a kapcsolat csak a szinkroniz\u00e1ci\u00f3 idej\u00e9re j\u00f6n l\u00e9tre. Mindegyiknek megvannak a maga el\u0151nyei \u00e9s h\u00e1tr\u00e1nyai, amiket a k\u00f6vetkez\u0151 r\u00e9szekben fogunk t\u00e1rgyalni.</p>"},{"location":"lecture-notes/adonet/#datareader","title":"DataReader","text":"<p>Az adatok lek\u00e9rdez\u00e9s\u00e9hez egy kapcsolatra van sz\u00fcks\u00e9g\u00fcnk. A kapcsolat r\u00f6vid fenn\u00e1ll\u00e1sa alatt friss, aktu\u00e1lis adatok \u00e9rkeznek az adatb\u00e1zisb\u00f3l, amiket tipikusan valamilyen bels\u0151 reprezent\u00e1ci\u00f3v\u00e1 alak\u00edtunk.</p> <p>Feldolgoz\u00e1s l\u00e9p\u00e9sei:</p> <ol> <li>kapcsolat megnyit\u00e1sa</li> <li>parancs futtat\u00e1sa az adatok lek\u00e9rdez\u00e9s\u00e9hez</li> <li>eredm\u00e9ny feldolgoz\u00e1sa (tipikusan: \u00fczleti logikai entit\u00e1sokra \u00e1tford\u00edt\u00e1s)</li> <li>reader lez\u00e1r\u00e1sa</li> <li>kapcsolat lez\u00e1r\u00e1sa</li> </ol> <p>A <code>DataReader</code> kapcsolati l\u00e1nc az adatb\u00e1zisig:</p> <p></p> <p>P\u00e9lda <code>DataReader</code> haszn\u00e1lat\u00e1ra:</p> <pre><code>using(var conn = new SqlConnection(connectionString))\n{\n    var command = new SqlCommand()\n    {\n      Connection = conn,\n      CommandText = \"SELECT ID, NAME FROM Product\"\n    }\n\n    conn.Open();\n    using(var reader = command.ExecuteReader())\n    {\n        while(reader.Read())\n        {\n            Console.WriteLine(\"{0}\\t{1}\", reader[\"ID\"], reader[\"Name\"]);\n            // tipikusan \u00fczleti logikai entit\u00e1st k\u00e9sz\u00edt\u00fcnk, amit egy mem\u00f3riabeli list\u00e1hoz adunk\n        }\n        // a using miatt nem kell reader.Close()\n    }\n    // a using miatt nem kell conn.Close()\n}\n</code></pre> <p>P\u00e1r dologra az\u00e9rt \u00e9rdemes odafigyelni!</p> <ul> <li>A <code>reader[\"ID\"]</code> eredm\u00e9nye <code>object</code> lesz, nem string vagy int. Helyettes\u00edthet\u0151 <code>reader.Get***(lek\u00e9rdez\u00e9sben_az_oszlop_indexe)</code> h\u00edv\u00e1ssal, ahol is a t\u00edpust (<code>String</code>, <code>Int32</code>, stb. is meg kell adnunk).</li> <li>Ha nem kompatibilisek a t\u00edpusok (pl. az adatb\u00e1zisban <code>nvarchar</code> \u00e9s mi <code>int32</code>-k\u00e9nt akarjuk olvasni), fut\u00e1s idej\u0171 hib\u00e1t fogunk kapni.</li> <li>Ha az adatb\u00e1zisban valamelyik oszlopban <code>NULL</code> \u00e9rt\u00e9k van a <code>reader.Get***</code> h\u00edv\u00e1sra szint\u00e9n fut\u00e1s idej\u0171 hib\u00e1t kapunk. Helyette ellen\u0151rizz\u00fck a <code>reader.IsDBNull(lek\u00e9rdez\u00e9sben_az_oszlop_indexe)</code> seg\u00edts\u00e9g\u00e9vel, \u00e9s ha ez <code>true</code>, akkor haszn\u00e1ljuk a t\u00edpusnak megfelel\u0151 <code>null</code> \u00e9rt\u00e9ket.</li> </ul> <p>El\u0151ny\u00f6k</p> <ul> <li> az adatok mindenkor a legfrissebbek, hiszen frissen az adatb\u00e1zisb\u00f3l k\u00e9rdezz\u00fck le</li> <li> egyszer\u0171bb konkurenciakezel\u00e9s, mert mindig friss adatokkal dolgozunk</li> <li> kisebb mem\u00f3ria ig\u00e9ny (l\u00e1sd majd a DataSet-et)</li> </ul> <p>H\u00e1tr\u00e1nyok</p> <ul> <li>folyamatos h\u00e1l\u00f3zati kapcsolat, am\u00edg m\u0171veleteket v\u00e9gz\u00fcnk - ez teh\u00e1t nem lehet hossz\u00fa idej\u0171</li> <li>a kapcsolatok darabsz\u00e1m\u00e1val rossz sk\u00e1l\u00e1zhat\u00f3s\u00e1g - ez\u00e9rt kell r\u00f6vid ideig haszn\u00e1lni a kapcsolatokat</li> </ul>"},{"location":"lecture-notes/adonet/#dataset","title":"DataSet","text":"<p>A <code>DataSet</code> egyfajta cache-nek, vagy mem\u00f3riabeli adatt\u00e1rnak tekinthet\u0151. Egy <code>adapter</code> (pl. <code>SqlDataAdapter</code>) seg\u00edts\u00e9g\u00e9vel k\u00e9ri le az adatb\u00e1zisb\u00f3l az adatokat, \u00e9s t\u00e1rolja el \u0151ket, majd z\u00e1rja a kapcsolatot az adatb\u00e1zissal. Ezt k\u00f6vet\u0151en ezen a <code>DataSet</code>-en tudunk m\u00f3dos\u00edt\u00e1sokat v\u00e9gezni, majd egy \u00faj kapcsolatban az <code>adapter</code> seg\u00edts\u00e9g\u00e9vel \"visszat\u00f6lteni\" (<code>update</code>) azt az adatb\u00e1zisba. \u00c9rdemes megjegyezni, hogy a lek\u00e9r\u00e9s \u00e9s az update k\u00f6z\u00f6tt eltelt id\u0151 alatt m\u00e1s m\u00f3dos\u00edthatja ugyanazt az adatb\u00e1zist, ez\u00e9rt is h\u00e1tr\u00e1nya a <code>DataSet</code>-nek a konkurens hozz\u00e1f\u00e9r\u00e9sekb\u0151l ad\u00f3d\u00f3 \u00fctk\u00f6z\u00e9s, \u00e9s a m\u00e1r kor\u00e1bban a tranzakci\u00f3kezel\u00e9sn\u00e9l megismert konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9m\u00e1k.</p> <p>Feldolgoz\u00e1s l\u00e9p\u00e9sei:</p> <ol> <li>kapcsolat megnyit\u00e1sa</li> <li><code>DataSet</code> felt\u00f6lt\u00e9se az adatb\u00e1zis egy r\u00e9sz\u00e9vel</li> <li>kapcsolat lez\u00e1r\u00e1sa</li> <li><code>DataSet</code> feldolgoz\u00e1sa (pl. felhaszn\u00e1l\u00f3 fel\u00fcleten megjelen\u00edteni, szerkeszteni) - ez hosszabb ideig is tarthat</li> <li>kapcsolat megnyit\u00e1sa</li> <li>v\u00e1ltoztat\u00e1sok visszat\u00f6lt\u00e9se</li> <li>kapcsolat lez\u00e1r\u00e1sa</li> </ol> <p>Az adatel\u00e9r\u00e9s m\u0171k\u00f6d\u00e9se <code>adapter</code>-rel kapcsolat n\u00e9lk\u00fcli modellben az al\u00e1bbi \u00e1br\u00e1n l\u00e1that\u00f3.</p> <p></p> <p><code>DataSet</code> kapcsolati l\u00e1nc az adatb\u00e1zisig:</p> <p></p> <p>P\u00e9lda <code>DataSet</code> haszn\u00e1lat\u00e1ra:</p> <pre><code>var dataSet = new DataSet();\nvar adapter = new SqlDataAdapter();\n\n// kapcsolatot nyitunk, felt\u00f6ltj\u00fck a DataSet-et az adatb\u00e1zisb\u00f3l, majd z\u00e1rjuk a kapcsolatot\nusing(var conn = new SqlConnection(connectionString))\n{\n    adapter.SelectCommand = new SqlCommand(\"SELECT * FROM Product\", conn);\n\n    conn.Open();\n    adapter.Fill(dataSet);\n}\n\n-------------------------------------------------------\n// dolgozunk az adatokkal/adatokon\n// tipikusan felhaszn\u00e1l\u00f3 fel\u00fcleten t\u00f6rt\u00e9nik, ez itt szeml\u00e9ltet\u0151 p\u00e9lda\nforeach(var row in dataSet.Tables[\"Product\"].Rows)\n{\n    Console.WriteLine(\"{0}\\t{1}\", row[\"ID\"], row[\"Name\"]);\n    row[\"Name\"] = \"new value\";\n}\n-------------------------------------------------------\n\n// Tipikusan id\u0151ben k\u00e9s\u0151bb, pl. egy \"ment\u00e9s\" gomb hat\u00e1s\u00e1ra kezd\u0151dik\n// Kapcsolatot nyitunk, update-elj\u00fck az adatb\u00e1zist, majd z\u00e1rjuk a kapcsolatot\nusing(var conn = new SqlConnection(connectionString))\n{\n    conn.Open();\n    adapter.Update(dataSet);\n    //dataSet.AcceptChanges(); -- \u00edgy csak a DataSet friss\u00fclne, az adatb\u00e1zis nem\n}\n</code></pre> <p>\u00c9rdemes megfigyelni, hogy az <code>adapter</code> csak a <code>Command</code>-on kereszt\u00fcl kommunik\u00e1l az adatb\u00e1zissal. Egy <code>adapter</code> t\u00f6bb ilyen <code>Command</code>-ot is haszn\u00e1lhat, ez\u00e1ltal t\u00f6bb <code>Connection</code>-nel ak\u00e1r t\u00f6bb adatb\u00e1zison is dolgozhatunk ugyanazon <code>DataSet</code>-tel.</p> <p>El\u0151ny\u00f6k</p> <ul> <li> nem sz\u00fcks\u00e9ges folyamatos h\u00e1l\u00f3zati kapcsolat</li> </ul> <p>H\u00e1tr\u00e1nyok</p> <ul> <li>\u00fctk\u00f6z\u00e9sek lehetnek a visszament\u00e9s sor\u00e1n</li> <li>a <code>DataSet</code> adatai nem mindig a legfrissebbek</li> <li>mem\u00f3ri\u00e1t foglal - szerver oldalon ez\u00e9rt is nem haszn\u00e1ljuk</li> </ul>"},{"location":"lecture-notes/adonet/#veszelyforrasok","title":"Vesz\u00e9lyforr\u00e1sok","text":""},{"location":"lecture-notes/adonet/#sql-injection","title":"SQL injection","text":"<p>Az SQL injection az a s\u00falyos hiba, amikor \u00fagy futtatunk egy lek\u00e9rdez\u00e9st, hogy a benne szerepl\u0151 param\u00e9terek \u00e9rt\u00e9k\u00e9t nem ellen\u0151rizz\u00fck futtat\u00e1s el\u0151tt. A param\u00e9terek \u00e9rkezhetnek kliens oldalr\u00f3l, felhaszn\u00e1l\u00f3 \u00e1ltal kiv\u00e1lasztott, vagy megadott adatokkal. Ebb\u0151l akkor sz\u00e1rmazhat probl\u00e9ma, ha egy rosszindulat\u00fa felhaszn\u00e1l\u00f3 SQL parancsot \u00edr egy olyan mez\u0151be, ahonnan m\u00e1st v\u00e1rn\u00e1nk. P\u00e9ld\u00e1ul egy felhaszn\u00e1l\u00f3nevet v\u00e1rn\u00e1nk, de helyette a <code>Monkey92); DROP TABLE Users;--</code> \u00e9rt\u00e9k \u00e9rkezik. Ha ezt a sz\u00f6veget befogadn\u00e1nk \u00e9s beilleszten\u00e9nk az SQL utas\u00edt\u00e1sunkba, azzal a <code>drop table</code>-t is v\u00e9grehajtan\u00e1nk, ezzel t\u00f6r\u00f6lve egy t\u00e1bl\u00e1nkat. Ez kifejezetten s\u00falyos hiba!</p> <p>MEGOLD\u00c1S</p> <p>Param\u00e9terek haszn\u00e1lata (l\u00e1sd: Command r\u00e9sz parancs l\u00e9trehoz\u00e1sa p\u00e9lda).</p>"},{"location":"lecture-notes/adonet/#connection-string","title":"Connection string","text":"<p>A connection string megalkot\u00e1sa nagyon hasonl\u00f3 hib\u00e1t rejt mag\u00e1ban, mint az SQL injection. Tegy\u00fck fel, hogy a felhaszn\u00e1l\u00f3t\u00f3l k\u00e9r\u00fcnk valamif\u00e9le adatot (pl. felhaszn\u00e1l\u00f3n\u00e9v, jelsz\u00f3). Ilyenkor nem tudhatjuk, hogy pontosan mit fogunk kapni. A connection string kulcs-\u00e9rt\u00e9k p\u00e1rokb\u00f3l \u00e1ll \u00e9s sok adatb\u00e1zis last-wins elvet alkalmaz ezekre. Ez a gyakorlatban azt jelenti, hogy ha egy kulcsra t\u00f6bb \u00e9rt\u00e9k is meg van adva a string-ben, akkor az jut \u00e9rv\u00e9nyre, ami k\u00e9s\u0151bb szerepel benne. Vagyis, ha a beg\u00e9pelt felhaszn\u00e1l\u00f3n\u00e9v \u00e9s jelsz\u00f3 ut\u00e1n j\u00f6n egy olyan kulcs-\u00e9rt\u00e9k p\u00e1r, ami m\u00e1r szerepelt a string-ben, akkor az \u00faj fel\u00fcl\u00edrja a r\u00e9git, ez pedig nagy kock\u00e1zatot rejt mag\u00e1ban, hiszen egy rossz indulat\u00fa felhaszn\u00e1l\u00f3 \u00edgy saj\u00e1t maga \u00e1ltal megadott param\u00e9tereket injekt\u00e1lhat a connection stringbe.</p> <p>MEGOLD\u00c1S</p> <p><code>ConnectionStringBuilder</code> haszn\u00e1lata (l\u00e1sd: Connection r\u00e9sz)</p>"},{"location":"lecture-notes/adonet/#connection-leak","title":"Connection leak","text":"<p>Amennyiben nem z\u00e1runk le minden <code>Connection</code>-t, akkor ah\u00e1nyszor lez\u00e1ratlan kapcsolatot tartalmaz\u00f3 k\u00f3dr\u00e9sz hajt\u00f3dik v\u00e9gre, annyiszor haszn\u00e1lunk el egy <code>Connection</code>-t a pool-b\u00f3l, a v\u00e9g\u00e9n pedig nem marad t\u00f6bb, \u00e9s az alkalmaz\u00e1sunk megakad. Ez az\u00e9rt alattomos hiba, mert \"csak\" az alkalmaz\u00e1s egy bizonyos ideig t\u00f6rt\u00e9n\u0151 fut\u00e1sa sor\u00e1n fog jelentkezni - a fejleszt\u0151 g\u00e9p\u00e9n szinte soha. Az ilyen probl\u00e9m\u00e1t neh\u00e9z felismerni.</p> <p>MEGOLD\u00c1S</p> <p><code>using</code> blokk haszn\u00e1lata a kapcsolat megnyit\u00e1s\u00e1ra, mert \u00edgy a blokk v\u00e9g\u00e9n mindig lez\u00e1r\u00f3dik a kapcsolat (l\u00e1sd: Tranzakci\u00f3 r\u00e9sz p\u00e9lda, vagy DataReader, vagy DataSet)</p> <p>A <code>DataReader</code>-t hasonl\u00f3an le kell z\u00e1rni, \u00e9s ugyan\u00fagy haszn\u00e1lhat\u00f3 r\u00e1 a <code>using</code> is.</p>"},{"location":"lecture-notes/architecture/","title":"Adatvez\u00e9relt rendszerek \u00e9s a t\u00f6bbr\u00e9teg\u0171 (h\u00e1romr\u00e9teg\u0171) architekt\u00fara","text":""},{"location":"lecture-notes/architecture/#mit-nevezunk-adatvezerelt-alkalmazasnak","title":"Mit nevez\u00fcnk adatvez\u00e9relt alkalmaz\u00e1snak?","text":"<p>Minden alkalmaz\u00e1s valamilyen m\u00f3don adatokat kezel, hiszen a sz\u00e1m\u00edt\u00f3g\u00e9p mem\u00f3ri\u00e1j\u00e1ban adatok vannak, \u00e9s a program ezeket manipul\u00e1lja. De m\u00e9gse minden alkalmaz\u00e1s adatvez\u00e9relt. Akkor h\u00edvunk egy alkalmaz\u00e1st adatvez\u00e9reltnek, ha a szoftver els\u0151dleges c\u00e9lja a tartalmazott adatok kezel\u00e9se.</p> <p>M\u00e1s sz\u00f3val, az adatvez\u00e9relt alkalmaz\u00e1s az\u00e9rt j\u00f6n l\u00e9tre, hogy adatokat t\u00e1roljon, megjelen\u00edtsen, manipul\u00e1ljon. A felhaszn\u00e1l\u00f3 az\u00e9rt l\u00e9p interakci\u00f3ba az alkalmaz\u00e1ssal, hogy az adatokhoz hozz\u00e1f\u00e9rjen.</p> <p>Egy sakkprogram eset\u00e9ben a t\u00e1bla \u00e1ll\u00e1sa mem\u00f3ri\u00e1ban tal\u00e1lhat\u00f3 adat. De a sakkprogram nem az\u00e9rt j\u00f6n l\u00e9tre, hogy ezt a mem\u00f3riabeli t\u00e1bl\u00e1t manipul\u00e1lja, hanem az\u00e9rt, hogy a j\u00e1t\u00e9kos sakkozzon.</p> <p>Egy adatvez\u00e9relt alkalmaz\u00e1sban az adat hat\u00e1rozza meg, hogy mik\u00e9nt m\u0171k\u00f6dik a szoftver. P\u00e9ld\u00e1ul az adat rekordok egyes attrib\u00fatumainak f\u00fcggv\u00e9ny\u00e9ben \u00e9rtelmezhet\u0151 egy t\u00f6rl\u00e9s m\u0171velet a rekordra, vagy sem. Egy hasonl\u00f3 p\u00e9lda, ahol az adat maga hat\u00e1rozza meg a rajta v\u00e9grehajthat\u00f3 m\u0171veleteket, a Neptun rendszerben a vizsgajelentkez\u00e9s. A f\u00e9l\u00e9vhez tartoz\u00f3 id\u0151szakok, bele\u00e9rtve, hogy mikor kezd\u0151dik a vizsgaid\u0151szak, maga is a Neptun rendszer adatai k\u00f6z\u00f6tt tal\u00e1lhat\u00f3. Ezen adat hat\u00e1rozza meg, hogy a felhaszn\u00e1l\u00f3 (hallgat\u00f3) tud-e egy vizsg\u00e1ra jelentkezni. Att\u00f3l, hogy egyik \u00e9vben m\u00e1skor kezd\u0151dik a vizsgaid\u0151szak, a program logik\u00e1ja (k\u00f3dja) nem v\u00e1ltozik meg, a szoftver m\u00e9gis k\u00e9pes m\u00e1shogyan viselkedni.</p>"},{"location":"lecture-notes/architecture/#pelda-adatvezerelt-alkalmazasra","title":"P\u00e9lda adatvez\u00e9relt alkalmaz\u00e1sra","text":"<p>A m\u00e1r eml\u00edtett Neptun rendszer egy tipikus adatvez\u00e9relt alkalmaz\u00e1s. C\u00e9lja az oktat\u00e1shoz kapcsol\u00f3d\u00f3 adatok, a kurzusok, jegyek, vizsg\u00e1k, stb. kezel\u00e9se.</p> <p>Egy m\u00e1sik p\u00e9lda a Gmail: az\u00e9rt l\u00e9tezik, hogy adatokat (itt: emailek, csatolm\u00e1nyok, kontaktok) kezeljen. Az alkalmaz\u00e1s minden funkci\u00f3ja ezen adatok kezel\u00e9s\u00e9r\u0151l, megjelen\u00edt\u00e9s\u00e9r\u0151l, manipul\u00e1l\u00e1s\u00e1r\u00f3l sz\u00f3l. Mindemellett, az adatokat hossz\u00fa t\u00e1von meg\u0151rzi, azaz minden m\u00f3dos\u00edt\u00e1s a rendszerben megmarad.</p>"},{"location":"lecture-notes/architecture/#adatvezerelt-rendszer-felepitese","title":"Adatvez\u00e9relt rendszer fel\u00e9p\u00edt\u00e9se","text":"<p>Vegy\u00fck a Gmail p\u00e9ld\u00e1j\u00e1t. Szeretn\u00e9nk egy olyan modern email rendszert \u00e9p\u00edteni, ahol lehet:</p> <ul> <li>emaileket k\u00fcldeni \u00e9s fogadni,</li> <li>van webes \u00e9s mobil fel\u00fclete is,</li> <li>a felhaszn\u00e1l\u00f3i fel\u00fclet t\u00f6bb nyelvet is t\u00e1mogat,</li> <li>tudunk f\u00e1jlokat csatolni</li> <li>a csatolm\u00e1nyokat ak\u00e1r Google Drive-r\u00f3l is tudjuk hivatkozni,</li> <li>tudjuk k\u00e9sleltetni egy email elk\u00fcld\u00e9s\u00e9t,</li> <li>stb.</li> </ul> <p>Gondoljuk v\u00e9gig</p> <p>Hogyan kezden\u00e9nk neki egy ilyen alkalmaz\u00e1s fejleszt\u00e9s\u00e9nek?</p> <p>Ez tal\u00e1n t\u00fal neh\u00e9z k\u00e9rd\u00e9s. Kezdj\u00fck egy egyszer\u0171bb k\u00e9rd\u00e9ssel: tegy\u00fck fel, hogy m\u00e1r majdnem minden r\u00e9sze m\u0171k\u00f6dik az alkalmaz\u00e1snak, csak \u00e9ppen a k\u00e9sleltetett email k\u00fcld\u00e9s hi\u00e1nyzik; ezt hogyan implement\u00e1ln\u00e1nk?</p> <p>P\u00e9ld\u00e1ul lehetne \u00fagy, hogy az email k\u00fcld\u00e9se gombra kattint\u00e1sn\u00e1l elind\u00edtunk egy id\u0151z\u00edt\u0151t, ami 1 perc m\u00falva ind\u00edtja csak az email k\u00fcld\u00e9st. Ez az\u00e9rt nem lesz j\u00f3 megold\u00e1s, mert ha k\u00f6zben bez\u00e1rjuk a web b\u00f6ng\u00e9sz\u0151t, akkor nem fog az id\u0151z\u00edt\u0151 lej\u00e1rni, \u00e9s nem lesz elk\u00fcldve az email.</p> <p>Helyette csin\u00e1lhatjuk \u00fagy, hogy r\u00f6gz\u00edtj\u00fck az email mellett, hogy mikor kell elk\u00fcldeni, \u00edgy ez az inform\u00e1ci\u00f3 is az email, mint kezelt adat r\u00e9sze lesz. Ezzel eld\u00f6nt\u00f6tt\u00fck, hogy nem a felhaszn\u00e1l\u00f3i fel\u00fclet feladata lesz a k\u00e9sleltetett email k\u00fcld\u00e9s. M\u00e9g nem tudjuk, hogy milyen alkalmaz\u00e1s komponensre b\u00edzzuk a feladatot, de nem a felhaszn\u00e1l\u00f3 fel\u00fcletre.</p> <p>Miel\u0151tt meg tudjuk v\u00e1laszolni a k\u00e9rd\u00e9st, hogy m\u00e9gis milyen komponensnek lesz a dolga az email j\u00f6v\u0151beli kik\u00fcld\u00e9se, n\u00e9zz\u00fcnk egy hasonl\u00f3 k\u00e9rd\u00e9st.</p> <p>A Gmail az email \u00e9rkez\u00e9s\u00e9nek idej\u00e9t magyar felhaszn\u00e1l\u00f3knak magyar szok\u00e1s szerint (pl. \"15:23\"), m\u00e1s nyelv\u0171 felhaszn\u00e1l\u00f3knak a saj\u00e1t preferenci\u00e1ik szerint jelen\u00edti meg (pl. \"3:23 PM\"). Ez azt jelenti, hogy az email, mint adat rekord t\u00f6bbf\u00e9le \u00e9rkez\u00e9si id\u0151vel rendelkezik? Nyilv\u00e1n nem. Az email \u00e9rkez\u00e9si ideje egyetlen d\u00e1tum, egy univerz\u00e1lis reprezent\u00e1ci\u00f3ban, \u00e9s csak akkor ker\u00fcl \u00e1talak\u00edt\u00e1sra, amikor megjelen\u00edti a felhaszn\u00e1l\u00f3 fel\u00fclet.</p> <p>Meg\u00e1llap\u00edtottuk teh\u00e1t, hogy vannak feladatok, amelyek a felhaszn\u00e1l\u00f3i fel\u00fclet felel\u0151ss\u00e9gi k\u00f6r\u00e9be tartoznak, \u00e9s vannak olyanok, amelyek nem. \u00cdgy \u00e9rkez\u00fcnk meg a t\u00f6bbr\u00e9get\u0171-, avagy h\u00e1romr\u00e9teg\u0171 architekt\u00far\u00e1hoz.</p>"},{"location":"lecture-notes/architecture/#a-tobbretegu-haromretegu-architektura","title":"A t\u00f6bbr\u00e9teg\u0171 (h\u00e1romr\u00e9teg\u0171) architekt\u00fara","text":"<p>Adatvez\u00e9relt rendszereket tipikusan a t\u00f6bbr\u00e9teg\u0171-, avagy h\u00e1romr\u00e9teg\u0171 architekt\u00fara (three-layered / three-tiered architecture) szerint \u00e9p\u00edt\u00fcnk fel. Jelen kontextusban a k\u00e9t elnevez\u00e9st szinonimak\u00e9nt kezelj\u00fck. Ez az architekt\u00fara megk\u00fcl\u00f6nb\u00f6zteti az alkalmaz\u00e1s h\u00e1rom f\u0151 komponenscsal\u00e1dj\u00e1t, avagy r\u00e9teg\u00e9t:</p> <ul> <li>a megjelen\u00edt\u00e9si r\u00e9teget,</li> <li>az \u00fczleti logikai r\u00e9teget,</li> <li>\u00e9s az adatel\u00e9r\u00e9si r\u00e9teget.</li> </ul> <p>Ezen k\u00edv\u00fcl az architekt\u00far\u00e1hoz kapcsol\u00f3dik m\u00e9g:</p> <ul> <li>az adatb\u00e1zis, ill. k\u00fcls\u0151 adatforr\u00e1sok;</li> <li>\u00e9s az \u00fan. r\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok (l\u00e1sd k\u00e9s\u0151bb).</li> </ul> <p>Az alkalmaz\u00e1sunkat \u00fagy szervezz\u00fck meg, hogy az egyes komponensek (szoftver elemek) r\u00e9tegekbe szervez\u0151dnek, \u00e9s minden egyes r\u00e9teg m\u00e1s-m\u00e1s funkcionalit\u00e1s\u00e9rt felel. Ez a logikai szervez\u00e9s megk\u00f6nny\u00edti a szoftverfejleszt\u0151k munk\u00e1j\u00e1t az\u00e1ltal, hogy egy\u00e9rtelm\u0171 felel\u0151ss\u00e9gi k\u00f6r\u00f6ket \u00e9s hat\u00e1rokat jel\u00f6l ki a r\u00e9tegekben.</p> <p>Mi\u00e9rt t\u00f6bbr\u00e9teg\u0171, hiszen csak h\u00e1rom r\u00e9tege van</p> <p>Az elnevez\u00e9s arra utal, hogy mindegyik r\u00e9teg maga is tov\u00e1bb bonthat\u00f3 tov\u00e1bbi r\u00e9tegekre az alkalmaz\u00e1s komplexit\u00e1s\u00e1nak f\u00fcggv\u00e9ny\u00e9ben. Att\u00f3l t\u00f6bbr\u00e9teg\u0171 az architekt\u00fara, hogy kett\u0151n\u00e9l t\u00f6bb r\u00e9tege van. (\u00cdgy szembe\u00e1ll\u00edtva a k\u00e9tr\u00e9teg\u0171 architekt\u00far\u00e1val, ahol a felhaszn\u00e1l\u00f3i fel\u00fclet \u00e9s az \u00fczleti logikai r\u00e9teg nem v\u00e1lik el.)</p> <p>Az egyes r\u00e9tegek nem csak saj\u00e1t felel\u0151ss\u00e9gi k\u00f6rrel rendelkeznek, hanem egyben meghat\u00e1rozz\u00e1k azt az interf\u00e9szt, amit a r\u00e1\u00e9p\u00fcl\u0151 r\u00e9tegek haszn\u00e1lhatnak. Az adatel\u00e9r\u00e9si r\u00e9teg defini\u00e1lja, milyen m\u0171veleteken kereszt\u00fcl \u00e9rhet\u0151 el az \u00fczleti logikai r\u00e9teg sz\u00e1m\u00e1ra; az \u00fczleti logikai r\u00e9teg hasonl\u00f3an defini\u00e1lja az interf\u00e9sz\u00e9t a megjelen\u00edt\u00e9si r\u00e9teg fel\u00e9. Ennek megfelel\u0151en minden r\u00e9teg csak az alatta lev\u0151vel kommunik\u00e1l (\u00edgy teh\u00e1t a prezent\u00e1ci\u00f3s r\u00e9teg nem ad ki pl. SQL lek\u00e9rdez\u00e9st az adatb\u00e1zis fel\u00e9), valamint a r\u00e9tegek \u00e1ltal defini\u00e1lt interf\u00e9sz m\u00f6g\u00f6tt az implement\u00e1ci\u00f3 cser\u00e9lhet\u0151v\u00e9 v\u00e1lik, \u00edgy el\u0151seg\u00edtve az alkalmaz\u00e1s hossz\u00fa karbantarthat\u00f3s\u00e1g\u00e1t.</p> <p>A r\u00e9tegek sz\u00e9tv\u00e1laszt\u00e1s\u00e1nak k\u00f6sz\u00f6nhet\u0151en az is gyakori, hogy az alkalmaz\u00e1sunk nem egy helyen, hanem a r\u00e9tegek ment\u00e9n t\u00f6bb kiszolg\u00e1l\u00f3n fut. Leggyakoribb esete ennek a megjelen\u00edt\u00e9si r\u00e9teg lev\u00e1laszt\u00e1sa, amely p\u00e9ld\u00e1ul egy webalkalmaz\u00e1s eset\u00e9n a felhaszn\u00e1l\u00f3 sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n a b\u00f6ng\u00e9sz\u0151ben fut, m\u00edg a t\u00f6bbi komponens a t\u00e1voli kiszolg\u00e1l\u00f3n tal\u00e1lhat\u00f3. Hasonl\u00f3an gyakori, hogy az adatr\u00e9teg (pl. adatb\u00e1zis) egy saj\u00e1t kiszolg\u00e1l\u00f3t kap teljes\u00edtm\u00e9ny okokb\u00f3l. Am\u00edg a r\u00e9tegek k\u00f6z\u00f6tti interf\u00e9szek v\u00e1ltozatlanok maradnak, a r\u00e9tegek ak\u00e1r kiszolg\u00e1l\u00f3k k\u00f6z\u00f6tt is mozgathat\u00f3ak. Ennek tipikus oka a teljes\u00edtm\u00e9ny-optimaliz\u00e1l\u00e1s \u00e9s a nagy terhel\u00e9sek kiszolg\u00e1l\u00e1s\u00e1nak el\u0151seg\u00edt\u00e9se (pl. forgalmas webhelyek eset\u00e9ben).</p> <p>Layer / tier</p> <p>Az architekt\u00fara angol elnevez\u00e9se megk\u00fcl\u00f6nb\u00f6zteti a logikai \u00e9s fizikai elv\u00e1laszt\u00e1st. A three-layered elnevez\u00e9sben a r\u00e9tegek logikailag k\u00fcl\u00f6nv\u00e1lnak, de azonos kiszolg\u00e1l\u00f3n futnak. A three-tiered azonban a r\u00e9tegek (tier) ment\u00e9n fizikai elv\u00e1laszt\u00e1s\u00e1ra, k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon val\u00f3 fut\u00e1sra is utal.</p> <p>Egy j\u00f3 architekt\u00far\u00e1val rendelkez\u0151 alkalmaz\u00e1s hossz\u00fa \u00e9letciklusa sor\u00e1n is karbantarthat\u00f3 marad. A r\u00e9tegez\u00e9s nem plusz teherk\u00e9nt, betartand\u00f3 szab\u00e1lyok halmazak\u00e9nt, hanem mank\u00f3k\u00e9nt seg\u00edti a fejleszt\u0151ket a k\u00f3d fejleszt\u00e9s\u00e9ben. Ez\u00e9rt egy t\u00f6bbr\u00e9teg\u0171 alkalmaz\u00e1s fejleszt\u00e9se sor\u00e1n fontos, hogy pontosan \u00e9rts\u00fck, mely r\u00e9tegek milyen felel\u0151ss\u00e9gekkel rendelkeznek, \u00e9s milyen feladatok tartoznak hozz\u00e1juk.</p> <p>A r\u00e9teges fel\u00e9p\u00edt\u00e9s nem azt jelenti, hogy a felhaszn\u00e1l\u00f3k \u00e1ltal haszn\u00e1lt funkci\u00f3k csak egy-egy r\u00e9tegben jelennek meg. A legt\u00f6bb funkci\u00f3 valamilyen m\u00f3don az \u00f6sszes r\u00e9tegben megjelenik: a funkci\u00f3hoz tartozik felhaszn\u00e1l\u00f3i fel\u00fclet, valamilyen adatkezel\u00e9s az \u00fczleti logik\u00e1ban, \u00e9s az eredm\u00e9ny ment\u00e9sre ker\u00fcl az adatb\u00e1zisba.</p> <p>A t\u00f6bbr\u00e9teg\u0171 architekt\u00far\u00e1val k\u00e9sz\u00fcl\u0151 alkalmaz\u00e1sok k\u00f3d szervez\u00e9se is t\u00fckr\u00f6zi a r\u00e9tegek fel\u00e9p\u00edt\u00e9s\u00e9t. Az adott programoz\u00e1si k\u00f6rnyezet lehet\u0151s\u00e9geit \u00e9s szok\u00e1sait figyelembe v\u00e9ve az egyes r\u00e9tegeket k\u00fcl\u00f6n projektekbe, csomagokba szok\u00e1s elhelyezni. Ez egy\u00e9rtelm\u0171v\u00e9 teszi az egym\u00e1sra \u00e9p\u00fcl\u00e9st is, hiszen a projektek \u00e9s csomagok k\u00f6z\u00f6tt \u00e1ltal\u00e1ban csak egyir\u00e1ny\u00fa hivatkoz\u00e1s lehets\u00e9ges (teh\u00e1t ha az \u00fczleti logikai csomag haszn\u00e1lja az adatel\u00e9r\u00e9si r\u00e9teget, akkor ford\u00edtva ez m\u00e1r nem t\u00f6rt\u00e9nhet meg).</p> <p>A t\u00f6bbr\u00e9teg\u0171 architekt\u00fara nem az egyetlen lehet\u0151s\u00e9g adatvez\u00e9relt alkalmaz\u00e1s megval\u00f3s\u00edt\u00e1sa eset\u00e9n. Kis, egyszer\u0171 alkalmaz\u00e1sokra c\u00e9lszer\u0171 lehet a k\u00e9tr\u00e9teg\u0171 architekt\u00fara, m\u00edg sokkal komplexebb rendszerek eset\u00e9n az alkalmaz\u00e1s tov\u00e1bbi darabol\u00e1sa is sz\u00fcks\u00e9ges lehet p\u00e9ld\u00e1ul \u00fan. mikroszolg\u00e1ltat\u00e1sok architekt\u00fara ir\u00e1ny\u00e1ba l\u00e9pve.</p>"},{"location":"lecture-notes/architecture/#a-tobbretegu-architektura-retegeinek-felelossege","title":"A t\u00f6bbr\u00e9teg\u0171 architekt\u00fara r\u00e9tegeinek felel\u0151ss\u00e9ge","text":"<p>Vizsg\u00e1ljuk meg alaposabban a r\u00e9tegeket, \u00e9s feladataikat, felel\u0151ss\u00e9geiket. Az architekt\u00fara r\u00e9szletesebben kifejtve az al\u00e1bbi elemeket tartalmazza.</p> <p></p> <p>Forr\u00e1s</p> <p>Microsoft Application Architecture Guide, 2<sup>nd</sup> Edition, https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ee658109%28v%3dpandp.10%29</p> <p>A r\u00e9tegeken \"lentr\u0151l felfel\u00e9\" haladunk v\u00e9gig.</p>"},{"location":"lecture-notes/architecture/#az-adatforrasok","title":"Az adatforr\u00e1sok","text":"<p>A leggyakoribb adatforr\u00e1s az adatb\u00e1zis. Ez lehet rel\u00e1ci\u00f3s, vagy ak\u00e1r NoSQL adatb\u00e1zis is. Feladata az adataink hossz\u00fa t\u00e1von megmarad\u00f3 \u00e9s megb\u00edzhat\u00f3 (\u00fan. \"perzisztens\") t\u00e1rol\u00e1sa. Tipikusan ez az adatb\u00e1zis egy megb\u00edzhat\u00f3 gy\u00e1rt\u00f3t\u00f3l sz\u00e1rmaz\u00f3 szoftver, amely egy k\u00fcl\u00f6n erre a c\u00e9lra \u00fczemeltetett kiszolg\u00e1l\u00f3n fut, \u00edgy az adatel\u00e9r\u00e9si r\u00e9teg h\u00e1l\u00f3zaton kereszt\u00fcl \u00e9ri el.</p> <p>El\u0151fordulhat az is, hogy a rendszer \u00e1ltal kezelt adatok nem mind a saj\u00e1t adatb\u00e1zisunkban tal\u00e1lhat\u00f3ak, hanem olyan m\u00e1s k\u00fcls\u0151 szolg\u00e1ltat\u00e1sokban, amelyeket \"adatb\u00e1zisk\u00e9nt\" haszn\u00e1lunk. P\u00e9ld\u00e1ul a Gmail eset\u00e9n f\u00e1jl csatolm\u00e1nyok t\u00e1rolhat\u00f3ak az emailekkel egy\u00fctt egy adatb\u00e1zisban, de lehet\u0151s\u00e9g\u00fcnk van Google Drive-r\u00f3l is csatolni f\u00e1jlokat. A Gmail ilyenkor a Google Drive-r\u00f3l let\u00f6lti az el\u00e9rhet\u0151 f\u00e1jlok list\u00e1j\u00e1t, hogy a felhaszn\u00e1l\u00f3 kiv\u00e1lassza a csatoland\u00f3 mell\u00e9kletet. A Google Drive nem adatb\u00e1zis, m\u00e9gis, a haszn\u00e1lat szempontj\u00e1b\u00f3l adatforr\u00e1sk\u00e9nt m\u0171k\u00f6dik.</p> <p>Az ilyen jelleg\u0171 k\u00fcls\u0151 szolg\u00e1ltat\u00e1sokat az\u00e9rt az adatb\u00e1zisok mellett helyezz\u00fck el k\u00e9pzeletben, mert a mi alkalmaz\u00e1sunk sz\u00e1m\u00e1ra csak adatokat szolg\u00e1ltatnak (pl. list\u00e1zd az el\u00e9rhet\u0151 f\u00e1jlokat). A bels\u0151 m\u0171k\u00f6d\u00e9s\u00fckbe nem l\u00e1tunk bele, \u00e9s nem is c\u00e9lunk azt meg\u00e9rteni. Ilyen szempontb\u00f3l nem nagy a k\u00fcl\u00f6nbs\u00e9g egy rel\u00e1ci\u00f3s adatb\u00e1zis \u00e9s egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1s k\u00f6z\u00f6tt.</p> <p>Ma m\u00e1r t\u00f6bb modern adatb\u00e1zis-kezel\u0151 rendszer is gyakran rendelkezik a k\u00fcls\u0151 szolg\u00e1ltat\u00e1sok el\u00e9r\u00e9s\u00e9hez haszn\u00e1lt HTTP/REST-jelleg\u0171 interf\u00e9sszel, \u00e9s nem SQL nyelven kell vel\u00fck kommunik\u00e1lni. \u00cdgy egyre kevesebb a k\u00fcl\u00f6nbs\u00e9g egy adatb\u00e1zis \u00e9s egy k\u00fcls\u0151 adatforr\u00e1s k\u00f6z\u00f6tt.</p>"},{"location":"lecture-notes/architecture/#adateleresi-reteg","title":"Adatel\u00e9r\u00e9si r\u00e9teg","text":"<p>Az adatel\u00e9r\u00e9si r\u00e9teg (data access layer, r\u00f6viden DAL) feladata az adatforr\u00e1sok k\u00e9nyelmes el\u00e9r\u00e9s\u00e9nek biztos\u00edt\u00e1sa. F\u0151 funkci\u00f3ja az elemi adatszolg\u00e1ltat\u00e1si m\u0171veletek biztos\u00edt\u00e1sa, mint egy \u00faj rekord t\u00e1rol\u00e1sa, meglev\u0151 m\u00f3dos\u00edt\u00e1sa vagy t\u00f6rl\u00e9se.</p> <p>Az adatforr\u00e1sokat \u00e9s az adatel\u00e9r\u00e9si r\u00e9teget szok\u00e1s m\u00e9g egyben adatr\u00e9tegnek (data layer) is nevezni.</p> <p>Az adatb\u00e1zisok el\u00e9r\u00e9s\u00e9hez sz\u00fcks\u00e9ges funkcionalit\u00e1sokat az \u00fan. data access components-ek val\u00f3s\u00edtj\u00e1k meg. C\u00e9ljuk, hogy elrejts\u00e9k a komplexit\u00e1st, ami az adatb\u00e1zis kezel\u00e9s\u00e9b\u0151l ad\u00f3dik, \u00e9s k\u00f6zpontilag k\u00e9nyelmes, a fels\u0151bb r\u00e9teg sz\u00e1m\u00e1ra egyszer\u0171en haszn\u00e1lhat\u00f3 szolg\u00e1ltat\u00e1sk\u00e9nt ny\u00fajts\u00e1k az adatt\u00e1rol\u00e1st. Ide tartozik p\u00e9ld\u00e1ul az SQL parancsok kezel\u00e9se, valamint az adatb\u00e1zis t\u00e1rol\u00e1si modellj\u00e9nek lek\u00e9pz\u00e9se az \u00fczleti logika sz\u00e1m\u00e1ra is k\u00e9nyelmesen haszn\u00e1lhat\u00f3 m\u00f3don.</p> <p>Amennyiben az adatok nem egy adatb\u00e1zisban, hanem egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1sban tal\u00e1lhat\u00f3ak, a service agent-ek feladata a k\u00fcls\u0151 rendszerrel val\u00f3 kommunik\u00e1ci\u00f3 kezel\u00e9se.</p> <p>Ebben a r\u00e9tegben tal\u00e1lhat\u00f3 komponensek \u00e1ltal\u00e1ban egy konkr\u00e9t technol\u00f3gia k\u00f6r\u00e9 csoportosulnak, p\u00e9ld\u00e1ul a v\u00e1lasztott adatb\u00e1zis-kezel\u0151 rendszer el\u00e9r\u00e9s\u00e9hez haszn\u00e1lt technol\u00f3gia (mint az ADO.NET, Entity Framework, vagy JDBC, JPA, stb.). Az itt megval\u00f3s\u00edtott logik\u00e1k gyakran szorosan csatol\u00f3dnak az adatkezel\u00e9si technol\u00f3gi\u00e1kkal. Fontos azonban, hogy ez a platform specifikuss\u00e1g ne sziv\u00e1rogjon ki ebb\u0151l a r\u00e9tegb\u0151l.</p> <p>Fontos</p> <p>Egy j\u00f3l megtervezett rendszerben SQL lek\u00e9rdez\u00e9sek csak az adatel\u00e9r\u00e9si r\u00e9tegben jelennek meg, a t\u00f6bbi r\u00e9teg semmilyen k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt nem \u00e1ll\u00edt \u00f6ssze SQL lek\u00e9rdez\u00e9st.</p> <p>Mivel az adatb\u00e1zisban val\u00f3 t\u00e1rol\u00e1s gondolkod\u00e1sm\u00f3dja (tipikusan a rel\u00e1ci\u00f3s s\u00e9ma), valamint az objektumorient\u00e1lt modellez\u00e9s nem egy az egyben fedik egym\u00e1st, ez\u00e9rt ennek a r\u00e9tegnek a feladata a k\u00e9t vil\u00e1g k\u00f6z\u00f6tti lek\u00e9pez\u00e9s \u00e9s megfeleltet\u00e9s megval\u00f3s\u00edt\u00e1sa. A rel\u00e1ci\u00f3s adatb\u00e1zisokban haszn\u00e1lt k\u00fcls\u0151 kulcsokat (foreign key) objektumorient\u00e1lt asszoci\u00e1ci\u00f3kra, kompoz\u00edci\u00f3kra alak\u00edtjuk, valamint ha sz\u00fcks\u00e9ges, konvert\u00e1l\u00e1st v\u00e9gz\u00fcnk a k\u00fcl\u00f6nb\u00f6z\u0151 rendszerek \u00e1ltal t\u00e1mogatott adatt\u00edpusok k\u00f6z\u00f6tt. Err\u0151l a feladatr\u00f3l a k\u00e9s\u0151bbiekben m\u00e9g r\u00e9szletesebben ejt\u00fcnk sz\u00f3t.</p> <p>A k\u00fcls\u0151 rendszerekkel val\u00f3 kommunik\u00e1ci\u00f3, ak\u00e1r egy adatb\u00e1zis-kezel\u0151 rendszerr\u0151l, ak\u00e1r egy k\u00fcls\u0151 szolg\u00e1ltat\u00e1sr\u00f3l van sz\u00f3, saj\u00e1tos kezel\u00e9stechnik\u00e1t ig\u00e9nyel. Teljes\u00edtm\u00e9ny szempontj\u00e1b\u00f3l nem mindegy, hogy a t\u00e1voli kiszolg\u00e1l\u00f3 megsz\u00f3l\u00edt\u00e1sa, a kapcsolat fel\u00e9p\u00edt\u00e9se mikor \u00e9s milyen gyakran t\u00f6rt\u00e9nik. Egyes kapcsolatfelv\u00e9teli m\u00f3dok, mint p\u00e9ld\u00e1ul a HTTP (\u00e9s alatta a TCP) kapcsolat fel\u00e9p\u00edt\u00e9se tipikusan egyszer\u0171 \u00e9s gyors; m\u00edg egy rel\u00e1ci\u00f3s adatb\u00e1zis szerverhez t\u00f6rt\u00e9n\u0151 csatlakoz\u00e1s hosszabb folyamat. \u00cdgy az adatel\u00e9r\u00e9si r\u00e9teg felel az\u00e9rt is, hogy megfelel\u0151 m\u00f3don kezelje a kapcsolatokat, \u00e9s ha lehets\u00e9ges, \u00fajra haszn\u00e1lja a kapcsolatokat (connection pooling). Ezt a m\u0171k\u00f6d\u00e9st \u00e1ltal\u00e1ban a j\u00f3l megv\u00e1lasztott kliens k\u00f6nyvt\u00e1rak automatikusan biztos\u00edtj\u00e1k is.</p> <p>Hasonl\u00f3an r\u00e9teg specifikus feladat az adatok konkurens el\u00e9r\u00e9s\u00e9nek \u00e9s m\u00f3dos\u00edt\u00e1s\u00e1nak kezel\u00e9se. Ezzel r\u00e9szletesen foglalkozunk k\u00e9s\u0151bb. Egyel\u0151re annyit \u00e9rdemes megjegyezni err\u0151l, hogy a t\u00f6bbr\u00e9teg\u0171 alkalmaz\u00e1st tipikusan egyszerre t\u00f6bb felhaszn\u00e1l\u00f3 haszn\u00e1lja (gondoljunk csak bele a Neptun rendszerbe, vagy egy webshop m\u0171k\u00f6d\u00e9s\u00e9be), \u00edgy el\u0151fordulhat, hogy egyszerre t\u00f6bben m\u00f3dos\u00edtan\u00e1nak a rendszerben. Ennek szab\u00e1lyait, hogy milyen m\u00f3dos\u00edt\u00e1sok enged\u00e9lyezettek, \u00e9s mik nem, a konkurenciakezel\u00e9s t\u00e9mak\u00f6r\u00e9ben fogjuk t\u00e1rgyalni.</p>"},{"location":"lecture-notes/architecture/#uzleti-logikai-reteg","title":"\u00dczleti logikai r\u00e9teg","text":"<p>Az \u00fczleti logikai r\u00e9teg adja az alkalmaz\u00e1sunk lelk\u00e9t. Az adatt\u00e1rol\u00e1s, az adatel\u00e9r\u00e9s, \u00e9s a megjelen\u00edt\u00e9s is mind az\u00e9rt sz\u00fcletik, hogy az \u00fczleti logikai r\u00e9tegben lefektetett funkcionalit\u00e1sokat ny\u00fajtani tudjuk.</p> <p>Hogy pontosan milyen funkci\u00f3kat ny\u00fajt ez a r\u00e9teg, annak f\u00fcggv\u00e9ny\u00e9ben alak\u00edtjuk ki, hogy milyen alkalmaz\u00e1sr\u00f3l van sz\u00f3. Ha a Neptun rendszert tervezz\u00fck, akkor vizsgajelentkez\u00e9sr\u0151l, t\u00e1rgyfelv\u00e9telr\u0151l, tanulm\u00e1nyi id\u0151szakokr\u00f3l fog sz\u00f3lni a r\u00e9teg; ha egy webshopot tervez\u00fcnk, akkor term\u00e9kek, keres\u00e9s, \u00e9rt\u00e9kel\u00e9s, v\u00e1s\u00e1rl\u00e1s lesz a k\u00f6z\u00e9ppontban.</p> <p>\u00c1ltal\u00e1nosan ebben a r\u00e9tegben</p> <ul> <li>\u00fczleti entit\u00e1sok (business entities),</li> <li>\u00fczleti komponensek (business components),</li> <li>\u00e9s \u00fczleti folyamatok (business workflows) tal\u00e1lhat\u00f3ak.</li> </ul> <p>Az entit\u00e1sok hordozz\u00e1k a kezelt inform\u00e1ci\u00f3kat. A probl\u00e9mater\u00fclet f\u00fcggv\u00e9ny\u00e9ben olyan entit\u00e1sokat defini\u00e1lunk, mint a term\u00e9k \u00e9s \u00e9rt\u00e9kel\u00e9s (egy webshopban), vagy a kurzus \u00e9s a vizsga (a Neptunban).</p> <p>Az entit\u00e1sok manipul\u00e1l\u00e1s\u00e1\u00e9rt felelnek a komponensek. Ezek olyan alapszolg\u00e1ltat\u00e1sokat implement\u00e1lnak, amelyek az alkalmaz\u00e1sunk \u00e1ltal megval\u00f3s\u00edtott bonyolult funkci\u00f3k alap \u00e9p\u00edt\u0151k\u00f6veit adj\u00e1k. Ilyen funkci\u00f3 lehet p\u00e9ld\u00e1ul a term\u00e9kek list\u00e1z\u00e1sa, vagy a n\u00e9v alapj\u00e1n t\u00f6rt\u00e9n\u0151 keres\u00e9s.</p> <p>Ezen alap funkci\u00f3kb\u00f3l \u00e9p\u00edtj\u00fck fel a folyamatokat. A folyamatok a v\u00e9gfelhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra fontos m\u0171veleteket fogj\u00e1k \u00f6ssze. Egy folyamat \u00e1ltal\u00e1ban t\u00f6bb komponens t\u00f6bb m\u0171velet\u00e9t haszn\u00e1lja. Ilyen folyamat p\u00e9ld\u00e1ul a rendel\u00e9s v\u00e9gleges\u00edt\u00e9se (checkout) egy webshopban, amely ellen\u0151rzi a term\u00e9keket, ki\u00e1ll\u00edtja a sz\u00e1ml\u00e1t, elk\u00fcldi a meger\u0151s\u00edt\u00e9st emailben, stb.</p>"},{"location":"lecture-notes/architecture/#szolgaltatasi-interfesz-alreteg","title":"Szolg\u00e1ltat\u00e1si interf\u00e9sz alr\u00e9teg","text":"<p>A fenti \u00e1br\u00e1n megk\u00fcl\u00f6nb\u00f6ztet\u00e9sre ker\u00fclt a services alr\u00e9teg. Ezt az \u00fczleti logikai r\u00e9teg r\u00e9sz\u00e9nek tekintj\u00fck, annak legfels\u0151 alr\u00e9tege. Feladata a k\u00fcls\u0151 h\u00edv\u00f3 sz\u00e1m\u00e1ra interf\u00e9szt biztos\u00edtani az \u00fczleti logikai r\u00e9teg funkcionalit\u00e1s\u00e1nak el\u00e9r\u00e9s\u00e9hez.</p> <p>Minden eddig t\u00e1rgyalt r\u00e9teg ugyan\u00edgy biztos\u00edt egy interf\u00e9szt a fels\u0151bb r\u00e9tegek sz\u00e1m\u00e1ra. Az \u00fczleti logikai r\u00e9teg az\u00e9rt speci\u00e1lis, \u00e9s az\u00e9rt szok\u00e1s ezt a szolg\u00e1ltat\u00e1si interf\u00e9sz alr\u00e9teget k\u00fcl\u00f6n megeml\u00edteni, mert manaps\u00e1g gyakran nem is egyetlen ilyen interf\u00e9szt publik\u00e1lnak az alkalmaz\u00e1sok. Gyakori, hogy egy alkalmaz\u00e1s t\u00f6bb megjelen\u00edt\u00e9si r\u00e9teggel is rendelkezik, gondoljunk csak bele a Gmail eset\u00e9be: webalkalmaz\u00e1s, \u00e9s sok f\u00e9le mobil platform. Mindegyik felhaszn\u00e1l\u00f3i fel\u00fclet hasonl\u00f3, de nem teljesen azonos szolg\u00e1ltat\u00e1st ny\u00fajt, \u00edgy gyakran elk\u00fcl\u00f6n\u00fclnek a k\u00fcl\u00f6nb\u00f6z\u0151 megjelen\u00edt\u00e9si r\u00e9tegek sz\u00e1m\u00e1ra ny\u00fajtott interf\u00e9szek.</p> <p>Tov\u00e1bbi gyakori eset, hogy az alkalmaz\u00e1sunk nem csak egy saj\u00e1t megjelen\u00edt\u00e9si r\u00e9teggel rendelkezik, hanem \u00fan. API-t (application programming interface) is el\u00e9rhet\u0151v\u00e9 tesz. Az API harmadik f\u00e9l sz\u00e1m\u00e1ra teszi el\u00e9rhet\u0151v\u00e9 az alkalmaz\u00e1sunk funkci\u00f3it. A saj\u00e1t felhaszn\u00e1l\u00f3i fel\u00fclet\u00fcnk, \u00e9s a harmadik f\u00e9l sz\u00e1m\u00e1ra ny\u00fajtott API funkcionalit\u00e1sa \u00e9s el\u00e9r\u00e9se gyakran elt\u00e9r\u0151, \u00e9s k\u00fcl\u00f6n technol\u00f3gi\u00e1t, \u00edgy k\u00fcl\u00f6n szolg\u00e1ltat\u00e1si interf\u00e9szeket is ig\u00e9nyel.</p> <p>Az API publik\u00e1l\u00e1ssal v\u00e1lhat a mi alkalmaz\u00e1sunk maga is k\u00fcls\u0151 adatforr\u00e1ss\u00e1 m\u00e1s alkalmaz\u00e1sok sz\u00e1m\u00e1ra.</p> <p>Az \u00fczleti logikai funkci\u00f3ink publik\u00e1l\u00e1s\u00e1val r\u00e9szletesebben foglalkozunk a f\u00e9l\u00e9v sor\u00e1n. Meg fogjuk ismerni a web services \u00e9s a REST modelleket.</p>"},{"location":"lecture-notes/architecture/#megjelenitesi-reteg","title":"Megjelen\u00edt\u00e9si r\u00e9teg","text":"<p>A megjelen\u00edt\u00e9si r\u00e9teg (presentation layer, UI, vagy felhaszn\u00e1l\u00f3i fel\u00fclet) feladata az adatok felhaszn\u00e1l\u00f3bar\u00e1t megjelen\u00edt\u00e9se, \u00e9s a lehets\u00e9ges m\u0171veletek kezdem\u00e9nyez\u00e9s\u00e9nek lehet\u0151v\u00e9 t\u00e9tele.</p> <p>Az adatok prezent\u00e1l\u00e1sa olyan m\u00f3don kell t\u00f6rt\u00e9njen, ahogy az a felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra hasznos. P\u00e9ld\u00e1ul egy list\u00e1s megjelen\u00edt\u00e9s eset\u00e9n gyakran a felhaszn\u00e1l\u00f3i fel\u00fclet feladata a rendez\u00e9s, csoportos\u00edt\u00e1s, kereshet\u0151s\u00e9g.</p> <p>Rendez\u00e9s \u00e9s keres\u00e9s</p> <p>A v\u00e1lasztott technol\u00f3gia f\u00fcggv\u00e9ny\u00e9ben a rendez\u00e9s, keres\u00e9s tipikusan ig\u00e9nybe veszi a t\u00f6bbi r\u00e9teget is. Nagy mennyis\u00e9g\u0171 adat, t\u00f6bb sz\u00e1z, vagy t\u00f6bb ezer rekordot nem c\u00e9lszer\u0171 egyben eljuttatni a megjelen\u00edt\u00e9si r\u00e9teg sz\u00e1m\u00e1ra, hogy ott legyen a keres\u00e9s megval\u00f3s\u00edtva. Ez egyr\u00e9szt terheli a h\u00e1l\u00f3zatot is, m\u00e1sr\u00e9szt a UI technol\u00f3gi\u00e1k limit\u00e1ci\u00f3i miatt nem hat\u00e9kony sok adatot itt mem\u00f3ri\u00e1ban tartani. Viszont, ha nem nagy mennyis\u00e9g\u0171 adatr\u00f3l van sz\u00f3, sokkal eleg\u00e1nsabb a megjelen\u00edt\u00e9si r\u00e9tegre b\u00edzni mindezt, mert sokkal gyorsabb lesz a visszajelz\u00e9s a felhaszn\u00e1l\u00f3nak (hiszen ha mindezt a UI v\u00e9gzi, nem sz\u00fcks\u00e9ges minden alkalommal a h\u00e1tt\u00e9rrendszerhez fordulni).</p> <p>Az adatok megjelen\u00edt\u00e9se sor\u00e1n a UI felel\u0151s olyan egyszer\u0171 transzform\u00e1ci\u00f3k\u00e9rt is, mint p\u00e9ld\u00e1ul a d\u00e1tum felhaszn\u00e1l\u00f3bar\u00e1t megjelen\u00edt\u00e9se. A kor\u00e1bban eml\u00edtett p\u00e9lda alapj\u00e1n teh\u00e1t egy d\u00e1tumot a felhaszn\u00e1l\u00f3i fel\u00fclet feladata a \"15:23\", 3:23 PM\", vagy ak\u00e1r a \"15 perccel ezel\u0151tt\" sz\u00f6veges megjelen\u00edt\u00e9sre \u00e1talak\u00edtani.</p> <p>Tov\u00e1bb\u00e1, a felhaszn\u00e1l\u00f3i fel\u00fclet feladata az \u00fan. lokaliz\u00e1ci\u00f3 is. A lokaliz\u00e1ci\u00f3 a UI felhaszn\u00e1l\u00f3 \u00e1ltal v\u00e1lasztott nyelven val\u00f3 megjelen\u00edt\u00e9se, amely kiterjed a statikus sz\u00f6vegekre, feliratokra is, de egyben a kult\u00fara f\u00fcgg\u0151 adat transzform\u00e1ci\u00f3kra is (mint a d\u00e1tumok, sz\u00e1mok, p\u00e9nznemek megjelen\u00edt\u00e9se is).</p> <p>A felhaszn\u00e1l\u00f3i fel\u00fclet felel m\u00e9g a v\u00e9gfelhaszn\u00e1l\u00f3 interakci\u00f3inak kezel\u00e9s\u00e9\u00e9rt. Ha egy gombra kattintottak, akkor a UI kezdem\u00e9nyezi a k\u00e9rt funkci\u00f3 v\u00e9grehajt\u00e1s\u00e1t, \u00e9s t\u00e1j\u00e9koztatja a v\u00e9geredm\u00e9nyr\u0151l a felhaszn\u00e1l\u00f3t.</p> <p>Amikor a felhaszn\u00e1l\u00f3 adatot visz be a rendszerbe, azt is a felhaszn\u00e1l\u00f3i fel\u00fclet biztos\u00edtja, \u00e9s ez a r\u00e9teg felel az adatok valid\u00e1ci\u00f3j\u00e1\u00e9rt (ellen\u0151rz\u00e9s\u00e9\u00e9rt) is. A valid\u00e1ci\u00f3 sor\u00e1n egyszer\u0171bb ellen\u0151rz\u00e9sek hajthat\u00f3k v\u00e9gre, mint p\u00e9ld\u00e1ul, hogy a sz\u00fcks\u00e9ges mez\u0151k nem maradhatnak \u00fcresen, az email c\u00edmben kell legyen @ karakter, a megadott percnek 0 \u00e9s 59 k\u00f6z\u00e9 kell esnie, stb.</p> <p>Valid\u00e1ci\u00f3</p> <p>A valid\u00e1ci\u00f3t nem el\u00e9g, ha kiz\u00e1r\u00f3lag a felhaszn\u00e1l\u00f3i fel\u00fclet v\u00e9gzi. A v\u00e1lasztott technol\u00f3gi\u00e1t\u00f3l f\u00fcgg\u0151en a UI k\u00f6nnyen \"kiker\u00fclhet\u0151\", \u00e9s lehet\u0151s\u00e9g van az adatokat k\u00f6zvetlen\u00fcl a h\u00e1tt\u00e9rrendszernek k\u00fcldeni. Ilyen esetben, ha a valid\u00e1ci\u00f3t csak a felhaszn\u00e1l\u00f3 fel\u00fclet val\u00f3s\u00edtan\u00e1 meg, \u00e9rv\u00e9nytelen adat ker\u00fclhetne a rendszerbe. Ez\u00e9rt a valid\u00e1ci\u00f3kat tipikusan megism\u00e9tli a h\u00e1tt\u00e9rrendszer is. Ennek ellen\u00e9re praktikus ezeket a felhaszn\u00e1l\u00f3i fel\u00fcleten is elv\u00e9gezni, mert azonnali visszajelz\u00e9st tudunk \u00edgy adni a felhaszn\u00e1l\u00f3nak.</p> <p>A r\u00e9teggel enn\u00e9l r\u00e9szletesebben nem foglalkozunk ezen t\u00e1rgy keretei k\u00f6z\u00f6tt.</p>"},{"location":"lecture-notes/architecture/#retegfuggetlen-szolgaltatasok","title":"R\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok","text":"<p>R\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sok (crosscutting concerns) n\u00e9ven szoktuk hivatkozni az alkalmaz\u00e1s olyan szolg\u00e1ltat\u00e1sait, amelyek nem csak egy r\u00e9tegben jelennek meg. Az ilyen szolg\u00e1ltat\u00e1sok implement\u00e1l\u00e1sakor igyeksz\u00fcnk  el\u00e9rni, hogy b\u00e1r t\u00f6bb r\u00e9tegben is jelen van az adott szolg\u00e1ltat\u00e1s, m\u00e9gis, egy k\u00f6z\u00f6s implement\u00e1ci\u00f3t, k\u00f3dot, megold\u00e1st haszn\u00e1ljunk.</p>"},{"location":"lecture-notes/architecture/#biztonsag","title":"Biztons\u00e1g","text":"<p>A biztons\u00e1gi szolg\u00e1ltat\u00e1sok lefedik</p> <ul> <li>a felhaszn\u00e1l\u00f3k bel\u00e9ptet\u00e9s\u00e9t (autentik\u00e1ci\u00f3)</li> <li>\u00e9s a hozz\u00e1f\u00e9r\u00e9s ellen\u0151rz\u00e9s\u00e9t (autoriz\u00e1ci\u00f3),</li> <li>valamint a nyomk\u00f6vet\u00e9st \u00e9s audit\u00e1l\u00e1st.</li> </ul> <p>Az autentik\u00e1ci\u00f3 a \"ki vagy\" k\u00e9rd\u00e9st, m\u00edg az autoriz\u00e1ci\u00f3 a \"mihez van jogod\" k\u00e9rd\u00e9st kezeli.</p> <p>Az autentik\u00e1ci\u00f3 nem csak a felhaszn\u00e1l\u00f3i fel\u00fcleten t\u00f6rt\u00e9n\u0151 bejelentkez\u00e9st jelenti. Az adatb\u00e1zis szerverek fel\u00e9 is tipikusan sz\u00fcks\u00e9g\u00fcnk van bejelentkez\u00e9sre, vagy ha k\u00fcls\u0151 szolg\u00e1ltat\u00e1s fel\u00e9 fordulunk, oda is be kell jelentkezn\u00fcnk. Ez\u00e9rt teh\u00e1t ez az aspektus t\u00f6bb r\u00e9tegben is jelen van.</p> <p>Bejelentkez\u00e9sre t\u00f6bbf\u00e9le megk\u00f6zel\u00edt\u00e9st v\u00e1laszthatunk. K\u00e9sz\u00edthet\u00fcnk saj\u00e1t bejelentkez\u00e9st, haszn\u00e1lhatunk valamilyen c\u00edmt\u00e1ras megold\u00e1st, vagy OAuth bejelentkez\u00e9st. Ha a mi alkalmaz\u00e1sunk bejelentkeztetett egy felhaszn\u00e1l\u00f3t, akkor eld\u00f6nthetj\u00fck, hogy a k\u00fcls\u0151 szolg\u00e1ltat\u00e1s fel\u00e9 ennek a felhaszn\u00e1l\u00f3nak a nev\u00e9ben fordulunk (pl. ahogy a Gmail a Google Drive-r\u00f3l sz\u00e1rmaz\u00f3 f\u00e1jlokat a bejelentkezett felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra list\u00e1zza), avagy egy k\u00f6zponti felhaszn\u00e1l\u00f3 nev\u00e9ben j\u00e1runk el (pl. ha a rendszer emailt k\u00fcld, akkor azt tipikusan egy k\u00f6zpontilag konfigur\u00e1lt fi\u00f3k nev\u00e9ben k\u00fcldi el).</p> <p>A hozz\u00e1f\u00e9r\u00e9s szab\u00e1lyoz\u00e1s megszabja, hogy milyen funkci\u00f3khoz ki f\u00e9rhet hozz\u00e1. Ennek ellen\u0151rz\u00e9se t\u00f6rt\u00e9nhet a felhaszn\u00e1l\u00f3i fel\u00fcleten is (ne is jelenjen meg a nem el\u00e9rhet\u0151 funkci\u00f3), de ahogy a bemenetek valid\u00e1ci\u00f3j\u00e1n\u00e1l is eml\u00edt\u00e9sre ker\u00fclt, az \u00fczleti logik\u00e1nak meg kell ism\u00e9telnie az ellen\u0151rz\u00e9st. Fontos, hogy ez a k\u00e9t valid\u00e1ci\u00f3 azonos szab\u00e1lyrendszer szerint dolgozzon.</p> <p>A nyomk\u00f6vet\u00e9s, audit\u00e1l\u00e1s feladata, hogy visszakereshet\u0151v\u00e9 v\u00e1ljon a rendszerben, hogy ki, mikor, mit csin\u00e1lt. C\u00e9lja, hogy egy ember ne tudja \"elt\u00fcntetni a nyomokat\". Ez a fajta napl\u00f3z\u00e1s t\u00f6bb ponton is megt\u00f6rt\u00e9nhet, tipikusan az \u00fczleti logik\u00e1ban \u00e9s az adatb\u00e1zisban.</p>"},{"location":"lecture-notes/architecture/#uzemeltetes","title":"\u00dczemeltet\u00e9s","text":"<p>Az \u00fczemeltet\u00e9si szempontok figyelembe v\u00e9tele el\u0151seg\u00edti, hogy a szoftver fejleszt\u00e9s ut\u00e1ni \u00e9letciklusa sor\u00e1n is kiel\u00e9g\u00edtse a felhaszn\u00e1l\u00f3k ig\u00e9nyeit. Ide olyan feladatok megold\u00e1sa tartozik, mint az egys\u00e9ges kiv\u00e9telkezel\u00e9s, a megfelel\u0151 napl\u00f3z\u00e1s \u00e9s monitoroz\u00e1s, valamint a konfigur\u00e1l\u00e1s \u00e9s konfigur\u00e1ci\u00f3-kezel\u00e9s.</p> <p>A kiv\u00e9telkezel\u00e9s sor\u00e1n egy olyan egys\u00e9ges m\u00f3dszert kell kialak\u00edtani, ami az alkalmaz\u00e1s fut\u00e1sa sor\u00e1n keletkez\u0151 minden kiv\u00e9telt megfog. Mindenk\u00e9ppen r\u00f6gz\u00edteni kell a hib\u00e1kat (pl. napl\u00f3z\u00e1ssal), \u00e9s emellett a felhaszn\u00e1l\u00f3t is valamilyen m\u00f3don t\u00e1j\u00e9koztatni a hiba jelleg\u00e9r\u0151l (pl. hogy pr\u00f3b\u00e1lja-e \u00fajra a m\u0171veletet, vagy v\u00e1rjon a jav\u00edt\u00e1sig). Az egys\u00e9ges kiv\u00e9telkezel\u00e9s az\u00e9rt nagyon fontos, mert az architekt\u00fara als\u00f3bb r\u00e9tegeiben el\u0151fordul\u00f3 hib\u00e1kat az \u00fczemeltet\u00e9s \u00e9s fejleszt\u00e9s nem l\u00e1tja, csak ha azok megfelel\u0151en kezelve \u00e9s r\u00f6gz\u00edtve lesznek.</p> <p>A napl\u00f3z\u00e1s \u00e9s monitoroz\u00e1s az \u00fczemszer\u0171 \u00e9s nem rendeltet\u00e9sszer\u0171 viselked\u00e9s k\u00f6vet\u00e9s\u00e9hez is fontos. A napl\u00f3z\u00e1s \u00e1ltal\u00e1ban sz\u00f6veges form\u00e1tum\u00fa rendszer \u00fczenetek r\u00f6gz\u00edt\u00e9s\u00e9t jelenti. A monitoroz\u00e1s a rendszer \u00e1llapot\u00e1t meghat\u00e1rozott jellemz\u0151k (\u00fan. KPI-k, key performance indicator) k\u00f6vet\u00e9s\u00e9t jelenti. Ilyen KPI lehet a mem\u00f3ria fogyaszt\u00e1s, a hib\u00e1s k\u00e9r\u00e9sek sz\u00e1ma, a kiszolg\u00e1lt felhaszn\u00e1l\u00f3k sz\u00e1ma, stb.</p> <p>A konfigur\u00e1ci\u00f3 kezel\u00e9s pedig arr\u00f3l sz\u00f3l, hogy az alkalmaz\u00e1s m\u0171k\u00f6d\u00e9s\u00e9t befoly\u00e1sol\u00f3 be\u00e1ll\u00edt\u00e1sokat hol t\u00e1roljuk, \u00e9s hogyan k\u00f6tj\u00fck be \u0151ket az alkalmaz\u00e1sba. Konfigur\u00e1ci\u00f3nak min\u0151s\u00fclnek kiszolg\u00e1l\u00f3k el\u00e9r\u00e9si \u00fatvonalai (pl. az adatb\u00e1zis szerver c\u00edme), de ak\u00e1r a megjelen\u00edt\u00e9si r\u00e9tegben haszn\u00e1lt h\u00e1tt\u00e9rsz\u00edn is. Alapelv, hogy a be\u00e1ll\u00edt\u00e1sokat min\u00e9l kev\u00e9sb\u00e9 \"\u00e9gess\u00fck be\" a forr\u00e1sk\u00f3dba, hogy alkalmazkodni tudjunk az \u00fczemeltet\u00e9s sor\u00e1n el\u0151fordul\u00f3 k\u00fcl\u00f6nb\u00f6z\u0151 k\u00f6rnyezetekhez. A konfigur\u00e1ci\u00f3 t\u00f6rt\u00e9nhet tipikusan konfigur\u00e1ci\u00f3s f\u00e1jlokkal, vagy kifejezetten konfigur\u00e1ci\u00f3-menedzsment c\u00e9lra szolg\u00e1l\u00f3 eszk\u00f6z\u00f6kkel is.</p> <p>Az \u00fczemeltet\u00e9si aspektusokkal nem fogunk r\u00e9szletesebben foglalkozni. Tipikusan a v\u00e1lasztott platform k\u00e9pess\u00e9geit \u00e9s lehet\u0151s\u00e9geit haszn\u00e1ljuk a megval\u00f3s\u00edt\u00e1shoz.</p>"},{"location":"lecture-notes/architecture/#kommunikacio","title":"Kommunik\u00e1ci\u00f3","text":"<p>A kommunik\u00e1ci\u00f3s szolg\u00e1ltat\u00e1s az egyes r\u00e9tegek k\u00f6z\u00f6tti kommunik\u00e1ci\u00f3s forma megv\u00e1laszt\u00e1s\u00e1\u00e9rt \u00e9s kezel\u00e9s\u00e9\u00e9rt felel. Ennek helyes megv\u00e1laszt\u00e1sa nem csak architektur\u00e1lis k\u00e9rd\u00e9s, mert nagyban f\u00fcgg a telep\u00edt\u00e9s mik\u00e9ntj\u00e9t\u0151l is. Amennyiben az egyes r\u00e9tegek elt\u00e9r\u0151 kiszolg\u00e1l\u00f3n ker\u00fclnek elhelyez\u00e9sre, h\u00e1l\u00f3zati alap\u00fa kommunik\u00e1ci\u00f3ra van sz\u00fcks\u00e9g; m\u00edg azonos kiszolg\u00e1l\u00f3n \u00fczemeltetett komponensek k\u00f6z\u00f6tt egyszer\u0171bb megold\u00e1sokat haszn\u00e1lhatunk.</p> <p>Manaps\u00e1g szinte minden alkalmaz\u00e1sban valahol megjelenik a h\u00e1l\u00f3zati kommunik\u00e1ci\u00f3: tipikusan az adatb\u00e1zis \u00e9s adatforr\u00e1sok ir\u00e1ny\u00e1ba, illetve a megjelen\u00edt\u00e9si r\u00e9teg \u00e9s a szolg\u00e1ltat\u00e1si interf\u00e9szek k\u00f6z\u00f6tt. Itt tipikusan HTTP vagy arra \u00e9p\u00fcl\u0151 kommunik\u00e1ci\u00f3t szoktak alkalmazni, b\u00e1r nagyobb teljes\u00edtm\u00e9nyt ig\u00e9nyl\u0151 alkalmaz\u00e1sok eset\u00e9n \u00e9rdemes lehet TCP alap\u00fa bin\u00e1ris kommunik\u00e1ci\u00f3t v\u00e1lasztani. Nagy rendszerek eset\u00e9n, ahol az egyes r\u00e9tegek maguk is elosztva, t\u00f6bb kiszolg\u00e1l\u00f3n tal\u00e1lhat\u00f3ak, pedig gyakori az \u00fczenetsorok (message queue) haszn\u00e1lata.</p> <p>A kommunik\u00e1ci\u00f3 r\u00e9sz\u00e9nek tekintj\u00fck \u00e1ltal\u00e1ban a titkos\u00edt\u00e1st is. Amennyiben az egyes r\u00e9tegek k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon futnak, fontos, hogy megfelel\u0151en titkos\u00edtsuk a kommunik\u00e1ci\u00f3t. A felhaszn\u00e1l\u00f3i fel\u00fclet \u00e9s a szolg\u00e1ltat\u00e1si interf\u00e9szek k\u00f6z\u00f6tt ez \u00e1ltal\u00e1ban HTTPS/TLS kommunik\u00e1ci\u00f3t jelent.</p>"},{"location":"lecture-notes/architecture/#backend-es-frontend","title":"Backend \u00e9s frontend","text":"<p>Ha az alkalmaz\u00e1sra egy kicsit m\u00e1s szemsz\u00f6gb\u0151l n\u00e9z\u00fcnk, akkor meg szoktuk k\u00fcl\u00f6nb\u00f6ztetni a backend \u00e9s a frontend r\u00e9szt. A frontend nagyr\u00e9szt a felhaszn\u00e1l\u00f3i fel\u00fclet, vagyis a prezent\u00e1ci\u00f3s r\u00e9teg, ill. annak v\u00e1ltozatos megjelen\u00e9si form\u00e1i (b\u00f6ng\u00e9sz\u0151ben fut\u00f3 webalkalmaz\u00e1s UI, nat\u00edv mobil alkalmaz\u00e1s, vastag kliens UI, stb). A felhaszn\u00e1l\u00f3 ezzel l\u00e9p kapcsolatba. A backend pedig a \"h\u00e1tt\u00e9rben\" fut\u00f3 rendszer, a szolg\u00e1ltat\u00e1si API-k, az \u00fczleti logikai r\u00e9teg, az adatel\u00e9r\u00e9s, adatb\u00e1zisok.</p> <p>A frontend nem csak felhaszn\u00e1l\u00f3 sz\u00e1m\u00edt\u00f3g\u00e9p\u00e9n jelenik meg. Frontend technol\u00f3gia f\u00fcggv\u00e9ny\u00e9ben gyakran el\u0151fordul, hogy a felhaszn\u00e1l\u00f3i fel\u00fclet egy r\u00e9sz\u00e9t a backend k\u00e9sz\u00edti el. Ezt szokt\u00e1k szerver oldali renderel\u00e9snek h\u00edvni.</p> <p>Ha \u00f6sszefoglal\u00f3an akarjuk hivatkozni, akkor a t\u00e1rgy keret\u00e9ben a backend technol\u00f3gi\u00e1kkal foglalkozunk.</p>"},{"location":"lecture-notes/architecture/#ellenorzo-kerdesek","title":"Ellen\u0151rz\u0151 k\u00e9rd\u00e9sek","text":"<ul> <li>Mik a h\u00e1romr\u00e9teg\u0171 architekt\u00fara r\u00e9tegei? Mik a felel\u0151ss\u00e9geik?</li> <li>Ismertesse a r\u00e9tegf\u00fcggetlen szolg\u00e1ltat\u00e1sokat!</li> <li>D\u00f6ntse el, hogy igaz vagy hamis az al\u00e1bbi \u00e1ll\u00edt\u00e1s:<ul> <li>Az adatbevitel valid\u00e1ci\u00f3j\u00e1\u00e9rt csak a megjelen\u00edt\u00e9si r\u00e9teg felel.</li> <li>Az architekt\u00fara szempontj\u00e1b\u00f3l helytelen, ha SQL parancsok ker\u00fclnek az \u00fczleti logikai r\u00e9tegbe.</li> <li>A h\u00e1romr\u00e9teg\u0171 architekt\u00fara r\u00e9tegei mindig k\u00fcl\u00f6n kiszolg\u00e1l\u00f3kon futnak.</li> <li>A h\u00e1romr\u00e9teg\u0171 architekt\u00fara akkor lesz t\u00f6bbr\u00e9teg\u0171, pl. n\u00e9gyr\u00e9teg\u0171, ha teljes\u00edtm\u00e9ny okokb\u00f3l az \u00fczleti logikai r\u00e9teget m\u00e1s kiszolg\u00e1l\u00f3ra vissz\u00fck, mint az adatel\u00e9r\u00e9si r\u00e9teget.</li> <li>A r\u00e9teges fel\u00e9p\u00edt\u00e9s garant\u00e1lja, hogy a r\u00e9tegek \u00e1ltal biztos\u00edtott szolg\u00e1ltat\u00e1sokat tetsz\u0151legesen megv\u00e1ltoztathatjuk, ez nem \u00e9rinti a t\u00f6bbi r\u00e9teget.</li> <li>A frontend \u00e9s a megjelen\u00edt\u00e9si r\u00e9teg egy \u00e9s ugyanaz.</li> <li>Kiv\u00e9telkezel\u00e9sre csak az \u00fczleti logikai r\u00e9tegben van sz\u00fcks\u00e9g.</li> </ul> </li> </ul>"},{"location":"lecture-notes/async/","title":"Aszinkron k\u00e9r\u00e9sek \u00e9s DTO-k (p\u00e9lda WebAPI alkalmaz\u00e1s)","text":"<p>Az al\u00e1bbi jegyzet a kiszolg\u00e1l\u00f3 oldali aszinkronit\u00e1st \u00e9s a DTO-k (Data Transfer Object-ek) haszn\u00e1lat\u00e1t mutatja be egy p\u00e9ld\u00e1n kereszt\u00fcl. Az alkalmaz\u00e1s egy ASP.NET Core WebApi kiszolg\u00e1l\u00f3 Entity Framework adatel\u00e9r\u00e9ssel, amely egy webshop kos\u00e1r kezel\u00e9s\u00e9t val\u00f3s\u00edtja meg.</p> <p>Szerz\u0151</p> <p>Az al\u00e1bbi jegyzet Zergi M\u00e1t\u00e9 munk\u00e1ja.</p>"},{"location":"lecture-notes/async/#aszinkronitas","title":"Aszinkronit\u00e1s","text":"<p>A webes alkalmaz\u00e1saink legnagyobb r\u00e9sze valamilyen m\u00f3don kommunik\u00e1l adatb\u00e1zissal. Err\u0151l a kommunik\u00e1ci\u00f3r\u00f3l nem felt\u00e9telezhetj\u00fck, hogy:</p> <ul> <li>el\u00e9rhet\u0151 az adatb\u00e1zis szerver,</li> <li>gyors a kapcsolat a kliens \u00e9s a kiszolg\u00e1l\u00f3 k\u00f6z\u00f6tt,</li> <li>az adatokat az adatb\u00e1zis szerver gyorsan \u00e1ll\u00edtja el\u0151.</li> </ul> <p>Ez\u00e9rt fel kell k\u00e9sz\u00fclni arra, hogy a kiszolg\u00e1l\u00e1s sor\u00e1n k\u00e9rt adatokra v\u00e1rni kell. Erre k\u00edn\u00e1l megold\u00e1st az aszinkronit\u00e1s, amely hat\u00e9konyan haszn\u00e1lja ki a kiszolg\u00e1l\u00f3 er\u0151forr\u00e1sait - p\u00e9ld\u00e1ul nem foglal a web kiszolg\u00e1l\u00f3n er\u0151forr\u00e1st, am\u00edg az az adatb\u00e1zisra v\u00e1r.</p> <p>Aszinkronit\u00e1s \u00e9s p\u00e1rhuzamoss\u00e1g</p> <p>Az aszinkronit\u00e1s nem azonos a p\u00e1rhuzamoss\u00e1ggal. Egy webes kiszolg\u00e1l\u00f3 a bej\u00f6v\u0151 k\u00e9r\u00e9seket p\u00e1rhuzamosan szolg\u00e1lja ki. Az aszinkronit\u00e1s egy k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sor\u00e1n alkalmazott m\u00f3dszer, amely az I/O m\u0171veletek (pl. adatb\u00e1zis el\u00e9r\u00e9s, f\u00e1jl el\u00e9r\u00e9s, h\u00e1l\u00f3zati kommunik\u00e1ci\u00f3) sor\u00e1n hat\u00e9konyan kezeli a kiszolg\u00e1l\u00f3 sz\u00e1lait.</p>"},{"location":"lecture-notes/async/#az-alkalmazas-adatbazis-modellje","title":"Az alkalmaz\u00e1s adatb\u00e1zis modellje","text":"<p>Az alkalmaz\u00e1sunk a t\u00e1rgy minta adatb\u00e1zis\u00e1hoz hasonl\u00f3, de egyszer\u0171bb adatb\u00e1zissal dolgozik, az ER diagramja itt l\u00e1that\u00f3:</p> <p></p> <p>Az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt a kosarakban a UserID nem idegen kulcsk\u00e9nt szerepel egy Users t\u00e1bl\u00e1ra, hanem egy statikus, 1-es ID-j\u0171 felhaszn\u00e1l\u00f3val dolgozunk. A val\u00f3s\u00e1gban t\u00f6bb felhaszn\u00e1l\u00f3 van, \u00edgy a UserID idegen kulcs lenne.</p> <p>A Products t\u00e1bla reprezent\u00e1l term\u00e9keket, a Manufacturers t\u00e1bla gy\u00e1rt\u00f3kat (ez gyors\u00edthatja a gy\u00e1rt\u00f3nkk\u00e9nt sz\u0171r\u00e9st), az OrderItems pedig kos\u00e1rban lev\u0151 term\u00e9keket.</p>"},{"location":"lecture-notes/async/#kiszolgalo-alkalmazas-felepitese","title":"Kiszolg\u00e1l\u00f3 alkalmaz\u00e1s fel\u00e9p\u00edt\u00e9se","text":"<p>ASP.NET Core WebApi \u00e9s Entity Framework seg\u00edts\u00e9g\u00e9vel szeretn\u00e9nk a fenti adatb\u00e1zis adatait REST-kompatibilis szolg\u00e1ltat\u00e1son kereszt\u00fcl el\u00e9rhet\u0151v\u00e9 tenni. Az adatb\u00e1zis modellez\u00e9s\u00e9hez, valamint a WebAPI kiszolg\u00e1l\u00e1shoz alapvet\u0151en h\u00e1rom (esetleg n\u00e9gy) feladatot kell elv\u00e9gezni:</p> <ol> <li>Adatb\u00e1zis t\u00e1bl\u00e1t/t\u00e1bl\u00e1kat modellez\u0151 oszt\u00e1ly/oszt\u00e1lyok l\u00e9trehoz\u00e1sa,</li> <li>Adatb\u00e1zis kontextus l\u00e9trehoz\u00e1sa,</li> <li>Data Transfer Object l\u00e9trehoz\u00e1sa, ha sz\u00fcks\u00e9g van az adatok \u00e1talak\u00edt\u00e1s\u00e1ra a kliens sz\u00e1m\u00e1ra,</li> <li>WebAPI Kontroller l\u00e9trehoz\u00e1sa</li> </ol> <p>Menj\u00fcnk v\u00e9gig ezeken a l\u00e9p\u00e9seken!</p>"},{"location":"lecture-notes/async/#adatbazist-modellezo-osztalyok-letrehozasa","title":"Adatb\u00e1zist modellez\u0151 oszt\u00e1lyok l\u00e9trehoz\u00e1sa","text":"<p>Az adatb\u00e1zist modellez\u0151 oszt\u00e1lyokat ASP.NET Core platformon egy Models mapp\u00e1ba szok\u00e1s szervezni, \u00e9s azon bel\u00fcl az \u00e1ltaluk reprezent\u00e1lt t\u00e1bla nev\u00e9vel l\u00e9trehozni \u0151ket.</p> <p>A Products t\u00e1bl\u00e1t reprezent\u00e1l\u00f3 C# oszt\u00e1ly:</p> <pre><code>namespace WebshopApi.Models\n{\n    public class Product\n    {\n        public string Name { get; set; }\n        public int ManufacturerID { get; set; }\n        public int Price { get; set; }\n        public int ID { get; set; }\n    }\n}\n</code></pre> <p>A Manufacturers t\u00e1bl\u00e1t reprezent\u00e1l\u00f3 C# oszt\u00e1ly:</p> <pre><code>namespace WebshopApi.Models\n{\n    public class Manufacturer\n    {\n        public string Name { get; set; }\n        public int ID { get; set; }\n    }\n}\n</code></pre> <p>Az OrderItems t\u00e1bl\u00e1t reprezent\u00e1l\u00f3 C# oszt\u00e1ly:</p> <pre><code>namespace WebshopApi.Models\n{\n    public class OrderItem\n    {\n        public int ID { get; set; }\n        public int ProductID { get; set; }\n        public int CartID { get; set; }\n        public int Pieces { get; set; }\n    }\n}\n</code></pre> <p>A Carts t\u00e1bl\u00e1t reprezent\u00e1l\u00f3 C# oszt\u00e1ly:</p> <pre><code>namespace WebshopApi.Models\n{\n    public class Cart\n    {\n        public int ID { get; set; }\n        public int UserID { get; set; }\n    }\n}\n</code></pre> <p>Megfigyelhet\u0151, hogy ezek az oszt\u00e1lyok csak adatok t\u00e1rol\u00e1s\u00e1ra alkalmasak, amiket az egyes C# property-ken kereszt\u00fcl tudunk majd el\u00e9rni.</p>"},{"location":"lecture-notes/async/#adatbazis-kontextus-letrehozasa","title":"Adatb\u00e1zis kontextus l\u00e9trehoz\u00e1sa","text":"<p>Miut\u00e1n l\u00e9trehoztuk a t\u00e1bl\u00e1kat modellez\u0151 oszt\u00e1lyokat, el tudjuk k\u00e9sz\u00edteni az adatb\u00e1zis eg\u00e9sz\u00e9t modellez\u0151 DbContext oszt\u00e1lyt. Ehhez a saj\u00e1t oszt\u00e1lyunkat le kell sz\u00e1rmaztatni az Entity Framework Core DbContext oszt\u00e1ly\u00e1b\u00f3l.</p> <pre><code>namespace WebshopApi.Models\n{\n    public class WebshopContext : DbContext\n    {\n        public WebshopContext(DbContextOptions&lt;WebshopContext&gt; options)\n            : base(options)\n        {\n        }\n\n        public DbSet&lt;Product&gt; Products { get; set; }\n        public DbSet&lt;Manufacturer&gt; Manufacturers { get; set; }\n        public DbSet&lt;Cart&gt; Carts { get; set; }\n        public DbSet&lt;OrderItem&gt; OrderItems { get; set; }\n    }\n}\n</code></pre> <p>Az adatb\u00e1zisban szerepl\u0151 egyes t\u00e1bl\u00e1kat DbSet-ek defini\u00e1l\u00e1s\u00e1val tudjuk el\u00e9rni. A DbSet-eknek meg kell adni, hogy milyen entit\u00e1sokat t\u00e1rolnak (pl. a <code>DbSet&lt;Products&gt;</code> egy <code>Products</code> entit\u00e1sokat t\u00e1rol\u00f3 <code>DbSet</code>), valamint a nev\u00fcket.</p> <p>A konstruktorban szerepl\u0151 <code>DbContextOptions</code>-t a kontextus konfigur\u00e1l\u00e1s\u00e1ra lehet haszn\u00e1lni. Erre egy p\u00e9lda, az alkalmaz\u00e1s <code>Startup</code> oszt\u00e1ly\u00e1ban (l\u00e1sd REST API &amp; ASP.NET Web API gyakorlat) a k\u00f6vetkez\u0151 konfigur\u00e1ci\u00f3:</p> <pre><code>public class Startup\n{\n    // ...\n\n    // Ezt a met\u00f3dust a runtime h\u00edvja meg. Ezt a met\u00f3dust haszn\u00e1ljuk servicek DI kont\u00e9nerhez val\u00f3 hozz\u00e1ad\u00e1s\u00e1hoz\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddDbContext&lt;WebshopContext&gt;(opt =&gt; \n                opt.UseSqlServer(@\"Data Source=(localdb)\\mssqllocaldb;Initial Catalog=Webshop;Integrated Security=True\"));\n        // ...\n    }\n}\n</code></pre>"},{"location":"lecture-notes/async/#data-transfer-object-letrehozasa","title":"Data Transfer Object l\u00e9trehoz\u00e1sa","text":"<p>Az el\u0151z\u0151 k\u00e9t l\u00e9p\u00e9s eredm\u00e9nyek\u00e9nt rendelkez\u00e9s\u00fcnkre \u00e1ll az adatb\u00e1zis \u00e9s t\u00e1bl\u00e1inak lek\u00e9pz\u00e9se. K\u00f6vetkez\u0151 l\u00e9p\u00e9sk\u00e9nt gondoljunk bele abba, hogyan n\u00e9z ki egy webshopban a kos\u00e1r: egy kos\u00e1rban egyszerre t\u00f6bb term\u00e9k jelenik meg. Teh\u00e1t m\u00edg az <code>OrderItem</code> oszt\u00e1lyunk egy megrendelt term\u00e9ket tud reprezent\u00e1lni, a teljes kosarat ilyen elemek list\u00e1ja jelenti. Ez a term\u00e9k lista egy \u00fan. Data Transfer Object haszn\u00e1lat\u00e1val \u00edrhat\u00f3 le: ez egy olyan oszt\u00e1ly, ami a kliens sz\u00e1m\u00e1ra haszn\u00e1lhat\u00f3 adatot gy\u0171jt \u00f6ssze az adatb\u00e1zisb\u00f3l.</p> <p>Defin\u00edci\u00f3: Data Transfer Object</p> <p>Egy olyan objektum, ami adatot sz\u00e1ll\u00edt fut\u00f3 alkalmaz\u00e1sok (itt: kliens \u00e9s szerver) k\u00f6z\u00f6tt.</p> <p>DTO-k haszn\u00e1lat\u00e1val nem csak k\u00e9nyelmesebb lesz az adatok k\u00fcld\u00e9se, hanem gyors\u00edtjuk is az alkalmaz\u00e1sunkat:</p> <ul> <li>Csak olyan adatot k\u00fcld\u00fcnk a kliensnek, amire annak sz\u00fcks\u00e9ge van.</li> <li>Tov\u00e1bb\u00e1, a DTO-ba \u00f6sszegy\u0171jthetj\u00fck az \u00f6sszetartoz\u00f3 adatokat \u00e9s egyben k\u00fcldj\u00fck el a kliensnek.</li> </ul> <p>Gondoljuk v\u00e9gig, hogyan \u00e9rdemes \u00f6sszegy\u0171jteni az adatokat, ha a kliens a kos\u00e1rban lev\u0151 \u00f6sszes term\u00e9ket, azok darabsz\u00e1m\u00e1t, valamint az \u00f6sszes term\u00e9k darabsz\u00e1m\u00e1t szeretn\u00e9nk megjelen\u00edteni?</p> <ol> <li> <p>Az <code>OrderItem</code>-ben a kliens szempontj\u00e1b\u00f3l felesleges adat a <code>CartID</code>, valamint az <code>ID</code>. Ezeket kisz\u0171rve \u00e9s a t\u00f6bbi property-t meghagyva m\u00e1r m\u00e1s oszt\u00e1llyal dolgozunk, mint az <code>OrderItem</code>, viszont m\u00e9g mindig csak egy kos\u00e1r cikket reprezent\u00e1lunk. Az \u00edgy keletkezett oszt\u00e1ly neve legyen <code>CartItem</code>.</p> </li> <li> <p>Vegy\u00fck \u00e9szre, hogy a <code>CartItem</code>-ben t\u00e1rolt <code>Product</code> term\u00e9kreprezent\u00e1ci\u00f3ra ugyanez a gondolatmenet \u00e9rv\u00e9nyes, azzal az elt\u00e9r\u00e9ssel, hogy a <code>Product</code> oszt\u00e1lyt b\u0151v\u00edteni kell a Manufacturer nev\u00e9vel, a <code>ManufacturerID</code> helyett (hiszen a felhaszn\u00e1l\u00f3i fel\u00fcleten ezt a nevet akarjuk megjelen\u00edteni). Teh\u00e1t hozzunk l\u00e9tre egy \u00faj <code>Product</code> oszt\u00e1lyt is, \u00e9s t\u00e1roljuk el ezt a <code>CartItem</code>-ben!</p> </li> <li> <p>Ilyen <code>CartItem</code> objektumokat gy\u0171jts\u00fcnk \u00f6ssze egy list\u00e1ba, valamint sz\u00e1moljuk, hogy h\u00e1ny term\u00e9k van \u00f6sszesen a kos\u00e1rban. Legyen ez egy <code>UserCart</code> oszt\u00e1ly. Ilyen <code>UserCart</code> p\u00e9ld\u00e1nyokat k\u00fcld\u00fcnk majd a kliensnek.</p> </li> </ol> <p>A DTO-kat \u00e9rdemes k\u00fcl\u00f6n szervezni az adatb\u00e1zis entit\u00e1sokt\u00f3l. Szervezz\u00fck \u0151ket egy DTOs mapp\u00e1ba! A fenti megold\u00e1ssal tov\u00e1bbmenve, n\u00e9zz\u00fck meg, hogyan fognak kin\u00e9zni ezek az oszt\u00e1lyok!</p> <p><code>CartItem</code> oszt\u00e1ly, ami kisz\u0171ri az <code>OrderItem</code>-b\u0151l a kliens sz\u00e1m\u00e1ra felesleges adatokat, valamint egy kliens oldali, kos\u00e1rban lev\u0151 \u00e1rucikket reprezent\u00e1l:</p> <pre><code>namespace WebshopApi.DTOs\n{\n    public class CartItem\n    {\n        public Product Product { get; set; } // Olyan product, amiben m\u00e1r nem ManufacturerID szerepel\n        public int Amount { get; set; } // A rendelt mennyis\u00e9g\n    }\n}\n</code></pre> <p>\u00c9s a hozz\u00e1 tartoz\u00f3 Product oszt\u00e1ly:</p> <pre><code>namespace WebshopApi.DTOs\n{\n    public class Product\n    {\n        public string ProductName { get; set; } // A term\u00e9k neve, pl AB123 Full HD TV\n        public string Manufacturer { get; set; } // A term\u00e9k gy\u00e1rt\u00f3j\u00e1nak !!neve!!, pl BMETV\n        public int Price { get; set; } // A term\u00e9k \u00e1ra\n        public int ID { get; set; } // A term\u00e9k azonos\u00edt\u00f3ja\n    }\n}\n</code></pre> <p>Mi\u00e9rt szerepel itt az ID?</p> <p>Jogosan mer\u00fclhet fel a k\u00e9rd\u00e9s, hogy itt mi\u00e9rt szerepel az <code>ID</code>. V\u00e9giggondolva, egy kos\u00e1relem \u00e1ll egy term\u00e9kb\u0151l, valamint abb\u00f3l, hogy h\u00e1ny darab van az adott term\u00e9kb\u0151l. Megjelen\u00edt\u00e9sn\u00e9l ez\u00e9rt a kos\u00e1r elemet a term\u00e9k azonos\u00edtja, hiszen a term\u00e9k azonos\u00edt\u00f3ja alapj\u00e1n tudjuk megjelen\u00edteni a term\u00e9khez tartoz\u00f3 esetleges inform\u00e1ci\u00f3kat. Ezt a probl\u00e9m\u00e1t meg lehetne oldani \u00fagy is, hogy a kos\u00e1r elemnek van azonos\u00edt\u00f3ja, \u00e9s a term\u00e9knek nincs, esetleg mindkett\u0151nek lehet, ebben a p\u00e9ld\u00e1ban a term\u00e9k azonos\u00edt\u00f3j\u00e1t haszn\u00e1ljuk.</p> <p>A <code>UserCart</code> oszt\u00e1ly, ami \u00f6sszegy\u0171jti az egyes rendelt cikkeket, \u00e9s sz\u00e1molja, hogy h\u00e1ny term\u00e9ket rendelt\u00fcnk \u00f6sszesen:</p> <pre><code>namespace WebshopApi.DTOs\n{\n    public class UserCart\n    {\n        public List &lt;CartItem&gt; CartPieces { get; set; }\n        public int NumberOfItems { get; set; }\n    }\n}\n</code></pre> <p>Azzal, hogy a <code>CartItem</code>-eket list\u00e1ban t\u00e1roljuk, k\u00f6nnyen kezelhet\u0151v\u00e9 v\u00e1lnak, mind szerver, mind kliens oldalon, hiszen a kifele men\u0151 JSON objektumban a lista majd egy t\u00f6mbk\u00e9nt fog szerepelni, amin k\u00f6nnyen v\u00e9gig lehet iter\u00e1lni.</p> <p>Ezt a <code>UserCart</code> objektumot k\u00fcldj\u00fck a kliens fel\u00e9 a kontrollerb\u0151l, miut\u00e1n \u00f6sszegy\u0171jt\u00f6tt\u00fck a hozz\u00e1 tartoz\u00f3 cikkeket \u00e9s \u00f6sszesz\u00e1moltuk, hogy \u00f6sszesen h\u00e1ny term\u00e9k van a kos\u00e1rban.</p>"},{"location":"lecture-notes/async/#controller-osztaly-letrehozasa","title":"Controller oszt\u00e1ly l\u00e9trehoz\u00e1sa","text":"<p>A kontroller oszt\u00e1lyunkat \u00e9rdemes egy Controllers mapp\u00e1ba szervezni, majd a REST API &amp; ASP.NET Web API gyakorlaton alapj\u00e1n hozzunk l\u00e9tre egy Controller oszt\u00e1lyt. Ez tartalmazni fog egy <code>WebshopContext</code>-et, valamint a HTTP k\u00e9r\u00e9sek kiszolg\u00e1l\u00e1s\u00e1hoz l\u00e9trehozott v\u00e9gpontokat.</p> <p>Itt szembes\u00fcl\u00fcnk el\u0151sz\u00f6r az aszinkronit\u00e1ssal. N\u00e9zz\u00fck egy p\u00e9ld\u00e1n kereszt\u00fcl:</p> <p>A GET k\u00e9r\u00e9s, ami lek\u00e9rdezi az \u00f6sszes kosarat:</p> <pre><code>[HttpGet]\npublic async Task&lt;ActionResult&lt;IEnumerable&lt;Cart&gt;&gt;&gt; GetCarts()\n{\n    var carts = await _context.Carts.ToListAsync();\n    return carts;\n}\n</code></pre> <p>Figyelj\u00fck meg a f\u00fcggv\u00e9ny deklar\u00e1ci\u00f3j\u00e1ban az <code>async</code> kulcssz\u00f3t \u00e9s a <code>Task</code> t\u00edpust, valamint a f\u00fcggv\u00e9ny t\u00f6rzs\u00e9ben a \"p\u00e1rj\u00e1t\", az <code>await</code>-et. Ezekre async-await-k\u00e9nt szoktunk hivatkozni. \u00c9rtelmezz\u00fck teh\u00e1t:</p> <ol> <li>A f\u00fcggv\u00e9ny <code>Cart</code> p\u00e9ld\u00e1nyok list\u00e1j\u00e1t, <code>IEnumerable&lt;Cart&gt;</code> ad vissza,</li> <li>Amelyet a WebAPI kontrollernek megfelel\u0151en egy <code>ActionResult</code>-ba csomagolunk,</li> <li>\u00c9s az eg\u00e9szet m\u00e9g egy <code>Task</code>-ba is tessz\u00fck. Ez az aszinkronit\u00e1s miatt van.</li> </ol> <p>A fentiek mindegyike m\u00e1s miatt kell, de \u00edgy, egy\u00fctt adj\u00e1k a teljes megold\u00e1st. N\u00e9zz\u00fck ebb\u0151l is az aszinkronit\u00e1st, azaz a <code>Task</code> t\u00edpust \u00e9s az <code>await</code> kulcssz\u00f3t. Ezzel a defin\u00edci\u00f3val egy \u00fan. \"promise\"-t adunk vissza (m\u00e1s nyelvekben szokt\u00e1k \u00edgy h\u00edvni), amely egy j\u00f6v\u0151ben elv\u00e9gzend\u0151 feladat eredm\u00e9ny\u00e9t (fogja) tartalmazni.</p> <p>Mi\u00e9rt j\u00f3 ez? Az\u00e9rt, mert a kontroller met\u00f3dus elv\u00e9gz\u00e9se \u00edgy lesz aszinkron. Amikor a rendszer egy <code>await</code> utas\u00edt\u00e1shoz \u00e9r, a sz\u00e1l, ami eddig a feldolgoz\u00e1st v\u00e9gezte, abbahagyja ennek a k\u00e9r\u00e9snek a kiszolg\u00e1l\u00e1s\u00e1t, \u00e9s egy m\u00e1sik k\u00e9r\u00e9s v\u00e9grehajt\u00e1s\u00e1val folytatja a munk\u00e1t. Mi\u00e9rt is? Mert az <code>await</code> \"m\u00f6g\u00f6tti\" feladatr\u00f3l tudjuk, hogy id\u0151ig\u00e9nyes: az adatb\u00e1zisra \u00e9s a h\u00e1l\u00f3zatra v\u00e1runk. Feleslegesen v\u00e1rakoztatn\u00e1nk a kiszolg\u00e1l\u00f3 sz\u00e1lat, ha az itt \"meg\u00e1llna\" \u00e9s bev\u00e1rn\u00e1 az eredm\u00e9nyt. Ehelyett a feladatot kiadjuk egy h\u00e1tt\u00e9r rendszernek (az oper\u00e1ci\u00f3s rendszer \u00e9s a .NET aszinkron I/O alrendszer\u00e9nek - ebbe azonban nem megy\u00fcnk bele), \u00e9s arr\u00f3l k\u00e9r\u00fcnk \u00e9rtes\u00edt\u00e9st, amikor az itt v\u00e1rt v\u00e9geredm\u00e9ny elk\u00e9sz\u00fclt. Amint ez megt\u00f6rt\u00e9nik, a kor\u00e1bban felf\u00fcggesztett k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa folytat\u00f3dik tov\u00e1bb.</p> <p>M\u00e1sk\u00e9nt megfogalmazva a mi alkalmaz\u00e1sunk kiszolg\u00e1l\u00f3 sz\u00e1lai mindig akt\u00edvan munk\u00e1t fognak v\u00e9gezni, nem v\u00e1rakoznak. A v\u00e1rakoz\u00e1s helyett m\u00e1s feladatok v\u00e9grehajt\u00e1s\u00e1ra lesznek k\u00e9pesek. Ez \u00f6sszess\u00e9g\u00e9ben azt jelenti, hogy kevesebb oper\u00e1ci\u00f3s rendszer sz\u00e1lat vesz\u00fcnk ig\u00e9nybe \u00e9s ezzel t\u00f6bb k\u00e9r\u00e9st tudunk kiszolg\u00e1lni. Ett\u0151l az alkalmaz\u00e1sunk hat\u00e9konyabb lesz.</p> <p>Az el\u0151bb bemutatott f\u00fcggv\u00e9nyt szintaktikailag tov\u00e1bb egyszer\u0171s\u00edthetj\u00fck ha elhagyjuk a lok\u00e1lis v\u00e1ltoz\u00f3t \u00e9s k\u00f6zvetlen\u00fcl visszaadjuk a <code>Task</code> eredm\u00e9nyt. Funkcion\u00e1lisan az al\u00e1bbi implement\u00e1ci\u00f3 megegyezik a fentivel, azonban a magyar\u00e1zatot a fenti r\u00e9szletesebb ki\u00edr\u00e1s jobban szeml\u00e9lteti.</p> <pre><code>[HttpGet]\npublic Task&lt;ActionResult&lt;IEnumerable&lt;Carts&gt;&gt;&gt; GetCarts()\n{\n    return _context.Carts.ToListAsync(); // nincs await, \u00e9s a deklar\u00e1ci\u00f3ban sincs async\n}\n</code></pre> <p>A ***Async f\u00fcggv\u00e9nyek</p> <p>A t\u00e1rgyban eddig l\u00e1tott, lek\u00e9rdez\u00e9seket ki\u00e9rt\u00e9kel\u0151 f\u00fcggv\u00e9nyeknek (<code>ToList</code>, <code>First</code>, <code>All</code>, <code>Find</code>, stb...) mind van <code>...Async</code> p\u00e1rja, \u00e9s hasonl\u00f3an kell \u0151ket haszn\u00e1lni a szinkron p\u00e1rjukhoz. Ezen f\u00fcggv\u00e9nyek az alapjai az aszinkron m\u0171k\u00f6d\u00e9nek.</p> <p>A m\u0171k\u00f6d\u00e9s r\u00e9szteleibe enn\u00e9l tov\u00e1bb nem megy\u00fcnk. Annyit jegyezz\u00fcnk meg, hogy ahhoz, hogy a kontroller\u00fcnk aszinkron legyen, kell, hogy legyen \"alatta\" (itt: az Entity Framework-ben) t\u00e1mogat\u00e1s az aszinkronit\u00e1sra.</p> <p>N\u00e9zz\u00fcnk egy bonyolultabb p\u00e9ld\u00e1t: egy kos\u00e1r tartalm\u00e1nak \u00f6sszegy\u0171jt\u00e9se, majd elk\u00fcld\u00e9se, a kos\u00e1r rekord megkeres\u00e9se <code>FindAsync</code> seg\u00edts\u00e9g\u00e9vel:</p> <pre><code>[HttpGet(\"{id}\")]\npublic async Task&lt;ActionResult&lt;UserCart&gt;&gt; GetCart(int id)\n{\n    // aszinkron k\u00e9r\u00e9s az id \u00e1ltal azonos\u00edtott kos\u00e1r megtal\u00e1l\u00e1s\u00e1ra\n    var cartRecord = await _context.Carts.FindAsync(id); \n\n    if (cartRecord == null)\n        return NotFound();\n\n    // lek\u00e9rdez\u00e9s fel\u00e9p\u00edt\u00e9se\n    var productsquery =\n        from p1 in _context.Products\n        join m1 in _context.Manufacturers on p1.ManufacturerID equals m1.ID\n        select new Product(p1.ID, m1.Name, p1.Name, p1.Price); // fel\u00e9p\u00edtj\u00fck a DTO Product-okat\n    // aszinkron ki\u00e9rt\u00e9kel\u00e9s\n    var products = await productsquery.ToListAsync().ConfigureAwait(false);\n\n    // aszinkron k\u00e9r\u00e9s az order itemsekre\n    var orderitemsquery = from oi in _context.OrderItems\n                          where oi.CartID == cartRecord.ID\n                          select oi;\n    var orderitems = await orderitemsquery.ToListAsync().ConfigureAwait(false);\n\n    // a tov\u00e1bbiakban szinkron a m\u0171velet, mert m\u00e1r mem\u00f3ri\u00e1ban van a k\u00e9t eredm\u00e9ny\n\n    // Keress\u00fck meg azokat a term\u00e9keket, amik a kos\u00e1rban vannak, \n    // joinoljuk az OrderItems rekordokkal, majd hozzunk l\u00e9tre a kett\u0151b\u0151l egy CartItem DTO objektumot\n    var cartitems = products.Join(orderitems, p =&gt; p.ID, oi =&gt; oi.ProductID,\n                                  (p, v) =&gt; new CartItem(p, v.Pieces)).ToList();\n\n    // UserCart DTO el\u0151\u00e1ll\u00edt\u00e1sa\n    return new UserCart()\n    {\n        CartPieces = cartitems,\n        NumberOfItems = cartitems.Count()\n    }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy minden aszinkron m\u0171veletn\u00e9l <code>await</code>-et kell haszn\u00e1lni! Viszont amikor m\u00e1r v\u00e9gezt\u00fcnk azokkal a m\u0171veletekkel, amikn\u00e9l az adatb\u00e1zishoz kell fordulni, m\u00e1r haszn\u00e1lhatunk szinkron m\u0171veleteket!</p> <p>A <code>ConfigureAwait</code> met\u00f3dus</p> <p>A <code>ConfigureAwait(false)</code> tov\u00e1bbi teljes\u00edtm\u00e9ny optimaliz\u00e1l\u00e1sra ad lehet\u0151s\u00e9get. Ezzel a h\u00edv\u00e1ssal azt jelezz\u00fck, hogy az <code>await</code>-elt eredm\u00e9ny meg\u00e9rkez\u00e9se ut\u00e1n b\u00e1rmely sz\u00e1l folyathatja a tov\u00e1bbi munk\u00e1t, nem sz\u00fcks\u00e9ges ugyanazon sz\u00e1lnak folytatnia a kiszolg\u00e1l\u00e1st, amely kezdte. Kiszolg\u00e1l\u00f3 oldali alkalmaz\u00e1sok sor\u00e1n ez \u00e1ltal\u00e1ban a helyes viselked\u00e9s, de nem minden aszinkron vil\u00e1gra igaz ez (p\u00e9ld\u00e1ul UI sz\u00e1lak haszn\u00e1lata eset\u00e9n sz\u00e1m\u00edt). Err\u0151l r\u00e9szletesebben l\u00e1sd: https://devblogs.microsoft.com/dotnet/configureawait-faq/.</p> <p>V\u00e9g\u00fcl n\u00e9zz\u00fcnk egy p\u00e9ld\u00e1t a <code>FirstOrDefaultAsync</code>-re, valamint egy kliens fel\u0151l \u00e9rkez\u0151 POST k\u00e9r\u00e9sre, amiben a kliens \u00e1ltal k\u00fcld\u00f6tt h\u00e1rom azonos\u00edt\u00f3 alapj\u00e1n megkeress\u00fck a megfelel\u0151 adatb\u00e1zis rekordokat, \u00e9s friss\u00edtj\u00fck \u0151ket (darabsz\u00e1m n\u00f6vel\u00e9s/cs\u00f6kkent\u00e9s):</p> <pre><code>// Modell oszt\u00e1ly a k\u00e9r\u00e9s argumentumainak kezel\u00e9s\u00e9re\nnamespace WebshopApi.Models\n{\n    public class PostCartItemArgs\n    {\n        public int CartId { get; set; }\n        public int ProductId { get; set; }\n        public int Amount { get; set; }\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n// Controller oszt\u00e1lyban lev\u0151 POST k\u00e9r\u00e9s\n[HttpPost]\npublic async Task&lt;IActionResult&gt; PostCartItem([FromBody] PostCartItemArgs data)\n{\n    // kos\u00e1r megkeres\u00e9se az ID alapj\u00e1n\n    var cart = await _context.Carts.FindAsync(data.CartId).ConfigureAwait(false);\n\n    if (cart == null)\n        return NotFound();\n\n    // keress\u00fck meg azokat az order itemeket, amik ebbe a kos\u00e1rba tartoznak, \u00e9s ezt a term\u00e9ket t\u00e1rolj\u00e1k\n    var orderitemquery = from oi in _context.OrderItems\n                         where (oi.CartID == data.Id &amp;&amp; oi.ProductID == data.ProductId)\n                         select oi;\n\n    // FirstOrDefault, hogy ha nem tal\u00e1l, az orderitem \u00e9rt\u00e9ke null legyen\n    var orderitem = await orderitemquery.FirstOrDefaultAsync().ConfigureAwait(false);\n\n    if (orderitem == null)\n    {\n        // Ha eddig nem szerepelt a rendelt term\u00e9kek k\u00f6z\u00f6tt, \u00faj OrderItems l\u00e9trehoz\u00e1sa\n        _context.OrderItems.Add(new OrderItems { CartID = data.Id, Amount = data.Amount, ProductID = data.ProductId });\n    }\n    else\n    {\n        // Ha m\u00e1r van ilyen term\u00e9k a rendel\u00e9sben\n        orderitem.Amount += data.Amount;\n\n        // Ha 0-ra cs\u00f6kkent a term\u00e9kb\u0151l rendelt darabsz\u00e1m, akkor t\u00f6r\u00f6lj\u00fck a rekordot\n        if (orderitem.Amount == 0)\n            _context.OrderItems.Remove(orderitem);\n    }\n\n    await _context.SaveChangesAsync(); // ez is await-elt, hiszen megint az adatb\u00e1zishoz fordulunk\n    return NoContent();\n}\n</code></pre> <p>Ki v\u00e1rja meg a <code>Task</code> eredm\u00e9ny\u00e9t, ha az csak a j\u00f6v\u0151ben fog elk\u00e9sz\u00fclni?</p> <p>Minden <code>async</code> f\u00fcggv\u00e9nyt valahol <code>await</code>-elni kell. Jelen esetben a kontroller met\u00f3dusunkat az ASP.NET Core keretrendszer fogja megh\u00edvni, \u00e9s az fogja \"megv\u00e1rni\" az eredm\u00e9nyt a JSON soros\u00edt\u00e1s el\u0151tt.</p>"},{"location":"lecture-notes/async/#teljes-peldakod","title":"Teljes p\u00e9ldak\u00f3d","text":"<p>A teljes p\u00e9ldak\u00f3d (p\u00e1r apr\u00f3 elt\u00e9r\u00e9ssel, valamint egy m\u00e1sik kontrollerrel) megtal\u00e1lhat\u00f3 a https://github.com/mzergi/WebshopApi/ repository-ban.</p>"},{"location":"lecture-notes/di/","title":"F\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s ASP.NET Core k\u00f6rnyezetben","text":"<p>Benedek Zolt\u00e1n, 2022.11.19</p> <p>Defin\u00edci\u00f3</p> <p>F\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s (Dependency Injection, r\u00f6viden DI) egy tervez\u00e9si minta. A fejleszt\u0151ket seg\u00edti abban, hogy az alkalmaz\u00e1s egyes r\u00e9szei laza csatol\u00e1ssal ker\u00fcljenek kialak\u00edt\u00e1sra.</p> <p>A f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s egy mechanizmus arra, hogy az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gi gr\u00e1fjainak l\u00e9trehoz\u00e1s\u00e1t f\u00fcggetlen\u00edts\u00fck az oszt\u00e1ly defin\u00edci\u00f3j\u00e1t\u00f3l.</p> <p>C\u00e9lok</p> <ul> <li>k\u00f6nnyebb b\u0151v\u00edthet\u0151s\u00e9g \u00e9s karbantarthat\u00f3s\u00e1g</li> <li>unit tesztelhet\u0151s\u00e9g</li> <li>k\u00f3d \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g</li> </ul> <p>Term\u00e9szetesen a fenti defin\u00edci\u00f3b\u00f3l \u00f6nmag\u00e1ban nem der\u00fcl ki, pontosan milyen probl\u00e9m\u00e1kat \u00e9s milyen m\u00f3don old meg a f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s. A k\u00f6vetkez\u0151 fejezetekben egy p\u00e9lda seg\u00edts\u00e9g\u00e9vel helyezz\u00fck kontextusba a probl\u00e9mak\u00f6rt, illetve p\u00e9lda keret\u00e9ben megismerked\u00fcnk az ASP.NET Core be\u00e9p\u00edtett DI szolg\u00e1ltat\u00e1s\u00e1nak alapjaival.</p> <p>Minta alkalmaz\u00e1s</p> <p>A C# forr\u00e1sk\u00f3d eg\u00e9sz itt \u00e9rhet\u0151 el: https://github.com/bmeviauac01/todoapi-di-sample</p>"},{"location":"lecture-notes/di/#pelda-1-fazis-szolgaltatas-osztaly-beegetett-fuggosegekkel","title":"P\u00e9lda 1. f\u00e1zis - szolg\u00e1ltat\u00e1s oszt\u00e1ly be\u00e9getett f\u00fcgg\u0151s\u00e9gekkel","text":"<p>A p\u00e9ld\u00e1nkban egy teend\u0151lista (TODO) kezel\u0151 alkalmaz\u00e1s e-mail \u00e9rtes\u00edt\u00e9seket k\u00fcld\u0151 r\u00e9szeibe tekint\u00fcnk bele, k\u00f3dr\u00e9szletek seg\u00edts\u00e9g\u00e9vel. Megjegyz\u00e9s: a k\u00f3d a t\u00f6m\u00f6rs\u00e9g \u00e9rdek\u00e9ben minimalisztikus.</p> <p>A p\u00e9ld\u00e1nk \"bel\u00e9p\u00e9si pontja\" a <code>ToDoService</code> oszt\u00e1ly <code>SendReminderIfNeeded</code> m\u0171velete.</p> <pre><code>// Teend\u0151k kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly\npublic class ToDoService\n{\n    const string smtpAddress = \"smtp.myserver.com\";\n\n    // Megvizsg\u00e1lja a param\u00e9terk\u00e9nt kapott todoItem objektumot, \u00e9s ha sz\u00fcks\u00e9ges,\n    // e-mail \u00e9rtes\u00edt\u00e9st k\u00fcld a teend\u0151r\u0151l a teend\u0151ben szerepl\u0151 kontakt szem\u00e9lynek.\n    public void SendReminderIfNeeded(TodoItem todoItem)\n    {\n        if (checkIfTodoReminderIsToBeSent(todoItem))\n        {\n            NotificationService notificationService = new NotificationService(smtpAddress);\n            notificationService.SendEmailReminder(todoItem.LinkedContactId, todoItem.Name);\n        }\n    }\n\n    bool checkIfTodoReminderIsToBeSent(TodoItem todoItem)\n    {\n        bool send = true;\n        /* ... */\n        return send;\n    }\n    // ...\n}\n\n// Entit\u00e1soszt\u00e1ly, egy v\u00e9grehajtand\u00f3 feladat adatait z\u00e1rja egys\u00e9gbe\npublic class TodoItem\n{\n    // Adatb\u00e1zis kulcs\n    public long Id { get; set; }\n    // Teend\u0151 neve/le\u00edr\u00e1sa\n    public string Name { get; set; }\n    // Jelzi, hogy a teend\u0151 elv\u00e9g\u00e9sre ker\u00fclt-e\n    public bool IsComplete { get; set; }\n    // Egy teend\u0151h\u00f6z lehet\u0151s\u00e9g van kontakt szem\u00e9ly hozz\u00e1rendel\u00e9s\u00e9re:  ha -1, nincs\n    // kontakt szem\u00e9ly hozz\u00e1rendelve, egy\u00e9bk\u00e9nt pedig a kontakt szem\u00e9ly azonos\u00edt\u00f3ja.\n    public int LinkedContactId { get; set; } = -1;\n}\n</code></pre> <p>A fenti k\u00f3dban (<code>ToDoService.SendReminderIfNeeded</code>) azt l\u00e1tjuk, hogy az e-mail k\u00fcld\u00e9s l\u00e9nyegi logik\u00e1j\u00e1t a <code>NotificationService</code> oszt\u00e1lyban kell keresn\u00fcnk. Val\u00f3ban, vizsg\u00e1l\u00f3d\u00e1sunk k\u00f6zpontj\u00e1ba ez az oszt\u00e1ly ker\u00fcl. A k\u00f6vetkez\u0151 k\u00f3dr\u00e9szlet ezen oszt\u00e1ly k\u00f3dj\u00e1t, valamint a f\u00fcgg\u0151s\u00e9geit mutatja be:</p> <pre><code>// \u00c9rtes\u00edt\u00e9sek k\u00fcld\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly\nclass NotificationService\n{\n    // Az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei\n    EMailSender _emailSender;\n    Logger _logger;\n    ContactRepository _contactRepository;\n\n    public NotificationService(string smtpAddress)\n    {\n        _logger = new Logger();\n        _emailSender = new EMailSender(_logger, smtpAddress);\n        _contactRepository = new ContactRepository();\n    }\n\n    // E-mail \u00e9rtes\u00edt\u00e9st k\u00fcld az adott azonos\u00edt\u00f3j\u00fa kontakt szem\u00e9lynek (a contactId\n    // egy kulcs a Contacts t\u00e1bl\u00e1ban)\n    public void SendEmailReminder(int contactId, string todoMessage)\n    {\n        string emailTo = _contactRepository.GetContactEMailAddress(contactId);\n        string emailSubject = \"TODO reminder\";\n        string emailMessage = \"Reminder about the following todo item: \" + todoMessage;\n        _emailSender.SendMail(emailTo, emailSubject, emailMessage);\n    }\n}\n\n// Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 oszt\u00e1ly\npublic class Logger\n{\n    public void LogInformation(string text) { /* ...*/ }\n    public void LogError(string text) { /* ...*/ }\n}\n\n// E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 oszt\u00e1ly\npublic class EMailSender\n{\n    Logger _logger;\n    string _smtpAddress;\n\n    public EMailSender(Logger logger, string smtpAddress)\n    {\n        _logger = logger;\n        _smtpAddress = smtpAddress;\n    }\n    public void SendMail(string to, string subject, string message)\n    {\n        _logger.LogInformation($\"Sendding e-mail. To: {to} Subject: {subject} Body: {message}\");\n\n        // ...\n    }\n}\n\n// Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly\npublic class ContactRepository\n{\n    public string GetContactEMailAddress(int contactId)\n    {\n        // ...\n    }\n    // ...\n}\n</code></pre> <p>P\u00e1r \u00e1ltal\u00e1nos gondolat:</p> <ul> <li>A <code>NotificationService</code> oszt\u00e1ly t\u00f6bb f\u00fcgg\u0151s\u00e9ggel rendelkezik (<code>EMailSender</code>, <code>Logger</code>, <code>ContactRepository</code> oszt\u00e1lyok), ezen oszt\u00e1lyokra \u00e9p\u00edtve val\u00f3s\u00edtja meg a szolg\u00e1ltat\u00e1sait.</li> <li>A f\u00fcgg\u0151s\u00e9g oszt\u00e1lyoknak lehetnek tov\u00e1bbi f\u00fcgg\u0151s\u00e9geik: az <code>EMailSender</code> remek p\u00e9lda erre, \u00e9p\u00edt a <code>Logger</code> oszt\u00e1lyra.</li> <li>Megjegyz\u00e9s: a <code>NotificationService</code>, <code>EMailSender</code>, <code>Logger</code>, <code>ContactRepository</code> oszt\u00e1lyokat szolg\u00e1ltat\u00e1soszt\u00e1lyoknak tekintj\u00fck, mert t\u00e9nyleges logik\u00e1t is tartalmaznak, nem csak adatokat z\u00e1rnak egys\u00e9gbe, mint pl. a <code>TodoItem</code>.</li> </ul> <p>Mint l\u00e1that\u00f3, a <code>SendEmailReminder</code> m\u0171veletet egy objektumgr\u00e1f szolg\u00e1lja ki, ahol a <code>NotificationService</code> a gy\u00f6k\u00e9robjektum, melynek h\u00e1rom f\u00fcgg\u0151s\u00e9ge van, \u00e9s a f\u00fcgg\u0151s\u00e9geinek (legal\u00e1bbis az <code>EMailSender</code>-nek) vannak tov\u00e1bbi f\u00fcgg\u0151s\u00e9gei. A k\u00f6vetkez\u0151 \u00e1bra ezt az objektumgr\u00e1fot illusztr\u00e1lja:</p> <p></p> <p>Megjegyz\u00e9s</p> <p>Felmer\u00fclhet benn\u00fcnk a k\u00e9rd\u00e9s, mi\u00e9rt a <code>NotificationService</code>-t, \u00e9s nem a <code>ToDoService</code>-t tekintj\u00fck gy\u00f6k\u00e9robjektumnak. Val\u00f3j\u00e1ban ez csak a n\u00e9z\u0151pontunkon m\u00falik: az egyszer\u0171s\u00e9g kedv\u00e9\u00e9rt a <code>ToDoService</code>-t egyfajta bel\u00e9p\u00e9si pontnak (\"kliensnek\") tekintj\u00fck a k\u00e9r\u00e9s vonatkoz\u00e1s\u00e1ban annak \u00e9rdek\u00e9ben, hogy kevesebb oszt\u00e1lyt kelljen a k\u00f6vetkez\u0151kben megvizsg\u00e1lnunk \u00e9s \u00e1talak\u00edtanunk. Egy val\u00f3 \u00e9letbeli alkalmaz\u00e1sban a <code>ToDoService</code>-t is j\u00f3 es\u00e9llyel a f\u00fcgg\u0151s\u00e9gi gr\u00e1f r\u00e9sz\u00e9nek tekinten\u00e9nk.</p> <p>Tekints\u00fck \u00e1t a megold\u00e1s legfontosabb jellemz\u0151it:</p> <ul> <li>Az oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit maga p\u00e9ld\u00e1nyos\u00edtja</li> <li>Az oszt\u00e1ly a f\u00fcgg\u0151s\u00e9gei konkr\u00e9t t\u00edpus\u00e1t\u00f3l f\u00fcgg (nem pedig interf\u00e9szekt\u0151l, \"absztrakci\u00f3kt\u00f3l\")</li> </ul> <p>Ez a megk\u00f6zel\u00edt\u00e9s t\u00f6bb s\u00falyos negat\u00edvummal b\u00edr:</p> <ol> <li>Rugalmatlans\u00e1g, neh\u00e9z b\u0151v\u00edthet\u0151s\u00e9g. A <code>NotificationService</code> (m\u00f3dos\u00edt\u00e1s n\u00e9lk\u00fcl) nem tud m\u00e1s lev\u00e9lk\u00fcld\u0151, napl\u00f3z\u00f3 \u00e9s contact repository implement\u00e1ci\u00f3kkal egy\u00fctt m\u0171k\u00f6dni, csak a be\u00e9getett <code>EMailSender</code>, <code>Logger</code> \u00e9s <code>ContactRepository</code> oszt\u00e1lyokkal. Vagyis pl. nem tudjuk m\u00e1s napl\u00f3z\u00f3 komponenssel, vagy pl. olyan contact repository-vel haszn\u00e1lni, amely m\u00e1s adatforr\u00e1sb\u00f3l dolgozik.</li> <li>Unit tesztelhet\u0151s\u00e9g hi\u00e1nya. A <code>NotificationService</code> (m\u00f3dos\u00edt\u00e1s n\u00e9lk\u00fcl) nem unit tesztelhet\u0151. Ehhez ugyanis le kell cser\u00e9lni az <code>EMailSender</code>, <code>Logger</code> \u00e9s <code>ContactRepository</code> f\u00fcgg\u0151s\u00e9geit olyanokra, melyek (tesztel\u00e9st seg\u00edt\u0151) egyszer\u0171/r\u00f6gz\u00edtett v\u00e1laszokat viselked\u00e9st mutatnak. Ne feledj\u00fck: a unit tesztel\u00e9s l\u00e9nyege, hogy egy oszt\u00e1ly viselked\u00e9s\u00e9t \u00f6nmag\u00e1ban tesztelj\u00fck (pl. az adatb\u00e1zist haszn\u00e1l\u00f3 ContactRepository helyett egy olyan ContactRepository-ra van sz\u00fcks\u00e9g, mely gyorsan, mem\u00f3ri\u00e1b\u00f3l szolg\u00e1lja ki a k\u00e9r\u00e9seket, a teszt el\u0151felt\u00e9teleinek megfelel\u0151en).</li> <li>Van m\u00e9g egy, els\u0151 r\u00e1n\u00e9z\u00e9sre nehezen \u00e9szrevehet\u0151 kellemetlen k\u00f6vetkezm\u00e9ny: a p\u00e9ld\u00e1nkban a <code>smtpAddress</code> param\u00e9tert is \u00e1t kell adni a <code>NotificationService</code> konstruktor\u00e1nak, az\u00e9rt, hogy azt tov\u00e1bb\u00edtani tudja az \u00e1ltala p\u00e9ld\u00e1nyos\u00edtott <code>EMailSender</code> f\u00fcgg\u0151s\u00e9g\u00e9nek. Ugyanakkor a <code>smtpAddress</code> a <code>NotificationService</code> sz\u00e1m\u00e1ra egy transzparens, \"\u00e9rtelmetlen\" inform\u00e1ci\u00f3, elviekben \"semmi k\u00f6ze hozz\u00e1\". Sajnos jelen pillanatban m\u00e9gis \u00e1t kell vezetni rajta, mert \u0151 p\u00e9ld\u00e1nyos\u00edtja az <code>EMailSender</code>-t, aki sz\u00e1m\u00e1ra ez az inform\u00e1ci\u00f3 relev\u00e1ns.</li> </ol> <p>A k\u00f6vetkez\u0151 l\u00e9p\u00e9sben \u00fagy alak\u00edtjuk \u00e1t a megold\u00e1sunkat, hogy a negat\u00edvumok t\u00f6bbs\u00e9g\u00e9t\u0151l meg tudjunk szabadulni.</p>"},{"location":"lecture-notes/di/#pelda-2-fazis-szolgaltatas-osztaly-manualis-fuggoseg-injektalassal","title":"P\u00e9lda 2. f\u00e1zis - szolg\u00e1ltat\u00e1s oszt\u00e1ly manu\u00e1lis f\u00fcgg\u0151s\u00e9g injekt\u00e1l\u00e1ssal","text":"<p>A kor\u00e1bbi megold\u00e1sunkat alak\u00edtjuk \u00e1t, a funkcion\u00e1lis k\u00f6vetelm\u00e9nyek v\u00e1ltozatlanok. Az \u00e1talak\u00edt\u00e1s legfontosabb ir\u00e1nyelvei: a f\u00fcgg\u0151s\u00e9geket absztrakci\u00f3kra, \"interf\u00e9sz alapokra\" helyezz\u00fck, \u00e9s az oszt\u00e1lyok nem maguk p\u00e9ld\u00e1nyos\u00edtj\u00e1k a f\u00fcgg\u0151s\u00e9geiket (a v\u00e1ltoztat\u00e1sok r\u00e9szletesebb kifejt\u00e9se a k\u00f3dblokk ut\u00e1n olvashat\u00f3).</p> <pre><code>public class ToDoService\n{\n    const string smtpAddress = \"smtp.myserver.com\";\n\n    // Megvizsg\u00e1lja a param\u00e9terk\u00e9nt kapott todoItem objektumot, \u00e9s ha sz\u00fcks\u00e9ges,\n    // e-mail \u00e9rtes\u00edt\u00e9st k\u00fcld a teend\u0151r\u0151l a teend\u0151ben szerepl\u0151 kontakt szem\u00e9lynek.\n    public void SendReminderIfNeeded(TodoItem todoItem)\n    {\n        if (checkIfTodoReminderIsToBeSent(todoItem))\n        {\n            var logger = new Logger();\n            var emailSender = new EMailSender(logger, smtpAddress);\n            var contactRepository = new ContactRepository();\n\n            NotificationService notificationService\n                = new NotificationService(logger, emailSender, contactRepository);\n            notificationService.SendEmailReminder(todoItem.LinkedContactId,\n                todoItem.Name);\n        }\n    }\n\n    bool checkIfTodoReminderIsToBeSent(TodoItem todoItem)\n    {\n        bool send = true;\n        /* ... */\n        return send;\n    }\n}\n\n// \u00c9rtes\u00edt\u00e9sek k\u00fcld\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly\nclass NotificationService\n{\n    // Az oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei\n    IEMailSender _emailSender;\n    ILogger _logger;\n    IContactRepository _contactRepository;\n\n    public NotificationService(ILogger logger, IEMailSender emailSender,\n        IContactRepository contactRepository)\n    {\n        _logger = logger;\n        _emailSender = emailSender;\n        _contactRepository = contactRepository;\n    }\n\n    // E-mail \u00e9rtes\u00edt\u00e9st k\u00fcld az adott azonos\u00edt\u00f3j\u00fa kontakt szem\u00e9lynek (a contactId\n    // egy kulcs a Contacts t\u00e1bl\u00e1ban)\n    public void SendEmailReminder(int contactId, string todoMessage)\n    {\n        string emailTo = _contactRepository.GetContactEMailAddress(contactId);\n        string emailSubject = \"TODO reminder\";\n        string emailMessage = \"Reminder about the following todo item: \" + todoMessage;\n        _emailSender.SendMail(emailTo, emailSubject, emailMessage);\n    }\n}\n\n#region Contracts (abstractions)\n\n// Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 interf\u00e9sz\npublic interface ILogger\n{\n    void LogInformation(string text);\n    void LogError(string text);\n}\n\n// E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 interf\u00e9sz\npublic interface IEMailSender\n{\n    void SendMail(string to, string subject, string message);\n}\n\n// Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 interf\u00e9sz\npublic interface IContactRepository\n{\n    string GetContactEMailAddress(int contactId);\n}\n\n#endregion\n\n#region Implementations\n\n// Napl\u00f3z\u00e1st t\u00e1mogat\u00f3 oszt\u00e1ly\npublic class Logger: ILogger\n{\n    public void LogInformation(string text) { /* ...*/  }\n    public void LogError(string text) {  /* ...*/  }\n}\n\n// E-mail k\u00fcld\u00e9sre szolg\u00e1l\u00f3 oszt\u00e1ly\npublic class EMailSender: IEMailSender\n{\n    ILogger _logger;\n    string _smtpAddress;\n\n    public EMailSender(ILogger logger, string smtpAddress)\n    {\n        _logger = logger;\n        _smtpAddress = smtpAddress;\n    }\n    public void SendMail(string to, string subject, string message)\n    {\n        _logger.LogInformation($\"Sendding e-mail. To: {to} Subject: {subject} Body: {message}\");\n\n        // ...\n    }\n}\n\n// Contact-ok perzisztens kezel\u00e9s\u00e9re szolg\u00e1l\u00f3 oszt\u00e1ly\npublic class ContactRepository: IContactRepository\n{\n    public string GetContactEMailAddress(int contactId)\n    {\n        // ...\n    }\n    // ...\n}\n\n#endregion\n</code></pre> <p>A kor\u00e1bbi megold\u00e1st a k\u00f6vetkez\u0151 pontokban fejlesztett\u00fck tov\u00e1bb:</p> <ul> <li>A <code>NotificationService</code> oszt\u00e1ly m\u00e1r nem maga p\u00e9ld\u00e1nyos\u00edtja a f\u00fcgg\u0151s\u00e9geit, hanem konstruktor  param\u00e9terekben kapja meg.</li> <li>Interf\u00e9szeket (absztrakci\u00f3kat) vezett\u00fcnk be a f\u00fcgg\u0151s\u00e9gek kezel\u00e9s\u00e9re.</li> <li>A <code>NotificationService</code> oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit interf\u00e9szek form\u00e1j\u00e1ban kapja meg. Azt, amikor egy oszt\u00e1ly a f\u00fcgg\u0151s\u00e9geit k\u00edv\u00fclr\u0151l kapja meg, DEPENDENCY INJECTION-nek (DI) vagyis f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1snak nevezz\u00fck.</li> <li>Eset\u00fcnkben konstruktor param\u00e9terekben kapj\u00e1k meg az oszt\u00e1lyok f\u00fcgg\u0151s\u00e9geiket. A DI ezen form\u00e1j\u00e1t CONSTRUCTOR INJECTION-nek (konstruktor injekt\u00e1l\u00e1s) nevezz\u00fck. Ez a f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s legyakoribb - \u00e9s legink\u00e1bb javasolt m\u00f3dja (alternat\u00edva pl. a property injection, amikor is publikus property setter seg\u00edts\u00e9g\u00e9vel \u00e1ll\u00edtjuk be az oszt\u00e1ly adott f\u00fcgg\u0151s\u00e9g\u00e9t).</li> </ul> <p>Megold\u00e1sunkban a <code>NotificationService</code> f\u00fcgg\u0151s\u00e9geit az oszt\u00e1ly (k\u00f6zvetlen) FELHASZN\u00c1L\u00d3JA p\u00e9ld\u00e1nyos\u00edtja (<code>ToDoService</code> oszt\u00e1ly). Els\u0151dlegesen ebb\u0151l ered\u0151en a k\u00f6vetkez\u0151 probl\u00e9m\u00e1k \u00e1llnak m\u00e9g fent:</p> <ol> <li>A <code>NotificationService</code> felhaszn\u00e1l\u00f3ja, vagyis a <code>ToDoService.SendReminderIfNeeded</code> m\u00e9g mindig f\u00fcgg a konkr\u00e9t implement\u00e1ci\u00f3s t\u00edpusokt\u00f3l (hiszen neki sz\u00fcks\u00e9ges p\u00e9ld\u00e1nyos\u00edtania a <code>Logger</code>, <code>EMailSender</code> \u00e9s <code>ContactRepository</code> oszt\u00e1lyokat).</li> <li>Ha az alkalmaz\u00e1sunkban t\u00f6bb helyen haszn\u00e1ljuk a <code>Logger</code>, <code>EMailSender</code> \u00e9s <code>ContactRepository</code> oszt\u00e1lyokat, mindenhol k\u00fcl\u00f6n-k\u00fcl\u00f6n explicit p\u00e9ld\u00e1nyos\u00edtani kell \u0151ket. Vagyis mindenhol k\u00fcl\u00f6n-k\u00fcl\u00f6n d\u00f6nteni kell \u00e9s meg kell adni, hogy milyen absztrakci\u00f3  (interf\u00e9sz t\u00edpus) eset\u00e9n milyen implement\u00e1ci\u00f3s t\u00edpust haszn\u00e1lunk az alkalmaz\u00e1sban. Ez a k\u00f3d/logika duplik\u00e1ci\u00f3 speci\u00e1lis, kiss\u00e9 nehezen kisz\u00farhat\u00f3 esete.</li> <li>A c\u00e9lunk ezzel szemben az lenne, hogy egyetlen k\u00f6zponti helyen hat\u00e1rozzuk meg hogy milyen absztrakci\u00f3 (interf\u00e9sz t\u00edpus) eset\u00e9n milyen implement\u00e1ci\u00f3s t\u00edpust kell mindenhol haszn\u00e1lni az alkalmaz\u00e1sban (pl. ILogger-&gt;Logger, IMailSender-&gt;EMailSender).</li> <li>Ez\u00e1ltal egyr\u00e9szt egy helyen, k\u00f6nnyen \u00e1t tudn\u00e1nk tekinteni a lek\u00e9pez\u00e9seinket.</li> <li>M\u00e1sr\u00e9szt ha meg akarjuk v\u00e1ltoztatni az egyik lek\u00e9pez\u00e9st (pl. ILogger eset\u00e9n Logger helyett AdvancedLogger haszn\u00e1lata), azt el\u00e9g egy k\u00f6zponti helyen megtenni.</li> </ol>"},{"location":"lecture-notes/di/#pelda-3-fazis-fuggosegek-injektalasa-net-dependency-injection-alapokon","title":"P\u00e9lda 3. f\u00e1zis - f\u00fcgg\u0151s\u00e9gek injekt\u00e1l\u00e1sa .NET Dependency Injection alapokon","text":"<p>Az el\u0151z\u0151 fejezetben z\u00e1r\u00f3gondolatk\u00e9nt megfogalmazott k\u00e9t probl\u00e9ma megold\u00e1s\u00e1ra m\u00e1r n\u00e9mi extra seg\u00edts\u00e9gre van sz\u00fcks\u00e9g\u00fcnk: egy Inversion of Control (IoC) kont\u00e9nerre (melyre DI, Dependency Injection kont\u00e9nerk\u00e9nt is szok\u00e1s hivatkozni). Egy IoC kont\u00e9nerbe absztrakci\u00f3s t\u00edpus -&gt; implement\u00e1ci\u00f3s t\u00edpus lek\u00e9pez\u00e9seket tudunk t\u00e1rolni (REGISTER), majd ezt k\u00f6vet\u0151en absztrakci\u00f3s t\u00edpus alapj\u00e1n implement\u00e1ci\u00f3s t\u00edpusokat p\u00e9ld\u00e1nyos\u00edtani (RESOLVE). R\u00e9szletesebben:</p> <ol> <li>REGISTER (regisztr\u00e1ci\u00f3): Az alkalmaz\u00e1s indul\u00e1sakor egyszer, k\u00f6zpontos\u00edtva egy Inversion of Control (IoC) kont\u00e9nerbe beregisztr\u00e1ljuk a f\u00fcgg\u0151s\u00e9gi lek\u00e9pez\u00e9seket (pl. ILogger-&gt;Logger, IMailSender-&gt;EMailSender). Ez a DI folyamat REGISTER l\u00e9p\u00e9se.<ul> <li>Megjegyz\u00e9s: ezzel megoldottuk az el\u0151z\u0151 fejezetben felvezetett 2. probl\u00e9m\u00e1t, a lek\u00e9pez\u00e9seket egy k\u00f6zponti helyen \u00e9s nem az alkalmaz\u00e1sban sz\u00e9tsz\u00f3rva adjuk meg.</li> </ul> </li> <li>RESOLVE (f\u00fcgg\u0151s\u00e9gfelold\u00e1s): Amikor az alkalmaz\u00e1s fut\u00e1sakor sz\u00fcks\u00e9g\u00fcnk van egy implement\u00e1ci\u00f3s objektumra, a kont\u00e9nert\u0151l az absztrakci\u00f3  (interf\u00e9szt) t\u00edpus\u00e1t megadva k\u00e9r\u00fcnk egy implement\u00e1ci\u00f3t (pl. ILoggert megadva egy Logger objektumot kapunk).<ul> <li>A resolve l\u00e9p\u00e9st az alkalmaz\u00e1s \"bel\u00e9p\u00e9si pontj\u00e1ban\" tessz\u00fck meg (pl. WebApi eset\u00e9n az egyes API k\u00e9r\u00e9sek be\u00e9rkez\u00e9sekor). A felold\u00e1st a kont\u00e9nert\u0151l csak a \"ROOT OBJECT\"-re (pl. WebApi eset\u00e9n a megfelel\u0151 Controller oszt\u00e1lyra) k\u00e9rj\u00fck explicit m\u00f3don: ez legy\u00e1rtja a root objectet, illetve annak valamennyi f\u00fcgg\u0151s\u00e9g\u00e9t, \u00e9s valamennyi k\u00f6zvetett f\u00fcgg\u0151s\u00e9g\u00e9t: el\u0151\u00e1ll egy objektumgr\u00e1f.  Ez az AUTOWIRING folyamata.</li> <li>Megjegyz\u00e9s: Web API eset\u00e9n a Resolve l\u00e9p\u00e9st a keretrendszer v\u00e9gzi el: mi csak annyit tapasztalunk, hogy a controller oszt\u00e1lyunk automatikusan p\u00e9ld\u00e1nyos\u00edt\u00f3dik, \u00e9s valamennyi konstruktor param\u00e9tere automatikusan kit\u00f6lt\u00e9sre ker\u00fcl (a REGISTER l\u00e9p\u00e9s regisztr\u00e1ci\u00f3i alapj\u00e1n).</li> </ul> </li> </ol> <p>Szerencs\u00e9re a .NET rendelkezik IoC Container alap\u00fa dependency injection szolg\u00e1ltat\u00e1ssal. A k\u00f6vetkez\u0151kben a tov\u00e1bbfejlesztett e-mail \u00e9rtes\u00edt\u0151 megold\u00e1sunkat p\u00e9ldak\u00e9nt haszn\u00e1lva vil\u00e1g\u00edtjuk meg jobban a mechanizmust.</p>"},{"location":"lecture-notes/di/#1-register-lepes-fuggosegek-beregisztralasa","title":"1) REGISTER l\u00e9p\u00e9s (f\u00fcgg\u0151s\u00e9gek beregisztr\u00e1l\u00e1sa)","text":"<p>Asp.Net Core k\u00f6rnyezetben a f\u00fcgg\u0151s\u00e9gek beregisztr\u00e1l\u00e1sa a <code>Program.cs</code> f\u00e1jl t\u00f6rt\u00e9nik: az itt tal\u00e1lhat\u00f3 k\u00f3dr\u00e9szek az alkalmaz\u00e1s inicializ\u00e1l\u00e1sakor futnak le. A sz\u00e1munkra relev\u00e1ns k\u00f3d:</p> <pre><code>var builder = WebApplication.CreateBuilder(args);\n\n// ...\nbuilder.Services.AddSingleton&lt;ILogger, Logger&gt;();\nbuilder.Services.AddTransient&lt;INotificationService, NotificationService&gt;();\nbuilder.Services.AddScoped&lt;IContactRepository, ContactRepository&gt;();\nbuilder.Services.AddSingleton&lt;IEMailSender, EMailSender&gt;(\n    sp =&gt; new EMailSender(sp.GetRequiredService&lt;ILogger&gt;(), \"smtp.myserver.com\") );\n// ...\n</code></pre> <p>Az els\u0151 sor egy <code>builder</code> objektumot hoz l\u00e9tre, ennek <code>Services</code> propertyje egy <code>IServiceCollection</code> t\u00edpus\u00fa objektum. Sz\u00e1munkra ez reprezent\u00e1lja a keretendszer \u00e1ltal m\u00e1r el\u0151re p\u00e9ld\u00e1nyos\u00edtott IoC kont\u00e9nert, ebbe tudjuk a saj\u00e1t f\u00fcgg\u0151s\u00e9geinket beregisztr\u00e1lni. A f\u00fcgg\u0151s\u00e9gek beregisztr\u00e1l\u00e1sa ezen <code>IServiceCollection</code> interf\u00e9sz AddSingleton, AddTransient \u00e9s AddScoped m\u0171veleteivel t\u00f6rt\u00e9nik.</p> <p>Megjegyz\u00e9s</p> <p>.NET 6-ot megel\u0151z\u0151 verzi\u00f3kban nem a <code>Program.cs</code> f\u00e1jlban, hanem egy <code>Startup</code> nev\u0171 oszt\u00e1ly <code>ConfigureServices</code> m\u0171velet\u00e9ben t\u00f6rt\u00e9nt a f\u00fcgg\u0151s\u00e9gek beregisztr\u00e1l\u00e1sa.</p> <p>A</p> <pre><code>builder.Services.AddSingleton&lt;ILogger, Logger&gt;();\n</code></pre> <p>sorral <code>ILogger</code> t\u00edpusk\u00e9nt a <code>Logger</code> implement\u00e1ci\u00f3s t\u00edpust regisztr\u00e1ljuk be (ILogger-&gt;Logger lek\u00e9pz\u00e9s), m\u00e9gpedig az AddSingleton m\u0171velet hat\u00e1s\u00e1ra singleton-k\u00e9nt. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l egy <code>ILogger</code> objektumot k\u00e9r\u00fcnk (resolve), a kont\u00e9nert\u0151l egy <code>Logger</code> objektumot kapunk, m\u00e9gpedig mindig ugyanazt a p\u00e9ld\u00e1nyt. A</p> <pre><code>builder.Services.AddTransient&lt;INotificationService, NotificationService&gt;();\n</code></pre> <p>sorral <code>INotificationService</code> t\u00edpusk\u00e9nt a <code>NotificationService</code> implement\u00e1ci\u00f3s t\u00edpust regisztr\u00e1ljuk be (INotificationService-&gt;NotificationService lek\u00e9pz\u00e9s), m\u00e9gpedig az AddTransient m\u0171velet hat\u00e1s\u00e1ra tranziens m\u00f3don. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l egy <code>INotificationService</code> objektumot k\u00e9r\u00fcnk (resolve), a kont\u00e9nert\u0151l egy <code>NotificationService</code> objektumot kapunk, m\u00e9gpedig minden lek\u00e9rdez\u00e9skor egy \u00fajonnan l\u00e9trehozott p\u00e9ld\u00e1nyt. A</p> <pre><code>builder.Services.AddScoped&lt;IContactRepository, ContactRepository&gt;();\n</code></pre> <p>sor <code>IContactRepository</code> t\u00edpusk\u00e9nt a <code>ContactRepository</code> implement\u00e1ci\u00f3s t\u00edpust regisztr\u00e1lja be (IContactRepository-&gt;ContactRepository lek\u00e9pz\u00e9s), m\u00e9gpedig az AddScoped m\u0171velet hat\u00e1s\u00e1ra scope-olt m\u00f3don. Ez azt jelenti, hogy ha k\u00e9s\u0151bb a kont\u00e9nert\u0151l <code>IContactRepository</code> objektumot k\u00e9r\u00fcnk (resolve),  <code>ContactRepository</code> objektumot kapunk, m\u00e9gpedig adott hat\u00f3k\u00f6r\u00f6n bel\u00fcl ugyanazt, elt\u00e9r\u0151 hat\u00f3k\u00f6r\u00f6kben m\u00e1sokat. A Web API alkalmaz\u00e1sokn\u00e1l egy-egy API k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sz\u00e1m\u00edt egy-egy megfelel\u0151 hat\u00f3k\u00f6rnek: vagyis a kont\u00e9nert\u0151l egy k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sor\u00e1n ugyanazt az objektump\u00e9ld\u00e1nyt, elt\u00e9r\u0151 k\u00e9r\u00e9sek eset\u00e9n m\u00e1sokat kapunk.</p> <p>A mintaalkalmaz\u00e1sunkban tov\u00e1bbi regisztr\u00e1ci\u00f3kkal is tal\u00e1lkozunk, ezekre k\u00e9s\u0151bb t\u00e9r\u00fcnk vissza.</p>"},{"location":"lecture-notes/di/#2-resolve-lepes-fuggosegek-feloldasa","title":"2) RESOLVE l\u00e9p\u00e9s (f\u00fcgg\u0151s\u00e9gek felold\u00e1sa)","text":""},{"location":"lecture-notes/di/#alapok","title":"Alapok","text":"<p>Jelen pillanatban ott tartunk, hogy az alkalmaz\u00e1s indul\u00e1sakor beregisztr\u00e1ltuk a szolg\u00e1ltat\u00e1s t\u00edpusok f\u00fcgg\u0151s\u00e9gi lek\u00e9pez\u00e9seit az ASP.NET Core IoC kont\u00e9ner\u00e9be. A t\u00edpuslek\u00e9pez\u00e9seink a k\u00f6vetkez\u0151k:</p> <ul> <li>ILogger -&gt; Logger, singletonk\u00e9nt</li> <li>INotificationService -&gt; NotificationService, tranziensk\u00e9nt</li> <li>IContactRepository -&gt; ContactRepository, scope-oltk\u00e9nt</li> <li>IEMailSender -&gt; EMailSender, singletonk\u00e9nt</li> </ul> <p>Ezt k\u00f6vet\u0151en, amikor sz\u00fcks\u00e9g\u00fcnk van egy adott implement\u00e1ci\u00f3s t\u00edpusra, a kont\u00e9nert\u0151l az (absztrakci\u00f3s) t\u00edpus, mint kulcs alapj\u00e1n k\u00e9rhet\u00fcnk egy implement\u00e1ci\u00f3s p\u00e9ld\u00e1nyt. Ennek sor\u00e1n ASP.NET Core k\u00f6rnyezetben a kont\u00e9nert egy <code>IServiceProvider</code> hivatkoz\u00e1s form\u00e1j\u00e1ban kapjuk meg, \u00e9s a <code>GetService</code> m\u0171velet k\u00fcl\u00f6nb\u00f6z\u0151 form\u00e1it haszn\u00e1ljuk. Pl.:</p> <pre><code>void SimpleResolve(IServiceProvider sp)\n{\n    // Mivel az ILogger t\u00edpushoz a Logger oszt\u00e1lyt regisztr\u00e1ltuk,\n    // egy Logger p\u00e9ld\u00e1nnyal t\u00e9r vissza.\n    var logger1 = sp.GetService(typeof(ILogger));\n\n    // A t\u00edpus generikus param\u00e9terben is megadhatjuk, k\u00e9nyelmesebb, ezt szoktuk haszn\u00e1lni.\n    // Ehhez sz\u00fcks\u00e9g van a Microsoft.Extensions.DependencyInjection n\u00e9vt\u00e9r using-ol\u00e1s\u00e1ra,\n    // mert ez a GetService forma ott defini\u00e1lt extension methodk\u00e9nt.\n    // Mivel az ILogger t\u00edpushoz a Logger oszt\u00e1lyt regisztr\u00e1ltuk,\n    // egy Logger p\u00e9ld\u00e1nnyal t\u00e9r vissza.\n    var logger2 = sp.GetService&lt;ILogger&gt;();\n\n    // M\u00edg a GetService null-t ad vissza, ha nem siker\u00fcl feloldani a\n    // kont\u00e9ner alapj\u00e1n a hivatkoz\u00e1st, a GetRequiredService kiv\u00e9telt dob.\n    var logger3 = sp.GetRequiredService&lt;ILogger&gt;();\n    // ...\n}\n</code></pre> <p>A p\u00e9ld\u00e1ban k\u00f3dkommentek r\u00e9szletesen elmagyar\u00e1zz\u00e1k a viselked\u00e9st. Minden esetben a l\u00e9nyeg az, hogy vagy a typeof oper\u00e1torral, vagy generikus param\u00e9terben megadunk egy absztrakci\u00f3s t\u00edpust, \u00e9s a <code>GetService</code> egy az ahhoz beregisztr\u00e1lt implement\u00e1ci\u00f3s t\u00edpussal t\u00e9r vissza.</p>"},{"location":"lecture-notes/di/#objektumgraf-feloldasa-autowiring","title":"Objektumgr\u00e1f felold\u00e1sa, autowiring","text":"<p>Az el\u0151z\u0151 p\u00e9ld\u00e1nkban a kont\u00e9ner a felold\u00e1s sor\u00e1n komolyabb \"fejt\u00f6r\u00e9s\" n\u00e9lk\u00fcl tudta a <code>Logger</code> oszt\u00e1lyt p\u00e9ld\u00e1nyos\u00edtani, ugyanis annak nincsenek tov\u00e1bbi f\u00fcgg\u0151s\u00e9gei: egyetlen default konstruktorral rendelkezik. Tekints\u00fck most az <code>INotificationService</code> felold\u00e1s\u00e1t:</p> <pre><code>public void ObjectGraphResolve(IServiceProvider sp)\n{\n    var notifService = sp.GetService&lt;INotificationService&gt;();\n    // ...\n}\n</code></pre> <p>A felold\u00e1s (GetService h\u00edv\u00e1s) sor\u00e1n a kont\u00e9nernek egy <code>NotificationService</code> objektumot kell l\u00e9trehoznia. Ez csak \u00fagy lehets\u00e9ges, ha minden konstruktor param\u00e9ter\u00e9nek megfelel\u0151 objektumot ad meg. Ez a gyakorlatban azt jelenti, hogy a l\u00e9trehoz\u00e1s sor\u00e1n feloldja az oszt\u00e1ly k\u00f6zvetlen \u00e9s k\u00f6zvetett f\u00fcgg\u0151s\u00e9geit, rekurz\u00edvan:</p> <ul> <li>A NotificationService oszt\u00e1ly egy h\u00e1romparam\u00e9teres konstruktorral rendelkezik (vagyis h\u00e1rom f\u00fcgg\u0151s\u00e9ge is van):  <code>NotificationService(ILogger logger, IEMailSender emailSender,  IContactRepository contactRepository)</code>. A konstruktorparam\u00e9tereket a <code>GetService</code> egyes\u00e9vel feloldja a regisztr\u00e1ci\u00f3k alapj\u00e1n:<ul> <li><code>ILogger</code> logger: egy <code>Logger</code> objektum lesz, mindig ugyanaz (mert singleton)<ul> <li><code>IEMailSender</code> emailSender: <code>EMailSender</code> objektum lesz, minden alkalommal m\u00e1s (mert transient)<ul> <li>Ennek van egy <code>ILogger</code> logger konstruktor param\u00e9tere, amit fel kell oldani:<ul> <li>Egy <code>Logger</code> objektum lesz, mindig ugyanaz (mert singleton)</li> </ul> </li> </ul> </li> <li><code>IContactRepository</code> contactRepository: <code>ContactRepository</code> objektum lesz, hat\u00f3k\u00f6r\u00f6nk\u00e9nt - Web API eset\u00e9n API h\u00edv\u00e1sonk\u00e9nt - m\u00e1s (mert scoped).</li> </ul> </li> </ul> </li> </ul> <p>A felold\u00e1s v\u00e9g\u00e9re - vagyis amikor visszat\u00e9r a fenti <code>GetService&lt;INotificationService&gt;()</code> h\u00edv\u00e1s - el\u0151\u00e1ll a teljesen felparam\u00e9terezett <code>NotificationService</code> objektum, valamennyi k\u00f6zvetlen \u00e9s k\u00f6zvetett f\u00fcgg\u0151s\u00e9g\u00e9vel, vagyis egy objektumgr\u00e1f-ot kapunk:</p> <p></p> <p>A DI keretrendszer/IoC kont\u00e9nerek azon tulajdons\u00e1g\u00e1t, hogy az objektumok f\u00fcgg\u0151s\u00e9geinek felder\u00edt\u00e9s\u00e9vel (a gyakorlatban jellemz\u0151en a konstruktor param\u00e9terek felder\u00edt\u00e9s\u00e9vel) a beregisztr\u00e1lt absztrakci\u00f3-&gt;implement\u00e1ci\u00f3 lek\u00e9pez\u00e9sek alapj\u00e1n k\u00e9pes objektumgr\u00e1fokat el\u0151\u00e1ll\u00edtani autowiring-nek nevezz\u00fck.</p>"},{"location":"lecture-notes/di/#fuggosegfeloldas-aspnet-web-api-osztalyok-eseten","title":"F\u00fcgg\u0151s\u00e9gfelold\u00e1s ASP.NET Web API oszt\u00e1lyok eset\u00e9n","text":"<p>Azon t\u00fal, hogy a megold\u00e1sunkat IoC kont\u00e9ner alapokra helyezz\u00fck, p\u00e1r tov\u00e1bbi v\u00e1ltoztat\u00e1st is v\u00e9grehajtunk a todo alkalmaz\u00e1sunkon. A <code>ToDoService</code> oszt\u00e1lyt megsz\u00fcntetj\u00fck, a funkcionalit\u00e1s\u00e1t kicsit m\u00e1s form\u00e1ban egy  ASP.NET Core <code>ControllerBase</code> lesz\u00e1rmazott <code>TodoController</code> oszt\u00e1lyba mozgatjuk. Ez az oszt\u00e1ly lesz a bel\u00e9p\u00e9si pont \u00e9s a gy\u00f6k\u00e9robjektum a k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa sor\u00e1n. Ez\u00e1ltal a megold\u00e1sunk jobban t\u00fckr\u00f6zi egy val\u00f3s Web API, MVC Web app, illetve Web Razor Pages app alkalmaz\u00e1s megk\u00f6zel\u00edt\u00e9s\u00e9t. A <code>ToDoService</code> oszt\u00e1lyt megtarthattuk volna a h\u00edv\u00e1si/f\u00fcgg\u0151s\u00e9gi l\u00e1ncunk k\u00f6zep\u00e9n, de demonstr\u00e1l\u00e1si c\u00e9ljainkat jobban szolg\u00e1lja egy egyszer\u0171s\u00edtett megk\u00f6zel\u00edt\u00e9s. Ezen t\u00falmen\u0151en bevezet\u00fcnk egy Entity Framework <code>DbContext</code> lesz\u00e1rmazott <code>TodoContext</code> oszt\u00e1lyt annak \u00e9rdek\u00e9ben, hogy demonstr\u00e1lni tudjuk, mik\u00e9ppen t\u00f6rt\u00e9nhet ennek injekt\u00e1l\u00e1sa a repository vagy egy\u00e9b oszt\u00e1lyainkba. Az objektumgr\u00e1funk a k\u00f6vetkez\u0151k\u00e9ppen n\u00e9z ki:</p> <p></p> <p>Az el\u0151z\u0151 k\u00e9t fejezetben feltett\u00fck, hogy a <code>GetService</code> h\u00edv\u00e1s\u00e1hoz egy <code>IServiceProvider</code> objektum rendelkez\u00e9sre \u00e1ll. Ha mi magunk hozunk l\u00e9tre egy kont\u00e9nert, akkor ez \u00edgy is van. Azonban csak a legritk\u00e1bb esetben szoktunk kont\u00e9nert k\u00f6zvetlen\u00fcl l\u00e9trehozni. Egy tipikus ASP.NET Web API alkalmaz\u00e1s eset\u00e9n a kont\u00e9nert a keretrendszer hozza l\u00e9tre, \u00e9s sz\u00e1munkra k\u00f6zvetlen\u00fcl nem is hozz\u00e1f\u00e9rhet\u0151. Ennek k\u00f6vetkezt\u00e9ben <code>IServiceProvider</code>hez - p\u00e1r indul\u00e1skori konfigur\u00e1ci\u00f3s \u00e9s kiterjeszt\u00e9si pontot eltekintve - hozz\u00e1f\u00e9r\u00e9st nem is kapunk. A j\u00f3 h\u00edr az, hogy erre nincs is sz\u00fcks\u00e9g. A DI alapkoncepci\u00f3j\u00e1ba ugyanis az is beletartozik, hogy a f\u00fcgg\u0151s\u00e9gfelold\u00e1st csak az alkalmaz\u00e1s bel\u00e9p\u00e9si pontj\u00e1ban a \"root object\"-re (gy\u00f6k\u00e9robjektum) v\u00e9gezz\u00fck el.  Web API eset\u00e9ben a bel\u00e9p\u00e9si pontot az egyes API k\u00e9r\u00e9sek kiszolg\u00e1l\u00e1sa jelenti. Amikor be\u00e9rkezik egy k\u00e9r\u00e9s, akkor az Url \u00e9s a routing szab\u00e1lyok alapj\u00e1n a keretrendszer meghat\u00e1rozza, mely Controller/ControllerBase lesz\u00e1rmazott oszt\u00e1lyt kell p\u00e9ld\u00e1nyos\u00edtani, \u00e9s azt l\u00e9tre is hozza. Amennyiben a controller oszt\u00e1lynak vannak f\u00fcgg\u0151s\u00e9gei (konstruktor param\u00e9terek), azok is felold\u00e1sra ker\u00fclnek a beregisztr\u00e1lt lek\u00e9pez\u00e9sek alapj\u00e1n, bele\u00e9rtve a k\u00f6zvetett f\u00fcgg\u0151s\u00e9geket is. El\u0151\u00e1ll a teljes objektumgr\u00e1f, a root object maga a controller oszt\u00e1ly.</p> <p>N\u00e9zz\u00fck ezt a gyakorlatban a kor\u00e1bbi p\u00e9ld\u00e1nk tov\u00e1bbfejleszt\u00e9s\u00e9vel, melyet egy <code>TodoController</code> oszt\u00e1llyal eg\u00e9sz\u00edtett\u00fcnk ki:</p> <pre><code>[Route(\"api/[controller]\")]\n[ApiController]\npublic class TodoController : ControllerBase\n{\n    // A TodoController oszt\u00e1ly f\u00fcgg\u0151s\u00e9gei\n    private readonly TodoContext _context; // ez egy DbContext\n    private readonly INotificationService _notificationService;\n\n    // A f\u00fcgg\u0151s\u00e9geket konstruktor param\u00e9terben kapja meg.\n    public TodoController(TodoContext context, INotificationService notificationService)\n    {\n        _context = context;\n        _notificationService = notificationService;\n\n        // Fill with some initial data\n        if (_context.TodoItems.Count() == 0)\n        {\n            _context.TodoItems.Add(new TodoItem { Name = \"Item1\" });\n            _context.TodoItems.Add(new TodoItem { Name = \"Item2\", LinkedContactId = 2});\n            _context.SaveChanges();\n        }\n    }\n\n    // API kezel\u0151f\u00fcggv\u00e9ny e-mail eml\u00e9keztet\u0151 \u00e9rtes\u00edt\u00e9s kik\u00fcld\u00e9s\u00e9re.\n    // P\u00e9lda: http post erre a c\u00edmre (pl. PostMan-nel):\n    //     http://localhost:58922/api/todo/2/reminder\n    // Ez a 2-es azonos\u00edt\u00f3j\u00fa todo item kontakt szem\u00e9ly\u00e9nek \u00e9rtes\u00edt\u00e9st k\u00fcld a todo itemr\u0151l.\n    [HttpPost(\"{id}/reminder\")]\n    public IActionResult ReminderMessageToLinkedContact(long id)\n    {\n        // Todo item kikeres\u00e9se, haszn\u00e1lja a _context DbContext objektumot\n        var item = _context.TodoItems.Find(id);\n        if (item == null)\n            return NotFound();\n\n        // Eml\u00e9keztet\u0151 e-mail kik\u00fcld\u00e9se\n        _notificationService.SendEmailReminder(item.LinkedContactId, item.Name);\n\n        // Val\u00f3j\u00e1ban nem hozunk l\u00e9tre semmit, egyszer\u0171 OK a v\u00e1lasz\n        return Ok();\n    }\n\n    // ... tov\u00e1bbi m\u0171veletek\n}\n</code></pre> <p>A <code>http://&lt;g\u00e9pc\u00edm&gt;/api/todo</code> url al\u00e1 bees\u0151 k\u00e9r\u00e9seket a routing szab\u00e1lyok alapj\u00e1n a <code>TodoController</code> oszt\u00e1ly kapja meg. Az \u00e9rtes\u00edt\u00e9s kik\u00fcld\u00e9s\u00e9t triggerel\u0151 <code>http://&lt;g\u00e9pc\u00edm&gt;/api/todo/&lt;todo-id&gt;/reminder</code> c\u00edmre \u00e9rkez\u0151 post k\u00e9r\u00e9st pedig a <code>TodoController.ReminderMessageToLinkedContact</code> m\u0171velete. A <code>TodoController</code>-t a keretrendszer p\u00e9ld\u00e1nyos\u00edtja, minden k\u00e9r\u00e9shez \u00faj objektumot hoz l\u00e9tre. Az oszt\u00e1lynak k\u00e9t f\u00fcgg\u0151s\u00e9ge van, melyeket konstruktor param\u00e9terben kap meg. Az els\u0151 egy <code>TodoContext</code> objektum, ami egy <code>DbContext</code> lesz\u00e1rmazott. A m\u00e1sik a m\u00e1r j\u00f3l ismert <code>INotificationService</code>. Mint az el\u0151z\u0151 fejezetben l\u00e1ttuk, a DI keretrendszer ezeket is p\u00e9ld\u00e1nyos\u00edtja a regisztr\u00e1lt lek\u00e9pez\u00e9sek alapj\u00e1n (az \u00f6sszes k\u00f6zvetett f\u00fcgg\u0151s\u00e9geikkel), param\u00e9terk\u00e9nt \u00e1tadja <code>TodoController</code> konstruktornak, ahol ezeket tagv\u00e1ltoz\u00f3kban elt\u00e1roljuk. \u00cdgy ezek a be\u00e9rkez\u0151 k\u00e9r\u00e9seket kiszolg\u00e1l\u00f3 m\u0171veletekben, mint pl. a  <code>ReminderMessageToLinkedContact</code>-ben  m\u00e1r rendelkez\u00e9sre \u00e1llnak.</p> <p>Megjegyz\u00e9s</p> <p>A <code>TodoContext</code> felold\u00e1sa csak akkor lehets\u00e9ges, ha ezt az IoC kont\u00e9nerbe el\u0151zetesen beregisztr\u00e1ltuk. Erre a k\u00f6vetkez\u0151 fejezetben t\u00e9r\u00fcnk ki.</p>"},{"location":"lecture-notes/di/#entity-framework-dbcontext-regisztracio-es-feloldas","title":"Entity Framework DbContext regisztr\u00e1ci\u00f3 \u00e9s felold\u00e1s","text":"<p>Alkalmaz\u00e1sokban - k\u00fcl\u00f6n\u00f6sen Asp.Net Core eset\u00e9ben - a DbContext haszn\u00e1lat\u00e1nak k\u00e9t m\u00f3dja lehets\u00e9ges:</p> <ul> <li>Minden alkalommal, amikor sz\u00fcks\u00e9g van r\u00e1, egy using blokkban p\u00e9ld\u00e1nyos\u00edtjuk \u00e9s fel is szabad\u00edtjuk. \u00cdgy egy be\u00e9rkez\u0151 k\u00e9r\u00e9s sor\u00e1n t\u00f6bb DbContext objektump\u00e9ld\u00e1ny is felhaszn\u00e1l\u00e1sra ker\u00fclhet.</li> <li>A <code>DbContext</code>-et be\u00e9rkez\u0151 k\u00e9r\u00e9senk\u00e9nt hozzuk l\u00e9tre, egy k\u00e9r\u00e9sen bel\u00fcl viszont megosztottan ugyanazt az objektump\u00e9ld\u00e1nyt haszn\u00e1lj\u00e1k az oszt\u00e1lyaink. Ez esetben a <code>DbContext</code>-re mint egy oszt\u00e1lyok k\u00f6z\u00f6tt megosztott repository-ra, pontosabban unit of work-re gondolunk. A bej\u00f6v\u0151 k\u00e9r\u00e9s sor\u00e1n egy <code>DbContext</code> objektumot hozunk l\u00e9tre, \u00e9s ezt injekt\u00e1ljuk be az erre \u00e9p\u00edt\u0151 oszt\u00e1lyoknak.</li> </ul> <p>Ez ut\u00f3bbi megk\u00f6zel\u00edt\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1ra remek k\u00e9zre es\u0151 be\u00e9p\u00edtett DI alap\u00fa megold\u00e1st ny\u00fajt az ASP.NET Core:  a kont\u00e9nerbe indul\u00e1skor beregisztr\u00e1ljuk a DbContext oszt\u00e1lyunkat, mely \u00edgy a Controller \u00e9s egy\u00e9b f\u00fcgg\u0151s\u00e9gei sz\u00e1m\u00e1ra automatikusan beinjekt\u00e1l\u00e1sra ker\u00fcl.</p> <p>N\u00e9zz\u00fck meg, hogyan is t\u00f6rt\u00e9nik a <code>TodoContext</code> <code>DbContext</code> lesz\u00e1rmazott oszt\u00e1lyunk beregisztr\u00e1l\u00e1sa a p\u00e9ld\u00e1nkban. A regisztr\u00e1ci\u00f3 helye a szok\u00e1sos <code>Program.cs</code> f\u00e1jl (.NET 6 el\u0151tt a szok\u00e1sos <code>Startup.ConfigureServices</code>):</p> <pre><code>// ...\nbuilder.Services.AddDbContext&lt;TodoContext&gt;(opt =&gt; opt.UseInMemoryDatabase(\"TodoList\"));\n// ...\n</code></pre> <p>Az <code>AddDbContext</code> egy a keretrendszer \u00e1ltal az <code>IServiceCollection</code> interf\u00e9szre defini\u00e1lt extension method. Ez a <code>DbContext</code> oszt\u00e1lyunk k\u00e9nyelmes beregisztr\u00e1ci\u00f3j\u00e1t teszi lehet\u0151v\u00e9. Ennek belsej\u00e9be nem l\u00e1tunk bele, mindenesetre lelke a scope-ot regisztr\u00e1ci\u00f3. \"Pszeudok\u00f3ddal\":</p> <pre><code>services.AddScoped&lt;TodoContext, TodoContext&gt;();\n</code></pre> <p>Mint a p\u00e9ld\u00e1ban l\u00e1that\u00f3, a <code>TodoContext</code> beregisztr\u00e1l\u00e1sa nem egy absztrakci\u00f3val t\u00f6rt\u00e9nik (nincs <code>ITodoContext</code> interf\u00e9sz), hanem mag\u00e1val a TodoContext implement\u00e1ci\u00f3s t\u00edpussal. A DI keretrendszerek/IoC kont\u00e9nerek t\u00e1mogatj\u00e1k, hogy a regisztr\u00e1ci\u00f3 sor\u00e1n az absztrakci\u00f3 egy konkr\u00e9t t\u00edpus legyen, jellemz\u0151en maga az implement\u00e1ci\u00f3s t\u00edpus. Ezt a megk\u00f6zel\u00edt\u00e9st csak indokolt esetben haszn\u00e1ljuk.</p> <p>ASP.NET Core k\u00f6rnyezetben a <code>DbContext</code> lesz\u00e1rmazott oszt\u00e1lyunk sz\u00e1m\u00e1ra soha nem vezet\u00fcnk be interf\u00e9szt, hanem az oszt\u00e1ly\u00e1nak a t\u00edpus\u00e1val ker\u00fcl beregisztr\u00e1l\u00e1sra az IoC kont\u00e9nerbe (a p\u00e9ld\u00e1nkban is <code>TodoContext</code>-&gt;<code>TodoContext</code> lek\u00e9pez\u00e9s t\u00f6rt\u00e9nik). A <code>DbContext</code> \u00f6nmag\u00e1ban is sz\u00e1mos perzisztencia providerrel (pl. MSSQL, Oracle, mem\u00f3ria, stb.) tud egy\u00fctt m\u0171k\u00f6dni, \u00edgy alkalmaz\u00e1sf\u00fcgg\u0151, mennyire van \u00e9rtelme absztrah\u00e1lni. Ha absztrah\u00e1ljuk az adathozz\u00e1f\u00e9r\u00e9st, akkor nem a <code>DbContext</code>-hez vezet\u00fcnk be interf\u00e9szt, hanem a Repository tervez\u00e9si mint\u00e1t haszn\u00e1ljuk, \u00e9s az egyes repository implement\u00e1ci\u00f3khoz vezet\u00fcnk be interf\u00e9szeket, valamint ezek vonatkoz\u00e1s\u00e1ban t\u00f6rt\u00e9nik az IoC kont\u00e9nerben a lek\u00e9pez\u00e9s (pl. <code>ITodoRepository</code>-&gt;<code>TodoRepository</code>). A repository oszt\u00e1lyok pedig vagy maguk p\u00e9ld\u00e1nyos\u00edtj\u00e1k a <code>DbContext</code> objektumokat, vagy konstruktor param\u00e9terben ker\u00fcl sz\u00e1mukra beinjekt\u00e1l\u00e1sra).</p> <p>Megjegyz\u00e9s</p> <p>Jelen dokumentumnak nem c\u00e9lja \u00e1ll\u00e1st foglalni abban, mely esetben c\u00e9lszer\u0171 Repository vagy egy\u00e9b mint\u00e1k seg\u00edts\u00e9g\u00e9vel a controller illetve service oszt\u00e1lyok sz\u00e1m\u00e1ra az EF/DbContext alap\u00fa adathozz\u00e1f\u00e9r\u00e9st egy DAL r\u00e9tegben elrejteni, illetve ezzel szemben mely esetben haszn\u00e1ljuk a DbContext oszt\u00e1lyt k\u00f6zvetlen\u00fcl a controller/szolg\u00e1ltat\u00e1s objektumainkban (vagyis a BLL-ben). Az illusztr\u00e1ci\u00f3 kedv\u00e9\u00e9rt a TodoApi alkalmaz\u00e1sunk ebben az \u00e9rtelemben vegyes megold\u00e1st alkalmaz: a TodoItem objektumok perziszt\u00e1l\u00e1s\u00e1ra a szolg\u00e1ltat\u00e1s oszt\u00e1lyok k\u00f6zvetlen\u00fcl a DbContext-et haszn\u00e1lj\u00e1k, m\u00edg a Contact-ok kezel\u00e9s\u00e9re a Repository mint\u00e1t haszn\u00e1ljuk.</p> <p>A fenti p\u00e9ld\u00e1ban az is l\u00e1that\u00f3, hogy a <code>AddDbContext</code> sor\u00e1n a DbContext (eset\u00fcnkben <code>TodoContext</code>) regisztr\u00e1l\u00e1sakor egy lambda kifejez\u00e9st is meg tudunk adni:</p> <pre><code>opt =&gt; opt.UseInMemoryDatabase(\"TodoList\")\n</code></pre> <p>Ezen a lambda kifejez\u00e9s\u00fcnket a kont\u00e9ner a k\u00e9s\u0151bbiekben a resolve sor\u00e1n - vagyis amikor egy <code>TodoContext</code> p\u00e9ld\u00e1nyos\u00edt\u00e1sa t\u00f6rt\u00e9nik - megh\u00edvja, \u00e9s param\u00e9terk\u00e9nt egy opci\u00f3z\u00f3 objektumot kapunk (a p\u00e9ld\u00e1ban <code>opt</code> argumentum): ennek seg\u00edts\u00e9g\u00e9vel lehet\u0151s\u00e9g\u00fcnk van a l\u00e9trehozand\u00f3 <code>TodoContext</code> objektum opci\u00f3z\u00e1s\u00e1ra, konfigur\u00e1l\u00e1s\u00e1ra. A p\u00e9ld\u00e1nkban a <code>UseInMemoryDatabase</code> m\u0171velet h\u00edv\u00e1s\u00e1val egy \"TodoList\" nev\u0171 mem\u00f3riaadatb\u00e1zist hozunk l\u00e9tre.</p>"},{"location":"lecture-notes/di/#haladobb-fuggosegregisztracio-pelda","title":"Halad\u00f3(bb) f\u00fcgg\u0151s\u00e9gregisztr\u00e1ci\u00f3 p\u00e9lda","text":"<p>Nem k\u00f6telez\u0151 tananyag.</p> <p>T\u00e9rj\u00fcnk ki a <code>Program.cs</code> f\u00e1jl kor\u00e1bban nem ismertetett szolg\u00e1ltat\u00e1sregisztr\u00e1ci\u00f3s r\u00e9szeire.</p> <p>Az <code>EMailSender</code> beregisztr\u00e1l\u00e1sa els\u0151 r\u00e1n\u00e9z\u00e9sre eg\u00e9szen tr\u00fckk\u00f6snek t\u0171nik:</p> <pre><code>builder.Services.AddSingleton&lt;IEMailSender, EMailSender&gt;(\n    sp =&gt; new EMailSender   (sp.GetRequiredService&lt;ILogger&gt;(), \"smtp.myserver.com\") );\n</code></pre> <p>A jobb meg\u00e9rt\u00e9s \u00e9rdek\u00e9ben n\u00e9zz\u00fck meg az EMailSender konstruktor\u00e1t:</p> <pre><code>public EMailSender(ILogger logger, string smtpAddress)\n{\n    _logger = logger;\n    _smtpAddress = smtpAddress;\n}\n</code></pre> <p>Az <code>EMailSender</code>t a kont\u00e9nernek kell majd a felold\u00e1s sor\u00e1n p\u00e9ld\u00e1nyos\u00edtania, ehhez a konstruktor param\u00e9tereket megfelel\u0151en meg kell tudni adnia. A logger param\u00e9ter teljesen \"rendben van\", a kont\u00e9ner ILogger-&gt;Logger regisztr\u00e1ci\u00f3ja alapj\u00e1n a kont\u00e9ner fel tudja oldani. Az <code>smtpAddress</code> param\u00e9ter \u00e9rt\u00e9k\u00e9t viszont nem tudja kital\u00e1lni. Az ASP.NET Core a probl\u00e9ma megold\u00e1s\u00e1ra a keretrendszer \"options\" mechanizmus\u00e1t javasolja, mely lehet\u0151v\u00e9 teszi, hogy az \u00e9rt\u00e9ket valamilyen konfigur\u00e1ci\u00f3b\u00f3l olvassuk be. Ez sz\u00e1munkra egy messzire vezet\u0151 sz\u00e1l lenne, \u00edgy egyszer\u0171s\u00edt\u00e9sk\u00e9ppen m\u00e1s megold\u00e1shoz folyamodtunk. Az <code>AddSingleton</code> (\u00e9s a t\u00f6bbi Add... m\u0171veletnek) van olyan overloadja, melyben egy lambda kifejez\u00e9st tudunk megadni. Ezt a lambd\u00e1t a kont\u00e9ner a k\u00e9s\u0151bbiekben a resolve sor\u00e1n (vagyis amikor egy <code>IEMailSender</code> alapj\u00e1n egy <code>EMailSender</code>t k\u00e9r\u00fcnk a kont\u00e9nert\u0151l) h\u00edvja, minden egyes p\u00e9ld\u00e1nyos\u00edt\u00e1s sor\u00e1n: ebben mi magunk p\u00e9ld\u00e1nyos\u00edtjuk az <code>EMailSender</code> objektumot, a konstruktor param\u00e9tereket az ig\u00e9nyeink szerint meghat\u00e1rozva. S\u0151t, a kont\u00e9ner \"van olyan kedves\", hogy lambda param\u00e9terben kapunk egy <code>IServiceCollection</code> objektumot (p\u00e9ld\u00e1nkban ez az <code>sp</code>), \u00e9s ezzel a kont\u00e9nerben m\u00e1r megl\u00e9v\u0151 regisztr\u00e1ci\u00f3k alapj\u00e1n a <code>GetRequiredService</code> \u00e9s <code>GetService</code> h\u00edv\u00e1sokkal k\u00e9nyelmesen tudunk t\u00edpusokat feloldani, amennyiben sz\u00fcks\u00e9g van r\u00e1.</p>"},{"location":"lecture-notes/di/#tovabbi-temakorok","title":"Tov\u00e1bbi t\u00e9mak\u00f6r\u00f6k","text":""},{"location":"lecture-notes/di/#dependency-injectionioc-kontenerek-altalanossagaban","title":"Dependency Injection/IoC kont\u00e9nerek \u00e1ltal\u00e1noss\u00e1g\u00e1ban","text":"<p>A .NET be\u00e9p\u00edtett DI kont\u00e9ner jellemz\u0151i:</p> <ul> <li>Alapszolg\u00e1ltat\u00e1sokat ny\u00fajt (pl. property injection-t nem t\u00e1mogat).</li> <li>Ha enn\u00e9l t\u00f6bbre van sz\u00fcks\u00e9g, haszn\u00e1lhatunk m\u00e1s IoC kont\u00e9nert is, az ASP.NET Core egy\u00fctt tud m\u0171k\u00f6dni vele.</li> <li>Sz\u00e1mos .NET (legyen az .NET Core, .NET Framework vagy mindkett\u0151) k\u00f6rnyezetben haszn\u00e1lhat\u00f3 Dependecy Injection/IoC kont\u00e9ner oszt\u00e1lyk\u00f6nyvt\u00e1r l\u00e9tezik, pl.: AutoFac, DryIoc, LightInject, Castle Windsor, Ninject, StructureMap, SimpleInjector, MEF.</li> <li>Microsoft.Extensions.DependencyInjection NuGet package-ben van implement\u00e1lva (az alapn\u00e9vt\u00e9r is ez)</li> <li>ASP.NET Core alkalmaz\u00e1sok eset\u00e9n m\u00e1r a .NET projekt l\u00e9trehoz\u00e1sakor telep\u00edtve van. S\u0151t, mint l\u00e1ttuk: az ASP.NET Core middleware intenz\u00edven haszn\u00e1lja \u00e9s \u00e9p\u00edt r\u00e1, a runtime konfigur\u00e1ci\u00f3/kiterjeszthet\u0151s\u00e9g alappill\u00e9re.</li> <li>Egy\u00e9b .NET alkalmaz\u00e1sok eset\u00e9n (pl. Console) a Microsoft.Extensions.DependencyInjection NuGet package-dzsel manu\u00e1lisan kell telep\u00edteni.</li> <li>Megjegyz\u00e9s: a NuGet package haszn\u00e1lhat\u00f3 (teljes) .NET Frameworkkel is, mivel .NET Standard-et t\u00e1mogat.</li> </ul>"},{"location":"lecture-notes/di/#service-locator-antipattern","title":"Service Locator antipattern","text":"<p>Az IoC kont\u00e9nerek haszn\u00e1lat\u00e1nak a dependency injectionnel szemben van egy m\u00e1sik haszn\u00e1lati m\u00f3dja. Ennek az a l\u00e9nyege, hogy az oszt\u00e1lyok sz\u00e1m\u00e1ra nem konstruktor param\u00e9terekben adjuk \u00e1t/injekt\u00e1ljuk be a f\u00fcgg\u0151s\u00e9geiket, hanem azokat az oszt\u00e1lyok a met\u00f3dusaikban az IoC kont\u00e9nert\u0151l a GetService m\u0171velettel magunk k\u00e9rdezik le. Ezt a megk\u00f6zel\u00edt\u00e9st Service Locator mint\u00e1nak nevezz\u00fck. Ez antipattern-nek tekintend\u0151, ugyanis a k\u00f3dban sz\u00e9tsz\u00f3rtan, minden egyes f\u00fcgg\u0151s\u00e9g felold\u00e1sakor haszn\u00e1ljuk a kont\u00e9nert, \u00edgy a k\u00f3dunk nagy r\u00e9sze f\u00fcggeni fog mag\u00e1t\u00f3l a kont\u00e9nert\u0151l! Ezzel szemben a dependency injection eset\u00e9ben a f\u00fcgg\u0151s\u00e9gfelold\u00e1st csak az alkalmaz\u00e1s bel\u00e9p\u00e9si pontj\u00e1ban a \"root object\"-ekre v\u00e9gezz\u00fck el, a k\u00f3dunk t\u00f6bbi r\u00e9sze teljesen f\u00fcggetlen a kont\u00e9nert\u0151l. Vegy\u00fck \u00e9szre, hogy a kor\u00e1bbi p\u00e9ld\u00e1nkban a  TodoController, NotificationService, EMailSender, Logger \u00e9s ContactRepository oszt\u00e1lyainkban sehol nem hivatkoztunk a kont\u00e9nerre (sem IServiceProvider-k\u00e9nt, sem m\u00e1s m\u00f3don).</p>"},{"location":"lecture-notes/di/#aspnet-core-keretrendszer-szolgaltatasok","title":"ASP.NET Core keretrendszer szolg\u00e1ltat\u00e1sok","text":"<p>Az ASP.NET Core sz\u00e1mos be\u00e9p\u00edtett szolg\u00e1ltat\u00e1ssal rendelkezik. Pl. ilyen a Wep API t\u00e1mogat\u00e1s is, vagy a felhaszn\u00e1l\u00f3 fel\u00fclettel is rendelkez\u0151 MVC/Razor alap\u00fa webalkalmaz\u00e1s t\u00e1mogat\u00e1s. Ezek t\u00f6bbs\u00e9ge maga is a DI keretrendszert haszn\u00e1lja f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1sra.</p> <p>ASP.NET Web API eset\u00e9n az alkalmaz\u00e1s indul\u00e1sakor be kell regisztr\u00e1ljunk sz\u00e1mos Web API-hoz tartoz\u00f3 \"seg\u00e9d\" szolg\u00e1ltat\u00e1st a DI kont\u00e9nerbe az al\u00e1bbi m\u00f3don (ezt a Program.cs f\u00e1jlba a VS automatikusan beteszi a projekt l\u00e9trehoz\u00e1sakor):</p> <pre><code>builder.Services.AddControllers();\n</code></pre> <p>Megjegyz\u00e9s</p> <p>.NET 6 el\u0151tti .NET verzi\u00f3kban a <code>Startup.cs</code> f\u00e1jl <code>Startup.ConfigureServices</code>-ben a <code>services.AddMvc()</code> sort kellett besz\u00farni.</p> <p>Az <code>AddControllers</code> egy be\u00e9p\u00edtett extension method az <code>IServiceProvider</code> interf\u00e9szre vonatkoz\u00f3an, mely sz\u00e1mos, a Wep API middleware/pipeline bels\u0151 m\u0171k\u00f6d\u00e9s\u00e9hez \u00e9s konfigur\u00e1ci\u00f3j\u00e1hoz sz\u00fcks\u00e9ges szolg\u00e1ltat\u00e1s \u00e9s konfigur\u00e1ci\u00f3s objektumot regisztr\u00e1l a kont\u00e9nerbe.</p>"},{"location":"lecture-notes/di/#szolgaltatas-objektumok-dispose-olasa","title":"Szolg\u00e1ltat\u00e1s objektumok dispose-ol\u00e1sa","text":"<p>A kont\u00e9ner az \u00e1ltala l\u00e9trehozott objektumokra <code>Dispose</code>-t h\u00edv, amennyiben az objektumok oszt\u00e1lya implement\u00e1lja az <code>IDisposable</code> interf\u00e9szt.</p>"},{"location":"lecture-notes/di/#irodalom","title":"Irodalom","text":"<ul> <li>https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection</li> <li>https://stackify.com/net-core-dependency-injection/amp</li> <li>https://medium.com/volosoft/asp-net-core-dependency-injection-best-practices-tips-tricks-c6e9c67f9d96</li> </ul>"},{"location":"lecture-notes/ef/","title":"Kapcsolatok defini\u00e1l\u00e1sa Entity Framework-ben","text":"<p>Rel\u00e1ci\u00f3s adatb\u00e1zisokban entit\u00e1sokat \u00e9s az \u0151ket \u00f6sszek\u00f6t\u0151 kapcsolatokat t\u00e1rolunk. \u00cdgy egyes egyedeken kereszt\u00fcl el\u00e9rhet\u00fcnk m\u00e1s, hozz\u00e1juk valamilyen m\u00f3don kapcsol\u00f3d\u00f3 egyedeket is. A rel\u00e1ci\u00f3s modellben ezt a t\u00e1bl\u00e1k \u00f6sszekapcsol\u00e1s\u00e1val tessz\u00fck, amelyet SQL nyelven <code>join</code>-nak h\u00edvunk. Az Entity Framework, mint ORM keretrendszer, a kapcsolatok kezel\u00e9s\u00e9re is ad k\u00e9sz \u00e9s k\u00e9nyelmes megold\u00e1st sz\u00e1munkra.</p>"},{"location":"lecture-notes/ef/#kapcsolatok-definialasa","title":"Kapcsolatok defini\u00e1l\u00e1sa","text":"<p>Konvenci\u00f3k kapcsolatok lek\u00e9pez\u00e9s\u00e9re</p> <p>Az Entity Framework rendelkezik alapvet\u0151 konvenci\u00f3kkal, amelyekkel a rendszer automatikusan, explicit konfigur\u00e1ci\u00f3 n\u00e9lk\u00fcl k\u00e9pes kapcsolatokat lek\u00e9pezni. Az al\u00e1bbiakban erre nem t\u00e9r\u00fcnk ki, helyette explicit defini\u00e1ljuk a kapcsolatokat. A manu\u00e1lis felkonfigur\u00e1l\u00e1ssal nem mellesleg l\u00e1that\u00f3bb\u00e1 v\u00e1lnak a sz\u00e1nd\u00e9kaink is.</p> <p>N\u00e9zz\u00fck is teh\u00e1t a p\u00e9lda objektumainkat, majd vizsg\u00e1ljuk meg a rajtuk megjelen\u0151 kapcsolatot:</p> <pre><code>public class Product\n{\n    public int ID;\n    public string Name;\n    public int Price;\n    public int VATID;\n\n    public VAT VAT { get; set; }\n}\n\npublic class VAT\n{\n    public int ID;\n    public int Percentage;\n    public ICollection&lt;Product&gt; Product { get; set; }\n}\n</code></pre> <p>A konfigur\u00e1l\u00e1st a <code>DBContext</code> lesz\u00e1rmazott, <code>OnModelCreating</code> f\u00fcggv\u00e9ny\u00e9ben tehetj\u00fck meg, ahol egy entit\u00e1sra a k\u00f6vetkez\u0151 f\u00fcggv\u00e9nyeket haszn\u00e1lhatjuk:</p> <pre><code>modelBuilder.Entity&lt;P\u00e9lda&gt;\n    .HasOne()/.HasMany()\n    .WithOne()/.WithMany()\n</code></pre> <p>A p\u00e9ld\u00e1nkban egy egy-t\u00f6bb kapcsolatot l\u00e1thatunk, amit a k\u00f6vetkez\u0151 m\u00f3don \u00edrhatunk le:</p> <pre><code>modelBuilder.Entity&lt;Product&gt;()\n            .HasOne(d =&gt; d.VAT)\n            .WithMany(p =&gt; p.Product)\n            .HasForeignKey(d =&gt; d.VatId);\n</code></pre> <p>\u00cdgy a k\u00e9t entit\u00e1s k\u00f6z\u00f6tt l\u00e9trej\u00f6v\u0151 kapcsolatot a <code>Product</code> t\u00e1bla <code>VAT</code>-ra mutat\u00f3 k\u00fcls\u0151 kulcsa adja (ami term\u00e9szetesen az adatb\u00e1zisban is megjelenik egy oszlop form\u00e1j\u00e1ban), de emellett k\u00f3d szinten a konkr\u00e9t <code>VAT</code> referencia is megjelenik a <code>Product</code> oszt\u00e1lyban, ahogy a <code>VAT</code> objektumhoz tartoz\u00f3 <code>Product</code> lista is el\u00e9rhet\u0151v\u00e9 v\u00e1lik sz\u00e1munkra egy C# property form\u00e1j\u00e1ban. Ezeket h\u00edvjuk navigation propertynek.</p>"},{"location":"lecture-notes/ef/#explicit-join","title":"Explicit join","text":"<p>A <code>DBContext</code>-\u00fcnk az entit\u00e1sok lek\u00e9rdez\u00e9s\u00e9hez <code>DBSet</code>-eket k\u00edn\u00e1l, amiken LINQ m\u0171veleteket hajthatunk v\u00e9gre. Az egyik ilyen m\u0171velet a <code>join</code> \u00f6sszekapcsol\u00e1s. A k\u00e9t <code>DBSet</code> \u00f6sszekapcsol\u00e1sa a k\u00fcls\u0151 kulcson kereszt\u00fcl t\u00f6rt\u00e9nhet. Az al\u00e1bbi LINQ kifejez\u00e9s az SQL megfelel\u0151j\u00e9hez hasonl\u00f3an deklarat\u00edvan le\u00edrja, hogy mit szeretn\u00e9nk megkapni.</p> <pre><code>var query = \n    from p in dbContext.Product\n    join v in dbContext.Vat on p.VatId equals v.Id\n    where p.Name.Contains(\"teszt\")\n    select v.Percentage;\n\n// Megmutatja a gener\u00e1lt SQL utas\u00edt\u00e1st\nConsole.WriteLine(query.ToQueryString());    \n</code></pre> <p>A h\u00e1tt\u00e9rben az al\u00e1bbi lesz a gener\u00e1lt SQL utas\u00edt\u00e1s:</p> <pre><code>SELECT [v].[Percentage]\nFROM [Product] AS [p]\nINNER JOIN [VAT] AS [v] ON [p].[VatId] = [v].[ID]\nWHERE [p].[Name] LIKE N'%teszt%'\n</code></pre> <p>Az ilyen m\u00f3d\u00fa kapcsol\u00e1sra azonban ritk\u00e1n van sz\u00fcks\u00e9g\u00fcnk - s\u0151t, ker\u00fclend\u0151 is, amikor rendelkez\u00e9s\u00fcnkre \u00e1llnak a navigation propertyk.</p>"},{"location":"lecture-notes/ef/#navigation-property","title":"Navigation property","text":"<p>Mivel a <code>DbContext</code>-ben pontosan felkonfigur\u00e1ltuk, hogy a <code>Product</code> \u00e9s <code>VAT</code> entit\u00e1sok k\u00f6z\u00f6tt milyen kapcsolat van, haszn\u00e1lhatjuk a <code>Product</code> oszt\u00e1lyban tal\u00e1lhat\u00f3 <code>VAT</code> property-t: ezt nevezz\u00fck navigation propertynek. A navigation property \"m\u00f6g\u00f6tti\" kapcsolatot az EF automatikusan kezeli, \u00e9s v\u00e9grehajtja az (\u00e1ltalunk explicit le nem \u00edrt) \u00f6sszekapcsol\u00e1st. \u00cdgy az el\u0151z\u0151 lek\u00e9rdez\u00e9s\u00fcnk a k\u00f6vetkez\u0151re egyszer\u0171s\u00f6dik:</p> <pre><code>var query =\n    from p in dbContext.Product\n    where p.Name.Contains(\"teszt\")\n    select p.VAT.Percentage;\n\n// Megmutatja a gener\u00e1lt SQL utas\u00edt\u00e1st\nConsole.WriteLine(query.ToQueryString());\n</code></pre> <p>Al\u00e1bb l\u00e1thatjuk a gener\u00e1lt lek\u00e9rdez\u00e9st, ami csak a join t\u00edpus\u00e1ban t\u00e9r el a kor\u00e1bbit\u00f3l, de egy\u00e9bk\u00e9nt \u00e9rdemben ugyan arra a megold\u00e1sra jutunk.</p> <pre><code>SELECT [v].[Percentage]\nFROM [Product] AS [p]\nLEFT JOIN [VAT] AS [v] ON [p].[VatId] = [v].[ID]\nWHERE [p].[Name] LIKE N'%teszt%'\n</code></pre> <p>Haszn\u00e1ljuk a navigation property-ket</p> <p>EF-ben mindig haszn\u00e1ljuk a navigation propertyket ott, ahol rendelkez\u00e9sre \u00e1llnak. Ker\u00fclj\u00fck az explicit <code>join</code> v\u00e9grehajt\u00e1s\u00e1t.</p>"},{"location":"lecture-notes/ef/#include","title":"Include","text":"<p>Az el\u0151z\u0151 p\u00e9ld\u00e1kban csak egy-egy skal\u00e1r eredm\u00e9nyt k\u00e9rdezt\u00fcnk le. De mi t\u00f6rt\u00e9nik a navigation property-kkel, amikor egy eg\u00e9sz entit\u00e1st k\u00e9rdez\u00fcnk le? P\u00e9ld\u00e1ul:</p> <pre><code>var prod = dbContext.Product.Where(p =&gt; p.Name.Contains(\"teszt\")).First();\n\nConsole.WriteLine(prod.Name); // ez m\u0171k\u00f6dik, ki\u00edrja a nevet\nConsole.WriteLine(prod.VAT.Percentage); // a navigation property el\u00e9r\u00e9se\n</code></pre> <p>A p\u00e9ld\u00e1ban az utols\u00f3 sorban fut\u00e1si idej\u0171 hib\u00e1t kapn\u00e1nk. Mi\u00e9rt is? Ugyan a navigation property-t felkonfigur\u00e1ltuk, de alapesetben az EF nem t\u00f6lti be a hivatkozott entit\u00e1sokat. Teh\u00e1t a lek\u00e9rdez\u00e9sekben dolgozhatunk vel\u00fck (ahogy kor\u00e1bban tett\u00fck a hivatkozott <code>v.Percentage</code> lek\u00e9rdez\u00e9s\u00e9vel), viszont amennyiben egy <code>Product</code> entit\u00e1st k\u00e9r\u00fcnk a rendszert\u0151l, abban nem szerepel a hivatkozott <code>VAT</code> entit\u00e1s. A rendszer k\u00e9pes lenne a hivatkozott rekordo(ka)t is let\u00f6lteni, de nem teszi. A fejleszt\u0151 feladata eld\u00f6nteni, hogy sz\u00fcks\u00e9ge van-e a hivatkozott entit\u00e1sokra. Gondoljunk csak bele, ha minden hivatkozott entit\u00e1st automatikusan let\u00f6ltene a rendszer (tranzit\u00edvan is), akkor egyetlen rekord el\u00e9r\u00e9s\u00e9vel ak\u00e1r sz\u00e1zakat, ezreket kellene megkeresnie az adatb\u00e1zisnak. Ez a legt\u00f6bb esetben felesleges.</p> <p>Ha m\u00e9gis sz\u00fcks\u00e9g\u00fcnk van a hivatkozott entit\u00e1sokra, akkor a fejleszt\u0151 a k\u00f3dban ezt specifik\u00e1lja az <code>Include</code> haszn\u00e1lat\u00e1val, \u00e9s a rendszer bet\u00f6lti a k\u00e9rt hivatkoz\u00e1sokat is.</p> <pre><code>var query =\n    from p in dbContext.Products.Include(p =&gt; p.VAT)\n    where p.Name.Contains(\"teszt\")\n    select p;\n\n// vagy ebben az esetben tal\u00e1n egy jobban l\u00e1that\u00f3 de teljesen ekvivalens megold\u00e1s:\n// var query = products\n//               .Include(p =&gt; p.VAT)\n//               .Where(p =&gt; p.Name.Contains(\"teszt\"));\n\nConsole.WriteLine(query.ToQueryString());\n</code></pre> <p>Ha megn\u00e9zz\u00fck a gener\u00e1lt SQL utas\u00edt\u00e1st, l\u00e1that\u00f3 benne a <code>join</code> \u00e9s az is, hogy a <code>select</code> minden sz\u00fcks\u00e9ges adatot lek\u00e9rdez.</p> <pre><code>SELECT [p].[Id], [p].[CategoryId], [p].[Description], [p].[Name], [p].[Price], [p].[Stock], [p].[VatId], [v].[ID], [v].[Percentage]\nFROM [Product] AS [p]\nLEFT JOIN [VAT] AS [v] ON [p].[VatId] = [v].[ID]\nWHERE [p].[Name] LIKE N'%teszt%'\n</code></pre> <p>Hivatkozott entit\u00e1sok automatikus lazy bet\u00f6lt\u00e9se</p> <p>Entity Frameworkben lehet\u0151s\u00e9g van a lazy loading bekapcsol\u00e1s\u00e1ra, aminek hat\u00e1s\u00e1ra a navigation property-ken kereszt\u00fcl hivatkozott entit\u00e1sokat a rendszer lazy m\u00f3don (azaz: amikor sz\u00fcks\u00e9g van r\u00e1) bet\u00f6lti k\u00fcl\u00f6n <code>Include</code> n\u00e9lk\u00fcl is. Ez a megold\u00e1s ugyan k\u00e9nyelmes a fejleszt\u0151 szempontj\u00e1b\u00f3l, de \u00e1ra van: a bet\u00f6lt\u00e9s akkor t\u00f6rt\u00e9nik meg, amikor sz\u00fcks\u00e9g lesz r\u00e1 (amikor a property-t el\u00e9ri a k\u00f3d), ami tipikusan t\u00f6bb k\u00fcl\u00f6n adatb\u00e1zis lek\u00e9rdez\u00e9st fog eredm\u00e9nyezni. Az <code>Include</code> megold\u00e1sban fentebb l\u00e1that\u00f3, hogy egyetlen lek\u00e9rdez\u00e9s bet\u00f6lti a <code>Product</code> \u00e9s <code>VAT</code> adatokat is. Ha ezt lazy loading-gal csin\u00e1ln\u00e1nk, akkor lenne egy lek\u00e9rdez\u00e9s a <code>Product</code> adataihoz, majd id\u0151ben k\u00e9s\u0151bb m\u00e9g egy a hivatkozott <code>VAT</code> lek\u00e9rdez\u00e9s\u00e9hez. Ez teh\u00e1t teljes\u00edtm\u00e9nyben jelent\u0151sen rosszabb.</p>"},{"location":"lecture-notes/linq/","title":"LINQ: Language Integrated Query","text":"<p>Adottak a k\u00f6vetkez\u0151 oszt\u00e1lyok, \u00e9s list\u00e1k ilyen objektumokb\u00f3l.</p> <pre><code>class Product\n{\n    public int ID;\n    public string Name;\n    public int Price;\n    public int VATID;\n}\n\nclass VAT\n{\n    public int ID;\n    public int Percentage;\n}\n\nList&lt;Product&gt; products = ...\nList&lt;VAT&gt; vat = ...\n</code></pre> <p><code>System.Linq</code></p> <p>A Linq haszn\u00e1lat\u00e1hoz a <code>System.Linq</code> n\u00e9vteret kell haszn\u00e1lnunk:</p> <pre><code>using System.Linq;\n</code></pre>"},{"location":"lecture-notes/linq/#linq-muveletek","title":"LINQ m\u0171veletek","text":"<p>Az al\u00e1bbi p\u00e9ld\u00e1kn\u00e1l, ahol el\u00e9rhet\u0151, mindk\u00e9t szintaktik\u00e1t mutatjuk. A k\u00e9t f\u00e9le szintaktika teljesen egyen\u00e9rt\u00e9k\u0171.</p>"},{"location":"lecture-notes/linq/#szures","title":"Sz\u0171r\u00e9s","text":"<pre><code>products.Where(p =&gt; p.Price &lt; 1000)\n\nfrom p in products\nwhere p.Price &lt; 1000\n</code></pre>"},{"location":"lecture-notes/linq/#projekcio","title":"Projekci\u00f3","text":"<pre><code>products.Select(p =&gt; p.Name)\n\nfrom p in products\nselect p.Name\n</code></pre>"},{"location":"lecture-notes/linq/#join","title":"Join","text":"<pre><code>from p in products\njoin v in vat on p.VATID equals v.Id\nselect p.Price * v.Percentage\n\nproducts.Join(vat, p =&gt; p.VATID, v =&gt; v.Id, (p, v) =&gt; p.Price * v.Percentage)\n</code></pre>"},{"location":"lecture-notes/linq/#sorrendezes","title":"Sorrendez\u00e9s","text":"<pre><code>products.OrderBy[Descending](p =&gt; p.Name)\n.ThenBy[Descending](p =&gt; p.Price)\n\nfrom p in products\norderby p.Name, p.Price [descending]\n</code></pre>"},{"location":"lecture-notes/linq/#halmaz-muveletek","title":"Halmaz m\u0171veletek","text":"<pre><code>products.Select(p =&gt; p.Name).Distinct()\n\nproducts.Where(p =&gt; p.Price &lt; 1000)\n.Union( products.Where(p =&gt; p.Price &gt; 100000) )\n\n// hasonl\u00f3an Except, Intersect\n</code></pre>"},{"location":"lecture-notes/linq/#aggregacio","title":"Aggreg\u00e1ci\u00f3","text":"<pre><code>products.Count()\n\nproducts.Select(p =&gt; p.Price).Average()\n\n// hasonl\u00f3an Sum, Min, Max\n</code></pre>"},{"location":"lecture-notes/linq/#elso-utolso","title":"Els\u0151, utols\u00f3","text":"<pre><code>products.First()\n\nproducts.Last()\n\nproducts.Where(p =&gt; p.Id==12).FirstOrDefault()\n\nproducts.Where(p =&gt; p.Id==12).SingleOrDefault()\n</code></pre>"},{"location":"lecture-notes/linq/#lapozas","title":"Lapoz\u00e1s","text":"<pre><code>products.Take(10)\n\nproducts.Skip(10).Take(10)\n</code></pre>"},{"location":"lecture-notes/linq/#tartalmazas-letezik-e","title":"Tartalmaz\u00e1s (l\u00e9tezik-e)","text":"<pre><code>products.Any(p =&gt; p.Price == 1234)\n\nproducts.Where(p =&gt; p.Price == 1234).Any()\n</code></pre>"},{"location":"lecture-notes/linq/#csoportositas","title":"Csoportos\u00edt\u00e1s","text":"<pre><code>from p in products\ngroup p by p.VATID\n\nproducts.GroupBy(p =&gt; p.VATID)\n</code></pre>"},{"location":"lecture-notes/linq/#bonyolultabb-projekcio","title":"Bonyolultabb projekci\u00f3","text":"<p>A projekci\u00f3 sor\u00e1n t\u00f6bb f\u00e9le m\u00f3don k\u00e9rhetj\u00fck az eredm\u00e9nyeket.</p>"},{"location":"lecture-notes/linq/#egesz-objektum","title":"Eg\u00e9sz objektum","text":"<pre><code>from p in products\n...\nselect p\n</code></pre> <p>Ilyenkor az eredm\u00e9ny <code>IQueryable&lt;Product&gt;</code>, azaz Product oszt\u00e1ly p\u00e9ld\u00e1nyokat kapunk.</p>"},{"location":"lecture-notes/linq/#csak-bizonyos-mezo","title":"Csak bizonyos mez\u0151","text":"<pre><code>from p in products\n...\nselect p.Name\n</code></pre> <p>Ilyenkor az eredm\u00e9ny <code>IQueryable&lt;string&gt;</code>, azaz csak a neveket kapjuk.</p>"},{"location":"lecture-notes/linq/#nevesitett-tipusok","title":"Neves\u00edtett t\u00edpusok","text":"<pre><code>from p in products\n...\nselect new MyType(p.Name, p.Price)\n</code></pre> <p>Ilyenkor az eredm\u00e9ny <code>IQueryable&lt;MyType&gt;</code>, ahol a MyType oszt\u00e1lyt deklar\u00e1lnunk kell, \u00e9s a select-ben a konstruktor\u00e1t h\u00edvjuk meg.</p>"},{"location":"lecture-notes/linq/#nevtelen-tipusok","title":"N\u00e9vtelen t\u00edpusok","text":"<pre><code>from p in products\nwhere p.Price &gt; 1000\nselect new { ID = p.ID, Name = p.Name };\n</code></pre> <p>N\u00e9vtelen t\u00edpust a <code>new { }</code> szintaktik\u00e1val hozhatunk l\u00e9tre. Ebb\u0151l a ford\u00edt\u00f3 egy oszt\u00e1ly defin\u00edci\u00f3t k\u00e9sz\u00edt a megadott nev\u0171 property-kkel. Ezt tipikusan akkor \u00e9rdemes haszn\u00e1lni, ha egy-k\u00e9t tulajdons\u00e1got szeretn\u00e9nk csak lek\u00e9rdezni, \u00e9s nincs sz\u00fcks\u00e9g\u00fcnk az eg\u00e9sz objektumra.</p> <p>Egy m\u00e1sik gyakori haszn\u00e1lati esete a n\u00e9vtelen t\u00edpusnak, amikor nem egy rekord p\u00e1r tulajdons\u00e1g\u00e1ra vagyunk k\u00edv\u00e1ncsiak, hanem sz\u00e1m\u00edtott \u00e9rt\u00e9ket k\u00e9rdez\u00fcnk le, pl. a term\u00e9kek neve \u00e9s brutt\u00f3 \u00e1ra:</p> <pre><code>from p in products\njoin v in vat on p.VATID equals v.Id\nselect new { Name = p.Name, FullPrice = p.Price * (1 + v.Percentage / 100) }\n</code></pre>"},{"location":"lecture-notes/linq/#linq-kifejezesek-es-az-ienumerableiqueryable","title":"LINQ kifejez\u00e9sek \u00e9s az IEnumerable/IQueryable","text":"<p>Annak f\u00fcggv\u00e9ny\u00e9ben, hogy a Linq m\u0171veleteket milyen adatforr\u00e1son haszn\u00e1ljuk, a <code>products.Where(p =&gt; p.Price &lt; 1000)</code> jelleg\u0171 kifejez\u00e9sek eredm\u00e9nye <code>IEnumerable&lt;T&gt;</code> vagy <code>IQueryable&lt;T&gt;</code>. Mindkett\u0151re igaz, hogy az eredm\u00e9nyhalmaz helyett csak le\u00edr\u00f3k, azaz a m\u0171velet m\u00e9g nem ker\u00fclt v\u00e9grehajt\u00e1sra. Ezt k\u00e9s\u0151i ki\u00e9rt\u00e9kel\u00e9snek (deferred execution) h\u00edvjuk, ugyanis a le\u00edrt m\u0171velet csak akkor fog v\u00e9grehajt\u00f3dni, amikor az eredm\u00e9nyekre t\u00e9nylegesen is sz\u00fcks\u00e9g van:</p> <ul> <li>amikor elkezd\u00fcnk iter\u00e1lni az eredm\u00e9nyhalmazon (pl. <code>foreach</code>),</li> <li>amikor elk\u00e9rj\u00fck az els\u0151 elemet (l\u00e1sd k\u00e9s\u0151bb, pl. <code>.First()</code>),</li> <li>amikor list\u00e1t k\u00e9r\u00fcnk az eredm\u00e9nyhalmazb\u00f3l (<code>.ToList()</code>).</li> </ul> <p>Ez a m\u0171k\u00f6d\u00e9s az\u00e9rt praktikus, mert \u00edgy tudjuk szintaktikailag egym\u00e1s ut\u00e1n f\u0171zni a LINQ m\u0171veleteket, mint p\u00e9ld\u00e1ul:</p> <pre><code>var l = products.Where(p =&gt; p.Price &lt; 1000)\n                .Where(p =&gt; p.Name.Contains('s'))\n                .OrderBy(p =&gt; p.Name)\n                .Select(p =&gt; p.Name)\n...\n\n// az l v\u00e1ltoz\u00f3 nem tartalmazza az eredm\u00e9nyhalmazt\n\nforeach(var x in l) // itt fog lefutni a t\u00e9nyleges ki\u00e9rt\u00e9kel\u00e9s\n   { ... }\n</code></pre> <p>Ki\u00e9rt\u00e9kel\u00e9s</p> <p>Ha mindenk\u00e9ppen szeretn\u00e9nk k\u00e9rni a lefuttat\u00e1st, akkor tipikusan a <code>.ToList()</code>-et haszn\u00e1ljuk. Ezzel azonban vigy\u00e1zzunk, fontoljuk meg, t\u00e9nyleg erre van-e sz\u00fcks\u00e9g\u00fcnk.</p>"},{"location":"lecture-notes/linq/#tovabbi-informaciok-es-peldak","title":"Tov\u00e1bbi inform\u00e1ci\u00f3k \u00e9s p\u00e9ld\u00e1k","text":"<p>Lambda kifejez\u00e9sek: https://www.tutorialsteacher.com/linq/linq-lambda-expression</p> <p>Linq: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/</p>"},{"location":"lecture-notes/mongodb/","title":"MongoDB alapok, m\u0171veletek, \u00e9s a MongoDB .NET Driver","text":""},{"location":"lecture-notes/mongodb/#nosql-adatbazisok","title":"NoSQL adatb\u00e1zisok","text":"<p>A NoSQL adatb\u00e1zisok a rel\u00e1ci\u00f3s s\u00e9m\u00e1t\u00f3l elt\u00e9r\u0151en m\u0171k\u00f6d\u0151 adatb\u00e1zisok \u00f6sszefoglal\u00f3 neve. A n\u00e9v valamennyire megt\u00e9veszt\u0151, mert a fogalomnak kev\u00e9s k\u00f6ze van az SQL nyelvhez - ehelyett a relev\u00e1ns k\u00fcl\u00f6nbs\u00e9g az adatreprezent\u00e1ci\u00f3ban \u00e9s a s\u00e9m\u00e1ban van. De m\u00e9gis mi\u00e9rt van sz\u00fcks\u00e9g\u00fcnk \u00faj fajta adatb\u00e1zisokra, amikor a rel\u00e1ci\u00f3s adatb\u00e1zisok r\u00e9g\u00f3ta j\u00f3l haszn\u00e1lhat\u00f3ak?</p> <ol> <li>Sk\u00e1l\u00e1z\u00e1s lehet kih\u00edv\u00e1s a rel\u00e1ci\u00f3s adatb\u00e1zisok eset\u00e9n<ul> <li>Bizonyos m\u00e9ret f\u00f6l\u00e9</li> <li>Glob\u00e1lis el\u00e9rhet\u0151s\u00e9g</li> <li>Rendelkez\u00e9sre\u00e1ll\u00e1s biztos\u00edt\u00e1sa    </li> </ul> </li> <li>Nem-struktur\u00e1lt adatok t\u00e1rol\u00e1sa eset\u00e9n ink\u00e1bb a h\u00e1tr\u00e1nyok jelentkeznek</li> </ol> <p>Ezekre a probl\u00e9m\u00e1kra a NoSQL adatb\u00e1zisok ny\u00fajtanak megold\u00e1st, azonban haszn\u00e1latuk mag\u00e1val hoz \u00faj kih\u00edv\u00e1sokat is. Ebben a vil\u00e1gban elhagyjuk a szigor\u00fa s\u00e9m\u00e1kat, helyette egy flexibilis s\u00e9m\u00e1t fogunk alkalmazni. Azaz nem lesznek er\u0151s elv\u00e1r\u00e1saink az adatb\u00e1zisban t\u00e1rolt adatokkal szemben. Ez komoly hat\u00e1ssal van az \u00fczleti logik\u00e1ra: milyen oszt\u00e1lyokat hozunk l\u00e9tre, a logika milyen adatok kit\u00f6lt\u00f6tts\u00e9g\u00e9re sz\u00e1m\u00edt \u00e9s a felhaszn\u00e1l\u00f3i fel\u00fcletre, ott milyen adatokat hogyan jelen\u00edt\u00fcnk meg, k\u00e9r\u00fcnk be \u00e9s valid\u00e1lunk.</p>"},{"location":"lecture-notes/mongodb/#a-mongodb-alap-koncepcioi","title":"A MongoDB alap koncepci\u00f3i","text":"<p>A MongoDB egy kliens-szerver architekt\u00far\u00e1j\u00fa nem-rel\u00e1ci\u00f3s adatb\u00e1zis. A k\u00e9p jobb oldal\u00e1n l\u00e1that\u00f3 a mongod, azaz Mongo d\u00e9mon, vagyis az a processz, ami az adatb\u00e1zis el\u00e9r\u00e9s\u00e9t biztos\u00edtja. A m\u00e1sik oldal a mi alkalmaz\u00e1sunk, ahonnan a kliens kapcsol\u00f3dik a szerverhez egy h\u00e1l\u00f3zati kapcsolaton kereszt\u00fcl. Ez a h\u00e1l\u00f3zati kapcsolat az \u00fan. wire protocol-on kereszt\u00fcl t\u00f6rt\u00e9nik, ez a MongoDB saj\u00e1t protokollja. Ebben a protokollban JSON form\u00e1j\u00fa adat kommunik\u00e1ci\u00f3 zajlik bin\u00e1risan (azaz BSON).</p> <p></p>"},{"location":"lecture-notes/mongodb/#logikai-felepites","title":"Logikai fel\u00e9p\u00edt\u00e9s","text":"<p>Egy MongoDB-alap\u00fa adatb\u00e1zis rendszer legfels\u0151 r\u00e9tege az \u00fan. klaszter, ebbe szervezz\u00fck a szervereket. Mi klaszterekkel ebben a t\u00e1rgyban nem foglalkozunk, azok a sk\u00e1l\u00e1z\u00e1s eszk\u00f6zei. A m\u00e1sodik szint a szerver szintje (a mongod processz), ami alatt az adatb\u00e1zis foglal helyet. Egy szerver/klaszter t\u00f6bb adatb\u00e1zist t\u00e1rolhat. Az adatb\u00e1zisok pedig gy\u0171jtem\u00e9nyekb\u0151l (collection) \u00e9p\u00fclnek fel. Ha a rel\u00e1ci\u00f3s adatb\u00e1zisokkal meg akarjuk feleltetni, akkor a gy\u0171jtem\u00e9nyek a t\u00e1bl\u00e1k megfelel\u0151i, ezen bel\u00fcl a sorok/rekordok pedig a gy\u0171jtem\u00e9nyben t\u00e1rolt dokumentumok lesznek.</p> <p>N\u00e9zz\u00fck ezeket pontosabban.</p>"},{"location":"lecture-notes/mongodb/#dokumentum","title":"Dokumentum","text":"<p>A dokumentum a MongoDB alap t\u00e1rol\u00e1si egys\u00e9ge. Egy dokumentum egy JSON (jelleg\u0171) f\u00e1jl, teh\u00e1t kulcs-\u00e9rt\u00e9k p\u00e1rokat tartalmaz. Maga a MongoDB BSON-k\u00e9nt, bin\u00e1ris reprezent\u00e1ci\u00f3k\u00e9nt t\u00e1rolja mindezt.</p> <pre><code>{\n    name: \"sue\",\n    age: 26,\n    status: \"A\",\n    groups: [ \"news\", \"sports\"]\n}\n</code></pre> <p>Kulcsoknak t\u00f6bbnyire b\u00e1rmilyen szabad sz\u00f6veget v\u00e1laszthatunk, de a neveknek egyedinek kell lenni\u00fck \u00e9s nem kezd\u0151dhetnek a <code>$</code> karakterrel. A nevek case sensitive-ek. Az \u00e9rt\u00e9k lehet sz\u00f6veg, sz\u00e1m, d\u00e1tum, bin\u00e1ris, be\u00e1gyazott elem, <code>null</code>, vagy ak\u00e1r a fenti p\u00e9ld\u00e1ban a <code>groups</code> kulcsn\u00e1l l\u00e1that\u00f3an t\u00f6mb is - rel\u00e1ci\u00f3s adatb\u00e1zisban ezt \u00edgy nem lehet reprezent\u00e1lni.</p> <p>Az objektum orient\u00e1lt vil\u00e1gban egy dokumentum felel meg egy objektumnak. Fontos megk\u00f6t\u00e9s, hogy a dokumentumok maxim\u00e1lis m\u00e9rete 16MB lehet, \u00e9s ez nem konfigur\u00e1lhat\u00f3 \u00e9rt\u00e9k.</p>"},{"location":"lecture-notes/mongodb/#gyujtemeny","title":"Gy\u0171jtem\u00e9ny","text":"<p>Rel\u00e1ci\u00f3s t\u00e1bla anal\u00f3gi\u00e1ja a gy\u0171jtem\u00e9ny, de nincs s\u00e9m\u00e1ja, \u00edgy ezeket l\u00e9trehozni, defini\u00e1lni se kell, els\u0151 haszn\u00e1latkor a rendszer automatikusan l\u00e9trehozza \u0151ket. \u00dagy fogalmazhatjuk meg, hogy a gy\u0171jtem\u00e9ny a \"hasonl\u00f3\" dokumentumok gy\u0171jt\u0151helye. B\u00e1r nincs s\u00e9ma, indexeket ennek ellen\u00e9re defini\u00e1lhatunk a gy\u0171jtem\u00e9nyeken, amely a gyors keres\u00e9st fogj\u00e1k seg\u00edteni. S\u00e9ma hi\u00e1ny\u00e1ban nincs tartom\u00e1nyi integrit\u00e1si krit\u00e9rium, teh\u00e1t p\u00e9ld\u00e1ul a helyes adatt\u00edpusok \u00e9s tartom\u00e1nyi krit\u00e9riumok biztos\u00edt\u00e1s\u00e1ban az adatb\u00e1zis nem ny\u00fajt seg\u00edts\u00e9get.</p>"},{"location":"lecture-notes/mongodb/#adatbazis","title":"Adatb\u00e1zis","text":"<p>Az adatb\u00e1zis ugyanazt a c\u00e9lt szolg\u00e1lja, mint rel\u00e1ci\u00f3s adatb\u00e1zisban. Ez fogja \u00f6ssze az alkalmaz\u00e1s adatait logikailag. Illetve hozz\u00e1f\u00e9r\u00e9si jogosults\u00e1gokat adatb\u00e1zis szinten tudunk adni. Az adatb\u00e1zisok neve case sensitive \u00e9s konvenci\u00f3 szerint tipikusan csupa kisbet\u0171.</p>"},{"location":"lecture-notes/mongodb/#kulcs","title":"Kulcs","text":"<p>Minden dokumentum egy\u00e9rtelm\u0171 azonos\u00edt\u00f3ja az <code>_id</code> mez\u0151, m\u00e1s kulcsot nem tudunk defini\u00e1lni. Ezt a mez\u0151t besz\u00far\u00e1skor nem sz\u00fcks\u00e9ges explicit megadni (de lehet), tipikusan a kliens driver vagy a szerver gener\u00e1lja (alap\u00e9rtelmez\u00e9sben egy 12 b\u00e1jtos <code>ObjectId</code>-t k\u00e9sz\u00edt).</p> <p>Az <code>_id</code> mez\u0151t\u0151l f\u00fcggetlen\u00fcl egyedis\u00e9get indexek seg\u00edts\u00e9g\u00e9vel tudunk garant\u00e1lni. Amennyiben sz\u00fcks\u00e9ges, defini\u00e1lhatunk teh\u00e1t m\u00e1s, kulcs-szer\u0171 mez\u0151ket is. Az \u00edgy defini\u00e1lt egyedi mez\u0151k lehetnek \u00f6sszetettek is (teh\u00e1t lehet t\u00f6bb mez\u0151 egy\u00fcttes egyedis\u00e9g\u00e9t el\u0151\u00edrni).</p> <p>K\u00fcls\u0151 kulcs hivatkoz\u00e1sok MongoDB-ben nincsenek. Tudunk hivatkozni m\u00e1s dokumentumokra azok kulcsainak bem\u00e1sol\u00e1s\u00e1val, azonban ezekre a rendszer nem v\u00e1llal garanci\u00e1t (pl. a hivatkozott dokumentum t\u00f6r\u00f6lhet\u0151).</p>"},{"location":"lecture-notes/mongodb/#mongodb-muveletek-es-a-mongodb-net-driver","title":"MongoDB m\u0171veletek \u00e9s a MongoDB .NET Driver","text":"<p>Az al\u00e1bbi, illusztr\u00e1ci\u00f3ra haszn\u00e1lt k\u00f3dr\u00e9szletek a hivatalos MongoDB.Driver NuGet csomagot haszn\u00e1lj\u00e1k.</p>"},{"location":"lecture-notes/mongodb/#kapcsolat-letesitese","title":"Kapcsolat l\u00e9tes\u00edt\u00e9se","text":"<p>A MongoDB adatb\u00e1zis el\u00e9r\u00e9s\u00e9hez els\u0151 l\u00e9p\u00e9sben sz\u00fcks\u00e9g\u00fcnk van egy kapcsolatra. A kapcsolatot egy <code>MongoClient</code> oszt\u00e1ly reprezent\u00e1lja. A kapcsolathoz sz\u00fcks\u00e9g\u00fcnk van a szerver el\u00e9rhet\u0151s\u00e9g\u00e9re (a connection stringr\u0151l r\u00e9szletesebben l\u00e1sd: https://docs.mongodb.com/manual/reference/connection-string/).</p> <pre><code>var client = new MongoClient(\"mongodb://localhost:27017\");\n</code></pre> <p>A kapcsolatot singleton-k\u00e9nt \u00e9rdemes kezelni, nem kell Dispose-olni.</p> <p>Kapcsolat \u00e9letciklusa</p> <p>A kapcsolatot tipikusan egy glob\u00e1lis statikus v\u00e1ltoz\u00f3ban t\u00e1roljuk, avagy a k\u00f6rnyezet \u00e1ltal t\u00e1mogatott IoC (Inversion of Control) / DI (Dependency Injection) t\u00e1rol\u00f3ban helyezz\u00fck el.</p> <p>Az adatb\u00e1zis neve szerepelhet ugyan a connection stringben (pl. <code>mongodb://localhost:27017/adatvez</code>), azt csak az autentik\u00e1ci\u00f3hoz haszn\u00e1lja a rendszer. \u00cdgy a kapcsolat fel\u00e9p\u00edt\u00e9se ut\u00e1n meg kell adnunk, milyen adatb\u00e1zist fogunk haszn\u00e1lni.</p> <pre><code>var db = client.GetDatabase(\"adatvez\");\n</code></pre> <p>Az adatb\u00e1zisnak nem kell el\u0151zetesen l\u00e9tezni. A fenti h\u00edv\u00e1s hat\u00e1s\u00e1ra, ha m\u00e9g nem l\u00e9tezik az adatb\u00e1zis, automatikusan l\u00e9trej\u00f6n.</p>"},{"location":"lecture-notes/mongodb/#gyujtemenyek-kezelese","title":"Gy\u0171jtem\u00e9nyek kezel\u00e9se","text":"<p>Egy rel\u00e1ci\u00f3s adatb\u00e1zist\u00f3l elt\u00e9r\u0151en MongoDB-ben a m\u0171veleteinket mindig egyetlen gy\u0171jtem\u00e9nyen v\u00e9gezz\u00fck, \u00edgy a gy\u0171jtem\u00e9ny kiv\u00e1laszt\u00e1sa nem a kiadott parancs r\u00e9sze (mint az SQL nyelvben a <code>from</code>), hanem a m\u0171velet el\u0151felt\u00e9tele. Egy adott gy\u0171jtem\u00e9nyt a <code>GetCollection</code> h\u00edv\u00e1ssal kaphatunk meg, generikus param\u00e9tere a dokumentum t\u00edpust megval\u00f3s\u00edt\u00f3 C# oszt\u00e1ly.</p> <pre><code>var collection = db.GetCollection&lt;BsonDocument&gt;(\"products\");\n</code></pre> <p>A .NET MongoDB driver alap koncepci\u00f3ja szerint minden dokumentumot lek\u00e9pez egy .NET objektumra. Ezzel automatikusan megval\u00f3s\u00edtja az \u00fan. ODM (Object Document Mapping) funkci\u00f3t. Az ODM az ORM megfelel\u0151je a NoSQL adatb\u00e1zisok vil\u00e1g\u00e1ban.</p> <p>\"Nyers\" json</p> <p>M\u00e1s nyelveken \u00e9s platformokon a MongoDB driverek nem mindig v\u00e9gzik el a lek\u00e9pez\u00e9st objektumokra, \u00edgy az interneten tal\u00e1lhat\u00f3 p\u00e9ld\u00e1kban gyakran \"nyers\" JSON dokumentumokon kereszt\u00fcli kommunik\u00e1ci\u00f3t mutatnak. Igyekezz\u00fcnk ezt elker\u00fclni, ahogy az ORM t\u00e9mak\u00f6r\u00e9ben megtanultuk, k\u00e9nyelmesebb \u00e9s biztons\u00e1gosabb az objektumorient\u00e1lt lek\u00e9pz\u00e9s.</p> <p>Az el\u0151z\u0151 p\u00e9ld\u00e1ban <code>BsonDocument</code> t\u00edpus\u00fa dokumentumot haszn\u00e1lunk. A <code>BsonDocument</code> egy \u00e1ltal\u00e1nos dokumentum reprezent\u00e1ci\u00f3, amiben kulcs-\u00e9rt\u00e9k p\u00e1rokat t\u00e1rolhatunk. Haszn\u00e1lata k\u00e9nyelmetlen \u00e9s nem t\u00edpusbiztos, ez\u00e9rt \u00e1ltal\u00e1ban nem ezt a megold\u00e1st haszn\u00e1ljuk. A javasolt megold\u00e1st l\u00e1sd hamarosan.</p> <p>A gy\u0171jtem\u00e9nyt reprezent\u00e1l\u00f3 v\u00e1ltoz\u00f3n tudunk tov\u00e1bbi m\u0171veleteket futtatni, p\u00e9ld\u00e1ul besz\u00farunk egy dokumentumot, majd list\u00e1zzuk a gy\u0171jtem\u00e9ny tartalm\u00e1t. A gy\u0171jtem\u00e9ny els\u0151 haszn\u00e1latkor automatikusan l\u00e9tre fog j\u00f6nni, azaz semmilyen m\u00f3don nem sz\u00fcks\u00e9ges defini\u00e1lnunk.</p> <pre><code>collection.InsertOne(new BsonDocument()\n{\n    { \"name\", \"Apple\" },\n    { \"categoryName\", \"Apple\" },\n    { \"price\", 123 }\n});\n\n// minden dokumentum list\u00e1z\u00e1sa: sz\u00fcks\u00e9g van egy sz\u0171r\u00e9si felt\u00e9telre, ami itt\n// egy \u00fcres felt\u00e9tel, azaz minden dokumentumra illeszkedik\nvar list = collection.Find(new BsonDocument()).ToList();\nforeach(var l in list)\n    Console.WriteLine(l);\n</code></pre> <p>Elnevez\u00e9si konvenci\u00f3</p> <p>A dokumentumban a kulcs nevek konvenci\u00f3 szerint kisbet\u0171vel kezd\u0151dnek, mint <code>price</code> vagy <code>categoryName</code> (ez az \u00fan. camel case \u00edr\u00e1sm\u00f3d). Ez a szok\u00e1s a MongoDB vil\u00e1g\u00e1nak megfelel\u0151 szeml\u00e9let historikus okokb\u00f3l. Hacsak nincs j\u00f3 okunk r\u00e1, ne t\u00e9rj\u00fcnk el ett\u0151l.</p>"},{"location":"lecture-notes/mongodb/#dokumentumok-lekepzese-c-objektumokra","title":"Dokumentumok lek\u00e9pz\u00e9se C# objektumokra","text":"<p>Ahogy a rel\u00e1ci\u00f3s adatb\u00e1zisokn\u00e1l l\u00e1thattuk az objektum-rel\u00e1ci\u00f3s lek\u00e9pz\u00e9st, MongoDB eset\u00e9n is c\u00e9lszer\u0171 objektumokkal \u00e9s oszt\u00e1lyokkal dolgoznunk. A MongoDB .NET drivere ezt teljes m\u00e9rt\u00e9kben biztos\u00edtja sz\u00e1munkra.</p> <p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt defini\u00e1lnunk kell a C# oszt\u00e1lyt, ill. oszt\u00e1lyokat, amikre az adatb\u00e1zis tartalm\u00e1t lek\u00e9pezz\u00fck. Mivel itt nincs az adatb\u00e1zisnak \u00e9s t\u00e1bl\u00e1nak s\u00e9m\u00e1ja, nem tudjuk a s\u00e9ma alapj\u00e1n gener\u00e1lni a C# k\u00f3dot (mint Entity Framework eset\u00e9n csin\u00e1ltuk). \u00cdgy ebben a vil\u00e1gban ink\u00e1bb a Code First elvet k\u00f6vetj\u00fck, azaz a C# k\u00f3dot k\u00e9sz\u00edtj\u00fck el, \u00e9s abb\u00f3l k\u00e9sz\u00fcl az adatb\u00e1zis \u00e9s gy\u0171jtem\u00e9ny (hab\u00e1r tudjuk, hogy itt nincs sz\u00f3 az oszt\u00e1ly alapj\u00e1n t\u00e1bl\u00e1k l\u00e9trehoz\u00e1s\u00e1r\u00f3l).</p> <p>Defini\u00e1ljuk a Term\u00e9kek reprezent\u00e1l\u00e1shoz az al\u00e1bbi oszt\u00e1lyokat.</p> <pre><code>public class Product\n{\n    public ObjectId Id { get; set; } // ez lesz az els\u0151dleges kulcs helyett az _id azonos\u00edt\u00f3\n    public string Name { get; set; }\n    public float Price { get; set; }\n    public int Stock { get; set; }\n    public string[] Categories { get; set; } // t\u00f6mb \u00e9rt\u00e9k\u0171 mez\u0151\n    public VAT VAT { get; set; } // be\u00e1gyaz\u00e1st alkalmazunk\n}\n\npublic class VAT // mivel ez be\u00e1gyazott entit\u00e1s, \u00edgy nem adunk neki egyedi azonos\u00edt\u00f3t\n{\n    public string VATCategoryName { get; set; }\n    public float Percentage { get; set; }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy kor\u00e1bban <code>price</code> n\u00e9ven haszn\u00e1ltuk a dokumentumban a kulcsot, de a C# oszt\u00e1lyban az \u00fan. Pascal Case szerint nagybet\u0171vel kezdj\u00fck: <code>Price</code>. A MongoDB .NET drivere be\u00e9p\u00fcl a C# nyelvbe \u00e9s a .NET k\u00f6rnyezetbe, \u00e9s annak szok\u00e1sait tiszteletben tartja, \u00edgy az oszt\u00e1ly defin\u00edci\u00f3ban szerepl\u0151 mez\u0151 nevek \u00e9s a MongoDB dokumentumaiban a kulcsok lek\u00e9pz\u00e9se automatikusan meg fog t\u00f6rt\u00e9nni, a <code>Price</code> oszt\u00e1ly tulajdons\u00e1gb\u00f3l <code>price</code> kulcs n\u00e9v lesz a dokumentumban.</p>"},{"location":"lecture-notes/mongodb/#a-lekepzes-testreszabasa","title":"A lek\u00e9pz\u00e9s testreszab\u00e1sa","text":"<p>A C# oszt\u00e1ly - MongoDB dokumentum lek\u00e9pz\u00e9s automatikus, de testreszabhat\u00f3. Amennyiben el szeretn\u00e9nk t\u00e9rni az alap konvenci\u00f3kt\u00f3l, t\u00f6bb f\u00e9le m\u00f3don is megtehetj\u00fck.</p> <p>A legegyszer\u0171bb, ha az oszt\u00e1ly defin\u00edci\u00f3j\u00e1ban attrib\u00fatumokkal jel\u00f6lj\u00fck a testreszab\u00e1st:</p> <pre><code>public class Product\n{\n    // _id mez\u0151re k\u00e9pz\u0151dik le\n    [BsonId]\n    public ObjectId Azonosito { get; set; }\n\n    // megadhatjuk a MongoDB dokumentumban haszn\u00e1latos nevet\n    [BsonElement(\"price\")]\n    public string Ar { get; set; }\n\n    // kihagyhatunk egyes mez\u0151ket\n    [BsonIgnore]\n    public string NemMentett { get; set; }\n}\n</code></pre> <p>M\u00e1sik lehet\u0151s\u00e9g\u00fcnk magasabb szinten \u00fan. konvenci\u00f3-csomagokat beregisztr\u00e1lni. A konvenci\u00f3-csomagok \u00e1ltal\u00e1nosan le\u00edrj\u00e1k, hogyan t\u00f6rt\u00e9njen a lek\u00e9pez\u00e9s. (Az alap viselked\u00e9s is egy konvenci\u00f3-csomag alapj\u00e1n defini\u00e1lt.)</p> <p>P\u00e9ld\u00e1ul az al\u00e1bbiakkal megadhatjuk, hogy camel case-re szeretn\u00e9nk a mez\u0151 neveket lek\u00e9pezni, valamint a default \u00e9rt\u00e9kkel rendelkez\u0151 adattagokat (C# nyelv szerint defini\u00e1lt default \u00e9rt\u00e9k) szeretn\u00e9nk kihagyni a dokumentumb\u00f3l.</p> <pre><code>// konvenci\u00f3k defini\u00e1l\u00e1sa\nvar pack = new ConventionPack();\npack.Add(new CamelCaseElementNameConvention());\npack.Add(new IgnoreIfDefaultConvention(true));\n\n// konvenci\u00f3k beregisztr\u00e1l\u00e1sa\n// az els\u0151 param\u00e9ter egy n\u00e9v\n// az utols\u00f3 param\u00e9terrel sz\u0171r\u00e9si felt\u00e9telt adhatunk meg, hol haszn\u00e1land\u00f3ak a konvenci\u00f3k\nConventionRegistry.Register(\"adatvez\", pack, t =&gt; true);\n</code></pre> <p>Enn\u00e9l bonyolultabb testreszab\u00e1sokra is lehet\u0151s\u00e9g\u00fcnk van, p\u00e9ld\u00e1ul defini\u00e1lhatunk konverzi\u00f3s logik\u00e1t a C# reprezent\u00e1ci\u00f3 \u00e9s a MongoDB reprezent\u00e1ci\u00f3 k\u00f6z\u00f6tti ford\u00edt\u00e1shoz, illetve megadhatjuk a lesz\u00e1rmaz\u00e1si hierarchia ment\u00e9s\u00e9nek m\u00f3dj\u00e1t. Ezekr\u0151l r\u00e9szletesebben a hivatalos dokument\u00e1ci\u00f3ban: https://mongodb.github.io/mongo-csharp-driver/2.8/reference/bson/serialization/.</p>"},{"location":"lecture-notes/mongodb/#lekerdezesek","title":"Lek\u00e9rdez\u00e9sek","text":"<p>A tov\u00e1bbiakban a t\u00edpusos, <code>Product</code> oszt\u00e1lyra lek\u00e9pz\u0151 m\u00f3don haszn\u00e1ljuk a gy\u0171jtem\u00e9nyt, \u00e9s \u00edgy v\u00e9gz\u00fcnk m\u0171veletet. Ez a javasolt megold\u00e1s, a <code>BsonDocument</code> alap\u00fa megold\u00e1st csak sz\u00fcks\u00e9g eset\u00e9n haszn\u00e1ljuk.</p> <p>A legegyszer\u0171bb lek\u00e9rdez\u00e9st m\u00e1r l\u00e1thattuk, list\u00e1zzunk minden dokumentumot:</p> <pre><code>var collection = db.GetCollection&lt;Product&gt;(\"products\");\n\nvar lista = collection.Find(new BsonDocument()).ToList();\nforeach (var p in lista)\n    Console.WriteLine($\"Id: {p.Id}, Name: {p.Name}\");\n</code></pre> <p>A list\u00e1z\u00e1s a <code>Find</code> met\u00f3dussal t\u00f6rt\u00e9nik. Az elnevez\u00e9s j\u00f3l mutatja a MongoDB filoz\u00f3fi\u00e1j\u00e1t: az adatb\u00e1zis keres\u00e9sre val\u00f3, minden elem list\u00e1z\u00e1sa nem praktikus, ez\u00e9rt nincs is r\u00e1 egyszer\u0171 szintaktika. A <code>Find</code> egy keres\u00e9si felt\u00e9telt v\u00e1r, ami itt egy \u00fcres felt\u00e9tel, azaz mindenre illeszkedik.</p> <p>A keres\u00e9si felt\u00e9telt t\u00f6bb f\u00e9le m\u00f3don le\u00edrhatjuk.</p> <p>A <code>BsonDocument</code> alap\u00fa sz\u0171r\u00e9sben nyersen, a MongoDB szintaktik\u00e1ja szerint kell meg\u00edrni a sz\u0171r\u00e9si felt\u00e9telt. Erre lehet\u0151s\u00e9g\u00fcnk van ugyan, de elker\u00fclj\u00fck, mert a MongoDB .NET drivere ezt megoldja sz\u00e1munkra, ha az al\u00e1bbiak szerint adjuk meg a keres\u00e9si felt\u00e9telt.</p> <p>A legt\u00f6bb esetben egy Lambda-kifejez\u00e9ssel le\u00edrhatjuk a felt\u00e9telt.</p> <pre><code>collection.Find(x =&gt; x.Price &lt; 123);\n</code></pre> <p>Ilyenkor a Lambda-kifejez\u00e9s egy <code>Predicate&lt;T&gt;</code> t\u00edpus\u00fa delegate, azaz a megadott oszt\u00e1lyt\u00edpuson (itt: <code>Product</code>) fogalmazzuk meg, \u00e9s <code>bool</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171. Teh\u00e1t a fenti p\u00e9ld\u00e1ban az <code>x</code> v\u00e1ltoz\u00f3 egy <code>Product</code> objektumot reprezent\u00e1l. Ez a keres\u00e9s m\u0171k\u00f6dik term\u00e9szetesen bonyolultabb esetekre is.</p> <pre><code>collection.Find(x =&gt; x.Price &lt; 123 &amp;&amp; x.Name.Contains(\"red\"));\n</code></pre> <p>A Lambda kifejez\u00e9sekkel le\u00edrt sz\u0171r\u00e9si felt\u00e9telek elrejtik, hogy a MongoDB-ben val\u00f3j\u00e1ban milyen keres\u00e9si felt\u00e9teleink is vannak. P\u00e9ld\u00e1ul az el\u0151bbi <code>Contains</code> keres\u00e9si felt\u00e9tel egy regul\u00e1ris kifejez\u00e9ssel val\u00f3 keres\u00e9st fog val\u00f3j\u00e1ban jelenteni.</p> <p>A MongoDB saj\u00e1t nyelv\u00e9n az el\u0151bbi sz\u0171r\u00e9s \u00edgy n\u00e9z ki:</p> <pre><code>{\n  \"price\": {\n    \"$lt\": 123.0\n  },\n  \"name\": \"/red/s\"\n}\n</code></pre> <p>Vegy\u00fck \u00e9szre, hogy ez a fajta le\u00edr\u00e1s \u00f6nmaga is egy dokumentum. Ha saj\u00e1t magunk akarn\u00e1nk meg\u00edrni a sz\u0171r\u00e9si felt\u00e9telt, akkor egy <code>BsonDocument</code>-ben kellene ezt a dokumentumot \u00f6ssze\u00e1ll\u00edtanunk. A sz\u0171r\u00e9si felt\u00e9telt le\u00edr\u00f3 dokumentum kulcsai a sz\u0171r\u00e9shez haszn\u00e1lt mez\u0151k, az \u00e9rt\u00e9k pedig a sz\u0171r\u00e9si felt\u00e9tel. A felt\u00e9tel bizonyos esetekben egy skal\u00e1r \u00e9rt\u00e9k, mint a regul\u00e1ris kifejez\u00e9s (vagy ha egyenl\u0151s\u00e9gre sz\u0171rn\u00e9nk), m\u00e1s esetekben a felt\u00e9tel egy be\u00e1gyazott dokumentum, mint a <code>&lt;</code> felt\u00e9tel eset\u00e9n. Ebben az <code>$lt</code> kulcs egy speci\u00e1lis kulcs, azt jel\u00f6li, hogy a less than oper\u00e1torral kell a ki\u00e9rt\u00e9kel\u00e9st v\u00e9gezni, \u00e9s az oper\u00e1tor jobb oldal\u00e1n a 123.0 \u00e9rt\u00e9k \u00e1ll. A regul\u00e1ris kifejez\u00e9st a JavaScript RegExp szintaktika szerint kell megadni. Az ilyen m\u00f3don felsorolt felt\u00e9telek automatikusan \u00e9s kapcsolatba ker\u00fclnek.</p> <p>A Lambda-kifejez\u00e9s helyett egy hasonl\u00f3 le\u00edr\u00e1st magunk is el\u0151\u00e1ll\u00edthatunk an\u00e9lk\u00fcl, hogy sz\u00f6veges form\u00e1ban kellene \u00f6ssze\u00e1ll\u00edtanunk a sz\u0171r\u00e9si felt\u00e9telt. A MongoDB .NET drivere lehet\u0151s\u00e9get ad nek\u00fcnk arra, hogy egy \u00fan. builder seg\u00edts\u00e9g\u00e9vel \u00e9p\u00edts\u00fck fel a sz\u0171r\u00e9si felt\u00e9telt.</p> <pre><code>collection.Find(\n    Builders&lt;Product&gt;.Filter.And(\n        Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Price, 123),\n        Builders&lt;Product&gt;.Filter.Regex(x =&gt; x.Name, \"/red/s\"),\n    )\n);\n</code></pre> <p>A fenti szintaktika kicsit b\u0151besz\u00e9d\u0171bb ugyan, mint a Lambda-kifejez\u00e9s, de k\u00f6zelebb \u00e1ll a MongoDB vil\u00e1g\u00e1hoz, \u00e9s jobban le\u00edrja, mit is szeretn\u00e9nk val\u00f3j\u00e1ban. Tekinthet\u00fcnk erre a szintaktik\u00e1ra \u00fagy, mint az SQL nyelvre: deklarat\u00edv, c\u00e9lorient\u00e1lt, de a platform k\u00e9pess\u00e9geit szem el\u0151tt tart\u00f3 le\u00edr\u00e1s. Emellett azonban t\u00edpusbiztos is.</p> <p>A <code>Builders&lt;T&gt;</code> generikus oszt\u00e1ly egy seg\u00e9doszt\u00e1ly, amivel sz\u0171r\u00e9si, \u00e9s k\u00e9s\u0151bb l\u00e1tni fogjuk, egy\u00e9b MongoDB specifikus defin\u00edci\u00f3kat \u00e9p\u00edthet\u00fcnk fel. A <code>Builders&lt;Product&gt;.Filter</code> a Product C# oszt\u00e1lyhoz illeszked\u0151 sz\u0171r\u00e9si felt\u00e9telek defini\u00e1l\u00e1s\u00e1ra haszn\u00e1lhat\u00f3. El\u0151sz\u00f6r egy \u00e9s kapcsolatot hozunk l\u00e9tre, amelyen bel\u00fcl k\u00e9t sz\u0171r\u00e9si felt\u00e9tel\u00fcnk lesz. Az oper\u00e1torok a kor\u00e1bban l\u00e1tott less than \u00e9s a regul\u00e1ris kifejez\u00e9s. Ezen f\u00fcggv\u00e9nyeknek k\u00e9t param\u00e9tert adunk \u00e1t: a mez\u0151t, amire sz\u0171rni szeretn\u00e9nk, \u00e9s az operandust.</p> <p>Expression szintaktika</p> <p>Vegy\u00fck \u00e9szre, hogy se itt, se a Lambda-kifejez\u00e9sekben nem haszn\u00e1ltunk string alap\u00fa mez\u0151neveket, mindenhol ugyanazzal a szintaktik\u00e1val (ez a C# Expression) az oszt\u00e1lydefin\u00edci\u00f3ra hivatkoztunk. Ez az\u00e9rt praktikus \u00edgy, mert elker\u00fclj\u00fck a mez\u0151nevek elg\u00e9pel\u00e9s\u00e9t.</p> <p>Val\u00f3j\u00e1ban mindegyik le\u00edr\u00e1s, amit haszn\u00e1ltunk, ugyanazt a sz\u0171r\u00e9si felt\u00e9telt jelenti. A MongoDB driver mindegyik szintaktik\u00e1t lek\u00e9pezi a saj\u00e1t bels\u0151 reprezent\u00e1ci\u00f3j\u00e1v\u00e1. A Lambda-kifejez\u00e9s alap\u00fa kevesebb karaktert ig\u00e9nyel, \u00e9s jobban illeszkedik a C# nyelvbe, m\u00edg az ut\u00f3bbi a MongoDB saj\u00e1toss\u00e1gainak kifejez\u00e9s\u00e9re val\u00f3. B\u00e1rmelyiket haszn\u00e1lhatjuk.</p>"},{"location":"lecture-notes/mongodb/#lekerdezes-eredmenyenek-felhasznalasa","title":"Lek\u00e9rdez\u00e9s eredm\u00e9ny\u00e9nek felhaszn\u00e1l\u00e1sa","text":"<p>A <code>collection.Find(...)</code> f\u00fcggv\u00e9ny eredm\u00e9nye m\u00e9g nem az eredm\u00e9nyhalmaz, hanem csak egy le\u00edr\u00f3 a lek\u00e9rdez\u00e9s v\u00e9grehajt\u00e1s\u00e1hoz. Az eredm\u00e9ny \u00e1ltal\u00e1ban h\u00e1rom f\u00e9le m\u00f3don k\u00e9rhet\u0151 le \u00e9s dolgozhat\u00f3 fel.</p>"},{"location":"lecture-notes/mongodb/#listazas","title":"List\u00e1z\u00e1s","text":"<p>K\u00e9rj\u00fck a teljes eredm\u00e9nyhalmazt egy listak\u00e9nt: <code>collection.Find(...).ToList()</code>.</p>"},{"location":"lecture-notes/mongodb/#elsoegyetlen-elem-lekerese","title":"Els\u0151/egyetlen elem lek\u00e9r\u00e9se","text":"<p>Amennyiben csak az els\u0151 elemre van sz\u00fcks\u00e9g\u00fcnk, vagy tudjuk, hogy csak egy elem lesz, akkor haszn\u00e1lhatjuk a <code>collection.Find(...).First()</code>, <code>.FirstOrDefault()</code>, vagy <code>.Single()</code>, <code>.SingleOrDefault()</code> f\u00fcggv\u00e9nyeket.</p>"},{"location":"lecture-notes/mongodb/#kurzor","title":"Kurzor","text":"<p>Ha az eredm\u00e9nyhalmaz sok dokumentumot tartalmaz, c\u00e9lszer\u0171 kurzorral feldolgozni. A MongoDB limit\u00e1lja a lek\u00e9rdez\u00e9sre adott v\u00e1lasz m\u00e9ret\u00e9t, ez\u00e9rt ha t\u00fal sok dokumentumot k\u00e9rdez\u00fcnk le, el\u0151fordulhat, hogy az eredm\u00e9ny helyett hib\u00e1t fogunk kapni. Ennek felold\u00e1s\u00e1ra haszn\u00e1ljuk a kurzorokat, ahol mindig csak egy r\u00e9szhalmaz\u00e1t kapjuk a dokumentumoknak.</p> <pre><code>var cur = collection.Find(...).ToCursor();\nwhile (cur.MoveNext()) // kurzor l\u00e9ptet\u00e9se\n{\n    foreach (var t in cur.Current) // a kurzor aktu\u00e1lis eleme nem egy dokumentum, hanem egy lista\n    { ... }\n}\n</code></pre>"},{"location":"lecture-notes/mongodb/#szureshez-hasznalhato-operatorok","title":"Sz\u0171r\u00e9shez haszn\u00e1lhat\u00f3 oper\u00e1torok","text":"<p>A sz\u0171r\u00e9si felt\u00e9telek a dokumentumban tal\u00e1lhat\u00f3 mez\u0151kre vonatkoznak, \u00e9s a sz\u0171r\u00e9si felt\u00e9tel mindig egy konstans. Teh\u00e1t nem lehets\u00e9ges p\u00e9ld\u00e1ul k\u00e9t mez\u0151t \u00f6sszehasonl\u00edtani, \u00e9s nem tudunk m\u00e1s gy\u0171jtem\u00e9nyekre se hivatkozni. L\u00e9tezik a MongoDB-ben egy \u00fan. aggreg\u00e1ci\u00f3s pipeline, amely seg\u00edts\u00e9g\u00e9vel bonyolultabb lek\u00e9rdez\u00e9seket is megfogalmazhatunk, most viszont az egyszer\u0171 lek\u00e9rdez\u00e9sekre koncentr\u00e1lunk.</p> <p>A sz\u0171r\u00e9si felt\u00e9tel teh\u00e1t a dokumentum egy mez\u0151j\u00e9t egy \u00e1ltalunk megadott konstanshoz hasonl\u00edtja. Az al\u00e1bbi lehet\u0151s\u00e9gek a leggyakrabban haszn\u00e1ltak.</p>"},{"location":"lecture-notes/mongodb/#osszehasonlitasi-operatorok","title":"\u00d6sszehasonl\u00edt\u00e1si oper\u00e1torok","text":"<pre><code>collection.Find(x =&gt; x.Price == 123);\ncollection.Find(Builders&lt;Product&gt;.Filter.Eq(x =&gt; x.Price, 123)); //Eq, mint equals\n\ncollection.Find(x =&gt; x.Price != 123);\ncollection.Find(Builders&lt;Product&gt;.Filter.Ne(x =&gt; x.Price, 123)); // Ne, mint not equals\n\ncollection.Find(x =&gt; x.Price &gt;= 123);\ncollection.Find(Builders&lt;Product&gt;.Filter.Gte(x =&gt; x.Price, 123)); // Gte, mint greater than or equal to\n\ncollection.Find(x =&gt; x.Price &lt; 123);\ncollection.Find(Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Price, 123)); // Lt, mint less than\n</code></pre>"},{"location":"lecture-notes/mongodb/#logikai-operatorok","title":"Logikai oper\u00e1torok","text":"<pre><code>collection.Find(x =&gt; x.Price &gt; 500 &amp;&amp; x.Price &lt; 1000);\ncollection.Find(\n    Builders&lt;Product&gt;.Filter.And(\n        Builders&lt;Product&gt;.Filter.Gt(x =&gt; x.Price, 500),\n        Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Price, 1000)\n    )\n);\n\ncollection.Find(x =&gt; x.Price &lt; 500 || x.Stock &lt; 10);\ncollection.Find(\n    Builders&lt;Product&gt;.Filter.Or(\n        Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Price, 500),\n        Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Stock, 10)\n    )\n);\n\ncollection.Find(x =&gt; !(x.Price &lt; 500 || x.Stock &lt; 10));\ncollection.Find(\n    Builders&lt;Product&gt;.Filter.Not(\n        Builders&lt;Product&gt;.Filter.Or(\n            Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Price, 500),\n            Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.Stock, 10)\n        )\n    )\n);\n</code></pre>"},{"location":"lecture-notes/mongodb/#tobb-ertek-kozul-valamelyikkel-megegyezo","title":"T\u00f6bb \u00e9rt\u00e9k k\u00f6z\u00fcl valamelyikkel megegyez\u0151","text":"<pre><code>collection.Find(x =&gt; x.Id == ... || x.Id = ...);\ncollection.Find(Builders&lt;Product&gt;.Filter.In(x =&gt; x.Id, new[] { ... }));\n// hasonl\u00f3an l\u00e9tezik a Nin, mint not in oper\u00e1tor\n</code></pre>"},{"location":"lecture-notes/mongodb/#ertek-letezik-nem-null","title":"\u00c9rt\u00e9k l\u00e9tezik (nem null)","text":"<pre><code>collection.Find(x =&gt; x.VAT != null);\ncollection.Find(Builders&lt;Product&gt;.Filter.Exists(x =&gt; x.VAT));\n</code></pre> <p>L\u00e9tezik-e</p> <p>A l\u00e9tezik-e, azaz nem null sz\u0171r\u00e9s az\u00e9rt k\u00fcl\u00f6nleges, mert a MongoDB szempontj\u00e1b\u00f3l k\u00e9t m\u00f3don is lehet null egy \u00e9rt\u00e9k: ha a kulcs l\u00e9tezik a dokumentumban \u00e9s \u00e9rt\u00e9ke null; avagy, ha a kulcs nem is l\u00e9tezik.</p>"},{"location":"lecture-notes/mongodb/#szures-beagyazott-dokumentum-mezojere","title":"Sz\u0171r\u00e9s be\u00e1gyazott dokumentum mez\u0151j\u00e9re","text":"<p>A MongoDB szempontj\u00e1b\u00f3l a be\u00e1gyazott dokumentumok ugyan\u00fagy haszn\u00e1lhat\u00f3k sz\u0171r\u00e9sre, teh\u00e1t az al\u00e1bbiak mind \u00e9rv\u00e9nyesek, \u00e9s az se okoz gondot, ha a be\u00e1gyazott dokumentum (a p\u00e9ld\u00e1kban a VAT nem l\u00e9tezik):</p> <pre><code>collection.Find(x =&gt; x.VAT.Percentage &lt; 27);\ncollection.Find(Builders&lt;Product&gt;.Filter.Lt(x =&gt; x.VAT.Percentage, 27));\n\ncollection.Find(Builders&lt;Product&gt;.Filter.Exists(x =&gt; x.VAT.Percentage, exists: false));\n// ez a nem l\u00e9tezik, azaz null sz\u0171r\u00e9s\n</code></pre>"},{"location":"lecture-notes/mongodb/#szures-tomb-erteku-mezore","title":"Sz\u0171r\u00e9s t\u00f6mb \u00e9rt\u00e9k\u0171 mez\u0151re","text":"<p>A dokumentum b\u00e1rmely mez\u0151je lehet t\u00f6mb \u00e9rt\u00e9k\u0171, mint a p\u00e9ld\u00e1ban a <code>string[] Categories</code>. MongoDB-ben a t\u00f6mb\u00f6kkel is egyszer\u0171en tudunk dolgozni, az <code>Any*</code> sz\u0171r\u00e9si felt\u00e9telekkel.</p> <pre><code>// azon term\u00e9keket, amelyek a jelzett kateg\u00f3ri\u00e1ban vannak\ncollection.Find(Builders&lt;Product&gt;.Filter.AnyEq(x =&gt; x.Categories, \"Labd\u00e1k\"));\n\n// azon term\u00e9keket, amelyek legal\u00e1bb egy olyan kateg\u00f3ri\u00e1hoz tartoznak, amelyet nem soroltunk fel\ncollection.Find(Builders&lt;Product&gt;.Filter.AnyNin(x =&gt; x.Categories, new[] { \"Labd\u00e1k\", \"\u00dct\u0151k\" }));\n</code></pre> <p>Any...</p> <p>Az <code>Any*</code> felt\u00e9telek a t\u00f6mb minden elem\u00e9t vizsg\u00e1lj\u00e1k, de a dokumentum szempontj\u00e1b\u00f3l csak egyszer illeszkednek. Teh\u00e1t, ha a t\u00f6mb t\u00f6bb eleme is illeszkedik egy felt\u00e9telre, att\u00f3l m\u00e9g csak egyszer kapjuk meg a dokumentumot az eredm\u00e9nyhalmazban.</p>"},{"location":"lecture-notes/mongodb/#lekerdezes-vegrehajto-pipeline","title":"Lek\u00e9rdez\u00e9s-v\u00e9grehajt\u00f3 pipeline","text":"<p>A MongoDB lek\u00e9rdez\u00e9sek egy \u00fan. pipeline-on haladnak v\u00e9gig. Ennek r\u00e9szleteivel nem fogunk megismerkedni, de az egyszer\u0171 sz\u0171r\u00e9seken k\u00edv\u00fcl p\u00e1r tov\u00e1bbi, lek\u00e9rdez\u00e9sekben haszn\u00e1lt elemet fogunk l\u00e1tni.</p>"},{"location":"lecture-notes/mongodb/#lapozas-rendezes","title":"Lapoz\u00e1s, rendez\u00e9s","text":"<p>A lapoz\u00e1shoz megadhatjuk, maxim\u00e1lisan h\u00e1ny illeszked\u0151 dokumentumot k\u00e9r\u00fcnk:</p> <pre><code>collection.Find(...).Limit(100);\n</code></pre> <p>A k\u00f6vetkez\u0151 lapon tal\u00e1lhat\u00f3 elemekhez pedig kihagyjuk az els\u0151 lapon m\u00e1r l\u00e1tott elemeket:</p> <pre><code>collection.Find(...).Skip(100).Limit(100);\n</code></pre> <p>A <code>Skip</code> \u00e9s <code>Limit</code> ebben a form\u00e1ban nem \u00e9rtelmes, ugyanis rendez\u00e9s n\u00e9lk\u00fcl az \"els\u0151 100 elem\" lek\u00e9rdez\u00e9s (a kliens sz\u00e1m\u00e1ra) nem determinisztikus. Teh\u00e1t az ilyen jelleg\u0171 lek\u00e9rdez\u00e9sekhez sz\u00fcks\u00e9ges, hogy egy megfelel\u0151 rendez\u00e9st is megadjunk. A rendez\u00e9s defini\u00e1l\u00e1sa a kor\u00e1bban m\u00e1r l\u00e1tott <code>Builders&lt;T&gt;</code> seg\u00edts\u00e9g\u00e9vel t\u00f6rt\u00e9nik.</p> <pre><code>collection.Find(...)\n    .Sort(Builders&lt;Product&gt;.Sort.Ascending(x =&gt; x.Name))\n    .Skip(100).Limit(100);\n</code></pre> <p>Lapoz\u00e1si probl\u00e9ma</p> <p>A fenti lapoz\u00e1s m\u00e9g mindig nem teljesen helyes. P\u00e9ld\u00e1ul, ha a k\u00e9t lap lek\u00e9rdez\u00e9se k\u00f6zben egy term\u00e9k t\u00f6rl\u00e9sre ker\u00fcl, akkor \"eggyel arr\u00e9bb cs\u00fasznak\" a term\u00e9kek, \u00e9s lesz egy term\u00e9k, amely kimarad a k\u00f6vetkez\u0151 lapoz\u00e1sn\u00e1l. Ez nem csak a MongoDB probl\u00e9m\u00e1ja. Gondolkodtat\u00f3 feladat: hogyan oldhat\u00f3 meg ez a probl\u00e9ma?</p>"},{"location":"lecture-notes/mongodb/#darabszam-lekerdezes","title":"Darabsz\u00e1m lek\u00e9rdez\u00e9s","text":"<p>A lek\u00e9rdez\u00e9sre illeszked\u0151 dokumentumok sz\u00e1m\u00e1t k\u00e9tf\u00e9le m\u00f3don is lek\u00e9rdezhetj\u00fck:</p> <pre><code>collection.CountDocuments(Builders&lt;Product&gt;.Filter.AnyEq(x =&gt; x.Categories, \"Labd\u00e1k\"));\n\ncollection.Find(Builders&lt;Product&gt;.Filter.AnyEq(x =&gt; x.Categories, \"Labd\u00e1k\")).CountDocuments();\n</code></pre>"},{"location":"lecture-notes/mongodb/#aggregacios-pipeline","title":"Aggreg\u00e1ci\u00f3s pipeline","text":"<p>Az aggreg\u00e1ci\u00f3s m\u0171veletek t\u00f6bb dokumentumot dolgoznak fel \u00e9s azokb\u00f3l valamilyen sz\u00e1m\u00edt\u00e1ssal el\u0151\u00e1ll\u00edtott eredm\u00e9nyt adnak vissza. A MongoDB h\u00e1rom m\u00f3dot biztos\u00edt sz\u00e1munkra ilyen \u00f6sszes\u00edt\u0151 m\u0171veletek elv\u00e9gz\u00e9s\u00e9hez:</p> <ul> <li>Aggreg\u00e1ci\u00f3s pipelineok</li> <li>Egyc\u00e9l\u00fa aggreg\u00e1ci\u00f3s m\u0171veletek (Single Purpose Aggregation Operations)</li> <li>Map-reduce f\u00fcggv\u00e9nyek</li> </ul> <p>A MongoDB 5.0 verzi\u00f3ja \u00f3ta a Map-reduce elavult m\u00f3dszernek sz\u00e1m\u00edt, mivel az aggreg\u00e1ci\u00f3s pipeline haszn\u00e1lhat\u00f3s\u00e1g \u00e9s sebess\u00e9g szempontj\u00e1b\u00f3l is kedvez\u0151bb n\u00e1la.</p> <p>Az egyc\u00e9l\u00fa aggreg\u00e1ci\u00f3s m\u0171veletek (Single Purpose Aggregation Operations) ter\u00e9n a MongoDB biztos\u00edtja sz\u00e1munkra a <code>IMongoCollection&lt;TDocument&gt;.EstimatedDocumentCount()</code>, <code>IMongoCollection&lt;TDocument&gt;.Count()</code> \u00e9s <code>IMongoCollection&lt;TDocument&gt;.Distinct()</code> f\u00fcggv\u00e9nyeket, melyeknek k\u00f6z\u00f6s jellemz\u0151j\u00fck, hogy mindegyik egy darab gy\u0171jtem\u00e9nyen v\u00e9gez m\u0171veletet.</p> <p></p> <p>Forr\u00e1s</p> <p>https://docs.mongodb.com/manual/images/distinct.bakedsvg.svg</p> <p>Az \u00e1ltal\u00e1nos aggreg\u00e1ci\u00f3khoz pedig k\u00e9sz\u00edthet\u00fcnk pipeline-okat. Egy aggreg\u00e1ci\u00f3s pipeline t\u00f6bb stage-b\u0151l \u00e9p\u00fcl fel, mindegyik valamilyen m\u0171veletet (filter, group, count, calculate stb.) v\u00e9gez a bemeneti dokumentumain. Egy pipeline k\u00e9pes t\u00f6bb eredm\u00e9nyt is visszaadni egy dokumentumhalmazr\u00f3l (pl. total, average, maximum vagy minimum \u00e9rt\u00e9keket).</p> <p>N\u00e9zz\u00fck ezt a csoportos\u00edt\u00e1s p\u00e9ld\u00e1j\u00e1n kereszt\u00fcl.</p> <pre><code>// A \"Labd\u00e1k\" kateg\u00f3ri\u00e1ba tartoz\u00f3 term\u00e9kek az \u00c1FA kulcs szerint csoportos\u00edtva\nforeach (var g in collection.Aggregate()\n                            .Match(Builders&lt;Product&gt;.Filter.AnyEq(x =&gt; x.Categories, \"Labd\u00e1k\")) // sz\u0171r\u00e9s\n                            .Group(x =&gt; x.VAT.Percentage, x =&gt; x) // csoportos\u00edt\u00e1s\n                            .ToList())\n{\n    Console.WriteLine($\"VAT percentage: {g.Key}\");\n    foreach(var p in g)\n        Console.WriteLine($\"\\tProduct: {p.Name}\");\n}\n</code></pre>"},{"location":"lecture-notes/mongodb/#beszuras-modositas-torles","title":"Besz\u00far\u00e1s, m\u00f3dos\u00edt\u00e1s, t\u00f6rl\u00e9s","text":"<p>A lek\u00e9rdez\u00e9sek ut\u00e1n ismerkedj\u00fcnk meg az adatm\u00f3dos\u00edt\u00e1sokkal.</p>"},{"location":"lecture-notes/mongodb/#uj-dokumentum-beszurasa","title":"\u00daj dokumentum besz\u00far\u00e1sa","text":"<p>\u00daj dokumentum besz\u00far\u00e1s\u00e1hoz az \u00faj dokumentumot reprezent\u00e1l\u00f3 objektumra van sz\u00fcks\u00e9g\u00fcnk. Ezt a gy\u0171jtem\u00e9nyhez tudjuk hozz\u00e1adni.</p> <pre><code>var newProduct = new Product\n{\n    Name = \"Alma\",\n    Price = 890,\n    Categories = new[] { \"Gy\u00fcm\u00f6lcs\u00f6k\" }\n};\ncollection.InsertOne(newProduct);\n\nConsole.WriteLine($\"Besz\u00fart rekord id: {newProduct.Id}\"); // besz\u00far\u00e1s ut\u00e1n friss\u00edt\u00e9sre ker\u00fcl a C# objektum, \u00e9s lek\u00e9rdezhet\u0151 az Id-ja\n</code></pre> <p>Figyelj\u00fck meg, hogy az <code>Id</code> mez\u0151t nem t\u00f6lt\u00f6tt\u00fck ki. Ezt a kliens oldali driver p\u00f3tolni fogja. Ha akarjuk, mi is adhatunk neki \u00e9rt\u00e9ket, de nem szok\u00e1s.</p> <p>Eml\u00e9kezz\u00fcnk r\u00e1, hogy a MongoDB-ben nincs s\u00e9ma, \u00edgy a besz\u00fart dokumentum lehet teljesen elt\u00e9r\u0151 a gy\u0171jtem\u00e9nyben tal\u00e1lhat\u00f3 t\u00f6bbi elemt\u0151l. Illetve figyelj\u00fck meg, hogy nem adtunk minden mez\u0151nek \u00e9rt\u00e9ket. Mivel nincsenek integrit\u00e1si krit\u00e9riumok, \u00edgy minden besz\u00far\u00e1s sikerrel fog j\u00e1rni, viszont a lek\u00e9rdez\u00e9sn\u00e9l lehetnek bel\u0151le probl\u00e9m\u00e1k (pl. ha felt\u00e9telezz\u00fck, hogy a rakt\u00e1rk\u00e9szlet mindig ki van t\u00f6ltve).</p> <p>T\u00f6bb dokumentum besz\u00far\u00e1s\u00e1ra az <code>InsertMany</code> f\u00fcggv\u00e9ny haszn\u00e1lhat\u00f3, azonban ne felejtkezz\u00fcnk el arr\u00f3l, hogy alap\u00e9rtelmezetten nincsenek tranzakci\u00f3k, \u00edgy a t\u00f6bb dokumentum besz\u00far\u00e1sa egyenk\u00e9nt f\u00fcggetlen m\u0171velet. Ha a besz\u00far\u00e1sok v\u00e9grehajt\u00e1sa k\u00f6zben valamely okb\u00f3l hiba t\u00f6rt\u00e9nik, az addig sikeresen besz\u00fart dokumentumok az adatb\u00e1zisban maradnak. Az egyes dokumentumok azonban atomi m\u00f3don ker\u00fclnek ment\u00e9sre, teh\u00e1t egy hiba sor\u00e1n se ker\u00fclhet egy \"f\u00e9l\" dokumentum az adatb\u00e1zisba.</p>"},{"location":"lecture-notes/mongodb/#dokumentumok-torlese","title":"Dokumentumok t\u00f6rl\u00e9se","text":"<p>A t\u00f6rl\u00e9shez egy sz\u0171r\u00e9si felt\u00e9telt kell defini\u00e1lnunk, \u00e9s vagy a <code>DeleteOne</code>, vagy a <code>DeleteMany</code> f\u00fcggv\u00e9nnyel t\u00f6r\u00f6lhet\u00fcnk. A k\u00fcl\u00f6nbs\u00e9g, hogy a <code>DeleteOne</code> az els\u0151 illeszked\u0151 dokumentumot t\u00f6rli csak, m\u00edg a <code>DeleteMany</code> az \u00f6sszeset. Ha tudjuk, hogy a felt\u00e9telnek csak egy dokumentum felelhet meg (p\u00e9ld\u00e1ul id alapj\u00e1n t\u00f6rl\u00fcnk), akkor \u00e9rdemes a <code>DeleteOne</code>-t haszn\u00e1lni, mert az adatb\u00e1zisnak nem kell kimer\u00edt\u0151 keres\u00e9st v\u00e9geznie.</p> <p>A t\u00f6rl\u00e9s felt\u00e9tele a keres\u00e9sn\u00e9l megismert szintaktik\u00e1kkal \u00edrhat\u00f3 le.</p> <p>A t\u00f6rl\u00e9s teh\u00e1t elt\u00e9r az Entity Framework eset\u00e9n tapasztalhat\u00f3 viselked\u00e9st\u0151l. Itt nem kell az entit\u00e1snak bet\u00f6ltve lennie, \u00e9s nem az entit\u00e1st t\u00f6r\u00f6lj\u00fck, hanem sz\u0171r\u00e9si felt\u00e9tellel \u00edrjuk le a t\u00f6rl\u00e9st.</p> <pre><code>var deleteResult = collection.DeleteOne(x =&gt; x.Id == new ObjectId(\"...\"));\nConsole.WriteLine($\"T\u00f6r\u00f6lve: {deleteResult.DeletedCount} db\");\n</code></pre> <p>Ha szeretn\u00e9nk a t\u00f6r\u00f6lt elemet megkapni, akkor haszn\u00e1lhatjuk a <code>FindOneAndDelete</code>-t, amely visszaadja a t\u00f6r\u00f6lt entit\u00e1st mag\u00e1t.</p>"},{"location":"lecture-notes/mongodb/#dokumentumok-megvaltoztatasa","title":"Dokumentumok megv\u00e1ltoztat\u00e1sa","text":"<p>A MongoDB tal\u00e1n leg\u00e9rdekesebb k\u00e9pess\u00e9gei a dokumentumok megv\u00e1ltoztat\u00e1sa k\u00f6r\u00fcl tal\u00e1lhat\u00f3ak. M\u00edg a kor\u00e1bbiak, a lek\u00e9rdez\u00e9sek, besz\u00far\u00e1sok, t\u00f6rl\u00e9sek a legt\u00f6bb adatb\u00e1zis (ak\u00e1r rel\u00e1ci\u00f3s, ak\u00e1r NoSQL) eset\u00e9n hasonl\u00f3ak, a MongoDB a m\u00f3dos\u00edt\u00f3 m\u0171veletekben j\u00f3val sz\u00e9lesebb spektrumot t\u00e1mogat.</p> <p>Alapvet\u0151en k\u00e9tf\u00e9le m\u00f3don tudunk egy dokumentumot megv\u00e1ltoztatni: lecser\u00e9lni az eg\u00e9sz dokumentumot egy \u00fajra, avagy r\u00e9szeit friss\u00edteni.</p>"},{"location":"lecture-notes/mongodb/#dokumentum-teljes-csereje","title":"Dokumentum teljes cser\u00e9je","text":"<p>A dokumentum teljes cser\u00e9j\u00e9hez sz\u00fcks\u00e9g\u00fcnk van egy sz\u0171r\u00e9si felt\u00e9telre, amellyel megadjuk, mely dokumentumot akarjuk cser\u00e9lni; valamint sz\u00fcks\u00e9g\u00fcnk van az \u00faj dokumentumra.</p> <pre><code>var replacementProduct = new Product\n{\n    Name = \"Alma\",\n    Price = 890,\n    Categories = new[] { \"Gy\u00fcm\u00f6lcs\u00f6k\" }\n};\nvar replaceResult = collection.ReplaceOne(x =&gt; x.Id == new ObjectId(\"...\"), replacementProduct);\nConsole.WriteLine($\"M\u00f3dos\u00edtva: {replaceResult.ModifiedCount}\");\n</code></pre> <p>Ez a csere 1-1 jelleg\u0171, azaz egy dokumentumot cser\u00e9l\u00fcnk egy dokumentumra. A m\u0171velet mag\u00e1ban atomi, azaz ha menet k\u00f6zben megszakad, akkor se fordulhat el\u0151, hogy egy f\u00e9l dokumentum ker\u00fclt elment\u00e9sre. Ha szeretn\u00e9nk megkapni a csere el\u0151tti dokumentumot, akkor a <code>FindOneAndReplace</code> met\u00f3dust haszn\u00e1lhatjuk.</p> <p>\u00c9rdekess\u00e9g</p> <p>A csere sor\u00e1n lehet\u0151s\u00e9g van a dokumentum id-j\u00e1nak m\u00f3dos\u00edt\u00e1s\u00e1ra is. Ha a csere dokumentumban m\u00e1s id szerepel, a dokumentum id-ja megv\u00e1ltozik.</p>"},{"location":"lecture-notes/mongodb/#dokumentum-modosito-operatorok","title":"Dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torok","text":"<p>A dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torokkal atomi m\u00f3don tudunk a dokumentum mez\u0151inek \u00e9rt\u00e9k\u00e9n v\u00e1ltoztatni an\u00e9lk\u00fcl, hogy a teljes dokumentumot lecser\u00e9ln\u00e9nk. A m\u00f3dos\u00edt\u00f3 m\u0171veletek le\u00edr\u00e1s\u00e1hoz a kor\u00e1bban m\u00e1r l\u00e1tott <code>Builders&lt;T&gt;</code> seg\u00edts\u00e9g\u00e9t vessz\u00fck ig\u00e9nybe.</p> <p>\u00c1ll\u00edtsunk be a rakt\u00e1rk\u00e9szletet egy konstans \u00e9rt\u00e9kre:</p> <pre><code>collection.UpdateOne(\n    filter: x =&gt; x.Id == new ObjectId(\"...\"),\n    update: Builders&lt;Product&gt;.Update.Set(x =&gt; x.Stock, 5));\n</code></pre> <p>Az <code>UpdateOne</code> f\u00fcggv\u00e9ny els\u0151 param\u00e9tere a sz\u0171r\u00e9si felt\u00e9tel. Le\u00edr\u00e1s\u00e1hoz b\u00e1rmely kor\u00e1bban ismertetett szintaktika haszn\u00e1lhat\u00f3. M\u00e1sodik param\u00e9tere a m\u00f3dos\u00edt\u00f3 m\u0171velet le\u00edr\u00f3ja, amelyet a <code>Builders&lt;T&gt;</code> seg\u00edts\u00e9g\u00e9vel \u00e9p\u00edthet\u00fcnk fel.</p> <p>A fenti p\u00e9ldak\u00f3dban a param\u00e9terek nev\u00e9t is ki\u00edrtuk (<code>filter:</code> \u00e9s <code>update:</code>), hogy egy\u00e9rtelm\u0171 legyen, hogy a param\u00e9ter mit jelk\u00e9pez. Ez nem k\u00f6telez\u0151, de az olvashat\u00f3s\u00e1got n\u00f6veli (a k\u00f3dsorok hossz\u00e1nak rov\u00e1s\u00e1ra).</p> <p>A m\u00f3dos\u00edt\u00e1s nem csak egy m\u0171veletet tartalmazhat.</p> <pre><code>collection.UpdateOne(\n    filter: x =&gt; x.Id == new ObjectId(\"...\"),\n    update: Builders&lt;Product&gt;.Update\n                .Set(x =&gt; x.Stock, 5) // rakt\u00e1rk\u00e9szlet legyen 5\n                .CurrentDate(x =&gt; x.StockUpdated) // mai d\u00e1tumot be\u00edrjuk, mint a friss\u00edt\u00e9s ideje\n                .Unset(x =&gt; x.NeedsUpdate) // t\u00f6r\u00f6lj\u00fck a friss\u00edtend\u0151 jelz\u00e9st\n);\n</code></pre> <p>A tipikusan haszn\u00e1lt m\u00f3dos\u00edt\u00f3 oper\u00e1torok:</p> <ul> <li><code>Set</code>: mez\u0151 \u00e9rt\u00e9k\u00e9nek be\u00e1ll\u00edt\u00e1sa;</li> <li><code>SetOnInsert</code>: mint a <code>Set</code>, de csak \u00faj dokumentum besz\u00far\u00e1sa eset\u00e9n fut le (l\u00e1sd upsert al\u00e1bb);</li> <li><code>Unset</code>: mez\u0151 t\u00f6rl\u00e9se (a kulcs \u00e9s \u00e9rt\u00e9k elt\u00e1vol\u00edt\u00e1sa a dokumentumb\u00f3l);</li> <li><code>CurrentDate</code>: aktu\u00e1lis d\u00e1tum be\u00edr\u00e1sa;</li> <li><code>Inc</code>: \u00e9rt\u00e9k n\u00f6vel\u00e9se;</li> <li><code>Min</code>, <code>Max</code>: mez\u0151 \u00e9rt\u00e9k\u00e9nek lecser\u00e9l\u00e9se, amennyiben a megadott \u00e9rt\u00e9k kisebb/nagyobb, mint a mez\u0151 jelenlegi \u00e9rt\u00e9ke;</li> <li><code>Mul</code>: \u00e9rt\u00e9k megszorz\u00e1sa;</li> <li><code>PopFirst</code>, <code>PopLast</code>: t\u00f6mbb\u0151l els\u0151/utols\u00f3 elem elt\u00e1vol\u00edt\u00e1sa;</li> <li><code>Pull</code>: t\u00f6mbb\u0151l \u00e9rt\u00e9k elt\u00e1vol\u00edt\u00e1sa;</li> <li><code>Push</code>: t\u00f6mbh\u00f6z \u00e9rt\u00e9k hozz\u00e1ad\u00e1sa a v\u00e9g\u00e9re (tov\u00e1bbi lehet\u0151s\u00e9gek ugyanebben az oper\u00e1torban: t\u00f6mb sorrendez\u00e9se, t\u00f6mb els\u0151 n elem\u00e9nek megtart\u00e1sa);</li> <li><code>AddToSet</code>: t\u00f6mbh\u00f6z \u00e9rt\u00e9k hozz\u00e1ad\u00e1sa, ha m\u00e9g nem l\u00e9tezik.</li> </ul> <p>A fenti m\u0171veletek akkor is \u00e9rtelmezettek, ha a megadott mez\u0151 nem l\u00e9tezik. Az oper\u00e1tor t\u00edpus\u00e1t\u00f3l f\u00fcgg\u0151en egy alap\u00e9rtelmezett \u00e9rt\u00e9ken v\u00e9gzi a m\u00f3dos\u00edt\u00e1st az adatb\u00e1zis. P\u00e9ld\u00e1ul az <code>Inc</code> \u00e9s <code>Mul</code> eset\u00e9n a mez\u0151 0 \u00e9rt\u00e9ket vesz fel, \u00e9s azon t\u00f6rt\u00e9nik a m\u00f3dos\u00edt\u00e1s. A t\u00f6mb m\u0171veletek eset\u00e9n egy \u00fcres t\u00f6mb ker\u00fcl m\u00f3dos\u00edt\u00e1sra. A t\u00f6bbi m\u0171velet eset\u00e9n dokument\u00e1ci\u00f3b\u00f3l kikereshet\u0151 a viselked\u00e9s.</p> <p>A fent l\u00e1tott m\u00f3dszerrel nem csak egyetlen dokumentum m\u00f3dos\u00edthat\u00f3. A k\u00e9rt szerkeszt\u0151 m\u0171velet t\u00f6bb, a sz\u0171r\u00e9si felt\u00e9telre illeszked\u0151 dokumentumon is elv\u00e9gezhet\u0151.</p> <p>P\u00e9ld\u00e1ul: a ny\u00e1ri szezonra val\u00f3 tekintettel minden labd\u00e1ra adjunk 25% engedm\u00e9nyt, \u00e9s adjuk \u0151ket hozz\u00e1 az akci\u00f3s kateg\u00f3ri\u00e1hoz.</p> <pre><code>collection.UpdateMany(\n    filter: Builders&lt;Product&gt;.Filter.AnyEq(x =&gt; x.Categories, \"Labd\u00e1k\"),\n    update: Builders&lt;Product&gt;.Update.Mul(x =&gt; x.Price, 0.75)\n                                   .AddToSet(x =&gt; x.Categories, \"Akci\u00f3s term\u00e9kek\"));\n</code></pre> <p>A m\u00f3dos\u00edt\u00f3 oper\u00e1torok atomi m\u00f3don teszik szerkeszthet\u0151v\u00e9 a dokumentumainkat. Haszn\u00e1latukkal kik\u00fcsz\u00f6b\u00f6lhet\u0151 a konkurens adathozz\u00e1f\u00e9r\u00e9sb\u0151l ered\u0151 probl\u00e9m\u00e1k egy r\u00e9sze.</p>"},{"location":"lecture-notes/mongodb/#upsert-beszuras-vagy-modositas","title":"Upsert: besz\u00far\u00e1s vagy m\u00f3dos\u00edt\u00e1s","text":"<p>M\u00f3dos\u00edt\u00f3 m\u0171velet sor\u00e1n lehet\u0151s\u00e9g\u00fcnk van az \u00fan. upsert (update/insert) jelleg\u0171 m\u0171k\u00f6d\u00e9sre. Ez azt jelenti, hogy vagy besz\u00far\u00e1s, vagy m\u00f3dos\u00edt\u00e1s t\u00f6rt\u00e9nik, annak f\u00fcggv\u00e9ny\u00e9ben, hogy megtal\u00e1lhat\u00f3 volt-e az elem az adatb\u00e1zisban. Az alapvet\u0151 viselked\u00e9s nem upsert, azt k\u00fcl\u00f6n k\u00e9rn\u00fcnk kell.</p> <pre><code>collection.ReplaceOne(\n    filter: x =&gt; x.Id == new ObjectId(\"...\"),\n    replacement: replacementObject,\n    options: new UpdateOptions() { IsUpsert = true });\n</code></pre> <p>Nem csak a teljes dokumentum cser\u00e9je eset\u00e9n van lehet\u0151s\u00e9g\u00fcnk upsert-re. A dokumentum m\u00f3dos\u00edt\u00f3 oper\u00e1torokkal is elv\u00e9gezhetj\u00fck ugyanezt. Ahogy l\u00e1thattuk, a m\u00f3dos\u00edt\u00f3 oper\u00e1torokat nem zavarja, ha nem l\u00e9tezik egy mez\u0151. Ugyan\u00edgy nem okoz gondot, ha nem l\u00e9tezik a dokumentum; ez azzal egyen\u00e9rt\u00e9k\u0171, mintha egy teljesen \u00fcres dokumentumon v\u00e9gezn\u00e9nk el a m\u00f3dos\u00edt\u00f3 m\u0171veleteket.</p> <pre><code>collection.UpdateOne(filter: ..., update: ..., options: new UpdateOptions() { IsUpsert = true });\n</code></pre> <p>Az upsert m\u0171velet egy eszk\u00f6z a konkurens m\u00f3dos\u00edt\u00e1sok ter\u00e9n a tranzakci\u00f3 hi\u00e1ny\u00e1ra. Mivel alap\u00e9rtelmezetten nincs tranzakci\u00f3nk, ez\u00e9rt nem tudunk meggy\u0151z\u0151dni arr\u00f3l a besz\u00far\u00e1s el\u0151tt, hogy m\u00e9g nem l\u00e9tezik egy adott rekord. Helyette haszn\u00e1lhatjuk az upsert m\u00f3dszert, ami atomi lek\u00e9rdez\u00e9st \u00e9s besz\u00far\u00e1st/m\u00f3dos\u00edt\u00e1st tesz lehet\u0151v\u00e9.</p> <p><code>merge</code></p> <p>SQL nyelvben a <code>merge</code> parancs ny\u00fajt erre hasonl\u00f3 megold\u00e1st.</p>"},{"location":"lecture-notes/mssql/server-side-programming/","title":"Microsoft SQL Server programoz\u00e1sa","text":"<p>A Microsoft SQL Server platform nyelve a T-SQL. A T-SQL nyelv platform specifikus, azaz a nyelv csak MSSQL szerveren haszn\u00e1lhat\u00f3 - b\u00e1r m\u00e1s platformoknak is meg van a saj\u00e1t, hasonl\u00f3 nyelve. A T-SQL nyelv \u00e9s az \u00e1ltala t\u00e1mogatott adatb\u00e1zisszerver-oldali programoz\u00e1si eszk\u00f6z\u00f6k az eredetileg deklarat\u00edv SQL nyelvet imperat\u00edv eszk\u00f6z\u00f6kkel eg\u00e9sz\u00edtik ki, mint v\u00e1ltoz\u00f3k haszn\u00e1lata, el\u00e1gaz\u00e1sok, elj\u00e1r\u00e1sok, valamint kapunk tov\u00e1bbi eszk\u00f6z\u00f6ket, mint p\u00e9ld\u00e1ul a triggerek \u00e9s kurzorok.</p>"},{"location":"lecture-notes/mssql/server-side-programming/#szerveroldali-programozas","title":"Szerveroldali programoz\u00e1s","text":"<p>Szerveroldali programoz\u00e1s</p> <p>Szerveroldali-, avagy adatb\u00e1zisszerver-oldali programoz\u00e1s alatt azt \u00e9rtj\u00fck, amikor az adatb\u00e1zisban nem csup\u00e1n adatot lek\u00e9rdez\u0151 \u00e9s m\u00f3dos\u00edt\u00f3 parancsokat hajtunk v\u00e9gre, hanem \u00fczleti logikai feladatokat is itt val\u00f3s\u00edtunk meg.</p> <p>Ahhoz, hogy meg\u00e9rts\u00fck, mikor \u00e9rdemes szerveroldali programoz\u00e1si eszk\u00f6z\u00f6ket haszn\u00e1lni, el\u0151sz\u00f6r azt \u00e9rdemes meg\u00e9rteni, mi\u00e9rt mer\u00fclhet egy\u00e1ltal\u00e1n fel benn\u00fcnk annak a lehet\u0151s\u00e9ge, hogy \u00fczleti logik\u00e1t az adatb\u00e1zisban \u00edrjunk meg.</p> <p>Mi\u00e9rt akarhatunk az adatb\u00e1zisban \u00fczleti logikai feladatokat megval\u00f3s\u00edtani?</p> <p>A r\u00e9tegzett architekt\u00far\u00e1ban egy als\u00f3bb r\u00e9teg szolg\u00e1ltat\u00e1st ny\u00fajt a felette elhelyezked\u0151 r\u00e9teg sz\u00e1m\u00e1ra. A fels\u0151bb r\u00e9teg teh\u00e1t \"nem tudja kiker\u00fclni\" az alatta lev\u0151 r\u00e9teget, azon kereszt\u00fcl kell a feladat\u00e1t elv\u00e9geznie. De ha belegondolunk, C#/Java/C++/stb. k\u00f3db\u00e1zisban nem felt\u00e9tlen\u00fcl tudunk hasonl\u00f3t garant\u00e1lni. Teh\u00e1t, ha egy komplex szab\u00e1lyrendszert \u00e9s logik\u00e1t megval\u00f3s\u00edtunk p\u00e9ld\u00e1ul egy C# oszt\u00e1lyban, akkor neh\u00e9z azt k\u00e9ts\u00e9get kiz\u00e1r\u00f3an garant\u00e1lni, hogy ezen oszt\u00e1lyt nem lehet \"megker\u00fclni\".</p> <p>Ha azonban a logika az adatb\u00e1zisban van, a logika nem, vagy sokkal kev\u00e9sb\u00e9 megker\u00fclhet\u0151. Ez abb\u00f3l is fog fakadni, hogy a szerveroldali programoz\u00e1s olyan eszk\u00f6z\u00f6ket ad a kez\u00fcnkbe (l\u00e1sd majd a triggereket), amelyek garant\u00e1lj\u00e1k, hogy a logik\u00e1nk minden esetben v\u00e9grehajt\u00e1sra ker\u00fcl.</p> <p>A szerveroldali programoz\u00e1snak el\u0151nyei \u00e9s h\u00e1tr\u00e1nyai vannak. Amikor azt vizsg\u00e1ljuk, egy funkci\u00f3t hol c\u00e9lszer\u0171 megval\u00f3s\u00edtani, a r\u00e9tegzett architekt\u00fara mellett azt is n\u00e9zn\u00fcnk kell, a technol\u00f3gia mire ad lehet\u0151s\u00e9get, illetve a lehets\u00e9ges alternat\u00edv\u00e1k k\u00f6z\u00fcl melyik j\u00e1r a legt\u00f6bb el\u0151nnyel.</p> <p>Ha \u00fczleti logikai funkci\u00f3t az adatb\u00e1zisban val\u00f3s\u00edtunk meg, az al\u00e1bbi el\u0151ny\u00f6kkel tal\u00e1lkozhatunk.</p> <ul> <li> <p>Az adatb\u00e1zis konzisztenci\u00e1\u00e9rt val\u00f3 felel\u0151ss\u00e9ge m\u00e9g egy\u00e9rtelm\u0171bb\u00e9 v\u00e1lik. A rel\u00e1ci\u00f3s modell nagy hangs\u00falyt fektet a konzisztenci\u00e1ra, de nem minden \u00fczleti logikai konzisztencia felt\u00e9tel \u00edrhat\u00f3 le k\u00f6zvetlen\u00fcl a rel\u00e1ci\u00f3s modellben. Gondoljunk csak arra a p\u00e9ld\u00e1ra, hogy a Neptun rendszerben a kurzusoknak van egy l\u00e9tsz\u00e1mlimitje. Ez egy \u00fczleti logikai szab\u00e1ly, amelyet, ha megszeg\u00fcnk, akkor az adatunk inkonzisztens \u00fczleti \u00e9rtelemben. Amennyiben ezen szab\u00e1ly betart\u00e1sa is az adatb\u00e1zisrendszer feladata, garant\u00e1lhat\u00f3, hogy mindig konzisztens lesz az adat.</p> </li> <li> <p>Cs\u00f6kkenthet\u0151 az adatb\u00e1zisb\u00f3l kifel\u00e9 ir\u00e1nyul\u00f3 adatforgalom. Sokszor adatot az\u00e9rt k\u00e9rdez\u00fcnk le, hogy megjelen\u00edts\u00fck a felhaszn\u00e1l\u00f3 sz\u00e1m\u00e1ra. Nem ezen tudunk cs\u00f6kkenteni. De olyan esetekben, amikor csak az\u00e9rt k\u00e9rdez\u00fcnk le adatot, hogy az alapj\u00e1n az \u00fczleti logika d\u00f6nt\u00e9st hozhasson, kihagyhat\u00f3 az adat utaztat\u00e1sa az adatb\u00e1zis \u00e9s az \u00fczleti logika k\u00f6z\u00f6tt, amennyiben a logik\u00e1t vissz\u00fck az adatb\u00e1zisba. Ez egyben biztons\u00e1gosabb is, mert nem ker\u00fcl feleslegesen a h\u00e1l\u00f3zatra adat (ahol esetleg lehallgathat\u00f3, avagy rosszul konfigur\u00e1lt alkalmaz\u00e1s miatt napl\u00f3f\u00e1jlokba, hiba\u00fczenetekbe ker\u00fclhet \u00e9rz\u00e9keny adat).</p> </li> <li> <p>Az adatb\u00e1zis szerverben meg\u00edrt logika felfoghat\u00f3 egy interf\u00e9szk\u00e9nt is, amely interf\u00e9sz az adat hozz\u00e1f\u00e9r\u00e9s \u00e9s m\u00f3dos\u00edt\u00e1s r\u00e9szleteit elrejti a felhaszn\u00e1l\u00f3 (itt: adatel\u00e9r\u00e9si r\u00e9teg avagy \u00fczleti logikai r\u00e9teg) el\u0151l. Ez egyr\u00e9szt absztrakci\u00f3t ad a kez\u00fcnkbe, m\u00e1sr\u00e9szt seg\u00edtheti a p\u00e1rhuzamos, gyorsabb fejleszt\u00e9st. Teh\u00e1t, am\u00edg egy fejleszt\u0151i csapat az adatb\u00e1zisban k\u00e9sz\u00edti a logik\u00e1t, egy m\u00e1sik csapat a r\u00e1\u00e9p\u00fcl\u0151 alkalmaz\u00e1st k\u00e9sz\u00edtheti, mert az interf\u00e9sz, azaz, hogy az adatb\u00e1zis mit \u00e9s hogyan tesz el\u00e9rhet\u0151v\u00e9, m\u00e1r kor\u00e1bban defini\u00e1lhat\u00f3 (az implement\u00e1ci\u00f3 n\u00e9lk\u00fcl). A hibajav\u00edt\u00e1s is k\u00f6nnyebb ilyen esetben, amennyiben a hiba az adatb\u00e1zisban meg\u00edrt logik\u00e1ban van. Ilyenkor el\u00e9g egy helyen, az adatb\u00e1zisban jav\u00edtani a k\u00f3dot, \u00e9s minden r\u00e1\u00e9p\u00fcl\u0151 rendszer r\u00f6gt\u00f6n j\u00f3l fog m\u0171k\u00f6dni (ellenben azzal, ha a hib\u00e1t mondjuk Java k\u00f3dban kell jav\u00edtani, mert akkor a Java k\u00f3db\u00e1zisra \u00e9p\u00fcl\u0151 alkalmaz\u00e1sokb\u00f3l \u00faj verzi\u00f3t kell kiadni, \u00e9s azt telep\u00edteni is kell minden felhaszn\u00e1l\u00f3n\u00e1l).</p> </li> </ul> <p>Term\u00e9szetesen a szerveroldali programoz\u00e1snak h\u00e1tr\u00e1nyai is vannak.</p> <ul> <li> <p>A nyelv, amit haszn\u00e1lunk platformf\u00fcgg\u0151. A megold\u00e1sok nem vihet\u0151ek \u00e1t egy adatb\u00e1zisrendszerb\u0151l m\u00e1sikba. S\u0151t, a programoz\u00f3i tud\u00e1s se vihet\u0151 \u00e1t k\u00f6nnyen. Egy C++ programoz\u00f3 k\u00f6nnyebben tud C#-ban k\u00f3dolni, mint ha nem lenne ilyen ismerete. De ez nem igaz a szerveroldali eszk\u00f6zt\u00e1rra. Egyik platform nem ugyanazt t\u00e1mogatja, mint a m\u00e1sik. A nyelvek szintaktik\u00e1ja is jelent\u0151sen elt\u00e9r. Az adatb\u00e1zisszerver-oldali programoz\u00e1s eg\u00e9szen m\u00e1s eszk\u00f6zt\u00e1rat \u00e9s megk\u00f6zel\u00edt\u00e9st, specifikus tud\u00e1st ig\u00e9nyel.</p> </li> <li> <p>Az adatb\u00e1zis terhel\u00e9se n\u0151. Nyilv\u00e1nval\u00f3, hogy ha t\u00f6bb feladatot l\u00e1t el egy szerver, akkor t\u00f6bb er\u0151forr\u00e1st fog ig\u00e9nyelni. Az adatb\u00e1zisok egy\u00e9bk\u00e9nt is kritikus pontjai az adatvez\u00e9relt rendszereknek, f\u0151k\u00e9nt, hogy a klasszikus rel\u00e1ci\u00f3s adatb\u00e1zisok nem j\u00f3l t\u00e1mogatj\u00e1k a horizont\u00e1lis sk\u00e1l\u00e1z\u00e1st (a terhel\u00e9s megoszt\u00e1s\u00e1t t\u00f6bb szerver k\u00f6z\u00f6tt). Ha m\u00e9g t\u00f6bb feladatot, m\u00e9g t\u00f6bb felel\u0151ss\u00e9get kap egy adatb\u00e1zis szerver, hamar lass\u00fav\u00e1 v\u00e1lhat.</p> </li> <li> <p>A technol\u00f3gia ma m\u00e1r nem fejl\u0151dik tov\u00e1bb. Nevezhetj\u00fck ak\u00e1r kifut\u00f3 technol\u00f3gi\u00e1nak is, amelyet legink\u00e1bb az \u00fan. legacy, m\u00e1r r\u00e9g\u00f3ta fejlesztett alkalmaz\u00e1sokban haszn\u00e1lnak legink\u00e1bb. \u00daj technol\u00f3giai eszk\u00f6zt\u00e1rat haszn\u00e1l\u00f3 szoftverfejleszt\u00e9si projektekben ritk\u00e1bban jelenik meg ezen szerveroldali vil\u00e1g.</p> </li> </ul>"},{"location":"lecture-notes/mssql/server-side-programming/#a-t-sql-nyelv-alapjai","title":"A T-SQL nyelv alapjai","text":"<p>A T-SQL nyelv teh\u00e1t a Microsoft SQL Server nyelve, amely a standard SQL utas\u00edt\u00e1sokon fel\u00fcl lehet\u0151s\u00e9get ad:</p> <ul> <li>v\u00e1ltoz\u00f3k haszn\u00e1lat\u00e1ra,</li> <li>el\u00e1gaz\u00e1sok \u00e9s ciklusok kezel\u00e9s\u00e9re,</li> <li>t\u00e1rolt elj\u00e1r\u00e1sok (\"met\u00f3dusok\") \u00edr\u00e1s\u00e1ra,</li> <li>kurzorok (iter\u00e1torok) haszn\u00e1lat\u00e1ra,</li> <li>triggerek (esem\u00e9nykezel\u0151 elj\u00e1r\u00e1sok) defini\u00e1l\u00e1s\u00e1ra,</li> <li>\u00e9s m\u00e9g sok minden m\u00e1sra is.</li> </ul> <p>N\u00e9zz\u00fck a nyelv szintaktik\u00e1j\u00e1t p\u00e9ld\u00e1kon kereszt\u00fcl. A pontos szintaktik\u00e1t l\u00e1sd a hivatalos dokument\u00e1ci\u00f3ban.</p> <p>Az al\u00e1bbi p\u00e9ld\u00e1k a minta adatb\u00e1zison futtathat\u00f3ak.</p>"},{"location":"lecture-notes/mssql/server-side-programming/#valtozok","title":"V\u00e1ltoz\u00f3k","text":"<p>A v\u00e1ltoz\u00f3kat haszn\u00e1lat el\u0151tt deklar\u00e1lni kell. Konvenci\u00f3 szerint a v\u00e1ltoz\u00f3k neve <code>@</code> karakterrel kezd\u0151dik. \u00c9rt\u00e9kad\u00e1s n\u00e9lk\u00fcl az inicializ\u00e1latlan v\u00e1ltoz\u00f3 <code>NULL</code> \u00e9rt\u00e9k\u0171.</p> <pre><code>DECLARE @num int\n\nSELECT @num\n-- NULL\n</code></pre> <p>\u00c9rt\u00e9kad\u00e1s a <code>SET</code> utas\u00edt\u00e1ssal lehets\u00e9ges, avagy k\u00f6zvetlen\u00fcl a deklar\u00e1ci\u00f3ban:</p> <pre><code>DECLARE @num int = 5\n\nSELECT @num\n-- 5\n\nSET @num = 3\n\nSELECT @num\n-- 3\n</code></pre> <p>A v\u00e1ltoz\u00f3 scope-ja nem k\u00f6t\u0151dik az utas\u00edt\u00e1s blokkhoz (<code>BEGIN-END</code> k\u00f6z\u00f6tt). A v\u00e1ltoz\u00f3 az \u00fan. batch-en bel\u00fcl vagy t\u00e1rolt elj\u00e1r\u00e1son bel\u00fcl \u00e9rv\u00e9nyes:</p> <pre><code>BEGIN\n  DECLARE @num int\n  SET @num = 3\nEND\n\nSELECT @num\n-- Ez m\u0171k\u00f6dik, a v\u00e1ltoz\u00f3 az utas\u00edt\u00e1s blokkon k\u00edv\u00fcl is el\u00e9rhet\u0151.\n-- 3\n\nGO -- \u00faj batch-et kezd\n\nSELECT @num\n-- Hiba: Must declare the scalar variable \"@num\".\n</code></pre> <p>V\u00e1ltoz\u00f3nak lek\u00e9rdez\u00e9ssel is adhatunk \u00e9rt\u00e9ket:</p> <pre><code>DECLARE @name nvarchar(max)\n\nSELECT @name = Name\nFROM Customer\nWHERE ID = 1\n</code></pre> <p>Ha a lek\u00e9rdez\u00e9s t\u00f6bb sorral t\u00e9r vissza, az utols\u00f3 \u00e9rt\u00e9k marad a v\u00e1ltoz\u00f3ban:</p> <pre><code>DECLARE @name nvarchar(max)\n\nSELECT @name = Name\nFROM Customer\n-- t\u00f6bb illeszked\u0151 sor is lesz\n-- SELECT utols\u00f3 eredm\u00e9nye ker\u00fcl v\u00e9g\u00fcl a v\u00e1ltoz\u00f3ba\n</code></pre> <p>Ha a lek\u00e9rdez\u00e9s nem t\u00e9r vissza eredm\u00e9nnyel, a v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke nem v\u00e1ltozik:</p> <pre><code>DECLARE @name nvarchar(max)\nSET @name = 'aaa'\n\nSELECT @name = Name\nFROM Customer\nWHERE ID = 99999999\n-- nincs illeszked\u0151 sor\n\nSELECT @name\n-- aaa\n</code></pre>"},{"location":"lecture-notes/mssql/server-side-programming/#utasitas-blokkok-es-vezerlesi-szerkezetek","title":"Utas\u00edt\u00e1s blokkok \u00e9s vez\u00e9rl\u00e9si szerkezetek","text":"<p>Utas\u00edt\u00e1s blokkot a <code>BEGIN-END</code> utas\u00edt\u00e1s p\u00e1r k\u00f6z\u00e9 \u00edrhatunk:</p> <pre><code>BEGIN\n  DECLARE @num int\n  SET @num = 3\nEND\n</code></pre> <p>El\u00e1gaz\u00e1st <code>IF-ELSE</code> szerkezettel k\u00e9sz\u00edthet\u00fcnk:</p> <pre><code>DECLARE @name nvarchar(max)\n\nSELECT @name = Name\nFROM Customer\nWHERE ID = 123\n\nIF @name IS NOT NULL -- Ha l\u00e9tezik a felhaszn\u00e1l\u00f3\nBEGIN\n  PRINT 'Updating email'\n  UPDATE Customer\n    SET Email = 'agh*******@gmail.com'\n    WHERE ID = 123\nEND\nELSE\nBEGIN\n  PRINT 'No such customer'\nEND\n</code></pre> <p>Ciklushoz a <code>WHILE</code> felt\u00e9telt \u00e9s egy <code>BEGIN-END</code> utas\u00edt\u00e1sblokkot haszn\u00e1lunk:</p> <pre><code>-- Gener\u00e1ljunk legal\u00e1bb 1000 term\u00e9ket (pl. tesztel\u00e9shez)\nWHILE (SELECT COUNT(*) FROM Product) &lt; 1000\nBEGIN\n    INSERT INTO Product(Name,Price,Stock,VATID,CategoryID)\n    VALUES ('Abc', 1, 1, 3, 13)\nEND\n</code></pre>"},{"location":"lecture-notes/mssql/server-side-programming/#beepitett-fuggvenyek","title":"Be\u00e9p\u00edtett f\u00fcggv\u00e9nyek","text":"<p>A T-SQL nyelvben sz\u00e1mtalan be\u00e9p\u00edtett f\u00fcggv\u00e9ny \u00e9rhet\u0151 el. Al\u00e1bb p\u00e1r p\u00e9lda a f\u00fcggv\u00e9nyekre \u00e9s haszn\u00e1latukra.</p> <p>Az al\u00e1bbi p\u00e9ld\u00e1kban a f\u00fcggv\u00e9nyek eredm\u00e9ny\u00e9t <code>select</code>-tel lek\u00e9rdezz\u00fck. Ez csup\u00e1n azt a c\u00e9lt szolg\u00e1lja, hogy l\u00e1thassuk az eredm\u00e9nyt. F\u00fcggv\u00e9ny b\u00e1rhol haszn\u00e1lhat\u00f3 a nyelvben, ahol skal\u00e1r \u00e9rt\u00e9k haszn\u00e1lhat\u00f3.</p> <p>String kezel\u0151 f\u00fcggv\u00e9nyek:</p> <pre><code>-- \u00d6sszef\u0171z\u00e9s\nSELECT CONCAT ('Happy ', 'Birthday!')\n-- Happy Birthday!\n\n-- Bal oldalr\u00f3l N darab karakter\nSELECT LEFT('ABCDEF',2)\n-- AB\n\n-- Sz\u00f6veg hossza\nSELECT LEN('ABCDEF')\n-- 6\n\n-- R\u00e9szstring csere\nSELECT REPLACE('Happy Birthday!', 'day', 'month')\n-- Happy Birthmonth!\n\n-- Kisbet\u0171sre alak\u00edt\u00e1s\nSELECT LOWER('ABCDEF')\n-- abcdef\n</code></pre> <p>D\u00e1tumok kezel\u00e9se:</p> <pre><code>-- Aktu\u00e1lis d\u00e1tum \u00e9s id\u0151\nSELECT GETDATE()\n-- 2021-09-28 10:43:59.120\n\n-- D\u00e1tum \u00e9v komponense\nSELECT YEAR(GETDATE())\n-- 2021\n\n-- D\u00e1tum meghat\u00e1rozott komponense\nSELECT DATEPART (day,'12/20/2021')\nSELECT DATEPART (month,'12/20/2021')\n-- 20\n-- 12\n\n-- D\u00e1tumok k\u00f6z\u00f6tti k\u00fcl\u00f6nbs\u00e9g adott m\u00e9rt\u00e9kegys\u00e9gben (itt: nap) m\u00e9rve\nSELECT DATEDIFF(day, '2021-09-28 12:10:09', '2021-11-04 13:45:09')\n-- 37\n</code></pre> <p>Adatt\u00edpus konvert\u00e1l\u00e1s:</p> <pre><code>SELECT CAST('12' as int)\n-- 12\n\nSELECT CONVERT(int, '12')\n-- 12\n\nSELECT CONVERT(int, 'aa')\n-- Hiba: Conversion failed when converting the varchar value 'aa' to data type int.\n\nSELECT TRY_CONVERT(int, 'aa')\n-- NULL\n</code></pre> <p><code>ISNULL</code>: eredm\u00e9nye az els\u0151 argumentum, ha az nem null, k\u00fcl\u00f6nben a m\u00e1sodik argumentum (ami lehet null is).</p> <pre><code>DECLARE @a int\nDECLARE @b int = 5\nSELECT ISNULL(@a, @b)\n-- 5\n</code></pre> <p>Nem keverend\u0151 \u00f6ssze az <code>is null</code> felt\u00e9tellel, pl.: <code>UPDATE Product SET Price=111 WHERE Price is null</code></p>"},{"location":"lecture-notes/mssql/server-side-programming/#kurzor","title":"Kurzor","text":"<p>A kurzor egy iter\u00e1tor, amellyel egy rekord halmazon tudunk elemenk\u00e9nt v\u00e9gigl\u00e9pni. Akkor haszn\u00e1ljuk, amikor egy lek\u00e9rdez\u00e9s t\u00f6bb elemmel t\u00e9r vissza, \u00e9s az elemekkel egyes\u00e9vel szeretn\u00e9nk tov\u00e1bbi feldolgoz\u00e1st v\u00e9gezni.</p> <p>A kurzor haszn\u00e1lata t\u00f6bb l\u00e9p\u00e9sb\u0151l \u00e1ll:</p> <ol> <li>A kurzort deklar\u00e1lni kell, majd meg kell nyitni.</li> <li>Az iter\u00e1ci\u00f3 egy ciklussal t\u00f6rt\u00e9nik.</li> <li>A kurzort bez\u00e1rjuk \u00e9s felszabad\u00edtjuk.</li> </ol>"},{"location":"lecture-notes/mssql/server-side-programming/#deklaracio-es-megnyitas","title":"Deklar\u00e1ci\u00f3 \u00e9s megnyit\u00e1s","text":"<p>A deklar\u00e1ci\u00f3 a <code>DECLARE</code> utas\u00edt\u00e1ssal t\u00f6rt\u00e9nik. Itt adjuk meg a lek\u00e9rdez\u00e9st is, amely az eredm\u00e9nyeket szolg\u00e1ltatja. A teljes szintaktika:</p> <pre><code>DECLARE kurzorn\u00e9v CURSOR \n  [ FORWARD_ONLY | SCROLL ] \n  [ STATIC | KEYSET | DYNAMIC | FAST_FORWARD ] \n  [ READ_ONLY | SCROLL_LOCKS | OPTIMISTIC ] \nFOR lek\u00e9rdez\u00e9s \n[ FOR UPDATE [ OF oszlopn\u00e9v [ ,...n ] ] ]\n</code></pre> <p>A deklar\u00e1ci\u00f3ban opcion\u00e1lis megadhat\u00f3 elemek jelent\u00e9se (r\u00e9szletesebben l\u00e1sd a dokument\u00e1ci\u00f3ban):</p> <ul> <li><code>FORWARD_ONLY</code>: csak <code>FETCH NEXT</code> lehets\u00e9ges</li> <li><code>SCROLL</code>: szabadon lehet el\u0151re \u00e9s visszafel\u00e9 is l\u00e9pni a kurzorban</li> <li><code>STATIC</code>: m\u00e1solatb\u00f3l dolgozik, az eredm\u00e9nyek a megnyit\u00e1s (<code>OPEN</code>) id\u0151pillanat\u00e1ban l\u00e1that\u00f3 tartalmat mutatja</li> <li><code>KEYSET</code>: megnyit\u00e1skori \u00e1llapot adja a sorokat \u00e9s sorrendj\u00fcket, de a rekord tartalma a <code>FETCH</code> pillanat\u00e1ban ker\u00fcl lek\u00e9rdez\u00e9sre</li> <li><code>DYNAMIC</code>: minden l\u00e9ptet\u00e9skor aktu\u00e1lis \u00e1llapotot adja, teh\u00e1t konkurens tranzakci\u00f3k m\u00f3dos\u00edt\u00e1sait is l\u00e1thatjuk</li> <li><code>READ_ONLY</code>: nem update-elhet\u0151 a kurzor \u00e1ltal l\u00e9ptetett tartalom</li> <li><code>SCROLL_LOCKS</code>: l\u00e9ptet\u00e9s z\u00e1rolja a sorokat (alapb\u00f3l nem), ez\u00e1ltal garant\u00e1lva, hogy a <code>FETCH</code> ut\u00e1ni m\u00f3dos\u00edt\u00e1s bizonyosan sikeres lesz</li> <li><code>OPTIMISTIC</code>: nem z\u00e1rol, optimista konkurenciakezel\u00e9st alkalmaz (a <code>FETCH</code> ideje \u00e9s azt k\u00f6vet\u0151 <code>UPDATE</code> k\u00f6z\u00f6tt nem t\u00f6rt\u00e9nt-e m\u00f3dos\u00edt\u00e1s)</li> <li><code>FOR UPDATE</code>: updatelehet\u0151 oszlopok list\u00e1ja</li> </ul> <p>A deklar\u00e1ci\u00f3 m\u00e9g nem el\u00e9g a haszn\u00e1lathoz, a kurzort meg kell nyitni az <code>OPEN</code> paranccsal. Az <code>OPEN</code> p\u00e1rja a kurzor haszn\u00e1lat\u00e1nak befejez\u00e9s\u00e9re a <code>CLOSE</code>. Bez\u00e1r\u00e1s ut\u00e1n a kurzor \u00fajra megnyithat\u00f3, \u00edgy k\u00fcl\u00f6n jelezni kell, amikor t\u00f6bbet m\u00e1r nem haszn\u00e1ljuk a kurzort a <code>DEALLOCATE</code> paranccsal. (Tipikusan a <code>CLOSE</code> \u00e9s <code>DEALLOCATE</code> egym\u00e1st k\u00f6veti, mert csak egyszer haszn\u00e1ljuk a kurzort.)</p>"},{"location":"lecture-notes/mssql/server-side-programming/#leptetes","title":"L\u00e9ptet\u00e9s","text":"<p>A kurzor aktu\u00e1lis elem\u00e9hez \u00fagy f\u00e9r\u00fcnk hozz\u00e1, hogy a <code>FETCH</code> utas\u00edt\u00e1ssal \"kim\u00e1soljuk\" lok\u00e1lis v\u00e1ltoz\u00f3(k)ba az \u00e9rt\u00e9keket. Az erre haszn\u00e1lt v\u00e1ltoz\u00f3kat el\u0151re deklar\u00e1lni kell. A <code>FETCH</code> utas\u00edt\u00e1s tipikusan a k\u00f6vetkez\u0151 elemet veszi (<code>FETCH NEXT</code>), de ha nem <code>FORWARD_ONLY</code> a kurzor, akkor l\u00e9phet\u00fcnk el\u0151re \u00e9s h\u00e1tra egyet \u00e9s t\u00f6bbet is:</p> <pre><code>FETCH   \n  [ NEXT | PRIOR | FIRST | LAST\n      | ABSOLUTE { n | @nvar }\n      | RELATIVE { n | @nvar }\n  ]\nFROM cursor_name\nINTO @variable_name [ ,...n ]\n</code></pre> <p>Azt, hogy a <code>FETCH</code> utas\u00edt\u00e1s sikeres volt-e, a <code>@@FETCH_STATUS</code> implicit v\u00e1ltoz\u00f3t lek\u00e9rdezve tudjuk meg. A <code>@@FETCH_STATUS</code> v\u00e1ltoz\u00f3 \u00e9rt\u00e9ke:</p> <ul> <li>0 sikeres FETCH eset\u00e9n,</li> <li>-1 sikertelen FETCH eset\u00e9n,</li> <li>-2 amennyiben a lek\u00e9rt sor hi\u00e1nyzik (<code>KEYSET</code> haszn\u00e1latakor lehets\u00e9ges).</li> </ul> <p>A teljes iter\u00e1ci\u00f3 \u00edgy k\u00e9t <code>FETCH</code> utas\u00edt\u00e1st \u00e9s egy <code>WHILE</code> ciklust ig\u00e9nyel:</p> <pre><code>-- declare, open ...\nFETCH NEXT FROM cur INTO @var1, @var2\nWHILE @@FETCH_STATUS = 0\nBEGIN\n  -- .. saj\u00e1t logika\n  FETCH NEXT FROM cur INTO @var1, @var2\nEND\n</code></pre> <p>Vegy\u00fck \u00e9szre, hogy a k\u00f3dban k\u00e9tszer szerepel a <code>FETCH</code> utas\u00edt\u00e1s. Ennek oka, hogy az els\u0151, cikluson k\u00edv\u00fcli a legels\u0151 rekord lek\u00e9rdez\u00e9s\u00e9hez haszn\u00e1latos, m\u00edg a m\u00e1sodik, a ciklus belsej\u00e9ben minden tov\u00e1bbi rekordot k\u00e9r le egyes\u00e9vel.</p>"},{"location":"lecture-notes/mssql/server-side-programming/#pelda","title":"P\u00e9lda","text":"<p>L\u00e1ssunk egy komplett p\u00e9ld\u00e1t. Keress\u00fck meg azon term\u00e9keket, amib\u0151l alig van rakt\u00e1ron, \u00e9s ha a legutols\u00f3 elad\u00e1s t\u00f6bb, mint egy \u00e9ve volt, akkor adjunk kedvezm\u00e9nyt a term\u00e9kre:</p> <pre><code>-- Ezekbe a v\u00e1ltoz\u00f3kba szedj\u00fck ki a kurzorb\u00f3l az adatokat\nDECLARE @ProductName nvarchar(max)\nDECLARE @ProductID int\nDECLARE @LastOrder datetime\n\nDECLARE products_cur CURSOR SCROLL SCROLL_LOCKS -- Z\u00e1rol\u00e1s hogy a m\u00f3dos\u00edt\u00e1s garant\u00e1ltan siker\u00fclj\u00f6n\nFOR\n  SELECT Id, Name FROM Product WHERE Stock &lt; 3 -- Kurzor lek\u00e9rdez\u00e9se\nFOR UPDATE OF Price -- Szeretn\u00e9nk friss\u00edteni is a rekordokat\n\n-- Tipikus megnyit\u00e1s, fetch, ciklus\nOPEN products_cur\nFETCH NEXT FROM products_cur INTO @ProductID, @ProductName\nWHILE @@FETCH_STATUS = 0\nBEGIN\n\n  -- A ciklusban ak\u00e1rmilyen m\u0171veletet v\u00e9gezhet\u00fcnk\n  -- Itt megkeress\u00fck az utols\u00f3 v\u00e1s\u00e1rl\u00e1s idej\u00e9t\n  SELECT @LastOrder = MAX([Order].Date)\n    FROM [Order] JOIN OrderItem ON [Order].Id = OrderItem.OrderId\n    WHERE OrderItem.ProductID = @ProductId\n\n  -- Diagnosztikai ki\u00edr\u00e1s\n  PRINT CONCAT('ProductID: ', convert(nvarchar, @ProductID), ' Last order: ', ISNULL(convert(nvarchar, @LastOrder), 'No last order'))\n\n  IF @LastOrder IS NULL OR @LastOrder &lt; DATEADD(year, -1, GETDATE())\n  BEGIN\n    UPDATE Product\n      SET Price = Price * 0.75\n      WHERE CURRENT OF products_cur\n      -- Aktu\u00e1lis kurzor rekord friss\u00edt\u00e9se\n      -- Alternat\u00edva: WHERE Id = @ProductID\n  END\n\n  -- K\u00f6vetkez\u0151 rekord lek\u00e9rdez\u00e9se, majd ugr\u00e1s a WHILE ciklushoz ellen\u0151rizve, hogy sikeres volt-e\n  FETCH NEXT FROM products_cur INTO @ProductID, @ProductName\nEND\n-- Kurzor haszn\u00e1lat\u00e1nak befejez\u00e9se\nCLOSE products_cur\nDEALLOCATE products_cur\n</code></pre>"},{"location":"lecture-notes/mssql/server-side-programming/#tarolt-eljaras-es-fuggveny","title":"T\u00e1rolt elj\u00e1r\u00e1s \u00e9s f\u00fcggv\u00e9ny","text":"<p>A kor\u00e1bbi p\u00e9ld\u00e1kban meg\u00edrt k\u00f3dokat a meg\u00edr\u00e1suk ut\u00e1n bek\u00fcldt\u00fck a szervernek, amely azonnal v\u00e9grehajtotta \u0151ket. Lehet\u0151s\u00e9g\u00fcnk van olyan k\u00f3dot is \u00edrni, amelyet a szerver elt\u00e1rol \u00e9s k\u00e9s\u0151bb b\u00e1rmikor megh\u00edvhatjuk. Egy modul\u00e1ris programoz\u00e1si k\u00f6rnyezetben f\u00fcggv\u00e9nyeknek, objektumorient\u00e1lt vil\u00e1gban pedig met\u00f3dusoknak szoktuk ezt h\u00edvni. Microsoft SQL Server eset\u00e9ben ezeket t\u00e1rolt elj\u00e1r\u00e1snak \u00e9s t\u00e1rolt f\u00fcggv\u00e9nynek h\u00edvjuk. A n\u00e9vben a t\u00e1rolt arra utal, hogy az elj\u00e1r\u00e1s k\u00f3dj\u00e1t az adatb\u00e1zis elt\u00e1rolja, \u00edgy az adat mellett r\u00e9sze lesz az adatb\u00e1zisnak (\u00e9s p\u00e9ld\u00e1ul a biztons\u00e1gi ment\u00e9sbe is beker\u00fcl).</p> <p>Az elj\u00e1r\u00e1s \u00e9s a f\u00fcggv\u00e9ny k\u00f6z\u00f6tt annyi a k\u00fcl\u00f6nbs\u00e9g, hogy az elj\u00e1r\u00e1soknak tipikusan nincs visszat\u00e9r\u00e9si \u00e9rt\u00e9ke, m\u00edg a f\u00fcggv\u00e9nyeknek van. Tov\u00e1bbi megk\u00f6t\u00e9s MSSQL platformon, hogy a f\u00fcggv\u00e9nyek csak olvashatj\u00e1k az adatb\u00e1zist, de m\u00f3dos\u00edt\u00e1st nem v\u00e9gezhetnek.</p>"},{"location":"lecture-notes/mssql/server-side-programming/#eljaras","title":"Elj\u00e1r\u00e1s","text":"<p>Egy t\u00e1rolt elj\u00e1r\u00e1st az al\u00e1bbi szintaktik\u00e1val hozhatunk l\u00e9tre:</p> <pre><code>CREATE [OR ALTER] PROC[EDURE] elj\u00e1r\u00e1s_n\u00e9v \n  [ { @param\u00e9ter adatt\u00edpus } ] [ ,...n ] \nAS\n[BEGIN]\n  sql_utas\u00edt\u00e1sok [ ...n ] \n[END]\n</code></pre> <p>A <code>CREATE OR ALTER</code> eredm\u00e9nye a t\u00e1rolt elj\u00e1r\u00e1s l\u00e9trehoz\u00e1sa, ha nem l\u00e9tezett, avagy ha m\u00e1r l\u00e9tezett ilyen n\u00e9vvel, akkor annak friss\u00edt\u00e9se az \u00faj tartalommal. MSSQL Server 2016 el\u0151tt nem volt <code>CREATE OR ALTER</code>, csak <code>CREATE PROC</code> \u00e9s <code>ALTER PROC</code>. Egy t\u00e1rolt elj\u00e1r\u00e1st a <code>DROP PROCEDURE</code> utas\u00edt\u00e1ssal lehet t\u00f6r\u00f6lni, melynek hat\u00e1s\u00e1ra az elj\u00e1r\u00e1s elt\u00e1vol\u00edt\u00e1sra ker\u00fcl a szerverb\u0151l \u00e9s t\u00f6bbet nem h\u00edvhat\u00f3 meg.</p> <p>L\u00e1ssuk p\u00e9ld\u00e1ul az \u00c1FA kulcs r\u00f6gz\u00edt\u00e9s\u00e9t a <code>VAT</code> t\u00e1bl\u00e1ba annak garant\u00e1l\u00e1s\u00e1val, hogy olyan kulcs nem r\u00f6gz\u00edthet\u0151 mely m\u00e1r l\u00e9tezik:</p> <pre><code>create or alter procedure InsertNewVAT -- t\u00e1rolt elj\u00e1r\u00e1s l\u00e9trehoz\u00e1sa, neve\n    @Percentage int                    -- t\u00e1rolt elj\u00e1r\u00e1s param\u00e9terei\nas\n  begin\n  -- innen kezd\u0151dik a k\u00f3d, amit az elj\u00e1r\u00e1s megh\u00edv\u00e1sakor v\u00e9grehajt a rendszer\n  begin tran                            -- nem megism\u00e9telhet\u0151 olvas\u00e1s elker\u00fcl\u00e9se v\u00e9gett\n  set transaction isolation level repeatable read\n\n  declare @Count int\n\n  select @Count = count(*)\n  from VAT\n  where Percentage = @Percentage\n\n  if @Count = 0\n      insert into VAT values (@Percentage)\n  else\n      print 'error';\n\ncommit\nend\n</code></pre> <p>T\u00e1rolt elj\u00e1r\u00e1s az el\u0151bbi parancs hat\u00e1s\u00e1ra l\u00e9trej\u00f6n, \u00e9s ut\u00e1na az al\u00e1bbi m\u00f3don h\u00edvhatjuk meg:</p> <pre><code>exec InsertNewVAT 27\n</code></pre> <p>A t\u00e1rolt elj\u00e1r\u00e1sok az adatb\u00e1zisunk r\u00e9szei. Microsoft SQL Server Management Studio-ban p\u00e9ld\u00e1ul a k\u00e9pen l\u00e1that\u00f3 helyen jelennek meg:</p> <p></p>"},{"location":"lecture-notes/mssql/server-side-programming/#skalar-fuggveny","title":"Skal\u00e1r f\u00fcggv\u00e9ny","text":"<p>F\u00fcggv\u00e9ny deklar\u00e1ci\u00f3ja az elj\u00e1r\u00e1s\u00e9hoz hasonl\u00f3an t\u00f6rt\u00e9nik, azonban meg kell adni a visszat\u00e9r\u00e9si t\u00edpust is:</p> <pre><code>CREATE [ OR ALTER ] FUNCTION n\u00e9v\n( [ { @param\u00e9ter adatt\u00edpus } ] [ ,...n ] )\nRETURNS adatt\u00edpus\n[ AS ]\nBEGIN\n  utas\u00edt\u00e1sok\n  RETURN skal\u00e1r_\u00e9rt\u00e9k\nEND\n</code></pre> <p>N\u00e9zz\u00fcnk egy <code>int</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171 f\u00fcggv\u00e9nyt, amelynek nincs bemen\u0151 param\u00e9tere:</p> <pre><code>CREATE OR ALTER FUNCTION LargestVATPercentage()\nRETURNS int\nBEGIN\nRETURN (SELECT MAX(Percentage) FROM VAT)\nEND\n</code></pre> <p>Ezt a f\u00fcggv\u00e9nyt \u00edgy haszn\u00e1lhatjuk:</p> <pre><code>select dbo.LargestVATPercentage()\n-- A dbo el\u0151tag a s\u00e9ma azonos\u00edt\u00e1sa, amivel azt jel\u00f6lj\u00fck, hogy ez nem egy be\u00e9p\u00edtett f\u00fcggv\u00e9ny\n-- En\u00e9lk\u00fcl a f\u00fcggv\u00e9nyt nem tal\u00e1lja meg a rendszer\n\n-- avagy p\u00e9ld\u00e1ul\nDECLARE @maxvat int = dbo.LargestVATPercentage()\nselect @maxvat\n</code></pre>"},{"location":"lecture-notes/mssql/server-side-programming/#tabla-fuggveny","title":"T\u00e1bla f\u00fcggv\u00e9ny","text":"<p>Nem csak skal\u00e1r \u00e9rt\u00e9kkel t\u00e9rhet vissza egy f\u00fcggv\u00e9ny, az eredm\u00e9ny lehet t\u00e1bla t\u00edpus\u00fa is. Ilyenkor a deklar\u00e1ci\u00f3 \u00edgy n\u00e9z ki:</p> <pre><code>CREATE [ OR ALTER ] FUNCTION n\u00e9v\n( [ { @param\u00e9ter adatt\u00edpus } ] [ ,...n ] )\nRETURNS TABLE\n[ AS ]\nRETURN select utas\u00edt\u00e1s\n</code></pre> <p>N\u00e9zz\u00fck p\u00e9ld\u00e1ul az \u00e1fakulcsok lek\u00e9r\u00e9s\u00e9t egy adott sz\u00e1zal\u00e9k felett:</p> <pre><code>CREATE FUNCTION VATPercentages(@min int)\nRETURNS TABLE\nAS RETURN\n(\n    SELECT ID, Percentage FROM VAT\n    WHERE Percentage &gt; @min\n)\n</code></pre> <p>Ezen f\u00fcggv\u00e9ny t\u00e1bl\u00e1t ad vissza, teh\u00e1t b\u00e1rhol haszn\u00e1lhatjuk a f\u00fcggv\u00e9nyt, ahol t\u00e1bla \u00e1llhat, p\u00e9ld\u00e1ul:</p> <pre><code>SELECT * FROM VATPercentages(20)\n</code></pre> <p>Mivel a f\u00fcggv\u00e9ny t\u00e1bl\u00e1t ad vissza, ak\u00e1r <code>join</code>-olhatunk is r\u00e1:</p> <pre><code>SELECT VAT.Percentage, count(*)\nFROM VAT JOIN VATPercentages(20) p on VAT.ID = p.Id\nGROUP BY VAT.Percentage\n</code></pre>"},{"location":"lecture-notes/mssql/server-side-programming/#hibakezeles","title":"Hibakezel\u00e9s","text":"<p>A t\u00e1rolt elj\u00e1r\u00e1st ismertet\u0151 p\u00e9ld\u00e1ban meg akartuk akad\u00e1lyozni a duplik\u00e1lt rekord besz\u00far\u00e1s\u00e1t egy t\u00e1bl\u00e1ba. Ezt fentebb \u00fagy \u00e9rt\u00fck el, hogy nem hajtottuk v\u00e9gre az utas\u00edt\u00e1st. Azonban c\u00e9lszer\u0171bb lenne jelezni a hib\u00e1t a h\u00edv\u00f3 sz\u00e1m\u00e1ra. Erre szolg\u00e1l a struktur\u00e1lt hibajelz\u00e9s \u00e9s kezel\u00e9s. Hiba eset\u00e9n a <code>throw</code> paranccsal dobhatunk hib\u00e1t. Ezen parancs hat\u00e1s\u00e1ra a k\u00f3d v\u00e9grehajt\u00e1sa megszakad \u00e9s a h\u00edv\u00f3hoz visszaker\u00fcl a v\u00e9grehajt\u00e1s (ahol a hiba lekezelhet\u0151, avagy tov\u00e1bbdobhat\u00f3). A hib\u00e1nak van egy hibasz\u00e1ma (50000 \u00e9s 2147483647 k\u00f6z\u00f6tt), egy sz\u00f6vege, \u00e9s egy 0-255 k\u00f6z\u00f6tti hiba \u00e1llapot azonos\u00edt\u00f3.</p> <p>Ezzel kieg\u00e9sz\u00edtve az \u00c1FA kulcs r\u00f6gz\u00edt\u00e9se az \u00c1FA t\u00e1bl\u00e1ba t\u00e1rolt elj\u00e1r\u00e1sunk \u00edgy n\u00e9z ki:</p> <pre><code>create or alter procedure InsertNewVAT\n    @Percentage int\nas\nbegin\n\n  begin tran\n  set transaction isolation level repeatable read\n\n  declare @Count int\n\n  select @Count = count(*)\n  from VAT\n  where Percentage = @Percentage\n\n  if @Count = 0\n      insert into VAT values (@Percentage)\n  else\n      throw 51000, 'error', 1;\n\n  commit\nend\n</code></pre> <p>Hiba lekezel\u00e9se (elkap\u00e1s\u00e1ra) az al\u00e1bbi szintaktik\u00e1t haszn\u00e1lhatjuk:</p> <pre><code>begin try\n  exec InsertNewVAT 27\nend try\nbegin catch\n  -- az al\u00e1bbi f\u00fcggv\u00e9nyekkel hozz\u00e1f\u00e9r\u00fcnk a hiba r\u00e9szleteihez (hasonl\u00f3an, mint a stack trace m\u00e1s nyelvekben)\n  SELECT\n    ERROR_NUMBER() AS ErrorNumber,\n    ERROR_SEVERITY() AS ErrorSeverity,\n    ERROR_STATE() AS ErrorState,\n    ERROR_PROCEDURE() AS ErrorProcedure,\n    ERROR_LINE() AS ErrorLine,\n    ERROR_MESSAGE() AS ErrorMessage;\nend catch\n</code></pre> <p>Hib\u00e1t term\u00e9szetesen nem csak mi dobhatunk. A rendszer is anal\u00f3g m\u00f3don jelez hib\u00e1kat, amelyeket ugyanezen eszk\u00f6z\u00f6kkel kezelhet\u00fcnk.</p>"},{"location":"lecture-notes/mssql/server-side-programming/#trigger","title":"Trigger","text":"<p>Az eddig ismertetett eszk\u00f6z\u00f6k \u00e9s nyelvi elemek hasonl\u00f3k m\u00e1s platformokon el\u00e9rhet\u0151 lehet\u0151s\u00e9gekhez. A triggerek azonban speci\u00e1lis eszk\u00f6z\u00f6k, amelyekhez hasonl\u00f3t m\u00e1shol nem igen tal\u00e1lunk. A triggerek esem\u00e9nykezel\u0151 t\u00e1rolt elj\u00e1r\u00e1sok. Haszn\u00e1latukkal az adatb\u00e1zisban t\u00f6rt\u00e9n\u0151 k\u00fcl\u00f6nb\u00f6z\u0151 esem\u00e9nyekre tudunk feliratkozni \u00e9s az esem\u00e9ny bek\u00f6vetkeztekor a rendszer a triggerben megadott k\u00f3dunkat lefuttatja.</p> <p>Az al\u00e1bbiakban kifejezetten DML triggerekkel foglalkozunk. Ezek az adatm\u00f3dos\u00edt\u00e1s (<code>insert</code>, <code>update</code>, <code>delete</code>) m\u0171veletek hat\u00e1s\u00e1ra lefut\u00f3 triggerek. L\u00e9teznek m\u00e1s triggerek is, ak\u00e1r rendszeresem\u00e9nyekre is lehet triggert k\u00e9sz\u00edteni, ezekkel kapcsolatban l\u00e1sd a hivatalos dokument\u00e1ci\u00f3t.</p>"},{"location":"lecture-notes/mssql/server-side-programming/#dml-trigger","title":"DML trigger","text":"<p>Triggerek haszn\u00e1lat\u00e1val t\u00f6bb olyan feladatot is meg tudunk oldani, amely n\u00e9lk\u00fcl\u00fck neh\u00e9z lenne. Gondoljunk p\u00e9ld\u00e1ul egy audit napl\u00f3z\u00e1si feladatra: amikor egy adott t\u00e1bl\u00e1ban valamilyen m\u00f3dos\u00edt\u00e1s t\u00f6rt\u00e9nik, arr\u00f3l r\u00f6gz\u00edts\u00fcnk egy rekordot egy napl\u00f3 t\u00e1bl\u00e1ba. Ezt a feladatot C#/Java/Python k\u00f3dban is meg tudn\u00e1nk oldani, csakhogy az \u00e9rintett t\u00e1bla tartalomm\u00f3dos\u00edt\u00e1s\u00e1t \u00edgy becsomagol\u00f3 oszt\u00e1ly vagy k\u00f3dr\u00e9szlet megker\u00fclhet\u0151 - semmi nem akad\u00e1lyozza meg a programoz\u00f3t abban, hogy \"kiker\u00fclje\" az \u00edgy meg\u00edrt logik\u00e1t \u00e9s az adatb\u00e1zist direktben \u00e9rje el. Ezt megakad\u00e1lyozni triggerekkel se tudjuk, azonban k\u00e9sz\u00edthet\u00fcnk egy triggert, amely C#/Java/Python k\u00f3d helyett elv\u00e9gzi a sz\u00fcks\u00e9ges napl\u00f3z\u00e1st.</p> <p>N\u00e9zz\u00fck is ennek a p\u00e9ld\u00e1nak a k\u00f3dj\u00e1t. Napl\u00f3zzuk teh\u00e1t b\u00e1rmely term\u00e9kek t\u00f6rl\u00e9s\u00e9t egy napl\u00f3 t\u00e1bl\u00e1ba:</p> <pre><code>-- Napl\u00f3 t\u00e1bla l\u00e9trehoz\u00e1sa\ncreate table AuditLog([Description] [nvarchar](max) NULL)\ngo\n\n-- Napl\u00f3z\u00f3 trigger\ncreate or alter trigger ProductDeleteLog\n  on Product\n  for delete\nas\ninsert into AuditLog(Description)\nselect 'Product deleted: ' + convert(nvarchar, d.Name) from deleted d\n</code></pre> <p>A fenti parancsok lefuttat\u00e1s\u00e1nak hat\u00e1s\u00e1ra l\u00e9trej\u00f6n a trigger az adatb\u00e1zisban (mint ahogy egy t\u00e1rolt elj\u00e1r\u00e1s is l\u00e9trej\u00f6n), \u00e9s a rendszer ezt a triggert minden \u00e9rintett esem\u00e9nyn\u00e9l lefuttatja. Teh\u00e1t a triggert nem mi futtatjuk, hanem a rendszer. Ennek ellen\u00e9re adunk nevet a triggernek, hogy hivatkozhassunk r\u00e1 (pl., ha t\u00f6r\u00f6lni akarjuk a <code>DROP TRIGGER</code> utas\u00edt\u00e1ssal). A trigger az \u00e9rintett t\u00e1bl\u00e1hoz k\u00f6tve l\u00e1that\u00f3 az adatb\u00e1zisban:</p> <p></p> <p>Egy DML trigger defini\u00e1l\u00e1s\u00e1nak szintaktik\u00e1ja az al\u00e1bbi:</p> <pre><code>CREATE TRIGGER trigger_n\u00e9v\nON { t\u00e1bla | n\u00e9zet }\n FOR  { [ DELETE ] [ , ] [ INSERT ] [ , ] [ UPDATE ] }\nAS \nsql_utas\u00edt\u00e1s [ ...n ]\n</code></pre> <p>L\u00e1ssuk, hogy a trigger defini\u00e1l\u00e1sakor megadjuk a t\u00e1bl\u00e1t avagy n\u00e9zetet, amelyre a triggert defini\u00e1ljuk. Egy trigger teh\u00e1t egyetlen t\u00e1bla esem\u00e9nyeire figyel. Azt, hogy milyen esem\u00e9ny, azt pedig \u00fagy adjuk meg, hogy felsoroljuk a m\u00f3dos\u00edt\u00f3 esem\u00e9nyeket (pl. <code>for update, insert</code>). Vegy\u00fck \u00e9szre, hogy a h\u00e1rom lehet\u0151s\u00e9g mindenf\u00e9le m\u00f3dos\u00edt\u00e1st lefed, \u00e9s hogy <code>select</code> jelleg\u0171 esem\u00e9ny nincs - hiszen az nem m\u00f3dos\u00edt\u00e1s.</p> <p>A trigger k\u00f3dj\u00e1ban defini\u00e1lt utas\u00edt\u00e1sokat a rendszer az \u00e9rintett t\u00e1bla specifik\u00e1lt esem\u00e9nyei ut\u00e1n hajtja v\u00e9gre. Ez azt jelenti, hogy a m\u00f3dos\u00edt\u00e1sokat a rendszer elv\u00e9gezte (p\u00e9ld\u00e1ul besz\u00far\u00e1s eset\u00e9n m\u00e1r szerepelnek az \u00faj sorok a t\u00e1bl\u00e1ban), azonban m\u00e9g a tranzakci\u00f3t nem z\u00e1rta le. \u00cdgy teh\u00e1t lehet\u0151s\u00e9g\u00fcnk van tov\u00e1bbi m\u00f3dos\u00edt\u00e1sokat v\u00e9gezni a tranzakci\u00f3 r\u00e9szek\u00e9nt (\u00e9s \u00edgy egyben, atominak l\u00e1tva az \"eredeti\" utas\u00edt\u00e1s \u00e9s a trigger eredm\u00e9ny\u00e9t is), vagy ak\u00e1r megszak\u00edtani a tranzakci\u00f3t. A triggerek egy speci\u00e1lis haszn\u00e1lati esete a (m\u00e1shogy nem le\u00edrhat\u00f3) konzisztencia ellen\u0151rz\u00e9se \u00e9s hiba eset\u00e9n a m\u00f3dos\u00edt\u00e1s megszak\u00edt\u00e1sa. Hamarosan l\u00e1tunk erre is p\u00e9ld\u00e1t.</p> <p>A triggerek utas\u00edt\u00e1s szint\u0171ek, ami azt jelenti, hogy DML utas\u00edt\u00e1sonk\u00e9nt egyszer h\u00edv\u00f3dnak meg. A trigger nem egyetlen rekord v\u00e1ltoz\u00e1s\u00e1t kezeli le, hanem egyetlen utas\u00edt\u00e1s \u00f6sszes m\u00f3dos\u00edt\u00e1s\u00e1t. Teh\u00e1t ha p\u00e9ld\u00e1ul egy <code>update</code> utas\u00edt\u00e1s 15 sort m\u00f3dos\u00edt, akkor a trigger egyetlen alkalommal ker\u00fcl megh\u00edv\u00e1sra \u00e9s abban az egyetlen alkalomban mind a 15 m\u00f3dos\u00edt\u00e1st egyszerre l\u00e1tja. Ez term\u00e9szetesen igaz a besz\u00far\u00e1sra \u00e9s t\u00f6rl\u00e9sre is - egy t\u00f6rl\u00e9s m\u0171velet t\u00f6r\u00f6lhet egyszerre t\u00f6bb sort, \u00e9s besz\u00farni is lehet egyetlen utas\u00edt\u00e1ssal t\u00f6bb rekordot.</p> <p>Nincs sor szint\u0171 trigger</p> <p>M\u00e1s adatb\u00e1zis platformon l\u00e9tezik sor szint\u0171 trigger, ahol is a m\u00f3dos\u00edtott sorokra egyenk\u00e9nt h\u00edv\u00f3dik meg a trigger. Microsoft SQL Server platformon ilyen nem l\u00e9tezik!</p> <p>Honnan tudjuk meg a triggerben milyen m\u00f3dos\u00edt\u00e1s t\u00f6rt\u00e9nt? A trigger k\u00f3dj\u00e1ban hozz\u00e1f\u00e9r\u00fcnk k\u00e9t napl\u00f3 t\u00e1bl\u00e1hoz az <code>inserted</code> \u00e9s <code>deleted</code> implicit v\u00e1ltoz\u00f3kon kereszt\u00fcl. Ezen t\u00e1bl\u00e1k szerkezete megegyezik annak a t\u00e1bl\u00e1nak a szerkezet\u00e9vel, amelyre a triggert defini\u00e1ltuk. A t\u00e1bl\u00e1k csak a trigger lefut\u00e1sa alatt l\u00e9teznek \u00e9s csak a triggerb\u0151l \u00e9rhet\u0151ek el. A tartalmuk att\u00f3l f\u00fcgg, hogy milyen jelleg\u0171 utas\u00edt\u00e1s ind\u00edtotta a triggert:</p> insert delete update inserted \u00faj rekordok \u00fcres rekordok \u00faj \u00e9rt\u00e9kei deleted \u00fcres t\u00f6r\u00f6lt rekordok rekordok r\u00e9gi \u00e9rt\u00e9kei <p>Besz\u00far\u00e1s eset\u00e9n teh\u00e1t a besz\u00fart rekordok a t\u00e1bl\u00e1ban is megtal\u00e1lhat\u00f3ak (de ott nem \"l\u00e1tjuk\", hogy \u00fajonnan ker\u00fcltek besz\u00far\u00e1sra), \u00e9s emellett az <code>inserted</code> t\u00e1bl\u00e1ban \u00e9rhet\u0151ek el. T\u00f6rl\u00e9s eset\u00e9n anal\u00f3g m\u00f3don a <code>deleted</code> t\u00e1bl\u00e1ban van a t\u00f6rl\u00e9s el\u0151tti \u00e1llapotuk, de a t\u00e1bl\u00e1b\u00f3l m\u00e1r t\u00f6r\u00f6lve vannak. V\u00e9gezet\u00fcl <code>update</code> eset\u00e9n a m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9s ut\u00e1ni \u00e1llapotokat l\u00e1tjuk a k\u00e9t napl\u00f3t\u00e1bl\u00e1ban. Ezen napl\u00f3 t\u00e1bl\u00e1kkal t\u00e1bla m\u00f3dj\u00e1ra kell dolgozni, teh\u00e1t mindig arra kell sz\u00e1m\u00edtanunk, hogy t\u00f6bb rekord van benn\u00fck.</p> <p>Az <code>inserted</code> \u00e9s <code>deleted</code> t\u00e1bl\u00e1k</p> <p>Az <code>inserted</code> \u00e9s <code>deleted</code> t\u00e1bla, csak t\u00e1blak\u00e9nt kezelhetj\u00fck! Teh\u00e1t nem haszn\u00e1lhatjuk mondjuk \u00edgy: <code>select @id=inserted.ID</code>, viszont haszn\u00e1lhatjuk kurzorban vagy <code>join</code>-ban is ezen t\u00e1bl\u00e1kat.</p> <p>L\u00e1ttunk m\u00e1r egy p\u00e9ld\u00e1t triggerrel megval\u00f3s\u00edtott audit napl\u00f3z\u00e1sra. N\u00e9zz\u00fck m\u00e1s jelleg\u0171 felhaszn\u00e1l\u00e1s\u00e1t. Legyen adott egy t\u00e1bla egy email c\u00edm oszloppal. Ellen\u0151rizz\u00fck besz\u00far\u00e1sn\u00e1l \u00e9s m\u00f3dos\u00edt\u00e1sn\u00e1l az email c\u00edm \u00e9rt\u00e9ket \u00e9s ne engedj\u00fcnk biztosan nem email c\u00edmnek kin\u00e9z\u0151 sz\u00f6veget besz\u00farni. Itt teh\u00e1t m\u00e1shogy nem le\u00edrhat\u00f3 konzisztencia szab\u00e1lyt tartunk be a triggerrel.</p> <pre><code>-- Az email c\u00edm ellen\u0151rz\u00e9shez k\u00e9sz\u00edts\u00fcnk egy f\u00fcggv\u00e9nyt\nCREATE FUNCTION [IsEmailValid](@email nvarchar(1000))   \nRETURNS bit -- true/false visszat\u00e9r\u00e9si \u00e9rt\u00e9k\nAS\nBEGIN\n  IF @email is null RETURN 0 -- Nem lehet null\n  IF @email = '' RETURN 0 -- Nem lehet \u00fcres string\n  IF @email LIKE '%_@%_._%' RETURN 1 -- Kb. email kin\u00e9zete van\n  RETURN 0\n  -- Ugyanez r\u00f6videbben a CASE szerkezettel:\n  -- RETURN CASE WHEN ISNULL(@email, '') &lt;&gt; '' AND @email LIKE '%_@%_._%' THEN 1 ELSE 0 END\nEND\n\n-- Defini\u00e1ljuk a triggert\ncreate or alter trigger CustomerEmailSyntaxCheck\n  on Customer\n  for insert, update -- besz\u00far\u00e1s \u00e9s m\u00f3dos\u00edt\u00e1s is \u00e9rdekel\nas\n-- Mind a besz\u00far\u00e1s mind m\u00f3dos\u00edt\u00e1s eset\u00e9n az inserted t\u00e1bl\u00e1ban lesz az \u00faj adat\n-- L\u00e9tezik-e olyan elem ott, amire az \u00faj email c\u00edm nem \u00e9rv\u00e9nyes\nif exists(select 1 from inserted i where dbo.IsEmailValid(i.Email)=0)\n  throw 51234, 'invalid email address', 1 -- szak\u00edtsuk meg a tranzakci\u00f3t a hiba eldob\u00e1s\u00e1val\n</code></pre> <p>A fenti trigger ugyan a besz\u00far\u00e1s avagy m\u00f3dos\u00edt\u00e1s ut\u00e1n fut, de m\u00e9g ugyanabban a tranzakci\u00f3ban. Teh\u00e1t ha hib\u00e1t dobunk, akkor a tranzakci\u00f3 meg fog szakadni (hacsak nem kezeli le a h\u00edv\u00f3). Azzal, hogy a trigger utas\u00edt\u00e1s szinten fut, egyetlen hib\u00e1s sor is az eg\u00e9sz utas\u00edt\u00e1st szak\u00edtja meg - term\u00e9szetesen ezt v\u00e1rjuk az atomis\u00e1g miatt: az utas\u00edt\u00e1s eg\u00e9sz\u00e9re, azaz t\u00f6bb sor besz\u00far\u00e1s\u00e1ra/m\u00f3dos\u00edt\u00e1s\u00e1ra egyszerre teljes\u00fcl az oszthatatlans\u00e1g.</p> <p>Triggerek tov\u00e1bbi gyakori felhaszn\u00e1l\u00e1si esete a denormaliz\u00e1lt adat karbantart\u00e1sa. Ugyan egy rel\u00e1ci\u00f3s adatb\u00e1zisban igyeksz\u00fcnk elker\u00fclni a denormaliz\u00e1l\u00e1st, a gyakorlatban teljes\u00edtm\u00e9ny okokb\u00f3l lehet m\u00e9gis sz\u00fcks\u00e9g sz\u00e1m\u00edtott adat k\u00fcl\u00f6n elt\u00e1rol\u00e1s\u00e1ra. N\u00e9zz\u00fcnk egy p\u00e9ld\u00e1t erre is. Tegy\u00fck fel, hogy a vev\u0151knek k\u00e9t email c\u00edme is van: egy a bejelentkez\u00e9shez, \u00e9s megadhatnak egy m\u00e1sikat, amit az \u00e9rtes\u00edt\u00e9sekhez haszn\u00e1lni akarnak. Hogy ne kelljen mindig mindk\u00e9t email c\u00edmet minden alkalommal lek\u00e9rdezni, \u00e9s v\u00e1lasztani a kett\u0151 k\u00f6z\u00fcl, legyen el\u00e9rhet\u0151 adatb\u00e1zisban a val\u00f3ban haszn\u00e1lt email c\u00edm, amely az el\u0151z\u0151 kett\u0151b\u0151l \"sz\u00e1m\u00edthat\u00f3\":</p> <pre><code>-- Plusz email c\u00edm oszlopok a vev\u0151knek\nalter table Customer\nadd [NotificationEmail] nvarchar(max), [EffectiveEmail] nvarchar(max)\ngo\n\n-- Haszn\u00e1lt email c\u00edmet friss\u00edt\u0151 trigger\ncreate or alter trigger CustomerEmailUpdate\n  on Customer\n  for insert, update\nas\nupdate Customer -- A Customer t\u00e1bl\u00e1t m\u00f3dos\u00edtjuk, nem az inserted-et\nset EffectiveEmail = ISNULL(i.NotificationEmail, i.Email) -- Egyik vagy m\u00e1sik \u00e9rt\u00e9ket m\u00e1solja az EffectiveEmail oszlopba\nfrom Customer c join inserted i on c.ID = i.ID -- Az inserted-ek alapj\u00e1n kell a Customer-ben kikeresni a rekordokat\n</code></pre> <p>Trigger rekurzi\u00f3</p> <p>Vegy\u00fck \u00e9szre az el\u0151bbi triggerben, hogy a m\u00f3dos\u00edt\u00e1s reag\u00e1l\u00e1sak\u00e9nt egy \u00fajabb m\u00f3dos\u00edt\u00e1st hajtunk v\u00e9gre. Ez teh\u00e1t rekurzi\u00f3. A DML triggerek rekurzi\u00f3ja alapesetben ki van kapcsolva, \u00edgy a fenti p\u00e9lda nem v\u00e1lt ki rekurzi\u00f3t. Amennyiben viszont enged\u00e9lyezett az adatb\u00e1zisban a trigger rekurzi\u00f3, azt kezeln\u00fcnk is kell.</p> <p>N\u00e9zz\u00fcnk egy m\u00e1sik denormaliz\u00e1lt adat karbantart\u00e1s p\u00e9ld\u00e1t. A megrendel\u00e9s t\u00e1bl\u00e1ba vegy\u00fcnk fel egy v\u00e9g\u00f6sszeg oszlopot, amely a megrendel\u00e9s teljes nett\u00f3 \u00e1ra, \u00e9s ezt automatikusan tartsuk karban:</p> <pre><code>create or alter trigger OrderTotalUpdateTrigger\n  on OrderItem\n  for insert, update, delete\nas\n\nupdate Order\nset Total = isnull(Total,0) + TotalChange\nfrom Order inner join\n        (select i.OrderID, sum(Amount*Price) as TotalChange\n        from inserted i\n        group by i.OrderID) OrderChange\n    on Order.ID = OrderChange.OrderID\n\nupdate Order\nset Total = isnull(Total,0) \u2013 TotalChange\nfrom Order inner join\n        (select d.OrderID, sum(Amount*Price) as TotalChange\n        from deleted d\n        group by d.OrderID) OrderChange\n    on Order.ID = OrderChange.OrderID\n</code></pre> <p>Ebben a triggerben \u00e9rdemes \u00e9szrevenni, hogy m\u00edg az esem\u00e9ny az <code>OrderItem</code> t\u00e1bl\u00e1ban t\u00f6rt\u00e9nik, a friss\u00edtend\u0151 tartalom az <code>Order</code> t\u00e1bl\u00e1ban van. Ez abszol\u00fat m\u0171k\u00f6d\u0151k\u00e9pes, egy trigger az adatb\u00e1zis b\u00e1rmely r\u00e9sz\u00e9t olvashatja \u00e9s \u00edrhatja, \u00e9s tov\u00e1bbra is minden m\u00f3dos\u00edt\u00e1s ugyanabban a tranzakci\u00f3ban fut. Tov\u00e1bb\u00e1 \u00e9rdemes meg\u00e9rteni, hogy a triggerben nem \u00fajrasz\u00e1moljuk az \u00f6sszeget, hanem kijav\u00edtjuk azt a v\u00e1ltoz\u00e1sokkal. Ez term\u00e9szetesen komplexebb\u00e9 teszi a trigger k\u00f3dj\u00e1t, de \u00edgy lesz hat\u00e9kony.</p> <p>Triggerek sorrendje</p> <p>Egy esem\u00e9nyre t\u00f6bb trigger is defini\u00e1lhat\u00f3, melyek lefut\u00e1si sorrendje nem specifik\u00e1lt. Az els\u0151 \u00e9s utols\u00f3 triggert megadhatjuk, de m\u00e1s tekintetben nem \u00e9p\u00edthet\u00fcnk a sorrendre - \u00e9s alapvet\u0151en nem is javasolt \u00fagy dolgozni a triggerekkel, hogy azok egym\u00e1sra \u00e9p\u00edtsenek.</p>"},{"location":"lecture-notes/mssql/server-side-programming/#instead-of-trigger","title":"Instead of trigger","text":"<p>A triggerek egy speci\u00e1lis fajt\u00e1ja az \u00fan. instead of trigger. Ilyen triggert t\u00e1bl\u00e1ra \u00e9s n\u00e9zetre is defini\u00e1lhatunk. N\u00e9zz\u00fck el\u0151bb a t\u00e1bla eset\u00e9t. T\u00e1bl\u00e1ra defini\u00e1lt instead of trigger, ahogy a neve sugallja, a v\u00e9grehajtand\u00f3 utas\u00edt\u00e1s (<code>insert/update/delete</code>) helyett fut le. Teh\u00e1t ilyenkor besz\u00far\u00e1s eset\u00e9n az \u00faj sorok nem ker\u00fcltek be a t\u00e1bl\u00e1ba, t\u00f6rl\u00e9sn\u00e9l nem ker\u00fcltek t\u00f6rl\u00e9sre, m\u00f3dos\u00edt\u00e1sn\u00e1l nem ker\u00fcltek m\u00f3dos\u00edt\u00e1sra. Helyette a triggerben tudjuk defini\u00e1lni, hogyan kell a m\u0171veletet v\u00e9grehajtani. Az \u00edgy fel\u00fcldefini\u00e1lt m\u0171k\u00f6d\u00e9sben hivatkozhatunk a t\u00e1bl\u00e1ra mag\u00e1ra \u00e9s v\u00e9grehajthatjuk a sz\u00fcks\u00e9ges utas\u00edt\u00e1st a t\u00e1bl\u00e1n, amely ebben az esetben nem okoz rekurzi\u00f3t. Ezen triggerek \u00e9rtelmezhet\u0151ek val\u00f3j\u00e1ban utas\u00edt\u00e1s el\u0151tti triggerk\u00e9nt, mivel a m\u00f3dos\u00edt\u00e1sok el\u0151tt v\u00e9gezhet\u00fcnk ellen\u0151rz\u00e9seket \u00e9s szak\u00edthatjuk meg a m\u0171veletet hiba eset\u00e9n.</p> <p>Tipikus felhaszn\u00e1l\u00e1si esete az instead of triggernek az ellen\u0151rz\u00e9si feladatokon t\u00fal p\u00e9ld\u00e1ul, ha egy t\u00f6rl\u00e9st val\u00f3j\u00e1ban nem akarunk v\u00e9grehajtani. Ezt szok\u00e1s soft delete-nek h\u00edvni, amikor t\u00f6rl\u00e9s helyett csak t\u00f6r\u00f6ltnek jel\u00f6lj\u00fck a rekordokat:</p> <pre><code>-- Soft delete flag oszlop a t\u00e1bl\u00e1ba 0 (azaz false) alap\u00e9rtelmezett \u00e9rt\u00e9kkel\nalter table Product\nadd [IsDeleted] bit NOT NULL CONSTRAINT DF_Product_IsDeleted DEFAULT 0\ngo\n\n-- Instead of trigger, azaz delete utas\u00edt\u00e1s hat\u00e1s\u00e1ra a t\u00f6rl\u00e9s nem hajt\u00f3dik v\u00e9gre\n-- helyette az al\u00e1bbi k\u00f3d fut le\ncreate or alter trigger ProductSoftDelete\n  on Product\n  instead of delete\nas\nupdate Product\n  set IsDeleted=1\n  where ID in (select ID from deleted)\n</code></pre> <p>Az instead of triggerek m\u00e1sik tipikus felhaszn\u00e1l\u00e1si esete a n\u00e9zetek. Egy n\u00e9zet egy lek\u00e9rdez\u00e9s eredm\u00e9nye, teh\u00e1t nem \u00e9rtelmezhet\u0151 az a m\u0171velet, hogy \u00faj adatot sz\u00farunk be a n\u00e9zetbe. Viszont egy instead of triggerrel defini\u00e1lhatjuk, mit kell a \"n\u00e9zetbe besz\u00far\u00e1s\" helyett v\u00e9grehajtani. N\u00e9zz\u00fcnk erre egy p\u00e9ld\u00e1t. A n\u00e9zetben a term\u00e9k \u00e9s \u00e1fa t\u00e1bl\u00e1kb\u00f3l kapcsoljuk \u00f6ssze az adatokat \u00fagy, hogy ne a hivatkozott \u00e1fa rekord azonos\u00edt\u00f3ja, hanem az \u00e1fa sz\u00e1zal\u00e9ka jelenjen meg a n\u00e9zetben. Ebbe a n\u00e9zetbe \u00fagy tudunk besz\u00farni, ha a m\u00f6g\u00f6tte lev\u0151 term\u00e9keket t\u00e1rol\u00f3 t\u00e1bl\u00e1ba sz\u00farunk be:</p> <pre><code>-- N\u00e9zet defini\u00e1l\u00e1sa\ncreate view ProductWithVatPercentage\nas\nselect p.Id, p.Name, p.Price, p.Stock, v.Percentage\nfrom Product p join Vat v on p.VATID=v.Id\n\n-- Instead of trigger a n\u00e9zetre a besz\u00far\u00e1s helyett\ncreate or alter trigger ProductWithVatPercentageInsert\non ProductWithVatPercentage\ninstead of insert\nas\n  -- A besz\u00far\u00e1s a Product t\u00e1bl\u00e1ba ker\u00fcl, minden inserted rekordnak egy \u00faj sora keletkezik\n  -- \u00c9s k\u00f6zben kikeress\u00fck a sz\u00e1zal\u00e9knak megfelel\u0151 \u00e1fa rekordot\n  -- A megold\u00e1s nem teljes, mert nem kezeli, ha nincs m\u00e9g ilyen \u00e1fa rekord\n  insert into Product(Name, Price, Stock, VATID, CategoryID)\n  select i.Name, i.Price, i.Stock, v.ID, 1\n    from inserted i join Vat v on v.Percentage = i.Percentage\n\n-- A trigger kipr\u00f3b\u00e1lhat\u00f3 a n\u00e9zetbe val\u00f3 besz\u00far\u00e1ssal\ninsert into ProductWithVatPercentage(Name, Price, Stock, Percentage)\nvalues ('Red ball', 1234, 22, 27)\n</code></pre>"},{"location":"lecture-notes/mssql/sql/","title":"SQL nyelv, MSSQL platformf\u00fcgg\u0151 SQL utas\u00edt\u00e1sok","text":"<p>A p\u00e9ld\u00e1k a minta adatb\u00e1zison futtathat\u00f3ak.</p>"},{"location":"lecture-notes/mssql/sql/#egyszeru-lekerdezesek","title":"Egyszer\u0171 lek\u00e9rdez\u00e9sek","text":"<p>Melyik term\u00e9k olcs\u00f3bb mint 2000 \u00e9s kevesebb, mint 50 db van bel\u0151le?</p> <pre><code>select Name, Price, Stock\nfrom Product\nwhere Price&lt;2000 and Stock&lt;50\n</code></pre> <p>Melyik term\u00e9khez nincs le\u00edr\u00e1s?</p> <pre><code>select *\nfrom Product\nwhere Description is null\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#tablak-osszekapcsolasa","title":"T\u00e1bl\u00e1k \u00f6sszekapcsol\u00e1sa","text":"<p>Budapesti k\u00f6zponti telephellyel rendelkez\u0151 vev\u0151k (a k\u00e9t megold\u00e1s ekvivalens)</p> <pre><code>select *\nfrom Customer c, CustomerSite s\nwhere c.MainCustomerSiteID=s.ID and City='Budapest'\n\nselect *\nfrom Customer c inner join CustomerSite s on c.MainCustomerSiteID=s.ID\nwhere City='Budapest'\n</code></pre> <p>List\u00e1zza ki az M bet\u0171vel kezd\u0151d\u0151 term\u00e9kek nev\u00e9t \u00e9s a megrendelt mennyis\u00e9geket \u00fagy, hogy azok a term\u00e9kek is benne legyenek a list\u00e1ban melyekb\u0151l nem rendeltek meg semmit</p> <pre><code>select p.Name, Sum(oi.Amount)\nfrom Product p\n     left outer join OrderItem oi on p.id=oi.ProductID\nwhere p.Name like 'M%'\ngroup by p.Name\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#rendezes","title":"Rendez\u00e9s","text":"<pre><code>select *\nfrom Product\norder by Name\n</code></pre> <p>Microsoft SQL Server specifikus: collation a rendez\u00e9s szab\u00e1lyait adja meg</p> <pre><code>select *\nfrom Product\norder by Name collate SQL_Latin1_General_Cp1_CI_AI\n</code></pre> <p>T\u00f6bb mez\u0151 szerinti rendez\u00e9s</p> <pre><code>select *\nfrom Product\norder by Stock desc, Price\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#allekerdezesek","title":"Allek\u00e9rdez\u00e9sek","text":"<p>List\u00e1zzuk ki a megrendel\u00e9sek d\u00e1tum\u00e1t, hat\u00e1ridej\u00e9t \u00e9s Status-\u00e1t</p> <pre><code>select o.Date, o.Deadline, s.Name\nfrom [Order] o inner join Status s on o.StatusId=s.ID\n</code></pre> <p>Alternat\u00edv, de nem ekvivalens megold\u00e1s: az allek\u00e9rdez\u00e9s az outer joinnak felel meg!</p> <pre><code>select o.Date, o.Deadline,\n       (select s.Name\n        from Status s\n        where o.StatusId=s.ID)\nfrom [Order] o\n</code></pre> <p><code>[Order]</code></p> <p>Az <code>[Order]</code> az\u00e9rt szerepel sz\u00f6gletes z\u00e1r\u00f3jelben, mert \u00edgy jel\u00f6lj\u00fck, hogy ez egy t\u00e1bla neve, \u00e9s nem az <code>order by</code> parancs kezdete.</p>"},{"location":"lecture-notes/mssql/sql/#duplikatum-szurese","title":"Duplik\u00e1tum sz\u0171r\u00e9se","text":"<p>Melyek azok a term\u00e9kek, melyb\u0151l egyszerre t\u00f6bb, mint 3 db-ot rendeltek? Ugyanabb\u00f3l a term\u00e9kb\u0151l t\u00f6bb alkalommal is el\u0151fordulhatott, de csak egyszer szeretn\u00e9nk a nev\u00e9t l\u00e1tni.</p> <pre><code>select distinct p.Name\nfrom Product p inner join OrderItem oi on oi.ProductID=p.ID\nwhere oi.Amount&gt;3\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#oszlopfuggvenyek","title":"Oszlopf\u00fcggv\u00e9nyek","text":"<p>Mennyibe ker\u00fcl a legdr\u00e1g\u00e1bb term\u00e9k?</p> <pre><code>select max(Price)\nfrom Product\n</code></pre> <p>Melyek a legdr\u00e1g\u00e1bb term\u00e9kek?</p> <pre><code>select *\nfrom Product\nwhere Price=(select max(Price) from Product)\n</code></pre> <p>Azon term\u00e9keket min, max \u00e9s \u00e1tlag mennyi\u00e9rt adt\u00e1k el, melyek nev\u00e9ben szerepel a Lego \u00e9s az \u00e1tlag elad\u00e1si \u00e1ruk 10.000-n\u00e9l nagyobb</p> <pre><code>select p.Id, p.Name, min(oi.Price), max(oi.Price), avg(oi.Price)\nfrom Product p\n     inner join OrderItem oi on p.ID=oi.ProductID\nWhere p.Name like '%Lego%'\ngroup by p.Id, p.Name\nhaving avg(oi.Price)&gt;10000\norder by 2\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#rekordok-letrehozasa","title":"Rekordok l\u00e9trehoz\u00e1sa","text":"<p>Egy rekord l\u00e9trehoz\u00e1sa minden oszlop (kiv\u00e9ve identity) adat\u00e1nak megad\u00e1s\u00e1val</p> <pre><code>insert into Product\nvalues ('aa', 100, 0, 3, 2, null)\n</code></pre> <p>Csak megnevezett oszlopok \u00e9rt\u00e9keinek kit\u00f6lt\u00e9se</p> <pre><code>insert into Product (Name,Price)\nvalues ('aa', 100)\n</code></pre> <p>Lek\u00e9rdez\u00e9s eredm\u00e9nyeinek besz\u00far\u00e1sa</p> <pre><code>insert into Product (Name, Price)\nselect Name, Price\nfrom InvoiceItem\nwhere Amount&gt;2\n</code></pre> <p>MSSQL specifikus: identity oszlop</p> <pre><code>create table VAT\n(\n   ID int identity primary key,\n   Percentage int\n)\n\ninsert into VAT(Percentage)\nvalues (27)\n\nselect @@identity\n</code></pre> <p>MSSQL specifikus: \u00e9rt\u00e9kad\u00e1s identity oszlopnak</p> <pre><code>set identity_insert VAT on\n\ninsert into VAT (ID, Percentage)\nvalues (123, 27)\n\nset identity_insert VAT off\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#rekordok-modositasa","title":"Rekordok m\u00f3dos\u00edt\u00e1sa","text":"<p>A Leg\u00f3k \u00e1r\u00e1t emelj\u00fck meg 10%-kal \u00e9s a rakt\u00e1rk\u00e9szlet\u00fcnket 5 db-bal</p> <pre><code>update Product\nset Price=1.1*Price,\n    Stock=Stock+5\nwhere Name like '%Lego%'\n</code></pre> <p>M\u00f3dos\u00edt\u00e1s, ha kapcsol\u00f3d\u00f3 t\u00e1bla alapj\u00e1n kell sz\u0171rni: emelj\u00fck meg 10%-kal azon 20%-os \u00c1FA kulcs\u00fa term\u00e9kek \u00e1r\u00e1t, melyb\u0151l, t\u00f6bb mint 10 db van rakt\u00e1ron</p> <pre><code>update Product\nset Price=1.1*Price\nwhere Stock&gt;10\nand VATID in\n(\n    select ID\n    from VAT\n    where Percentage=20\n)\n</code></pre> <p>MSSQL Server specifikus szintaktika az el\u0151z\u0151re</p> <pre><code>update Product\nset Price=1.1*Price\nfrom Product p\n     inner join VAT v on p.VATID=v.ID\nwhere Stock&gt;10\n      and Percentage=20\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#rekordok-torlese","title":"Rekordok t\u00f6rl\u00e9se","text":"<pre><code>delete\nfrom Product\nwhere ID&gt;10\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#sorszamozas","title":"Sorsz\u00e1moz\u00e1s","text":"<p>Sorsz\u00e1moz\u00e1s egy adott rendez\u00e9s szerint</p> <pre><code>select p.*,\n       rank() over (order by Name) as r,\n       dense_rank() over (order by Name) as dr\nfrom Product p\n</code></pre> <p>Sorsz\u00e1moz\u00e1s csoportos\u00edt\u00e1sonk\u00e9nt</p> <pre><code>select p.*\n       ,rank() over (partition by CategoryID order by Name) as r\n       ,dense_rank() over (partition by CategoryID order by Name) as dr\nfrom Product p\n</code></pre> <p>Rank \u00e9s dense_rank</p> <p>A dense_rank-t\u00f3l elt\u00e9r\u0151en a rank kihagy sorsz\u00e1mokat az egyenl\u0151 helyez\u00e9s ut\u00e1n. Az \u00e1tugrott sorsz\u00e1mok sz\u00e1ma att\u00f3l f\u00fcgg, hogy h\u00e1ny sor kapott azonos rangot. P\u00e9ld\u00e1ul Mary \u00e9s Lisa ugyanannyi term\u00e9ket adott el, \u00edgy mindkett\u0151 sorsz\u00e1ma 1. A rank-kal a k\u00f6vetkez\u0151 sorsz\u00e1m a 3, m\u00edg dense_rank eset\u00e9n a k\u00f6vetkez\u0151 sorsz\u00e1m a 2.</p>"},{"location":"lecture-notes/mssql/sql/#cte-common-table-expression","title":"CTE (Common Table Expression)","text":"<p>Motiv\u00e1ci\u00f3: allek\u00e9rdez\u00e9ssel nehezen \u00e1ttekinthet\u0151v\u00e9 v\u00e1lnak a lek\u00e9rdez\u00e9sek</p> <p>ABC sorrendben melyik az els\u0151 h\u00e1rom term\u00e9k</p> <pre><code>select *\nfrom\n(\n    select p.*\n            ,rank() over (order by Name) as r\n            ,dense_rank() over (order by Name) as dr\n    from Product p\n) a\nwhere a.dr&lt;=3\n</code></pre> <p>Ugyan az a lek\u00e9rdez\u00e9s CTE haszn\u00e1lat\u00e1val</p> <pre><code>with q1\nas\n(\n    select *\n            ,rank() over (order by Name) as r\n            ,dense_rank() over (order by Name) as dr\n    from Product\n)\nselect *\nfrom q1\nwhere q1.dr&lt;=3\n</code></pre> <p>H\u00e1ny darabot adtak el a m\u00e1sodik legdr\u00e1g\u00e1bb term\u00e9kb\u0151l?</p> <pre><code>with q\nas\n(\n    select *\n            , dense_rank() over (order by Price desc) as dr\n    from Product\n)\nselect q.ID, q.Name, sum(Amount)\nfrom q\n     inner join OrderItem oi on oi.ProductID=q.ID\nwhere q.dr = 2\ngroup by q.ID, q.Name\n</code></pre> <p>Lapoz\u00e1s: term\u00e9kek list\u00e1z\u00e1sa ABC sorrendben a 3. rekord\u00f3l a 8. rekordig</p> <pre><code>with q\nas\n(\n    select *\n            , rank() over (order by Name) as r\n    from Product\n)\nselect *\nfrom q\nwhere q.r between 3 and 8\n</code></pre> <p>Lapoz\u00e1s: MSSQL Server (2012+) specifikus megold\u00e1s</p> <pre><code>select *\nfrom Product\norder by Name\noffset 2 rows\nfetch next 6 rows only\n\nselect top 3 *\nfrom Product\norder by Name\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#xml-dokumentumok-lekerdezese","title":"XML dokumentumok lek\u00e9rdez\u00e9se","text":"<p>Egy rel\u00e1ci\u00f3s adatb\u00e1zisban a rel\u00e1ci\u00f3s adatok mellett f\u00e9lig struktur\u00e1lt adatokat (pl.: XML) is elt\u00e1rolhatunk, viszont a rel\u00e1ci\u00f3s a f\u0151 tartalom. A minta adatb\u00e1zisban a <code>Product</code> t\u00e1bla <code>Description</code> mez\u0151je XML form\u00e1tum\u00fa.</p>"},{"location":"lecture-notes/mssql/sql/#xpath","title":"XPath","text":"<p>Egy XML dokumentum fa strukt\u00far\u00e1j\u00fa. Az XPath nyelv seg\u00edts\u00e9g\u00e9vel navig\u00e1lhatunk a f\u00e1ban \u00e9s kiv\u00e1laszthatunk csom\u00f3pontokat megadott sz\u0171r\u00e9si szempontok alapj\u00e1n. Az al\u00e1bbi t\u00e1bl\u00e1zat szeml\u00e9lteti az XPath nyelv m\u0171k\u00f6d\u00e9s\u00e9t \u00e9s k\u00e9pess\u00e9geit</p> XPath kifejez\u00e9s Jelent\u00e9s tagn\u00e9v Csom\u00f3pont n\u00e9vvel megadva / A gy\u00f6k\u00e9rt\u0151l kezd\u0151dik a keres\u00e9s // Aktu\u00e1lis csom\u00f3pontt\u00f3l kezdve b\u00e1rmely lesz\u00e1rmazottban . Aktu\u00e1lis csom\u00f3pont .. Sz\u00fcl\u0151 csom\u00f3pont @nev Adott nev\u0171 attrib\u00fatum /konyvtar/konyv[k] A k. konyv gyerek a konyvtar elemen bel\u00fcl (1-t\u0151l kezd\u0151dik az indexel\u00e9s) /konyvtar/konyv[last()] Utols\u00f3 gyerek /konyvtar/konyv[position()&lt;k] Az els\u0151 k-1 gyerek //cim[@nyelv=\"hu\"] Azok a cim elemek, amelyeknek van \"hu\" \u00e9rt\u00e9k\u0171 nyelv attrib\u00fatuma //cim[text()] A cim elemek sz\u00f6vege (a tag-ek k\u00f6z\u00f6tti r\u00e9sz) /konyvtar/konyv[ar&gt;5000] Azok a konyvtar elemek bel\u00fcli konyv elemek, amelyeknek az ar gyereke legal\u00e1bb 5000 <p>XQuery \u00e9s XPath</p> <p>Az XPath a fentiek mellett m\u00e9g sok m\u00e1s k\u00e9pess\u00e9ggel is rendelkezik, sokkal bonyolultabb lek\u00e9rdez\u00e9sekre is k\u00e9pes.</p> <p>A tov\u00e1bbi p\u00e9ld\u00e1kban XQuery nyelvet haszn\u00e1lva fogjuk megadni a lek\u00e9rdezend\u0151 adatokat. Az XQuery az XPath-re \u00e9p\u00fcl \u00e9s eg\u00e9sz\u00edti ki azt tov\u00e1bbi funkci\u00f3kkal. Mind az XPath, mind az XQuery platformf\u00fcggetlen, W3C standardokra \u00e9p\u00fcl\u0151 nyelv.</p>"},{"location":"lecture-notes/mssql/sql/#lekerdezesek","title":"Lek\u00e9rdez\u00e9sek","text":"<p>Adott teh\u00e1t egy olyan t\u00e1bla, amiben van egy XML t\u00edpus\u00fa mez\u0151. Amellett, hogy a mez\u0151 teljes \u00e9rt\u00e9k\u00e9t lek\u00e9rdezhetj\u00fck, a tartalm\u00e1ra is k\u00e9pesek vagyunk lek\u00e9rdez\u00e9seket megfogalmazni. Az XML dokumentumokban val\u00f3 lek\u00e9rdez\u00e9shez az XML adatt\u00edpuson defini\u00e1lt <code>query(XQuery)</code>, <code>value(XQuery, SQLType)</code> \u00e9s <code>exist(XQuery)</code> T-SQL f\u00fcggv\u00e9nyt haszn\u00e1lhatjuk. N\u00e9zz\u00fcnk ezekre p\u00e1r p\u00e9ld\u00e1t.</p> <p>K\u00e9rdezz\u00fck le, hogy h\u00e1ny csomagb\u00f3l \u00e1llnak a term\u00e9kek!</p> <pre><code>select Description.query('/product/package_parameters/number_of_packages')\nfrom Product\n</code></pre> <p>Ennek az eredm\u00e9nye p\u00e9ld\u00e1ul a k\u00f6vetkez\u0151 lehet:</p> <pre><code>&lt;number_of_packages&gt;1&lt;/number_of_packages&gt;\n</code></pre> <p>A <code>query()</code> XML-lel t\u00e9r vissza, ha csak az \u00e9rt\u00e9kre van sz\u00fcks\u00e9g, akkor a <code>value()</code> met\u00f3dust haszn\u00e1lhatjuk. A <code>value()</code> met\u00f3dusnak meg kell adni a lek\u00e9rdezett adat t\u00edpus\u00e1t is string liter\u00e1lk\u00e9nt.</p> <pre><code>select Description.value('(/product/package_parameters/number_of_packages)[1]', 'int')\nfrom Product\n</code></pre> <p>Ennek az eredm\u00e9nye m\u00e1r az 1 lesz sz\u00e1mk\u00e9nt.</p> <p>SQLType</p> <p>A param\u00e9terk\u00e9nt \u00e1tadott t\u00edpus nem lehet xml. A megadott t\u00edpusra val\u00f3 konvert\u00e1l\u00e1s T-SQL <code>CONVERT</code> f\u00fcggv\u00e9nnyel t\u00f6rt\u00e9nik.</p> <p>K\u00e9rdezz\u00fck le azoknak a term\u00e9keknek a nev\u00e9t, amelyek a 0-18 h\u00f3napos koroszt\u00e1lynak aj\u00e1nlottak.</p> <pre><code>select Name\nfrom Product\nwhere Description.exist('(/product)[(./recommended_age)[1] eq \"0-18 m\"]')=1\n</code></pre> <p>Az <code>exist()</code> 1-gyel t\u00e9r vissza, ha a megadott XQuery kifejez\u00e9ssel futtatott lek\u00e9rdez\u00e9s nem \u00fcres eredm\u00e9nnyel t\u00e9r vissza; vagy 0-val, amennyiben a lek\u00e9rdez\u00e9s eredm\u00e9nye \u00fcres.</p> <p>A lek\u00e9rdez\u00e9st <code>exist()</code> helyett <code>value()</code> met\u00f3dus seg\u00edts\u00e9g\u00e9vel is megfogalmazhatjuk.</p> <pre><code>select Name\nfrom Product\nwhere Description.value('(/product/recommended_age)[1]', 'varchar(max)')='0-18 m'\n</code></pre>"},{"location":"lecture-notes/mssql/sql/#manipulalo-lekerdezesek","title":"Manipul\u00e1l\u00f3 lek\u00e9rdez\u00e9sek","text":"<p>Nem csak lek\u00e9rdezni tudunk XML adatokat, hanem m\u00f3dos\u00edtani is. A m\u00f3dos\u00edt\u00e1s az adatb\u00e1zisban atomi m\u00f3don t\u00f6rt\u00e9nik, azaz nem kell kliens oldalra let\u00f6lteni az XML-t, m\u00f3dos\u00edtani, majd visszat\u00f6lteni. Helyette a szerveroldali programoz\u00e1s filoz\u00f3fi\u00e1j\u00e1t k\u00f6vetve a logik\u00e1t (itt: m\u00f3dos\u00edt\u00e1s) vissz\u00fck az adatb\u00e1zisba. Az adatm\u00f3dos\u00edt\u00f3 lek\u00e9rdez\u00e9seket a <code>modify(XML_DML)</code> f\u00fcggv\u00e9nnyel hajthatjuk v\u00e9gre, ahol is az \u00fan. XML DML nyelven kell megfogalmaznunk a m\u00f3dos\u00edt\u00e1sunkat. N\u00e9zz\u00fcnk erre is p\u00e1r p\u00e9ld\u00e1t.</p> <p>Az Lego City harbour nev\u0171 term\u00e9kn\u00e9l az aj\u00e1nlott \u00e9letkort \u00edrjuk \u00e1t 6-99 \u00e9vre.</p> <pre><code>update Product\nset Description.modify(\n'replace value of (/product/recommended_age/text())[1]\nwith \"6-99 y\"')\nwhere Name='Lego City harbour'\n</code></pre> <p>A megadand\u00f3 kifejez\u00e9s k\u00e9t r\u00e9szb\u0151l \u00e1ll: az els\u0151ben (<code>replace value of</code>) kell a m\u00f3dos\u00edtani k\u00edv\u00e1nt elemet kell kiv\u00e1lasztani, a m\u00e1sodikban (<code>with</code>) az \u00faj \u00e9rt\u00e9ket kell megadni. Egy XML-en bel\u00fcl csak egy elem m\u00f3dos\u00edthat\u00f3, \u00edgy az \u00fatvonalat \u00fagy kell megadni, hogy csak egy elemre illeszkedjen - ez\u00e9rt szerepel p\u00e9ld\u00e1ban a v\u00e9g\u00e9n az <code>[1]</code>.</p> <p>Sz\u00farjunk be a Lego City harbour term\u00e9khez a <code>package_size</code> tag ut\u00e1n egy <code>weight</code> tag-et a s\u00faly megad\u00e1s\u00e1ra.</p> <pre><code>update Product\nset Description.modify(\n'insert &lt;weight&gt;2.28&lt;/weight&gt;\nafter (/product/package_parameters/package_size)[1]')\nwhere Name='Lego City harbour'\n</code></pre> <p>A megadand\u00f3 kifejez\u00e9s itt is k\u00e9t r\u00e9szb\u0151l \u00e1ll: az els\u0151ben (<code>insert</code>) kell megadni az \u00faj elemet, m\u00e1sodikban kell le\u00edrni azt, hogy hova sz\u00farja be az \u00faj elemet. Az \u00faj elemet fel lehet venni a megadott elem testv\u00e9rek\u00e9nt vagy gyerekek\u00e9nt.</p> <p>T\u00f6r\u00f6lj\u00fck minden term\u00e9k le\u00edr\u00e1s\u00e1b\u00f3l a <code>description</code> tag(ek)-et.</p> <pre><code>update Product\nset Description.modify('delete /product/description')\nwhere Description is not null\n</code></pre> <p>A t\u00f6rl\u00e9sn\u00e9l a <code>delete</code> ut\u00e1n meg kell adni a t\u00f6rlend\u0151 elemek \u00fatvonal\u00e1t.</p>"},{"location":"lecture-notes/openapi/","title":"OpenAPI 3 \u00e9s a Swagger","text":"<p>A REST API-r\u00f3l tudjuk, hogy nem szabv\u00e1ny, hanem \"architektur\u00e1lis st\u00edlus\". Azaz nem szigor\u00fa szab\u00e1lyokat k\u00f6vet, hanem ir\u00e1nyelveket \u00e9s szok\u00e1sokat. Felmer\u00fcl a k\u00e9rd\u00e9s, hogy amennyiben egy REST API-t integr\u00e1ci\u00f3s eszk\u00f6znek k\u00edv\u00e1nunk haszn\u00e1lni, hogyan tudjuk min\u00e9l szabv\u00e1nyosabb m\u00f3don dokument\u00e1lni? Web Service-ek eset\u00e9n a SOAP szabv\u00e1ny, WSDL, DTD \u00e9s XSD le\u00edr\u00f3k val\u00f3k erre a c\u00e9lra. Egy REST API-n\u00e1l pedig az OpenAPI.</p>"},{"location":"lecture-notes/openapi/#openapi-30","title":"OpenAPI 3.0","text":"<p>Az OpenAPI teh\u00e1t egy API le\u00edr\u00f3, amely egy REST API-t publik\u00e1l\u00f3 webalkalmaz\u00e1sban egy f\u00e1jlk\u00e9nt \u00e9rhet\u0151 el a webszerverr\u0151l. Ez a specifik\u00e1ci\u00f3 tartalmazza az API m\u0171veleteit, adatt\u00edpusait, dokument\u00e1ci\u00f3j\u00e1t. N\u00e9zz\u00fck a tartalm\u00e1t.</p> <p>OpenAPI specifik\u00e1ci\u00f3t a legritk\u00e1bb esetben \u00edrunk k\u00e9zzel, helyette gener\u00e1ljuk a REST API-t megval\u00f3s\u00edt\u00f3 rendszerben technol\u00f3giaspecifikus eszk\u00f6z\u00f6kkel. Az al\u00e1bbiakban a p\u00e9ld\u00e1k teh\u00e1t csak szeml\u00e9ltetik, hogyan n\u00e9z ki egy OpenAPI specifik\u00e1ci\u00f3 \u00e9s milyen koncepci\u00f3kkal dolgozhatunk.</p>"},{"location":"lecture-notes/openapi/#meta-informaciok","title":"Meta inform\u00e1ci\u00f3k","text":"<p>A metainform\u00e1ci\u00f3k szakaszban adhatunk meg inform\u00e1ci\u00f3kat az API-r\u00f3l \u00e1ltal\u00e1nosan. Ebben a szakaszban olyan inform\u00e1ci\u00f3kat lehet megadni, mint p\u00e9ld\u00e1ul, hogy mit csin\u00e1l az API, mi az API alap URL c\u00edme, milyen webes protokollt k\u00f6vet, \u00e9s milyen autentik\u00e1ci\u00f3s megold\u00e1sokat t\u00e1mogat.</p> <pre><code>openapi: 3.0.0\ninfo:\n  version: 1.0.0\n  title: Simple Artist API\n  description: A simple API to illustrate OpenAPI concepts\n\nservers:\n  - url: https://example.io/v1\n\n# Basic authentication\ncomponents:\n  securitySchemes:\n    BasicAuth:\n      type: http\n      scheme: basic\nsecurity:\n  - BasicAuth: []\n\npaths: {}\n...\n</code></pre>"},{"location":"lecture-notes/openapi/#api-vegpontok","title":"API v\u00e9gpontok","text":"<p>Az \u00e1ltalunk k\u00e9sz\u00edtett API v\u00e9gpontjait adjuk meg a <code>paths</code> alatt. Az alap URL-hez k\u00e9pes relat\u00edv el\u00e9r\u00e9si \u00faton \u00e9rhetj\u00fck el \u0151ket, jelen esetben <code>/artist</code> \u00fatvonalon. Specifik\u00e1lhatunk benn\u00fck HTTP ig\u00e9ket, melyeket a v\u00e9gpontok haszn\u00e1lnak, ilyen p\u00e9ld\u00e1ul a <code>get</code>.</p> <pre><code>...\npaths:\n  /artists:\n    get:\n     description: Returns a list of artists \n...\n</code></pre> <p>Ha ASP.NET controllert k\u00e9pzel\u00fcnk a v\u00e9gpont m\u00f6g\u00e9, akkor a controller met\u00f3dus valahogy \u00edgy n\u00e9z ki:</p> <pre><code>[HttpGet(\"artists\")]\npublic IEnumerable&lt;Artist&gt; GetAll(){\n    return artistRepository.List();\n}\n</code></pre> <p>A v\u00e9gpontokban defini\u00e1lnunk kell a v\u00e1laszokat is, amiket a kliens kaphat. Ezeket a HTTP ig\u00e9k le\u00edr\u00e1sa alatt a <code>responses</code> tulajdons\u00e1ghoz kell \u00edrnunk. Ehhez sz\u00fcks\u00e9g\u00fcnk van egy HTTP st\u00e1tusz k\u00f3dra, illetve egy le\u00edr\u00e1sra, amely a v\u00e1lasz s\u00e9m\u00e1j\u00e1t ismerteti.</p> <pre><code>paths:\n  /artists:\n    get:\n      responses:\n        '200':\n          description: Successfully returned a list of artists\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  required:\n                    - username\n                  properties:\n                    artist_name:\n                      type: string\n                    artist_genre:\n                      type: string\n                    albums_recorded:\n                      type: integer\n                    username:\n                      type: string\n\n        '400':\n          description: Invalid request\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:   \n                  message:\n                    type: string\n...\n</code></pre> <p>A fenti 200-as st\u00e1tusz k\u00f3d eset\u00e9n visszaadott lista egy eleme C#-ban az al\u00e1bbiak szerint n\u00e9zhet ki.</p> <pre><code>class Artist\n{\n  [Required]\n  [JsonPropertyName(\"username\")]\n  public string Username { get; set; }\n\n  [JsonPropertyName(\"artist_name\")]\n  public string ArtistName { get; set; }\n\n  [JsonPropertyName(\"artist_genre\")]\n  public string ArtistGenre { get; set; }\n\n  [JsonPropertyName(\"albums_recorded\")]\n  public int AlbumsRecorded { get; set; }\n}\n</code></pre>"},{"location":"lecture-notes/openapi/#parameterek","title":"Param\u00e9terek","text":"<p>Lehet\u0151s\u00e9g\u00fcnk van sz\u00e1mtalan param\u00e9ter megad\u00e1s\u00e1ra, mellyel a kliensek \u00e9s a szerver k\u00f6z\u00f6tti kommunik\u00e1ci\u00f3 specifikuss\u00e1g\u00e1t tudjuk n\u00f6velni. Ilyen param\u00e9ter p\u00e9ld\u00e1ul a lek\u00e9rdez\u00e9s param\u00e9ter (query parameter). Ahhoz, hogy egy p\u00e9ld\u00e1ul egy <code>GET http://example.com/v1/artists?limit=20&amp;offset=3</code> k\u00e9r\u00e9st ki tudjunk szolg\u00e1lni a fenti k\u00f3dot az al\u00e1bbi sorokkal kell b\u0151v\u00edten\u00fcnk:</p> <pre><code>[HttpGet(\"artists\")]\npublic IEnumerable&lt;Artist&gt; GetByLimOffs(int limit, int offset){\n  return artistRepository.List(limit, offset);\n}\n</code></pre> <p>Ennek az OpenAPI le\u00edr\u00e1sa pedig az al\u00e1bbi lesz:</p> <pre><code>paths:\n  /artists:\n    get:\n      parameters:\n        - name: limit\n          in: query\n          description: Limits the number of items on a page\n          schema:\n            type: integer\n        - name: offset\n          in: query\n          description: Specifies the page number of the artists to be displayed\n...\n</code></pre> <p>Az query string mellett az URL path r\u00e9sz\u00e9ben is sz\u00e1ll\u00edthat\u00f3 param\u00e9ter, p\u00e9ld\u00e1ul a <code>GET http://example.com/v1/artists/{username}</code> form\u00e1j\u00e1ban. Ekkor a C# k\u00f3d \u00edgy n\u00e9z ki:</p> <pre><code>[HttpGet(\"artists/{username}\")]\npublic IEnumerable&lt;Artist&gt; GetByUsername(string username){\n    return artistRepository.GetByUname(username);\n}\n</code></pre> <p>Ehhez pedig az al\u00e1bbi OpenAPI specifik\u00e1ci\u00f3 r\u00e9szlet tartozik.</p> <pre><code>paths:\n  /artists/{username}:\n    get:\n      description: Obtain information about an artist from his or her unique username\n      parameters:\n        - name: username\n          in: path\n          required: true\n          schema:\n            type: string\n\n      responses:\n        '200':\n          description: Successfully returned an artist\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  artist_name:\n                    type: string\n                  artist_genre:\n                    type: string\n                  albums_recorded:\n                    type: integer\n\n        '400':\n          description: Invalid request\n          content:\n            application/json:\n              schema:\n                type: object \n                properties:           \n                  message:\n                    type: string\n</code></pre> <p>P\u00e9ldak\u00f3djaink egy alap API kezdetleges v\u00e1ltozat\u00e1t \u00e1ll\u00edtott\u00e1k el\u0151. J\u00f3l l\u00e1that\u00f3, hogy ez a k\u00f3d egy komolyabb API le\u00edr\u00e1sn\u00e1l hatalmas mennyis\u00e9get is el\u00e9rhet. Fontos l\u00e1tni teh\u00e1t, hogy az API le\u00edr\u00e1s\u00e1hoz el\u0151bb a logikailag \u00f6sszerakott adatb\u00e1zist \u00e9s egy azt reprezent\u00e1l\u00f3 modellt kell alkotnunk, mert csak az ut\u00e1n k\u00e9pzelhet\u0151 el az API modellje - amit r\u00e1ad\u00e1sul az el\u0151bbiekb\u0151l fogunk tipikusan gener\u00e1lni.</p>"},{"location":"lecture-notes/openapi/#polimorfizmus-es-orokles-openapi-30-alatt","title":"Polimorfizmus \u00e9s \u00f6r\u00f6kl\u00e9s OpenAPI 3.0 alatt","text":"<p>Az \u00f6r\u00f6kl\u00e9s \u00e9s polimorfizmus is objektumorient\u00e1lt fogalmak. Az OpenAPI viszont nem objektumorient\u00e1lt - hiszen nem programoz\u00e1si nyelv. M\u00e9gis, az OpenAPI-ban is felmer\u00fcl a k\u00e9rd\u00e9s, hogyan lehet ism\u00e9tl\u0151d\u0151 adatr\u00e9szeket \"kiemelni\", azaz, hogy a \"k\u00f6z\u00f6s\" s\u00e9m\u00e1t ne kell sokszor ism\u00e9telni. Objektumorient\u00e1lt nyelvben erre term\u00e9szetesen a lesz\u00e1rmaz\u00e1s a megold\u00e1s. Az OpenAPI specifik\u00e1ci\u00f3ja is lehet\u0151s\u00e9get biztos\u00edt arra, hogy a k\u00f6z\u00f6s tulajdons\u00e1gok ne alkossanak sormint\u00e1t, ezzel cs\u00fany\u00e1v\u00e1 t\u00e9ve az am\u00fagy is hossz\u00fa OpenAPI defin\u00edci\u00f3t. N\u00e9zz\u00fcnk erre egy p\u00e9ld\u00e1t.</p> <p>Tegy\u00fck fel, hogy k\u00e9t f\u00e9le hiba\u00fczenetet tudunk visszaadni, az egyik \"r\u00e9szhalmaza\" a m\u00e1siknak. C#-ben mindez \u00edgy n\u00e9zne ki:</p> <pre><code>class BasicErrorModel\n{\n  public string Message { get; set; }\n  public int Code { get; set; }\n}\nclass ExtendedErrorModel : BasicErrorModel\n{\n  public string RootCause { get; set; }\n}\n</code></pre> <p>Ez OpenApi-ban az <code>allOf</code> kulcssz\u00f3 haszn\u00e1lat\u00e1val \u00edrhat\u00f3 le, \u00e9s \u00edgy n\u00e9z ki:</p> <pre><code>    components:\n      schemas:\n        BasicErrorModel:\n          type: object\n          required:\n            - message\n            - code\n          properties:\n            message:\n              type: string\n            code:\n              type: integer\n              minimum: 100\n              maximum: 600\n        ExtendedErrorModel:\n          allOf:     # \"\u00e1tveszi\" a hivatkozott modell \u00f6sszes elem\u00e9t \u00e9s kieg\u00e9sz\u00edti tov\u00e1bbiakkal\n            - $ref: '#/components/schemas/BasicErrorModel'\n            - type: object\n              required:\n                - rootCause\n              properties:\n                rootCause:\n                  type: string\n</code></pre> <p>Az <code>allOf</code> seg\u00edt abban, hogy egy relat\u00edv el\u00e9r\u00e9si \u00fat megad\u00e1s\u00e1val egyes\u00edts\u00fck az \u00e1ltalunk k\u00e9sz\u00edtett \"lesz\u00e1rmazott\" attrib\u00fatumait az el\u00e9r\u00e9si \u00fat t\u00faloldal\u00e1n \u00e1ll\u00f3 modell attrib\u00fatumaival. Van egy szab\u00e1ly, amelyet aj\u00e1nlott k\u00f6vetn\u00fcnk az <code>allOf</code> parancsn\u00e1l, ez pedig nem m\u00e1s mint, hogy ne haszn\u00e1ljunk azonos attrib\u00fatum neveket k\u00fcl\u00f6nb\u00f6z\u0151 adatt\u00edpusokkal. Ha ilyen el\u0151fordul a k\u00f3dban az sz\u00e1mtalan hib\u00e1hoz vezethet.</p> <p>M\u00e1sik, objektumorient\u00e1lt vil\u00e1gban gyakran haszn\u00e1lt eszk\u00f6z a polimorfizmus, azaz amikor a konkr\u00e9t p\u00e9ld\u00e1ny egy lesz\u00e1rmaz\u00e1si hierarchia b\u00e1rmely t\u00edpusa lehet. A polimorfizmus megold\u00e1s\u00e1hoz az <code>allOf</code>-hoz hasonl\u00f3 <code>oneOf</code> kulcssz\u00f3t tudjuk haszn\u00e1lni. Az al\u00e1bbi p\u00e9ld\u00e1ban a <code>oneOf</code> parancs lehet\u0151v\u00e9 teszi, hogy az adat <code>simpleObject</code> vagy <code>complexObject</code> s\u00e9m\u00e1t is tartalmazhasson, de midig csak az egyiket.</p> <pre><code>...\n    components:\n      responses:\n        sampleObjectResponse:\n          content:\n            application/json:\n              schema:\n                oneOf:\n                  - $ref: '#/components/schemas/simpleObject'\n                  - $ref: '#/components/schemas/complexObject'\n     ...\n    components:\n      schemas:\n        simpleObject:\n          ...\n        complexObject:\n          ...\n</code></pre> <p>Amennyiben ezt C#-ban pr\u00f3b\u00e1ljuk elk\u00e9pzelni, akkor <code>SimpleObject</code> \u00e9s <code>ComplexObject</code> is oszt\u00e1lyok, amelyek tipikusan (de nem sz\u00fcks\u00e9gszer\u0171en) rendelkeznek egy k\u00f6z\u00f6s \u0151ssel.</p> <p>Azon t\u00fal, hogy a polimorfizmust a fentiekben a s\u00e9m\u00e1ban kifejezt\u00fck, val\u00f3ban m\u00e9g nem vagyunk k\u00e9szen. Az OpenAPI ugyanis csak a s\u00e9m\u00e1r\u00f3l sz\u00f3l. Arr\u00f3l nem, hogy a C#/Java/stb. k\u00f3dban a t\u00e9nyleges adatb\u00f3l hogyan keletkezhet objektum. Hiszen ez nem az OpenAPI felel\u0151ss\u00e9ge - ez a soros\u00edt\u00e1sra tartozik. A deszerializ\u00e1l\u00e1s (JSON -&gt; objektum) sor\u00e1n kell majd val\u00f3j\u00e1ban eld\u00f6nteni, hogy az adat, ami \u00e9rkezik, az melyik t\u00edpusnak felel meg. Ezt a tipikus JSON soros\u00edt\u00f3 k\u00f6nyvt\u00e1rak csak k\u00fcl\u00f6n konfigur\u00e1ci\u00f3 \u00e1r\u00e1n tudj\u00e1k elv\u00e9gezni. Ezzel teh\u00e1t \u00e9rdemes vizsg\u00e1zni, az OpenAPI csak a probl\u00e9ma fel\u00e9t oldotta meg.</p> <p>A szakirodalom v\u00e9lem\u00e9nye ez\u00e9rt is megoszlik a polimorfizmusr\u00f3l mint lehets\u00e9ges <code>edge-case</code>-r\u0151l. Az OpenAPI 3.0 kiad\u00e1s\u00e1val megjelentek a m\u00e1r fent eml\u00edtett parancsok, viszont m\u00e9g 2019-ben is sz\u00e1mtalan olyan szolg\u00e1ltat\u00e1s volt, amely nem t\u00e1mogatta ezek haszn\u00e1lat\u00e1t.</p>"},{"location":"lecture-notes/openapi/#openapi-vs-swagger-mik-is-a-kulonbsegek","title":"OpenAPI vs Swagger, mik is a k\u00fcl\u00f6nbs\u00e9gek?","text":"<p>Az OpenAPI \u00e9s a Swagger a szakm\u00e1ban t\u00f6bbnyire szinonimak\u00e9nt jelenik meg, de m\u00e1st jelentenek hivatalosan. Az OpenAPI a \"Swaggerb\u0151l j\u00f6tt l\u00e9tre\", annak szabv\u00e1nyos\u00edtott v\u00e1ltozata, m\u00edg a Swagger egy szoftvercsomag. 2017-ben az OpenAPI 3.0 megjelen\u00e9se el\u00e9g nagy m\u00e9rf\u00f6ldk\u0151nek sz\u00e1m\u00edtott. Ez volt az els\u0151 hivatalos kiad\u00e1s 2015 \u00f3ta, amikor is a SmartBear Software az OpenAPI Initiative-nek aj\u00e1nd\u00e9kozta a jogokat, illetve megt\u00f6rt\u00e9nt a Swagger Specification -&gt; OpenAPI Specification n\u00e9vv\u00e1lt\u00e1s.</p> <p>A k\u00fcl\u00f6nbs\u00e9g legegyszer\u0171bben \u00edgy \u00e9rthet\u0151 meg:</p> <ul> <li>OpenAPI = specifik\u00e1ci\u00f3</li> <li>Swagger = eszk\u00f6z\u00f6k a specifik\u00e1ci\u00f3 megval\u00f3s\u00edt\u00e1s\u00e1hoz</li> </ul> <p>Az OpenAPI a specifik\u00e1ci\u00f3 hivatalos neve. A specifik\u00e1ci\u00f3 fejleszt\u00e9s\u00e9t az OpenAPI Initiative seg\u00edti, amelyben t\u00f6bb mint 30 szervezet vesz r\u00e9szt az IT vil\u00e1g k\u00fcl\u00f6nb\u00f6z\u0151 ter\u00fcleteir\u0151l - k\u00f6zt\u00fck a Microsoft, a Google, az IBM \u00e9s a CapitalOne. A Swagger eszk\u00f6z\u00f6k fejleszt\u00e9s\u00e9t vezet\u0151 Smartbear Software szint\u00e9n tagja az OpenAPI Initiative-nek, \u00e9s seg\u00edti a specifik\u00e1ci\u00f3 fejl\u0151d\u00e9s\u00e9t. A Swagger eszk\u00f6zt\u00e1r ny\u00edlt forr\u00e1sk\u00f3d\u00fa, ingyenes \u00e9s kereskedelmi eszk\u00f6z\u00f6k kever\u00e9k\u00e9t tartalmazza, amelyek az API \u00e9letciklus k\u00fcl\u00f6nb\u00f6z\u0151 szakaszaiban haszn\u00e1lhat\u00f3k:</p> <ul> <li>Swagger Editor:  lehet\u0151v\u00e9 teszi az OpenAPI-specifik\u00e1ci\u00f3k YAML-ben t\u00f6rt\u00e9n\u0151 szerkeszt\u00e9s\u00e9t a b\u00f6ng\u00e9sz\u0151ben, valamint a dokument\u00e1ci\u00f3k val\u00f3s idej\u0171 el\u0151n\u00e9zet\u00e9t.</li> <li>Swagger UI: egy HTML, JavaScript \u00e9s CSS eszk\u00f6z\u00f6kb\u0151l \u00e1ll\u00f3 gy\u0171jtem\u00e9ny, amely dinamikusan gy\u00f6ny\u00f6r\u0171 dokument\u00e1ci\u00f3t gener\u00e1l egy OAS-kompatibilis API-b\u00f3l.</li> <li>Swagger Codegen: Lehet\u0151v\u00e9 teszi az API kliensk\u00f6nyvt\u00e1rak (SDK gener\u00e1l\u00e1sa), szerver csonkok \u00e9s dokument\u00e1ci\u00f3 automatikus gener\u00e1l\u00e1s\u00e1t egy OpenAPI Spec alapj\u00e1n.</li> <li>Swagger Parser: \u00d6n\u00e1ll\u00f3 k\u00f6nyvt\u00e1r az OpenAPI defin\u00edci\u00f3k Java-b\u00f3l t\u00f6rt\u00e9n\u0151 elemz\u00e9s\u00e9re.</li> <li>Swagger Core: Java-alap\u00fa k\u00f6nyvt\u00e1rak az OpenAPI-defin\u00edci\u00f3k l\u00e9trehoz\u00e1s\u00e1hoz, fogyaszt\u00e1s\u00e1hoz \u00e9s az azokkal val\u00f3 munk\u00e1hoz.</li> <li>Swagger Inspector (ingyenes): API-tesztel\u0151 eszk\u00f6z, amely lehet\u0151v\u00e9 teszi az API-k valid\u00e1l\u00e1s\u00e1t \u00e9s OpenAPI-defin\u00edci\u00f3k gener\u00e1l\u00e1s\u00e1t egy megl\u00e9v\u0151 API-b\u00f3l.</li> <li>SwaggerHub (ingyenes \u00e9s kereskedelmi): API-tervez\u00e9s \u00e9s dokument\u00e1ci\u00f3, az OpenAPI-val dolgoz\u00f3 csapatok sz\u00e1m\u00e1ra k\u00e9sz\u00fclt.</li> </ul> <p>A Swagger sz\u00e1mtalan lehet\u0151s\u00e9get ny\u00fajt a fejleszt\u0151k sz\u00e1m\u00e1ra a le\u00edr\u00e1sok elk\u00e9sz\u00edt\u00e9s\u00e9hez. Ezeket a le\u00edr\u00e1sokat \u00e1ltal\u00e1ban JSON vagy YAML nyelveken k\u00e9sz\u00edtj\u00fck. A hivatalos forr\u00e1sok mind a YAML nyelvet aj\u00e1nlj\u00e1k, ugyanis k\u00f6nnyebben olvashat\u00f3 \u00e9s gyorsabban meg\u00e9rthet\u0151.</p>"},{"location":"lecture-notes/openapi/#forrasok","title":"Forr\u00e1sok","text":"<p>A jegyzet elk\u00e9sz\u00edt\u00e9s\u00e9hez a hivatalos dokument\u00e1ci\u00f3 szolg\u00e1lt forr\u00e1sk\u00e9nt:</p> <ul> <li>https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/</li> <li>https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/</li> <li>https://support.smartbear.com/swaggerhub/docs/tutorials/writing-swagger-definitions.html</li> <li>https://support.smartbear.com/swaggerhub/docs/tutorials/openapi-3-tutorial.html</li> </ul>"},{"location":"lecture-notes/restapi/","title":"REST API (Gyakorl\u00f3 p\u00e9ld\u00e1k)","text":"<p>\u00c9rdekess\u00e9g</p> <p>A p\u00e9ld\u00e1k t\u00f6bbs\u00e9ge egy l\u00e9tez\u0151, k\u00f6zismert tanulm\u00e1nyi rendszer m\u0171k\u00f6d\u00e9s\u00e9n alapszik.</p>"},{"location":"lecture-notes/restapi/#elmeleti-kerdesek","title":"Elm\u00e9leti k\u00e9rd\u00e9sek","text":"<ol> <li> <p>Minek a r\u00f6vid\u00edt\u00e9se a REST?</p> </li> <li> <p>Milyen egys\u00e9gekben, milyen m\u0171veletekben kell gondolkoznunk, amikor REST API-t tervez\u00fcnk?</p> </li> <li> <p>Foglald \u00f6ssze, hogy a REST API szerint az egyes HTTP ig\u00e9ket milyen t\u00edpus\u00fa m\u0171veletekhez haszn\u00e1ljuk!</p> </li> </ol> Megold\u00e1s: 1. feladat <p>Representational State Transfer</p> Megold\u00e1s: 2. feladat <p>Ebben az architekt\u00fara st\u00edlusban az alapvet\u0151 egys\u00e9g az er\u0151forr\u00e1s, ami tipikusan valamilyen adatentit\u00e1snak feleltethet\u0151 meg (pl. Task, Product, Order, stb.). M\u0171veleteket tekintve egy-egy k\u00e9r\u00e9s-v\u00e1lasz p\u00e1ros valamilyen er\u0151forr\u00e1sra vonatkoz\u00f3 \u00e1llapot\u00e1tvitel (State Transfer). Az \u00e1tvitel ir\u00e1ny\u00e1t a HTTP ige hat\u00e1rozza meg.</p> Megold\u00e1s: 3. feladat <p></p>"},{"location":"lecture-notes/restapi/#gyakorlati-kerdesek","title":"Gyakorlati k\u00e9rd\u00e9sek","text":"<ol> <li> <p>Egy tanulm\u00e1nyi rendszerb\u0151l szeretn\u00e9nk lek\u00e9rdezni egy adott h\u00e9tre vonatkoz\u00f3 esem\u00e9nyeket. A b\u00f6ng\u00e9sz\u0151 fejleszt\u0151i eszk\u00f6zeivel azt tapasztaljuk, hogy ebben az esetben az al\u00e1bbi k\u00e9r\u00e9st k\u00fcldj\u00fck el a szervernek: <pre><code>Request URL:        https://domain.hu/hallgatoi/TimeTableHandler.ashx\nRequest Method:     POST\nStatus Code:        200 OK\nRemote Address:     152.66.28.54:443\nReferrer Policy:    strict-origin-when-cross-origin\n</code></pre> Az el\u0151z\u0151 feladatot tekintve miben s\u00e9rti ez a megold\u00e1s a REST API ir\u00e1nymutat\u00e1sait?</p> </li> <li> <p>Tanulm\u00e1nyi rendszer\u00fcnket friss\u00edteni szeretn\u00e9nk, hogy val\u00f3ban REST API-t implement\u00e1ljon. Hogyan \u00edrn\u00e1d \u00e1t a k\u00f6vetkez\u0151 lek\u00e9rdez\u00e9st, ha... a) specifik\u00e1ci\u00f3ba van r\u00f6gz\u00edtve, hogy mindig pontosan egy napt\u00e1ri hetet szeretn\u00e9nk lek\u00e9rdezni \u00e9s k\u00e9s\u0151bb sem szeretn\u00e9nk ezen v\u00e1ltoztatni? b) a lek\u00e9rdezend\u0151 id\u0151tartam eleje \u00e9s v\u00e9ge is tetsz\u0151legesen v\u00e1laszthat\u00f3 marad? <pre><code>Request URL:        https://domain.hu/hallgatoi/timetable\nRequest Method:     POST\n</code></pre> <pre><code>Request Body: {\n    startDate: 1702281600000,\n    endDate: 1702857599000,\n    showClasses: true,\n    showExams: true,\n    showTasks: false\n}\n</code></pre></p> </li> </ol> Megold\u00e1s: 1. feladat <p>A <code>Request Method</code> mez\u0151ben azt l\u00e1tjuk, hogy <code>POST</code> met\u00f3dust haszn\u00e1ltunk lek\u00e9rdez\u00e9shez. A REST API szerint lek\u00e9rdez\u00e9shez <code>GET</code> haszn\u00e1land\u00f3.</p> Megold\u00e1s: 2. feladat <p>A megold\u00e1s sor\u00e1n egy dologban biztosak lehet\u00fcnk: <code>Request Method: GET</code>, hiszen lek\u00e9rdezni szeretn\u00e9nk adatot.  </p> <p>a) feladat Innent\u0151l kezdve azonban m\u00e1r t\u00f6bb ir\u00e1nyban is elindulhatunk. Legegyszer\u0171bb megold\u00e1s, ha egyszer\u0171en minden param\u00e9tert, ami eddig a <code>Request Body</code>-ban utazott, be\u00edrjuk az URL-be, mint param\u00e9ter. Ekkor a megold\u00e1sunk \u00edgy n\u00e9zne ki: <pre><code>Request URL:        https://domain.hu/hallgatoi/timetable?startDate=1702281600000&amp;endDate=1702857599000&amp;showClasses=true&amp;showExams=true&amp;showTasks=false\nRequest Method:     GET\n</code></pre> Ez az a pillanat, ahol sokan h\u00e1trad\u0151ln\u00e9nek, esetleg a v\u00e1llukat is megveregetn\u00e9k, hogy megoldott\u00e1k a feladatot. Azonban gondolkodjunk el egy picit... Mi is a REST API alapgondolata? Er\u0151forr\u00e1sokat kezel\u00fcnk. Ahhoz, hogy a megold\u00e1sunk val\u00f3ban megfeleljen ennek a szeml\u00e9letnek, szerver oldalon sajnos nagyobb v\u00e1ltoztat\u00e1s sz\u00fcks\u00e9ges, mint az el\u0151z\u0151 megold\u00e1sn\u00e1l, de mi most API-t tervez\u00fcnk, emiatt ne f\u00e1jjon a fej\u00fcnk. Na de milyen er\u0151forr\u00e1s szerepel ebben a lek\u00e9rdez\u00e9sben? Mit szeretn\u00e9nk lek\u00e9rdezni? Egy h\u00e9t esem\u00e9nyeit. Az esem\u00e9nyek a v\u00e1laszban fognak szerepelni, mint objektumok, ez\u00e9rt azokat nem tudjuk kiemelni, de mi\u00e9rt ne emelhetn\u00e9nk ki a heteket? <pre><code>https://domain.hu/hallgatoi/timetable/week/51?showClasses=true&amp;showExams=true&amp;showTasks=false\n</code></pre> \u00cdgy m\u00e1r mindj\u00e1rt olvashat\u00f3bb az URL. Egy r\u00e9szletr\u0151l azonban megfeledkezt\u00fcnk: Melyik \u00e9vre vagyunk k\u00edv\u00e1ncsiak? Gyorsan jav\u00edtsuk is ki: <pre><code>https://domain.hu/hallgatoi/timetable/year/2023/week/51?showClasses=true&amp;showExams=true&amp;showTasks=false\n</code></pre> M\u00e9g egy utols\u00f3 gondolat motoszk\u00e1lhat benn\u00fcnk: Nem lenne szebb azt, hogy milyen esem\u00e9nyekre vagyunk k\u00edv\u00e1ncsiak egy list\u00e1ban \u00e1tadni? Pr\u00f3b\u00e1ljuk ki! A v\u00e9gleges lek\u00e9rdez\u00e9s\u00fcnk, teh\u00e1t a k\u00f6vetkez\u0151: <pre><code>Request URL:     https://domain.hu/hallgatoi/timetable/year/2023/week/51?showEvents=classes,exams\nRequest Method:  GET\n</code></pre></p> <p>b) feladat Ebben az esetben nem tudjuk az el\u0151z\u0151 k\u00e9rd\u00e9shez hasonl\u00f3an kezelni a lek\u00e9rdezend\u0151 intervallumot, itt k\u00e9nytelenek lesz\u00fcnk az intervallum kezdet\u00e9t \u00e9s v\u00e9g\u00e9t is param\u00e9terk\u00e9nt \u00e1tadni. A megjelen\u00edtend\u0151 esem\u00e9nyek t\u00edpus\u00e1t azonban itt is \u00e1tadhatjuk listak\u00e9nt, \u00edgy teh\u00e1t egy lehets\u00e9ges megold\u00e1s a k\u00f6vetkez\u0151: <pre><code>Request URL:     https://domain.hu/hallgatoi/timetable?startDate=1702281600000&amp;endDate=1702857599000&amp;showEvents=classes,exams\nRequest Method:  GET\n</code></pre></p>"},{"location":"lecture-notes/transactions/","title":"Tranzakci\u00f3kezel\u00e9s adatb\u00e1zisokban","text":"<p>Kontextus</p> <p>Az al\u00e1bbiak alapvet\u0151en rel\u00e1ci\u00f3s adatb\u00e1zisokra vonatkoz\u00f3an ismertetik a tranzakci\u00f3kat. Azonban a probl\u00e9m\u00e1k \u00e9s megold\u00e1sok egy r\u00e9sze \u00e1ltal\u00e1nos, \u00e9s m\u00e1s jelleg\u0171 adatb\u00e1zis rendszerekben is megtal\u00e1lhat\u00f3ak.</p>"},{"location":"lecture-notes/transactions/#konkurens-adathozzaferes","title":"Konkurens adathozz\u00e1f\u00e9r\u00e9s","text":"<p>Az adatb\u00e1zis-kezel\u0151 rendszerek kliens-szerver \u00fczemm\u00f3dban m\u0171k\u00f6dnek. A kliensek (az \u00e1ltalunk \u00edrt szoftverek) csatlakoznak az adatb\u00e1zishoz \u00e9s k\u00e9r\u00e9seket hajtatnak v\u00e9gre. Ebben a fel\u00e1ll\u00e1sban egy adatb\u00e1zis-kezel\u0151 rendszer \u00e9s t\u00f6bb kliens vesz r\u00e9szt. Az adatb\u00e1zis rendszer c\u00e9lja, hogy min\u00e9l t\u00f6bb k\u00e9r\u00e9st szolg\u00e1ljon ki, ez\u00e9rt a k\u00e9r\u00e9seket egym\u00e1ssal p\u00e1rhuzamosan hajtja v\u00e9gre. Egy ilyen rendszerben az al\u00e1bbi konkurens (egy id\u0151ben t\u00f6rt\u00e9n\u0151) adathozz\u00e1f\u00e9r\u00e9si esetek lehets\u00e9gesek.</p> <ul> <li>Amennyiben a hozz\u00e1f\u00e9r\u00e9sek, ak\u00e1r \u00edr\u00e1s, ak\u00e1r olvas\u00e1s, elt\u00e9r\u0151 adatra vonatkoznak, nincs probl\u00e9ma, a m\u0171veletek egyszerre is t\u00f6rt\u00e9nhetnek.</li> <li>Amennyiben minden hozz\u00e1f\u00e9r\u00e9s csak olvas\u00e1s, nincs probl\u00e9ma: olvasni egyszerre t\u00f6bben is tudnak.</li> <li>Viszont, ha ugyanazon adathoz egy id\u0151ben t\u00f6bben f\u00e9rnek hozz\u00e1, \u00e9s legal\u00e1bb egy \u00edr\u00e1s is van k\u00f6zt\u00fck, akkor fell\u00e9phet a konkurencia probl\u00e9m\u00e1ja.</li> </ul> <p>Ez a konkurencia probl\u00e9ma nem k\u00fcl\u00f6nb\u00f6zik az oper\u00e1ci\u00f3s rendszerek \u00e9s v\u00e1ltozatos programoz\u00e1si nyelvek eset\u00e9n megismert konkurencia \u00e9s k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s probl\u00e9m\u00e1j\u00e1t\u00f3l. Ott t\u00f6bbnyire mem\u00f3ria hozz\u00e1f\u00e9r\u00e9sr\u0151l, azonos mem\u00f3riater\u00fclet \u00edr\u00e1s-olvas\u00e1s\u00e1r\u00f3l van sz\u00f3, \u00e9s a megold\u00e1s a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s, azaz a programoz\u00f3 v\u00e9delmi vonallal l\u00e1tja el az adat hozz\u00e1f\u00e9r\u00e9s hely\u00e9t.</p> <p>Adatb\u00e1zis-kezel\u0151 rendszerekben a konkurens hozz\u00e1f\u00e9r\u00e9s az adatb\u00e1zisban tal\u00e1lhat\u00f3 rekordokra (sorokra) vonatkozik, \u00e9s a v\u00e9delmi vonalat a tranzakci\u00f3k adj\u00e1k.</p>"},{"location":"lecture-notes/transactions/#tranzakciok","title":"Tranzakci\u00f3k","text":"<p>Defin\u00edci\u00f3</p> <p>A tranzakci\u00f3 a feldolgoz\u00e1s logikai egys\u00e9ge, olyan m\u0171veletek sorozata, melyek csak egy\u00fcttesen \u00e9rtelmesek.</p> <p>A tranzakci\u00f3kkal teh\u00e1t m\u0171veleteket fogunk \u00f6ssze egy egys\u00e9gbe, amelyekre vonatkoz\u00f3an a rendszer biztos\u00edtja az al\u00e1bbi tulajdons\u00e1gokat:</p> <ul> <li>atomi v\u00e9grehajt\u00e1s (atomicity),</li> <li>konzisztencia (consistency),</li> <li>egym\u00e1st\u00f3l val\u00f3 izol\u00e1ci\u00f3 (isolation),</li> <li>\u00e9s tart\u00f3ss\u00e1g (durability).</li> </ul> <p>Vizsg\u00e1ljuk meg a tranzakci\u00f3k alaptulajdons\u00e1gait, hogy meg\u00e9rthess\u00fck, hogyan oldhatjuk meg haszn\u00e1latukkal a konkurens adathozz\u00e1f\u00e9r\u00e9s probl\u00e9m\u00e1j\u00e1t.</p> <p>A tranzakci\u00f3 csak eszk\u00f6z</p> <p>A tranzakci\u00f3k (a k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s biztos\u00edt\u00e1s\u00e1hoz haszn\u00e1lt mutexekhez hasonl\u00f3an) csak eszk\u00f6zt adnak a programoz\u00f3 kez\u00e9be, de a helyes haszn\u00e1lat a fejleszt\u0151 felel\u0151ss\u00e9ge.</p>"},{"location":"lecture-notes/transactions/#tranzakciok-alaptulajdonsagai","title":"Tranzakci\u00f3k alaptulajdons\u00e1gai","text":""},{"location":"lecture-notes/transactions/#atomi-vegrehajtas","title":"Atomi v\u00e9grehajt\u00e1s","text":"<p>Az atomi v\u00e9grehajt\u00e1s azt jelenti, hogy a m\u0171velet sorozatunk t\u00f6bb utas\u00edt\u00e1st tartalmaz, azonban ezen utas\u00edt\u00e1s sorozat csak egyben \u00e9rtelmes, a r\u00e9szleges v\u00e9grehajt\u00e1st meg kell akad\u00e1lyozni. Erre az\u00e9rt van sz\u00fcks\u00e9g, mert gyakran az adatb\u00e1zisban v\u00e9grehajtott m\u0171veleteinket t\u00f6bb utas\u00edt\u00e1s seg\u00edts\u00e9g\u00e9vel tudjuk csak kifejezni, de az utas\u00edt\u00e1sok k\u00f6z\u00f6tt nem szak\u00edthat\u00f3 meg a m\u0171velet.</p> <p>K\u00e9pzelj\u00fck el egy webshopban a v\u00e1s\u00e1rl\u00e1s v\u00e9g\u00e9t lez\u00e1r\u00f3 m\u0171veletet:</p> <ol> <li>R\u00f6gz\u00edtj\u00fck a megrendel\u00e9st, elmentj\u00fck egy rekordban a megrendel\u0151 adatait</li> <li>A megrendelt term\u00e9kn\u00e9l cs\u00f6kkentj\u00fck a rakt\u00e1ron lev\u0151 darabsz\u00e1mot, hiszen egyet eladtunk</li> </ol> <p>Ez a m\u0171veletsorozat csak egyben \u00e9rtelmes. Amennyiben a megrendel\u00e9st r\u00f6gz\u00edtett\u00fck, musz\u00e1j a rakt\u00e1rk\u00e9szletet is cs\u00f6kkenteni, k\u00fcl\u00f6nben t\u00f6bbet adhatunk el a term\u00e9kb\u0151l, mint amennyi rendelkez\u00e9sre \u00e1ll. A k\u00e9t l\u00e9p\u00e9s k\u00f6z\u00f6tt teh\u00e1t a m\u0171velet nem szak\u00edthat\u00f3 f\u00e9lbe.</p> <p>Ezt garant\u00e1lja az atomi v\u00e9grehajt\u00e1s: ha a m\u0171veletsorozat v\u00e9grehajt\u00e1sa megkezd\u0151d\u00f6tt, akkor annak vagy teljes eg\u00e9sz\u00e9ben le kell futnia, vagy vissza kell \u00e1llnia a v\u00e9grehajt\u00e1st megel\u0151z\u0151 \u00e1llapotba.</p>"},{"location":"lecture-notes/transactions/#konzisztencia","title":"Konzisztencia","text":"<p>Az adatb\u00e1zis konzisztenci\u00e1j\u00e1nak szab\u00e1lyait r\u00e9szben az integrit\u00e1si krit\u00e9riumokkal \u00edrhatjuk le: p\u00e9ld\u00e1ul egy k\u00fcls\u0151 kulcs \u00e1ltal hivatkozott rekordnak l\u00e9teznie kell. Ezen k\u00edv\u00fcl az adatok k\u00f6z\u00f6tti \u00f6sszef\u00fcgg\u00e9seket is bele\u00e9rtj\u00fck a konzisztenci\u00e1ba: p\u00e9ld\u00e1ul a Neptun rendszerben nem lehet t\u00f6bb jelentkez\u0151 a vizsg\u00e1ra, mint a vizsga l\u00e9tsz\u00e1mkorl\u00e1tja.</p> <p>Tranzakci\u00f3k haszn\u00e1lata biztos\u00edtja sz\u00e1munkra, hogy az adatb\u00e1zisunk mindig konzisztens \u00e1llapotban van. Egy megkezdett tranzakci\u00f3 lefut\u00e1sa sor\u00e1n el\u0151fordulhat ideiglenesen inkonzisztens \u00e1llapot, mint a fenti p\u00e9ld\u00e1ban az egyes l\u00e9p\u00e9sek k\u00f6z\u00f6tt. Azonban a tranzakci\u00f3 v\u00e9g\u00e9re a konzisztenci\u00e1nak helyre kell \u00e1llnia. M\u00e1s sz\u00f3val: a tranzakci\u00f3k az adatb\u00e1zist konzisztens \u00e1llapotb\u00f3l konzisztens \u00e1llapotba viszik.</p>"},{"location":"lecture-notes/transactions/#tartossag","title":"Tart\u00f3ss\u00e1g","text":"<p>A tart\u00f3ss\u00e1g tulajdons\u00e1ga azt \u00edrja el\u0151, hogy a tranzakci\u00f3 hat\u00e1sa tart\u00f3san megmarad, azaz a tranzakci\u00f3 \u00e1ltal v\u00e9gzett m\u0171veletek eredm\u00e9nye nem veszhet el. Praktikusan ez azt jelenti, hogy a tranzakci\u00f3 \u00e1ltal v\u00e9gzett m\u00f3dos\u00edt\u00e1sok nem csak mem\u00f3ri\u00e1ban ker\u00fclnek elv\u00e9gz\u00e9sre, hanem tart\u00f3s t\u00e1rra (merevlemezre) is ki\u00edr\u00e1sra ker\u00fclnek.</p> <p>Az adatb\u00e1zisban k\u00e9t f\u00e9le hib\u00e1t k\u00fcl\u00f6nb\u00f6ztet\u00fcnk meg, amikor adatveszt\u00e9s k\u00f6vetkezhet be: soft crash \u00e9s hard crash. Soft crash eset\u00e9n az adatb\u00e1zis szerver le\u00e1ll, \u00edgy a mem\u00f3ria tartalma elveszik. Ez ellen v\u00e9denek a tranzakci\u00f3k. Hard crash eset\u00e9n a merevlemez is s\u00e9r\u00fcl; ez ellen csak a biztons\u00e1gi ment\u00e9s tud v\u00e9deni.</p>"},{"location":"lecture-notes/transactions/#izolacio","title":"Izol\u00e1ci\u00f3","text":"<p>Az izol\u00e1ci\u00f3 a tranzakci\u00f3k egym\u00e1st\u00f3l val\u00f3 \"elszigetel\u00e9s\u00e9t\" jelenti. A tranzakci\u00f3inkat \u00fagy \u00edrhatjuk meg, hogy annak helyes lefuttat\u00e1s\u00e1r\u00f3l a rendszer fog gondoskodni. A fejleszt\u0151 teh\u00e1t \u00fagy \u00edrhatja meg a tranzakci\u00f3t, mintha az a rendszerben egyed\u00fcl futna, \u00e9s az adatb\u00e1zis rendszer garant\u00e1lja, hogy megadott szab\u00e1lyrendszer szerint nem fog el\u0151fordulni konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9ma.</p> <p>Val\u00f3j\u00e1ban a rendszerben egyszerre sok tranzakci\u00f3 fut, azonban az adatb\u00e1zis-kezel\u0151 rendszer garant\u00e1lja, hogy olyan \u00fctemez\u00e9sben futtatja tranzakci\u00f3kat, amelyek nem s\u00e9rtik a tranzakci\u00f3k \u00e1ltal elv\u00e1rt izol\u00e1ci\u00f3s szintet. Ehhez a tranzakci\u00f3nak specifik\u00e1lnia kell az izol\u00e1ci\u00f3s szintet.</p>"},{"location":"lecture-notes/transactions/#izolacios-problemak-es-izolacios-szintek","title":"Izol\u00e1ci\u00f3s probl\u00e9m\u00e1k \u00e9s izol\u00e1ci\u00f3s szintek","text":"<p>Az izol\u00e1ci\u00f3s szintek megismer\u00e9s\u00e9hez el\u0151sz\u00f6r meg kell ismern\u00fcnk, hogy pontosan milyen konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9m\u00e1k mer\u00fclhetnek fel.</p>"},{"location":"lecture-notes/transactions/#problemak","title":"Probl\u00e9m\u00e1k","text":""},{"location":"lecture-notes/transactions/#piszkos-olvasas-dirty-read","title":"Piszkos olvas\u00e1s (dirty read)","text":"<p>A piszkos olvas\u00e1s sor\u00e1n egy tranzakci\u00f3 egy m\u00e1sik tranzakci\u00f3 nem kommit\u00e1lt adatait haszn\u00e1lja:</p> <ol> <li>Egy tranzakci\u00f3 fut\u00e1sa sor\u00e1n m\u00f3dos\u00edt egy \u00e9rt\u00e9ket, de m\u00e9g nem kommit\u00e1l.</li> <li>Egy m\u00e1sik tranzakci\u00f3 ugyanezt a (m\u00e1r m\u00f3dos\u00edtott) \u00e9rt\u00e9ket kiolvassa.</li> <li>Az els\u0151 tranzakci\u00f3 megszak\u00edt\u00e1sra ker\u00fcl, \u00e9s a rendszer vissza\u00e1ll\u00edtja a m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9ket.</li> </ol> <p>A 2. l\u00e9p\u00e9sben felhaszn\u00e1lt \u00e9rt\u00e9k teh\u00e1t \u00e9rv\u00e9nytelen azt nem lett volna szabad felhaszn\u00e1lni.</p> <p></p> <p>Forr\u00e1s</p> <p>A k\u00e9pek forr\u00e1sa: https://vladmihalcea.com/2014/01/05/a-beginners-guide-to-acid-and-database-transactions/</p> <p>Ker\u00fclni kell</p> <p>A piszkos olvas\u00e1st szinte minden esetben el akarjuk ker\u00fclni.</p>"},{"location":"lecture-notes/transactions/#elveszett-modositas-lost-update","title":"Elveszett m\u00f3dos\u00edt\u00e1s (lost update)","text":"<p>Az elveszett m\u00f3dos\u00edt\u00e1s sor\u00e1n k\u00e9t \u00edr\u00e1s ker\u00fcl konfliktusba:</p> <ol> <li>Egy tranzakci\u00f3 megv\u00e1ltoztat egy \u00e9rt\u00e9ket.</li> <li>Egy m\u00e1sik tranzakci\u00f3 ugyanazon \u00e9rt\u00e9ket fel\u00fcl\u00edrja.</li> </ol> <p>V\u00e9geredm\u00e9nyben csak a m\u00e1sodik \u00edr\u00e1s eredm\u00e9nye marad meg, mintha az els\u0151 m\u00f3dos\u00edt\u00e1s nem is t\u00f6rt\u00e9nt volna meg.</p> <p></p>"},{"location":"lecture-notes/transactions/#nem-megismetelheto-olvasas-nonrepeatable-read","title":"Nem megism\u00e9telhet\u0151 olvas\u00e1s (nonrepeatable read)","text":"<p>A nem megism\u00e9telhet\u0151 olvas\u00e1s sor\u00e1n a lek\u00e9rdez\u00e9s eredm\u00e9nye f\u00fcgg att\u00f3l, hogy id\u0151ben mikor adt\u00e1k ki egy tranzakci\u00f3ban:</p> <ol> <li>Egy tranzakci\u00f3 lek\u00e9rdez egy adatot.</li> <li>Egy m\u00e1sik tranzakci\u00f3 m\u00f3dos\u00edtja ugyanazt az adatelemet.</li> <li>Ha az els\u0151 tranzakci\u00f3 megism\u00e9tli a kor\u00e1bbi lek\u00e9rdez\u00e9st, m\u00e1s eredm\u00e9nyt kap.</li> </ol> <p></p>"},{"location":"lecture-notes/transactions/#fantom-rekordok-phantom-recordsphantom-read","title":"Fantom rekordok (phantom records/phantom read)","text":"<p>A fantom rekordok probl\u00e9m\u00e1ja akkor jelentkezik, amikor rekord halmazokkal dolgozunk:</p> <ol> <li>Egy tranzakci\u00f3 lek\u00e9rdez egy eredm\u00e9nyhalmazt, amelyben t\u00f6bb rekord van.</li> <li>Ek\u00f6zben egy m\u00e1sik tranzakci\u00f3 t\u00f6r\u00f6l egy rekordot, amely r\u00e9sze a lek\u00e9rdezett eredm\u00e9nyhalmaznak.</li> <li>Az els\u0151 tranzakci\u00f3 elkezdi feldolgozni az eredm\u00e9nyhalmazt, p\u00e9ld\u00e1ul iter\u00e1tor-szer\u0171en egyes\u00e9vel megy v\u00e9gig a rekordhalmazon.</li> </ol> <p>A t\u00f6r\u00f6lt rekord ilyenkor r\u00e9sze a lek\u00e9rdezett eredm\u00e9nyhalmaznak, vagy sem? Hasonl\u00f3an elk\u00e9pzelhet\u0151 az is, hogy egy rekord m\u00f3dosul a 2. l\u00e9p\u00e9sben. Ilyenkor a 3. l\u00e9p\u00e9sben a kor\u00e1bbi, vagy a m\u00f3dosult \u00e1llapot\u00e1t kellene l\u00e1tni?</p> <p></p>"},{"location":"lecture-notes/transactions/#izolacios-szintek","title":"Izol\u00e1ci\u00f3s szintek","text":"<p>A fenti probl\u00e9m\u00e1k mindegyike elker\u00fclhet\u0151 a megfelel\u0151 izol\u00e1ci\u00f3s szint megv\u00e1laszt\u00e1s\u00e1val. Azonban min\u00e9l \"magasabb\" izol\u00e1ci\u00f3s szintet v\u00e1lasztunk, ann\u00e1l kisebb az adatb\u00e1zis-kezel\u0151 rendszer \u00e1tbocs\u00e1t\u00f3k\u00e9pess\u00e9ge, \u00e9s ann\u00e1l nagyobb a lehet\u0151s\u00e9ge a holtpont kialakul\u00e1s\u00e1nak (l\u00e1sd al\u00e1bb). Ez\u00e9rt a c\u00e9l egy megfelel\u0151 kompromisszum megtal\u00e1l\u00e1sa a lehets\u00e9ges probl\u00e9m\u00e1k \u00e9s a teljes\u00edtm\u00e9ny k\u00f6z\u00f6tt.</p> <p>Az ANSI/ISO SQL szabv\u00e1ny az al\u00e1bbi izol\u00e1ci\u00f3s szinteket k\u00fcl\u00f6nb\u00f6zteti meg.</p> <ul> <li>Read uncommitted: nem ny\u00fajt megold\u00e1st egyik probl\u00e9m\u00e1ra se.</li> <li>Read committed: nincs piszkos olvas\u00e1s.</li> <li>Repeatable read: nincs piszkos olvas\u00e1s, se nem megism\u00e9telhet\u0151 olvas\u00e1s.</li> <li>Serializable: egyik probl\u00e9ma sem fordulhat el\u0151.</li> </ul> <p>Mit haszn\u00e1ljunk?</p> <p>A read uncommitted szintet \u00e1ltal\u00e1ban nem haszn\u00e1ljuk. A serializable-t pedig lehet\u0151s\u00e9g szerint elker\u00fclj\u00fck. Az alap\u00e9rtelmezett szint \u00e1ltal\u00e1ban a read committed.</p>"},{"location":"lecture-notes/transactions/#utemezes-biztositasa-zarolas","title":"\u00dctemez\u00e9s biztos\u00edt\u00e1sa: z\u00e1rol\u00e1s","text":"<p>Az izol\u00e1ci\u00f3 biztos\u00edt\u00e1s\u00e1nak m\u00f3dja a z\u00e1rol\u00e1s: az adatb\u00e1zis-kezel\u0151 rendszer a rekordok olvas\u00e1sa \u00e9s \u00edr\u00e1sa sor\u00e1n megjel\u00f6li (z\u00e1rolja) az \u00e9rintett elemeket. A z\u00e1r elhelyez\u00e9se a hozz\u00e1f\u00e9r\u00e9s idej\u00e9ben t\u00f6rt\u00e9nik, m\u00edg az elenged\u00e9se a tranzakci\u00f3 v\u00e9gezt\u00e9vel. Azt, hogy milyen m\u0171velet eset\u00e9ben milyen z\u00e1rol\u00e1sra van sz\u00fcks\u00e9g (kiz\u00e1r\u00f3lagos, vagy megosztott z\u00e1r), az izol\u00e1ci\u00f3s szint \u00e9s az adott adatb\u00e1zis-kezel\u0151 rendszer implement\u00e1ci\u00f3ja hat\u00e1rozza meg.</p> <p>A z\u00e1rak seg\u00edts\u00e9g\u00e9vel val\u00f3j\u00e1ban a tranzakci\u00f3kat \u00fctemezi a rendszer. Amikor egy z\u00e1r nem \u00e9rhet\u0151 el, mert a m\u00f6g\u00f6ttes adatelemet m\u00e1s tranzakci\u00f3 haszn\u00e1lja \u00e9s a konkurens el\u00e9r\u00e9s a v\u00e1lasztott izol\u00e1ci\u00f3s szint szerint nem engedhet\u0151 meg, a tranzakci\u00f3 v\u00e1rakoztat\u00e1sra ker\u00fcl.</p> <p>Ha egy rendszerben z\u00e1rak vannak, akkor tudjuk, hogy holtpontok (deadlock) is el\u0151fordulhatnak. Holtpont akkor alakulhat ki, ha egy id\u0151ben legal\u00e1bb k\u00e9t tranzakci\u00f3 szeretn\u00e9 ugyanazon z\u00e1rakat megszerezni. Az al\u00e1bbi \u00e1br\u00e1n a folytonos ny\u00edl jel\u00f6li a megszerzett z\u00e1rat, a szaggatott vonal pedig a megszerzend\u0151 z\u00e1rat. A megszerzend\u0151 z\u00e1rak egyike se adhat\u00f3 ki, \u00edgy mind a k\u00e9t tranzakci\u00f3 meg\u00e1ll, v\u00e1rakoz\u00e1sra k\u00e9nyszer\u00fcl, de egyik se fog tudni ebb\u0151l az \u00e1llapotb\u00f3l kil\u00e9pni.</p> <p></p> <p>Adatb\u00e1zis-kezel\u0151 rendszerekben a holtpontok nem el\u0151zhet\u0151ek meg, viszont kezelni sz\u00fcks\u00e9ges az el\u0151fordul\u00e1sukat. A megold\u00e1s, hogy a rendszer akt\u00edvan figyeli a z\u00e1rakat, \u00e9s amikor holtpontot \u00e9rz\u00e9kel, akkor az egyik \u00e9rintett tranzakci\u00f3t megszak\u00edtja \u00e9s m\u00f3dos\u00edt\u00e1sait \u00e9rv\u00e9nytelen\u00edti. Egy adatb\u00e1zist haszn\u00e1l\u00f3 alkalmaz\u00e1snak erre az eshet\u0151s\u00e9gre fel kell k\u00e9sz\u00fclnie.</p> <p>Holtpontok kezel\u00e9se</p> <p>Holtpont ut\u00e1n, ha a tranzakci\u00f3 megszak\u00edt\u00e1sra ker\u00fclt, nem igaz\u00e1n tehet m\u00e1st az alkalmaz\u00e1s vagy felhaszn\u00e1l\u00f3, mint hogy kis id\u0151 eltelt\u00e9vel \u00fajra megpr\u00f3b\u00e1lja a m\u0171veletet.</p>"},{"location":"lecture-notes/transactions/#tranzakcios-hatarok","title":"Tranzakci\u00f3s hat\u00e1rok","text":"<p>A tranzakci\u00f3kr\u00f3l l\u00e1thattuk, hogy egy m\u0171veletsorozatot fognak egybe. Ehhez sz\u00fcks\u00e9g van a tranzakci\u00f3 elej\u00e9nek \u00e9s v\u00e9g\u00e9nek jel\u00f6l\u00e9s\u00e9hez. A tranzakci\u00f3 hat\u00e1rok platform f\u00fcgg\u0151en jel\u00f6lhet\u0151ek, de alapvet\u0151en \u00e9rv\u00e9nyesek az al\u00e1bbiak.</p> <ol> <li> <p>Minden m\u0171velet az adatb\u00e1zisban tranzakci\u00f3ban fut. Ha nem jel\u00f6li a fejleszt\u0151 a tranzakci\u00f3 haszn\u00e1lat\u00e1t, akkor minden SQL utas\u00edt\u00e1s automatikusan \u00f6nmag\u00e1ban egy tranzakci\u00f3.</p> <p>Egyszer\u0171 SQL utas\u00edt\u00e1sok tranzakci\u00f3ja</p> <p>Mivel minden SQL utas\u00edt\u00e1s tranzakci\u00f3ban fut, minden utas\u00edt\u00e1sra \u00f6nmag\u00e1ban is teljes\u00fclnek a tranzakci\u00f3k tulajdons\u00e1gai. P\u00e9ld\u00e1ul, ha egy <code>delete</code> utas\u00edt\u00e1s t\u00f6bb rekordot t\u00f6r\u00f6l, nem lehets\u00e9ges, hogy az utas\u00edt\u00e1s a lefut\u00e1sa k\u00f6zben megszakad, \u00e9s csak a rekordok fele ker\u00fclt t\u00f6rl\u00e9sre.</p> </li> <li> <p>A fejleszt\u0151 a tranzakci\u00f3 megkezd\u00e9shez a <code>begin transaction</code> SQL utas\u00edt\u00e1st, m\u00edg a bejezes\u00e9hez a <code>commit</code> vagy <code>rollback</code> utas\u00edt\u00e1sokat haszn\u00e1lhatja. A commit sikeresen lez\u00e1rja a tranzakci\u00f3t \u00e9s minden v\u00e1ltoz\u00e1st ment, m\u00edg rollback eset\u00e9n a tranzakci\u00f3 eldob\u00e1sra ker\u00fcl, \u00e9s vissza\u00e1ll a tranzakci\u00f3 megkezd\u00e9se el\u0151tti \u00e1llapot.</p> <p>Egym\u00e1sba \u00e1gyaz\u00e1s</p> <p>Adatb\u00e1zis-kezel\u0151 rendszer f\u00fcgg\u0151en lehet\u0151s\u00e9g van tranzakci\u00f3ba \u00e1gyazott tranzakci\u00f3ra is. Ilyenkor a z\u00e1r\u00f3jelez\u00e9s szab\u00e1lyainak megfelel\u0151en t\u00f6rt\u00e9nik a tranzakci\u00f3k lez\u00e1r\u00e1sa.</p> </li> </ol>"},{"location":"lecture-notes/transactions/#tranzakcios-naplozas","title":"Tranzakci\u00f3s napl\u00f3z\u00e1s","text":"<p>Eddigiekben csak arr\u00f3l besz\u00e9lt\u00fcnk, mit biztos\u00edt az adatb\u00e1zis-kezel\u0151 rendszer a tranzakci\u00f3k haszn\u00e1lat\u00e1val. Ismerj\u00fck meg ennek m\u0171k\u00f6d\u00e9s\u00e9t is.</p> <p>A tranzakci\u00f3s napl\u00f3z\u00e1s seg\u00edts\u00e9g\u00e9vel az adatb\u00e1zis rendszer nyomon tudja k\u00f6vetni a fut\u00f3 tranzakci\u00f3k \u00e1ltal v\u00e9gzett m\u00f3dos\u00edt\u00e1sokat, vissza tudja \u00e1ll\u00edtani a tranzakci\u00f3 megkezd\u00e9se el\u0151tti \u00e1llapotot, \u00e9s soft crash eset\u00e9n a f\u00e9lbeszakadt tranzakci\u00f3kat visszag\u00f6rgeti (rollback).</p> <p>Ahhoz, hogy meg\u00e9rts\u00fck a tranzakci\u00f3s napl\u00f3z\u00e1st, az al\u00e1bbi koncepcion\u00e1lis rendszermodellel dolgozunk.</p> <p></p> <p>Ebben a modellben a k\u00f6vetkez\u0151 m\u0171veletek vannak:</p> <ul> <li>Begin T(x): Tranzakci\u00f3 kezdete</li> <li>Input(A): Adatelem beolvas\u00e1sa az adatb\u00e1zis tart\u00f3s t\u00e1rb\u00f3l (lemezr\u0151l)</li> <li>Output(A) Adatelem ki\u00edr\u00e1sa az adatb\u00e1zis tart\u00f3s t\u00e1rba (lemezre)</li> <li>Read(A): Tranzakci\u00f3 kiolvassa az adatelemet a mem\u00f3ria bufferb\u0151l</li> <li>Write(A): Tranzakci\u00f3 vissza\u00edrja az adatelemet a mem\u00f3ria bufferbe</li> <li>FLUSH_LOG: Tranzakci\u00f3s napl\u00f3 lemezre \u00edr\u00e1sa</li> </ul> <p>A napl\u00f3z\u00e1s m\u0171k\u00f6d\u00e9s\u00e9t egy p\u00e9ld\u00e1n kereszt\u00fcl mutatjuk meg. A p\u00e9ld\u00e1ban a tranzakci\u00f3 k\u00e9t adatelemet m\u00f3dos\u00edt: A-t 2-vel cs\u00f6kkenti, \u00e9s B-t 2-vel n\u00f6veli.</p>"},{"location":"lecture-notes/transactions/#undo-tipusu-naplozas","title":"Undo t\u00edpus\u00fa napl\u00f3z\u00e1s","text":"<p>Kezdetben a mem\u00f3ria buffer \u00fcres, az adatok csak az adatb\u00e1zis f\u00e1jlban tal\u00e1lhat\u00f3ak meg. A v\u00e9grehajt\u00e1s ez\u00e9rt az adatok beolvas\u00e1s\u00e1val kezd\u0151dik.</p> M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Begin(T1) 10 20 - - Begin T1 Input(A) 10 20 10 - Input(B) 10 20 10 20 <p>A tranzakci\u00f3 sz\u00e1m\u00e1ra el\u0151\u00e1lltak a sz\u00fcks\u00e9ges adatok a mem\u00f3ria bufferben. A m\u00f3dos\u00edt\u00e1s elv\u00e9gz\u00e9s\u00e9hez a tranzakci\u00f3 kiolvassa az adatot, majd a m\u00f3dos\u00edtott \u00e9rt\u00e9ket vissza\u00edrja. Ezzel egy\u00fctt a tranzakci\u00f3s napl\u00f3ban r\u00f6gz\u00edt\u00e9sre ker\u00fcl a m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9k.</p> M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 10 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 20 <p>Ezzel a tranzakci\u00f3 befejezve a m\u0171veleteit, azonban a v\u00e1ltoztat\u00e1sok m\u00e9g nem lettek mentve. Ehhez kommit\u00e1l a tranzakci\u00f3, amely sor\u00e1n el\u0151sz\u00f6r a tranzakci\u00f3s napl\u00f3 bejegyz\u00e9sei a napl\u00f3f\u00e1jlba ki\u00edr\u00e1sra ker\u00fclnek, majd megt\u00f6rt\u00e9nik a m\u00f3dos\u00edt\u00e1s az adatb\u00e1zisban.</p> M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Flush_LOG 10 20 8 22 Output(A) 8 20 8 22 Output(B) 8 22 8 22 Commit T1 <p>Gondoljuk v\u00e9gig, hogy soft crash eset\u00e9n hogyan kell helyre\u00e1ll\u00edtani a rendszert.</p> <ul> <li>Amennyiben a tranzakci\u00f3 a kommit el\u0151tt lett megszak\u00edtva, nincs dolga a rendszernek, mert az adatb\u00e1zis f\u00e1jlban nem t\u00f6rt\u00e9nt m\u00f3dos\u00edt\u00e1s, a mem\u00f3ria buffer pedig a soft crash hat\u00e1s\u00e1ra elt\u0171nik.</li> <li>Amennyiben a tranzakci\u00f3 elkezdte a kommit proced\u00far\u00e1t, az adatb\u00e1zisba m\u00e1r ki\u00edr\u00e1sra ker\u00fclhetett valamennyi v\u00e1ltoztat\u00e1s. Ezeket vissza kell \u00e1ll\u00edtani. Ilyenkor a tranzakci\u00f3s napl\u00f3t h\u00e1tulr\u00f3l olvasva kell feldolgozni, \u00e9s minden olyan tranzakci\u00f3 eset\u00e9n, amelynek nincs commit bejegyz\u00e9se a napl\u00f3ban, vissza\u00e1ll\u00edthat\u00f3 a napl\u00f3ban tal\u00e1lhat\u00f3 m\u00f3dos\u00edt\u00e1s el\u0151tti \u00e9rt\u00e9k.</li> </ul> <p>R\u00f6viden \u00f6sszefoglalva undo napl\u00f3z\u00e1s eset\u00e9n</p> <ul> <li>az adatb\u00e1zis nem \u00edrhat\u00f3 \u00e1t, am\u00edg a tranzakci\u00f3s napl\u00f3 nincs ki\u00edrva,</li> <li>\u00e9s commit jelet csak az adatb\u00e1zis \u00edr\u00e1s ut\u00e1n lehet kitenni a napl\u00f3ba.</li> </ul> <p>A m\u0171k\u00f6d\u00e9s kulcsa, hogy a tranzakci\u00f3s napl\u00f3t el\u0151bb kell ki\u00edrni, mint a m\u00f3dos\u00edt\u00e1sokat az adatb\u00e1zis f\u00e1jlban elv\u00e9gezn\u00e9 a rendszer. A megold\u00e1s h\u00e1tr\u00e1nya, hogy k\u00e9tszer is kell a tranzakci\u00f3s napl\u00f3t f\u00e1jlba \u00edrni (amely a diszk \u00edr\u00e1s miatt k\u00f6lts\u00e9ges m\u0171velet).</p>"},{"location":"lecture-notes/transactions/#redo-tipusu-naplozas","title":"Redo t\u00edpus\u00fa napl\u00f3z\u00e1s","text":"<p>A m\u0171veletsorozat a kor\u00e1bban l\u00e1tott beolvas\u00e1sokkal kezd\u0151dik, majd k\u00f6vetkezik a m\u00f3dos\u00edt\u00e1sok elv\u00e9gz\u00e9se, de ez\u00fattal a tranzakci\u00f3s napl\u00f3ban a m\u00f3dos\u00edt\u00e1s ut\u00e1ni \u00e9rt\u00e9k ker\u00fcl r\u00f6gz\u00edt\u00e9sre.</p> M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 8 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 22 <p>A m\u00f3dos\u00edt\u00e1sok v\u00e9gleges\u00edt\u00e9s\u00e9hez a tranzakci\u00f3 elkezdi a kommit folyamatot, amely a tranzakci\u00f3s napl\u00f3t ki\u00edrja, \u00e9s r\u00f6gz\u00edti a kommit\u00e1l\u00e1s t\u00e9ny\u00e9t - de az adatb\u00e1zis f\u00e1jlban m\u00e9g nem m\u00f3dosultak az adatok. \u00cdgy a tranzakci\u00f3s napl\u00f3 f\u00e1jlba t\u00f6rt\u00e9n\u0151 \u00edr\u00e1sa egy m\u0171veletre reduk\u00e1l\u00f3dott (szemben az undo t\u00edpus\u00fa napl\u00f3z\u00e1ssal).</p> M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Commit T1 Flush_LOG 10 20 8 22 <p>A tranzakci\u00f3s napl\u00f3 ment\u00e9se ut\u00e1n v\u00e9gezhet\u0151 el a t\u00e9nyleges adat ment\u00e9se az adatb\u00e1zis f\u00e1jlba.</p> M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Output(A) 8 20 8 22 Output(B) 8 22 8 22 <p>Gondoljuk v\u00e9gig, hogy soft crash eset\u00e9n hogyan kell helyre\u00e1ll\u00edtani a rendszert.</p> <ul> <li>Amennyiben a tranzakci\u00f3 a kommit el\u0151tt lett megszak\u00edtva, nincs dolga a rendszernek, mert az adatb\u00e1zis f\u00e1jlban nem t\u00f6rt\u00e9nt m\u00f3dos\u00edt\u00e1s, a mem\u00f3ria buffer pedig a soft crash hat\u00e1s\u00e1ra elt\u0171nik.</li> <li>Amennyiben a tranzakci\u00f3 elkezdte a kommit proced\u00far\u00e1t, m\u00e1r ki\u00edr\u00e1sra ker\u00fclt a napl\u00f3ba a commit t\u00e9nye, de az adatb\u00e1zis f\u00e1jl m\u00e9g nem m\u00f3dosult. Ha ilyenkor szakad meg a v\u00e9grehajt\u00e1s, akkor a vissza\u00e1ll\u00edt\u00e1s sor\u00e1n a tranzakci\u00f3s napl\u00f3t ez elej\u00e9t\u0151l kezdve kell feldolgozni, \u00e9s minden kommit\u00e1lt tranzakci\u00f3t \u00fajra v\u00e9gre kell hajtani.</li> </ul> <p>R\u00f6viden \u00f6sszefoglalva redo napl\u00f3z\u00e1s eset\u00e9n</p> <ul> <li>az adatb\u00e1zis nem \u00edrhat\u00f3 \u00e1t, am\u00edg a tranzakci\u00f3s napl\u00f3 nincs ki\u00edrva,</li> <li>\u00e9s commit jelet az adatb\u00e1zis \u00edr\u00e1s el\u0151tt kell kitenni a napl\u00f3ba.</li> </ul> <p>Az undo napl\u00f3z\u00e1shoz k\u00e9pest teh\u00e1t kevesebb a tranzakci\u00f3s napl\u00f3 szinkroniz\u00e1l\u00e1sa, de hosszabb a vissza\u00e1ll\u00edt\u00e1si folyamat.</p>"},{"location":"lecture-notes/transactions/#undoredo-naplozas","title":"Undo/redo napl\u00f3z\u00e1s","text":"<p>A nev\u00e9b\u0151l ad\u00f3d\u00f3an ez a megold\u00e1s az el\u0151z\u0151 kett\u0151 kombin\u00e1ci\u00f3ja. A p\u00e9lda m\u0171veletsor ugyan\u00fagy kezd\u0151dik, mint kor\u00e1bban. A k\u00fcl\u00f6nbs\u00e9g a tranzakci\u00f3s napl\u00f3ba val\u00f3 \u00edr\u00e1sn\u00e1l jelentkezik: mind a v\u00e1ltoz\u00e1s el\u0151tti, mind a v\u00e1ltoz\u00e1s ut\u00e1ni \u00e9rt\u00e9k ki\u00edr\u00e1sra ker\u00fcl.</p> M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Read(A) 10 20 10 20 Write(A) 10 20 8 20 T1, A, 10, 8 Read(B) 10 20 8 20 Write(B) 10 20 8 22 T1, B, 20, 22 <p>A kommit folyamat is egyszer\u0171s\u00f6dik. Az adatb\u00e1zis f\u00e1jlba val\u00f3 \u00edr\u00e1s \u00e9s a kommit jel ki\u00edr\u00e1sa a tranzakci\u00f3s napl\u00f3ba tetsz\u0151leges sorrendben elv\u00e9gezhet\u0151 (de mindenk\u00e9ppen meg kell el\u0151zze \u0151ket a tranzakci\u00f3s napl\u00f3 f\u00e1jlba \u00edr\u00e1sa). A v\u00e1ltoz\u00e1s teh\u00e1t, hogy a commit jel helye nem k\u00f6t\u00f6tt.</p> M\u0171velet A (adatb\u00e1zis) B (adatb\u00e1zis) A (buffer) B (buffer) Tranzakci\u00f3s napl\u00f3 Flush_LOG 10 20 8 22 Output(A) 8 20 8 22 Commit T1 Output(B) 8 22 8 22 <p>A vissza\u00e1ll\u00edt\u00e1s sor\u00e1n a kor\u00e1bban ismertetett m\u00f3dok kombin\u00e1l\u00e1s\u00e1ra van sz\u00fcks\u00e9g:</p> <ul> <li>m\u00e1r kommit\u00e1lt tranzakci\u00f3k eset\u00e9ben a v\u00e1ltoz\u00e1s \u00fajraj\u00e1tsz\u00e1s\u00e1ra van sz\u00fcks\u00e9g (mind a redo eset\u00e9n),</li> <li>m\u00edg a f\u00e9lbeszakadt tranzakci\u00f3k el\u0151tti \u00e1llapot az undo napl\u00f3z\u00e1shoz hasonl\u00f3an \u00e1ll\u00edthat\u00f3 helyre.</li> </ul> <p>Ennek a megold\u00e1snak az el\u0151nye, hogy</p> <ul> <li>kevesebb szinkroniz\u00e1ci\u00f3 sz\u00fcks\u00e9ges a bels\u0151 m\u0171k\u00f6d\u00e9sben (a tranzakci\u00f3s napl\u00f3 \u00edr\u00e1sa \u00e9s az adatb\u00e1zis f\u00e1jlok \u00edr\u00e1sa tekintet\u00e9ben),</li> <li>valamint a m\u00f3dos\u00edt\u00e1s hamarabb r\u00f6gz\u00edthet\u0151 az adatb\u00e1zis f\u00e1jlban (nem kell a tranzakci\u00f3s napl\u00f3ban megv\u00e1rni a commit jel r\u00f6gz\u00edt\u00e9s\u00e9t).</li> </ul>"},{"location":"lecture-notes/transactions/#tranzakcios-naplo-meretenek-csokkentese","title":"Tranzakci\u00f3s napl\u00f3 m\u00e9ret\u00e9nek cs\u00f6kkent\u00e9se","text":"<p>A tranzakci\u00f3s napl\u00f3 f\u00e1jlt id\u0151nk\u00e9nt sz\u00fcks\u00e9ges ki\u00fcr\u00edteni, nem n\u0151het a v\u00e9gtelens\u00e9gig. Olyan tranzakci\u00f3k bejegyz\u00e9sei t\u00f6r\u00f6lhet\u0151ek bel\u0151le, amelyek val\u00f3ban kommit\u00e1l\u00e1sra ker\u00fcltek (az adatb\u00e1zis f\u00e1jlba be\u00edr\u00e1sra ker\u00fclt minden eredm\u00e9ny\u00fck), vagy amelyek megszakadtak, \u00e9s nem kell \u0151ket vissza\u00e1ll\u00edtani. Ez a folyamat \u00e1ltal\u00e1ban automatikus, de kezdem\u00e9nyezhet\u0151 manu\u00e1lisan is.</p> <p>Tranzakci\u00f3 hossza \u00e9s tranzakci\u00f3s napl\u00f3 m\u00e9rete</p> <p>Hosszan fut\u00f3 tranzakci\u00f3k eset\u00e9ben k\u00fcl\u00f6n\u00f6sen \u00e9rdemes figyelni a tranzakci\u00f3s napl\u00f3 m\u00e9ret\u00e9re. Min\u00e9l nagyobbra n\u0151, ann\u00e1l lassabb ut\u00e1na a m\u00e9ret cs\u00f6kkent\u00e9s.</p>"},{"location":"lecture-notes/transactions/#deadlock-informacio-kinyerese-mssql-adatbazisbol","title":"Deadlock inform\u00e1ci\u00f3 kinyer\u00e9se MSSQL adatb\u00e1zisb\u00f3l","text":"<p>Deadlock (holtpont)</p> <p>Holtpont akkor alakulhat ki, ha adott k\u00e9t tranzakci\u00f3 illetve k\u00e9t z\u00e1r. Az egyik tranzakci\u00f3 rendelkezik az egyik z\u00e1rral, m\u00edg a m\u00e1sik a m\u00e1sikkal. Ekkor holtpont alakul ki, ha mindk\u00e9t tranzakci\u00f3 meg szeretn\u00e9 szerezni a m\u00e1sik \u00e1ltal m\u00e1r megszerzett z\u00e1rat.</p> <p>Legyen adott az A \u00e9s B tranzakci\u00f3, illetve a \u00e9s b er\u0151forr\u00e1s. A tranzakci\u00f3 z\u00e1rolja a er\u0151forr\u00e1st, B tranzakci\u00f3 z\u00e1rolja b er\u0151forr\u00e1st. Viszont A tranzakci\u00f3 szeretn\u00e9 z\u00e1rolni b er\u0151forr\u00e1st is \u00e9s B tranzakci\u00f3 szeretn\u00e9 z\u00e1rolni a er\u0151forr\u00e1st is. Ebben az esetben ki fog alakulni egy holtpont.</p> <p>N\u00e9zz\u00fck meg az el\u0151bbi p\u00e9ld\u00e1n kereszt\u00fcl, hogyan tudjuk diagnosztiz\u00e1lni a holtpontot, ha el\u0151\u00e1ll egy rendszerben. Ehhez el\u0151sz\u00f6r is \u00e1ll\u00edtsuk el\u0151 a holtpontot.</p> <ol> <li> <p>Hozzunk l\u00e9tre k\u00e9t t\u00e1bl\u00e1t, amin mesters\u00e9gesen el\u0151\u00e1ll\u00edtjuk a holtpontot.</p> <p>L\u00e9trehozzuk az els\u0151 t\u00e1bl\u00e1t <code>Lefty</code> n\u00e9ven, amelynek egy attrib\u00fatuma lesz, a <code>Numbers</code>:</p> <pre><code>CREATE TABLE dbo.Lefty (Numbers INT PRIMARY KEY CLUSTERED);\nINSERT INTO dbo.Lefty VALUES (1), (2), (3); \n</code></pre> <p>L\u00e9trehozzuk a m\u00e1sodik t\u00e1bl\u00e1t <code>Righty</code> n\u00e9ven, amelynek szint\u00e9n egy attrib\u00fatuma lesz, a <code>Numbers</code>:</p> <pre><code>CREATE TABLE dbo.Righty (Numbers INT PRIMARY KEY CLUSTERED);\nINSERT INTO dbo.Righty VALUES (1), (2), (3); \n</code></pre> </li> <li> <p>A k\u00e9t tranzakci\u00f3nak egyszerre kell lefutnia, ahhoz hogy holtpont alakulhasson ki. Amennyiben k\u00e9zzel tesztel\u00fcnk, akkor ez nehezen kivitelezhet\u0151, teh\u00e1t a v\u00e9grehajt\u00e1s sorrendje:</p> <ol> <li>Az els\u0151 tranzakci\u00f3b\u00f3l az els\u0151 <code>UPDATE</code> utas\u00edt\u00e1st hajtjuk v\u00e9gre</li> <li>A m\u00e1sodik tranzakci\u00f3b\u00f3l mindkett\u0151 <code>UPDATE</code> utas\u00edt\u00e1st v\u00e9grehajtjuk</li> <li>Az els\u0151 tranzakci\u00f3b\u00f3l v\u00e9grehajtjuk a m\u00e1sodik <code>UPDATE</code> utas\u00edt\u00e1st</li> </ol> <p>Els\u0151 tranzakci\u00f3:</p> <pre><code>BEGIN TRAN\nUPDATE dbo.Lefty\nSET Numbers = Numbers * 2;\nGO\n\nUPDATE dbo.Righty\nSET Numbers = Numbers * 2;\nGO\n</code></pre> <p>M\u00e1sodik tranzakci\u00f3:</p> <pre><code>BEGIN TRAN\nUPDATE dbo.Righty\nSET Numbers = Numbers + 1;\nGO\n\nUPDATE dbo.Lefty\nSET Numbers = Numbers + 1;\nGO\n</code></pre> </li> </ol> <p>Ezzel el\u0151 is \u00e1llt a holtpont. A rendszer fel fogja oldani ezt a holtpontot egy kis id\u0151 eltelt\u00e9vel. Miel\u0151tt ez megt\u00f6rt\u00e9nik, megn\u00e9zhetj\u00fck, hogy mit is l\u00e1tunk a rendszerben.</p> <p>A tranzakci\u00f3k \u00e1ltal elhelyezett z\u00e1rakat le lehet k\u00e9rdeni az adatb\u00e1zisban a k\u00f6vetkez\u0151 lek\u00e9rdez\u00e9ssel:</p> <pre><code>SELECT\n    OBJECT_NAME(P.object_id) AS TableName,\n    Resource_type, request_status,  request_session_id\nFROM\n    sys.dm_tran_locks dtl\n    join sys.partitions P\nON dtl.resource_associated_entity_id = p.hobt_id\n</code></pre> <p>P\u00e9ld\u00e1nk sor\u00e1n ennek a lek\u00e9rdez\u00e9snek az eredm\u00e9nye:</p> TableName Resource_type request_status request_session_id 1 Righty KEY GRANT 54 2 Lefty KEY GRANT 53 <p>Teh\u00e1t az els\u0151 tranzakci\u00f3 a <code>Lefty</code> t\u00e1bl\u00e1n helyezett el egy z\u00e1rat, m\u00edg a m\u00e1sodik tranzakci\u00f3 a <code>Righty</code> t\u00e1bl\u00e1n</p> <p>A blokkolt tranzakci\u00f3kr\u00f3l szint\u00e9n sz\u00e1mos adatot szolg\u00e1ltat az adatb\u00e1zis, amelyeket a k\u00f6vetkez\u0151 SQL utas\u00edt\u00e1ssal lehet lek\u00e9rdezni:</p> <pre><code>SELECT blocking_session_id AS BlockingSessionID,\n       session_id AS VictimSessionID,\n       wait_time/1000 AS WaitDurationSecond\nFROM sys.dm_exec_requests\nCROSS APPLY sys.dm_exec_sql_text([sql_handle])\nWHERE blocking_session_id &gt; 0 \n</code></pre> <p>P\u00e9ld\u00e1nk sor\u00e1n ennek a lek\u00e9rdez\u00e9snek az eredm\u00e9nye:</p> BlockingSessionID VictimSessionID WaitDurationSecond 1 54 53 0 2 53 54 72 <p>Teh\u00e1t az 53-as ID-val rendelkez\u0151 tranzakci\u00f3 v\u00e1rakoztatja az 54-es ID-val rendelkez\u0151 tranzakci\u00f3t 72 m\u00e1sodperce, illetve az 54-es ID-val rendelkez\u0151 tranzakci\u00f3 v\u00e1rakoztatja az 53-as ID-val rendelkez\u0151 tranzakci\u00f3t 0 m\u00e1sodperce.</p> <p>A holtpontot az adatb\u00e1zis r\u00f6vid id\u0151n bel\u00fcl mag\u00e1t\u00f3l megsz\u0171ntette. Ha manu\u00e1lisan szeretn\u00e9nk beavatkozni, akkor ezt a <code>kill</code> paranccsal tehetj\u00fck meg kiv\u00e1lasztva azt a tranzakci\u00f3t, amit le akarunk \u00e1ll\u00edtani (pl. <code>kill 53</code>).</p>"},{"location":"lecture-notes/transactions/#ellenorzo-kerdesek","title":"Ellen\u0151rz\u0151 k\u00e9rd\u00e9sek","text":"<ul> <li>Milyen konkurens adathozz\u00e1f\u00e9r\u00e9si probl\u00e9m\u00e1kat ismersz?</li> <li>Milyen izol\u00e1ci\u00f3s szintek vannak? Milyen probl\u00e9m\u00e1kra adnak megold\u00e1st?</li> <li>Mik a tranzakci\u00f3k alaptulajdons\u00e1gai?</li> <li>D\u00f6ntse el, hogy igaz vagy hamis az al\u00e1bbi \u00e1ll\u00edt\u00e1s:<ul> <li>A serializable izol\u00e1ci\u00f3s szint egym\u00e1s ut\u00e1n hajtja v\u00e9gre a tranzakci\u00f3kat.</li> <li>A holtpont elker\u00fclhet\u0151 a megfelel\u0151 izol\u00e1ci\u00f3s szint haszn\u00e1lat\u00e1val.</li> <li>A read committed \u00e1ltal\u00e1ban az alap\u00e9rtelmezett izol\u00e1ci\u00f3s szint.</li> <li>Ha nem haszn\u00e1lunk explicit ind\u00edtott tranzakci\u00f3t, akkor (alapesetben) elker\u00fclj\u00fck a piszkos olvas\u00e1st.</li> <li>A tranzakci\u00f3s napl\u00f3 v\u00e9d mindenf\u00e9le adatveszt\u00e9ssel szemben.</li> <li>Redo tranzakci\u00f3s napl\u00f3z\u00e1s eset\u00e9n a commit jellel kezd\u0151dik a tranzakci\u00f3s napl\u00f3.</li> </ul> </li> </ul>"},{"location":"seminar/ef/","title":"Entity Framework","text":"<p>A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a LINQ lek\u00e9rdez\u00e9sek haszn\u00e1lat\u00e1t, valamint az Entity Framework Core ORM keretrendszer alapvet\u0151 m\u0171k\u00f6d\u00e9s\u00e9t.</p> <p>Entity Framework Core</p> <p>A gyakorlat sor\u00e1n a .NET 8-ot (r\u00e9gebben .NET Core) \u00e9s Entity Framework Core 8-ot haszn\u00e1ljuk, amely m\u00e1r 2016 \u00f3ta platformf\u00fcggetlen, \u00e9s Linuxos \u00e9s Mac-en is haszn\u00e1lhat\u00f3.</p> <p>A r\u00e9gebbi Entity Framework 6 (nem a Core) alapvet\u0151en a r\u00e9gebbi .NET Frameworkh\u00f6z k\u00e9sz\u00fclt, \u00e9s ott bevett gyakorlat volt az entit\u00e1s modellt egy vizu\u00e1lis modell szerkeszt\u0151 eszk\u00f6zben lehetett karbantartani (EDMX), \u00e9s ebb\u0151l C# k\u00f3dot gener\u00e1lni. Az EF 6-ban az EDMX mellett m\u00e1r t\u00e1mogatott volt a Code-First megk\u00f6zel\u00edt\u00e9s is, ahol EDMX szerkeszt\u00e9s helyett m\u00e1r k\u00f6zvetlen\u00fcl a C# oszt\u00e1lyokat \u00edrhattuk. Ezt az EF Core tov\u00e1bbvitte, \u00e9s most m\u00e1r ez az egyed\u00fcli lehet\u0151s\u00e9g (\u00e9s nem mellesleg k\u00e9nyelmesebb is).</p> <p>A LINQ lek\u00e9rdez\u00e9sek tekintet\u00e9ben a k\u00e9t technol\u00f3gia k\u00f6zel azonos \u00e9lm\u00e9nyt ny\u00fajt, de apr\u00f3bb szintaktikai elt\u00e9r\u00e9sek ad\u00f3dhatnak, illetve az EF Core funkcion\u00e1lisan m\u00e1r gazdagabb.</p>"},{"location":"seminar/ef/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Microsoft Visual Studio 2022</li> <li>Microsoft SQL Server (LocalDB vagy Express edition)</li> <li>SQL Server Management Studio</li> <li>Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql</li> </ul> <p>Amit \u00e9rdemes \u00e1tn\u00e9zned:</p> <ul> <li>C# nyelv</li> <li>Entity Framework Core \u00e9s LINQ</li> </ul> <p>Windows mentes fejleszt\u00e9s</p> <p>A labor alapvet\u0151en elv\u00e9gezhet\u0151 open-source eszk\u00f6z\u00f6kkel is (VSCode, .NET 8 SDK, MSSQL Linux alap\u00fa verzi\u00f3ja ak\u00e1r dockerb\u0151l), de a labor nem ezeket az eszk\u00f6z\u00f6ket haszn\u00e1lja.</p>"},{"location":"seminar/ef/#gyakorlat-menete","title":"Gyakorlat menete","text":"<p>A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be.</p> <p>Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!</p>"},{"location":"seminar/ef/#feladat-0-adatbazis-letrehozasa-ellenorzese","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se","text":"<p>Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban.)</p>"},{"location":"seminar/ef/#feladat-1-projekt-letrehozasa-adatbazis-lekepzese","title":"Feladat 1: Projekt l\u00e9trehoz\u00e1sa, adatb\u00e1zis lek\u00e9pz\u00e9se","text":"<p>Hozz l\u00e9tre Visual Studio seg\u00edts\u00e9g\u00e9vel egy C# konzolalkalmaz\u00e1st .NET 8 keretrendszer felett (teh\u00e1t ne a r\u00e9gi .NET Framework alap\u00fat).</p> <p></p> <p>Hozd l\u00e9tre a projektet, a neve legyen a neptun k\u00f3dod \u00e9s a <code>c:\\work</code> mapp\u00e1ba dolgozz.</p> <ol> <li> <p>Hozzuk l\u00e9tre a kiindul\u00f3 EF Core Code First modell\u00fcnket. Ehhez most egy \u00fagynevezett Reverse Engineering Code First megold\u00e1st fogunk alkalmazni, aminek a l\u00e9nyege, hogy mivel m\u00e1r van egy kiindul\u00f3 adatb\u00e1zisunk abb\u00f3l gener\u00e1lunk egy Code-First modellt, de ezut\u00e1n a tov\u00e1bbiakban Code-First m\u00f3don dolgozunk.</p> <ul> <li>Telep\u00edts\u00fck az EF Core al\u00e1bbi csomagjait a projektbe a NuGet UI-r\u00f3l (project jobb gomb / Manage NuGet Packages) vagy a projektf\u00e1jlba m\u00e1soljuk be a k\u00f6vetkez\u0151t</li> <li>\u00c9rdemes a k\u00f3dot m\u00e1solni, gyorsabb!</li> </ul> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.SqlServer\" Version=\"8.0.8\" /&gt;\n    &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Design\" Version=\"8.0.8\"&gt;\n        &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;\n        &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;\n    &lt;/PackageReference&gt;\n    &lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"8.0.8\"&gt;\n        &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;\n        &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;\n    &lt;/PackageReference&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <ul> <li>Futtassuk le az al\u00e1bbi EF Core PowerShell parancsot a VS-en bel\u00fcl a Package Manager Console-ban, ami legener\u00e1lja nek\u00fcnk az adatb\u00e1zis kontextust \u00e9s az entit\u00e1s modellt, a connection stringbe \u00edrjuk bele az adatb\u00e1zis nev\u00e9t a 'NEPTUN' hely\u00e9re:</li> </ul> <pre><code>Scaffold-DbContext 'Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=NEPTUN;Integrated Security=True' Microsoft.EntityFrameworkCore.SqlServer -Context AdatvezDbContext -OutputDir Entities\n</code></pre> <p>EF Core .NET CLI</p> <p>A tov\u00e1bbiakban is a Package Manager Console-b\u00f3l el\u00e9rhet\u0151 parancsokat fogjuk haszn\u00e1lni, ami egy\u00e9bk\u00e9nt a <code>Microsoft.EntityFrameworkCore.Tools</code> csomaggal telep\u00fcl fel. Ha valaki a konvencion\u00e1lis CLI-t szeretn\u00e9 haszn\u00e1lni VS-en k\u00edv\u00fcl, az al\u00e1bbi linken megtal\u00e1lja a dokument\u00e1ci\u00f3t.</p> </li> <li> <p>Vizsg\u00e1ljuk meg a gener\u00e1lt code-first modellt.</p> <ul> <li>Az adatb\u00e1zis el\u00e9r\u00e9se az <code>AdatvezDbContext</code> oszt\u00e1lyon kereszt\u00fcl t\u00f6rt\u00e9nik</li> <li>Adatb\u00e1zis t\u00e1bl\u00e1k <code>DbSet</code> tulajdons\u00e1gokon kereszt\u00fcl \u00e9rhet\u0151ek el.</li> <li>A kapcsolat konfigur\u00e1ci\u00f3ja az <code>OnConfiguring</code> met\u00f3dusban t\u00f6rt\u00e9nik. \u00c9les alkalmaz\u00e1sban ez tipikusan konfigur\u00e1ci\u00f3s \u00e1llom\u00e1nyb\u00f3l \u00e9rkezik, ez\u00e9rt is ker\u00fclt legener\u00e1l\u00e1sra a <code>AdatvezDbContext(DbContextOptions&lt;AdatvezDbContext&gt; options)</code> konstruktor</li> <li>Az adatb\u00e1zis modell az <code>OnModelCreating</code> met\u00f3dusban ker\u00fclt konfigur\u00e1l\u00e1sra.</li> </ul> </li> <li> <p>M\u00f3dos\u00edtsunk a modellen</p> <p>Nevezz\u00fck \u00e1t a <code>CustomerSite</code> entit\u00e1s <code>Customer</code> navig\u00e1ci\u00f3s propertyj\u00e9t <code>MainCustomer</code>-re az entit\u00e1sban, \u00e9s az <code>OnModelCreating</code>-ben is. Ez a m\u00f3dos\u00edt\u00e1s az adatb\u00e1zis s\u00e9m\u00e1n nem v\u00e1ltoztat csup\u00e1n a code-first modellen.</p> CustomerSite.cs<pre><code>public virtual Customer? MainCustomer { get; set; }\n</code></pre> AdatvezDbContext.cs<pre><code>protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    // ...\n\n    modelBuilder.Entity&lt;CustomerSite&gt;(entity =&gt;\n    {\n        // ...\n\n        entity.HasOne(d =&gt; d.MainCustomer)\n            .WithMany(p =&gt; p.CustomerSites)\n            .HasForeignKey(d =&gt; d.CustomerId)\n            .HasConstraintName(\"FK__CustomerS__Custo__32E0915F\");\n    });\n\n    // ...\n}\n</code></pre> </li> <li> <p>M\u00f3dos\u00edtsunk az adatb\u00e1zis s\u00e9m\u00e1n - Migr\u00e1ci\u00f3k</p> <p>Jelenleg a code-first modell\u00fcnket scaffoldoltuk a megl\u00e9v\u0151 adatb\u00e1zisb\u00f3l, de nem szeretn\u00e9nk a tov\u00e1bbiakban database-first megk\u00f6zel\u00edt\u00e9ssel karbantartani a s\u00e9m\u00e1t. Helyette haszn\u00e1ljunk code-first migr\u00e1ci\u00f3kat az adatb\u00e1zis s\u00e9ma m\u00f3dos\u00edt\u00e1s\u00e1hoz.</p> <ul> <li> <p>Hozzunk l\u00e9tre egy kiindul\u00f3 migr\u00e1ci\u00f3t <code>Init</code> n\u00e9ven, ami a kiindul\u00f3 s\u00e9m\u00e1nkat fogja tartalmazni. A Package Manager Console-ban adjuk ki a k\u00f6vetkez\u0151 parancsot.</p> <pre><code>Add-Migration Init\n</code></pre> </li> <li> <p>Pr\u00f3b\u00e1ljuk meg lefuttatni ezt a migr\u00e1ci\u00f3t az adatb\u00e1zison a k\u00f6vetkez\u0151 paranccsal.</p> <pre><code>Update-Database\n</code></pre> <p>Ez \u00e9rtelemszer\u0171en nem siker\u00fcl, mert a migr\u00e1ci\u00f3ban l\u00e9v\u0151 utas\u00edt\u00e1sok egy \u00fcres adatb\u00e1zishoz k\u00e9pest szeretn\u00e9 migr\u00e1lni a s\u00e9m\u00e1t, viszont nek\u00fcnk az adatb\u00e1zisunkban m\u00e1r ez a s\u00e9ma l\u00e9tezik.  Az EF egy speci\u00e1lis t\u00e1bl\u00e1ban az <code>__EFMigrationHitory</code>-ban k\u00f6veti azt, hogy melyik migr\u00e1ci\u00f3 van m\u00e1r \u00e9rv\u00e9nyes\u00edtve az adatb\u00e1zison.</p> </li> <li> <p>Vegy\u00fck fel most k\u00e9zzel ebbe a t\u00e1bl\u00e1ba az <code>Init</code> migr\u00e1ci\u00f3t, amivel jelezz\u00fck az EF-nek, hogy ez m\u00e1r l\u00e9nyeg\u00e9ben lefutott. Figyelj\u00fcnk oda a migr\u00e1ci\u00f3 nev\u00e9re, aminek a d\u00e1tumot is tartalmaznia kell, ez\u00e9rt a Solution Explorerb\u0151l a f\u00e1jl nev\u00e9t m\u00e1soljuk ki!</p> <p></p> <p></p> </li> <li> <p>M\u00f3dos\u00edtsunk az adatb\u00e1zis s\u00e9m\u00e1n a code-first modell\u00fcnkben.</p> <ul> <li> <p>Legyen a <code>Product</code> entit\u00e1sunk <code>Price</code> tulajdons\u00e1ga <code>double</code> helyett <code>decimal</code>, ami hasznosabb p\u00e9nzmennyis\u00e9gek t\u00e1rol\u00e1s\u00e1ra. Illetve legyen k\u00f6telez\u0151 (nem nullozhat\u00f3).</p> Pruduct.cs<pre><code>public decimal Price { get; set; }\n</code></pre> </li> <li> <p>K\u00f6telez\u0151s\u00e9get \u00e9s az SQL mez\u0151 pontoss\u00e1g\u00e1t \u00e1ll\u00edtsuk be a <code>modelBuilder</code>rel, ez egy \u00faj sor lesz.</p> AdatvezDbContext.cs<pre><code>protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    // ...\n\n    modelBuilder.Entity&lt;Product&gt;(entity =&gt;\n    {\n        // ...\n\n        entity.Property(e =&gt; e.Price).HasPrecision(18, 2).IsRequired();\n\n        // ...\n    }\n\n    // ...\n}\n</code></pre> </li> <li> <p>K\u00e9sz\u00edts\u00fcnk migr\u00e1ci\u00f3t a v\u00e1ltoztat\u00e1sunkr\u00f3l \u00e9s ellen\u0151rizz\u00fck a gener\u00e1lt migr\u00e1ci\u00f3t</p> <pre><code>Add-Migration ProductPriceDecimal\n</code></pre> </li> <li> <p>Futtassuk le a migr\u00e1ci\u00f3t az adatb\u00e1zison \u00e9s ellen\u0151rizz\u00fck a hat\u00e1s\u00e1t az adatb\u00e1zisban</p> <pre><code>Update-Database\n</code></pre> </li> </ul> </li> </ul> </li> </ol>"},{"location":"seminar/ef/#feladat-2-lekerdezesek","title":"Feladat 2: Lek\u00e9rdez\u00e9sek","text":"<p>A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket LINQ haszn\u00e1lat\u00e1val. \u00cdrd ki konzolra az eredm\u00e9nyeket.</p> <p>Debugger seg\u00edts\u00e9g\u00e9vel n\u00e9zd meg, hogy milyen SQL utas\u00edt\u00e1s gener\u00e1l\u00f3dik: az <code>IQueryable</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3ra h\u00fazva az egeret l\u00e1that\u00f3 a gener\u00e1lt SQL, amint az eredm\u00e9nyhalmaz iter\u00e1l\u00e1sa elkezd\u0151dik.  A napl\u00f3z\u00e1s is bekapcsolhat\u00f3 az al\u00e1bbi paranccsal: </p> <p>Feladatok:</p> <ol> <li> <p>List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron!</p> </li> <li> <p>\u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek!</p> </li> <li> <p>K\u00e9sz\u00edts olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azokat a megrendel\u00e9seket, melyek \u00f6ssz\u00e9rt\u00e9ke t\u00f6bb mint 30.000 Ft! Az eredm\u00e9nyhalmaz ki\u00edr\u00e1sakor a vev\u0151 nev\u00e9t k\u00f6vet\u0151en soronk\u00e9nt szerepeljenek az egyes t\u00e9telek (Term\u00e9k n\u00e9v, mennyis\u00e9g, nett\u00f3 \u00e1r).</p> </li> <li> <p>List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait!</p> </li> <li> <p>List\u00e1zd ki azokat a vev\u0151 p\u00e1rokat, akiknek ugyanabban a v\u00e1rosban van telephely\u00fck. Egy p\u00e1r csak egyszer szerepeljen a list\u00e1ban.</p> </li> </ol> Megold\u00e1s <pre><code>using ConsoleApp3.Entities;\n\nusing Microsoft.EntityFrameworkCore;\n\nConsole.WriteLine(\"***** M\u00e1sodik feladat *****\");\nusing (var db = new AdatvezDbContext())\n{\n    // 2.1\n    Console.WriteLine(\"\\t2.1:\");\n    // Query szintaktika\n    var productStockQuery = from p in db.Products\n                            where p.Stock &gt; 30\n                            select p;\n\n    // Fluent / Method Chaining szintaktika\n    // var productStockQuery = db.Products.Where(p =&gt; p.Stock &gt; 30);\n\n    foreach (var p in productStockQuery)\n    {\n        Console.WriteLine($\"\\t\\tName={p.Name}\\tStock={p.Stock}\");\n    }\n\n    // 2.2\n    Console.WriteLine(\"\\t2.2:\");\n    var productOrderQuery = db.Products.Where(p =&gt; p.OrderItems.Count &gt;= 2);\n\n    // query szintaktika\n    //var productOrderQuery = from p in db.Products\n    //                        where p.OrderItems.Count &gt;= 2\n    //                        select p;\n\n    foreach (var p in productOrderQuery)\n    {\n        Console.WriteLine($\"\\t\\tName={p.Name}\");\n    }\n\n    // 2.3\n    Console.WriteLine(\"\\t2.3 helytelen megold\u00e1s\");\n    var orderTotalQuery = db.Orders.Where(o =&gt; o.OrderItems.Sum(oi =&gt; oi.Amount * oi.Price) &gt; 30000);\n\n    // query szintaktika\n    //var orderTotalQuery = from o in db.Orders\n    //                      where o.OrderItems.Sum(oi =&gt; oi.Amount * oi.Price) &gt; 30000\n    //                      select o;\n\n    //foreach (var o in orderTotalQuery)\n    //{\n    //    // Ez az\u00e9rt fog elsz\u00e1llni, mert EF Core-ban nincs alap\u00e9rtelmezetten Lazy Loading,\n    //    // \u00edgy a navig\u00e1ci\u00f3s propertyk nem lesznek felt\u00f6ltve\n    //    Console.WriteLine(\"\\t\\tName={0}\", o.CustomerSite.MainCustomer.Name);\n    //    foreach (var oi in o.OrderItems)\n    //    {\n    //        Console.WriteLine($\"\\t\\t\\tProduct={oi.Product.Name}\\tPrice={oi.Price}\\tAmount={oi.Amount}\");\n    //    }\n    //}\n\n    // 2.3 m\u00e1sodik megold\u00e1s\n    // Include-oljuk a hi\u00e1nyz\u00f3 navig\u00e1ci\u00f3s tulajdons\u00e1gokat.\n    // Expression alap\u00fa Include-hoz sz\u00fcks\u00e9g van a k\u00f6vetkez\u0151 n\u00e9vt\u00e9r import\u00e1l\u00e1s\u00e1ra: (CTRL + . is felaj\u00e1nlja a haszn\u00e1lat sor\u00e1n)\n    // using Microsoft.EntityFrameworkCore;\n\n    // Csak egy lek\u00e9rdez\u00e9st fog gener\u00e1lni, a Navigation Propertyket is felt\u00f6lti r\u00f6gt\u00f6n\n    Console.WriteLine(\"\\tc 2.3 helyes megold\u00e1s:\");\n    var orderTotalQuery2 = db.Orders\n        .Include(o =&gt; o.OrderItems)\n            .ThenInclude(oi =&gt; oi.Product)\n        .Include(o =&gt; o.CustomerSite)\n        .Include(o =&gt; o.CustomerSite.MainCustomer)\n        .Where(o =&gt; o.OrderItems.Sum(oi =&gt; oi.Amount * oi.Price) &gt; 30000);\n\n    // query szintaktika\n    //var orderTotalQuery2 = from o in db.Orders\n    //                       .Include(o =&gt; o.OrderItems)\n    //                           .ThenInclude(oi =&gt; oi.Product)\n    //                       .Include(o =&gt; o.CustomerSite)\n    //                       .Include(o =&gt; o.CustomerSite.MainCustomer)\n    //                   where o.OrderItems.Sum(oi =&gt; oi.Amount * oi.Price) &gt; 30000\n    //                   select o;\n\n    foreach (var o in orderTotalQuery2)\n    {\n        Console.WriteLine(\"\\t\\tName={0}\", o.CustomerSite.MainCustomer.Name);\n        foreach (var oi in o.OrderItems)\n        {\n            Console.WriteLine($\"\\t\\t\\tProduct={oi.Product.Name}\\tPrice={oi.Price}\\tAmount={oi.Amount}\");\n        }\n    }\n\n    // 2.4\n    Console.WriteLine(\"\\t2.4:\");\n    var maxPriceQuery = db.Products.Where(p =&gt; p.Price == db.Products.Max(a =&gt; a.Price));\n\n    // query szintaktika\n    //var maxPriceQuery = from p in db.Products\n    //                    where p.Price == db.Products.Max(a =&gt; a.Price)\n    //                    select p;\n\n    foreach (var t in maxPriceQuery)\n    {\n        Console.WriteLine($\"\\t\\tName={t.Name}\\tPrice={t.Price}\");\n    }\n\n    // 2.5\n    Console.WriteLine(\"\\t2.5:\");\n    var cityJoinQuery = db.CustomerSites\n        .Join(db.CustomerSites, s1 =&gt; s1.City, s2 =&gt; s2.City, (s1, s2) =&gt; new { s1, s2 })\n        .Where(x =&gt; x.s1.CustomerId &gt; x.s2.CustomerId)\n        .Select(x =&gt; new { c1 = x.s1.MainCustomer, c2 = x.s2.MainCustomer });\n\n    // query szintaktika\n    //var cityJoinQuery = from s1 in db.CustomerSites\n    //                    join s2 in db.CustomerSites on s1.City equals s2.City\n    //                    where s1.CustomerId &gt; s2.CustomerId\n    //                    select new { c1 = s1.MainCustomer, c2 = s2.MainCustomer };\n\n    foreach (var v in cityJoinQuery)\n    {\n        Console.WriteLine($\"\\t\\tCustomer 1={v.c1.Name}\\tCustomer 2={v.c2.Name}\");\n    }\n}\n</code></pre>"},{"location":"seminar/ef/#feladat-3-adatmodositasok","title":"Feladat 3: Adatm\u00f3dos\u00edt\u00e1sok","text":"<p>A <code>DbContext</code> nem csak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl besz\u00far\u00e1sok, m\u00f3dos\u00edt\u00e1sok \u00e9s t\u00f6rl\u00e9sek is v\u00e9grehajthat\u00f3ak.</p> <ol> <li> <p>\u00cdrj olyan LINQ-ra \u00e9p\u00fcl\u0151 C# k\u00f3dot, amely az \"LEGO\" kateg\u00f3ri\u00e1s term\u00e9kek \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal!</p> </li> <li> <p>Hozz l\u00e9tre egy \u00faj kateg\u00f3ri\u00e1t Expensive toys n\u00e9ven, \u00e9s sorold \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft!</p> </li> </ol> Megold\u00e1s <pre><code>Console.WriteLine(\"***** Harmadik feladat *****\");\nusing (var db = new AdatvezDbContext())\n{\n    // 3.1\n    Console.WriteLine(\"\\t3.1:\");\n    var legoProductsQuery = db.Products.Where(p =&gt; p.Category.Name == \"LEGO\");\n\n    Console.WriteLine(\"\\tM\u00f3dos\u00edt\u00e1s el\u0151tt:\");\n    // A ToList, de sim\u00e1n a foreach is adatb\u00e1zis k\u00e9r\u00e9st induk\u00e1l\n    foreach (var p in legoProductsQuery.ToList())\n    {\n        Console.WriteLine($\"\\t\\t\\tName={p.Name}\\tStock={p.Stock}\\tPrice={p.Price}\");\n        p.Price = 1.1m * p.Price;\n    }\n\n    db.SaveChanges();\n\n    Console.WriteLine(\"\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n:\");\n    foreach (var p in legoProductsQuery.ToList())\n    {\n        Console.WriteLine($\"\\t\\t\\tName={p.Name}\\tStock={p.Stock}\\tPrice={p.Price}\");\n    }\n\n    // 3.2\n    Console.WriteLine(\"\\t3.2:\");\n    var expensiveToysCategory = db.Categories\n        .Where(c =&gt; c.Name == \"Expensive Toys\")\n        .SingleOrDefault();\n\n    if (expensiveToysCategory == null)\n    {\n        expensiveToysCategory = new Category { Name = \"Expensive toys\" };\n\n        // Erre nem feltetlenul van szukseg: ha van atrendelt termek, ahhoz hozzakotjuk a kategoria entitast\n        // es bekerul automatikusan a kategoria tablaba is. Igy viszont, hogy explicit felvesszuk, (1) jobban\n        // kifejezi a szandekunkat; es (2) akkor is felvesszuk a kategoriat, ha vegul nincs atrendelt termek.\n        db.Categories.Add(expensiveToysCategory);\n    }\n\n    var expensiveProductsQuery = db.Products.Where(p =&gt; p.Price &gt; 8000);\n\n    foreach (var p in expensiveProductsQuery.ToList())\n    {\n        p.Category = expensiveToysCategory;\n    }\n\n    db.SaveChanges();\n\n    expensiveProductsQuery = db.Products\n        .Include(p =&gt; p.Category)\n        .Where(p =&gt; p.Category.Name == \"Expensive toys\");\n\n    foreach (var p in expensiveProductsQuery)\n    {\n        Console.WriteLine($\"\\t\\tName={p.Name}\\tPrice={p.Price}\\tCategory={p.Category.Name}\");\n    }\n}\n</code></pre>"},{"location":"seminar/ef/#feladat-4-kitekintes-tarolt-eljarasok-hasznalata","title":"Feladat 4: Kitekint\u00e9s: T\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata","text":"<p>K\u00e9sz\u00edts egy t\u00e1rolt elj\u00e1r\u00e1st egy \u00faj code first migr\u00e1ci\u00f3n kereszt\u00fcl, amely kilist\u00e1zza azon term\u00e9keket melyb\u0151l legal\u00e1bb egy megadott darabsz\u00e1m felett adtak el. H\u00edvd meg a t\u00e1rolt elj\u00e1r\u00e1st C# k\u00f3db\u00f3l!</p> <ol> <li> <p>K\u00e9sz\u00edtsd egy \u00faj \u00fcres migr\u00e1ci\u00f3t <code>PopularProducts_SP</code> n\u00e9ven.</p> <pre><code>Add-Migration PopularProducts_SP\n</code></pre> </li> <li> <p>Hozd l\u00e9tre a t\u00e1rolt elj\u00e1r\u00e1st az al\u00e1bbi k\u00f3ddal. A vissza ir\u00e1ny\u00fa migr\u00e1ci\u00f3 meg\u00edr\u00e1s\u00e1t\u00f3l most tekints\u00fcnk el, ahol egy\u00e9bk\u00e9nt t\u00f6r\u00f6lni kellene a t\u00e1rolt elj\u00e1r\u00e1st.</p> <pre><code>public partial class PopularProducts_SP : Migration\n{\n    protected override void Up(MigrationBuilder migrationBuilder)\n    {\n        migrationBuilder.Sql(\n@\"CREATE OR ALTER PROCEDURE dbo.PopularProducts (@MinAmount int = 10)\nAS\nSELECT Product.* \nFROM Product \nINNER JOIN\n(\n    SELECT OrderItem.ProductID\n    FROM OrderItem\n    GROUP BY OrderItem.ProductID\n    HAVING SUM(OrderItem.Amount) &gt; @MinAmount\n) a ON Product.ID = a.ProductID\");\n    }\n\n    protected override void Down(MigrationBuilder migrationBuilder)\n    {\n    }\n}\n</code></pre> </li> <li> <p>Friss\u00edtsd az adatb\u00e1zist \u00e9s ellen\u0151rizd az eredm\u00e9ny\u00e9t!</p> <pre><code>Update-Database\n</code></pre> </li> <li> <p>H\u00edvd meg a t\u00e1rolt elj\u00e1r\u00e1st a kontextus <code>Product</code> <code>DbSet</code>-j\u00e9r\u0151l indulva a <code>FromSqlInterpolated</code> vagy <code>FromSqlRaw</code> met\u00f3dusokkal</p> Megold\u00e1s <pre><code>Console.WriteLine(\"***** Negyedik feladat *****\");\nusing (var db = new AdatvezDbContext())\n{\n    var popularProducts = db.Products.FromSqlInterpolated($\"EXECUTE dbo.PopularProducts @MinAmount={5}\");\n    foreach (var p in popularProducts)\n    {\n        Console.WriteLine($\"\\tName={p.Name}\\tStock={p.Stock}\\tPrice={p.Price}\");\n    }\n}\n</code></pre> <p><code>FromSqlInterpolated</code> vs. <code>FromSqlRaw</code></p> <p>A fenti megold\u00e1sban a <code>FromSqlInterpolated</code> f\u00fcggv\u00e9nnyel ker\u00fcl defini\u00e1l\u00e1sra a h\u00edv\u00e1s, ahol a nev\u00e9b\u0151l is ad\u00f3d\u00f3an az interpol\u00e1land\u00f3 stringet m\u00e9g az EF feldolgozza \u00e9s az interpol\u00e1ci\u00f3t nem hagyom\u00e1nyosan stringk\u00e9nt v\u00e9gzi el, hanem <code>SqlParameter</code>eket helyettes\u00edt be az SQL injection elleni v\u00e9delem \u00e9rdek\u00e9ben.</p> <p>Ezzel szemben a <code>FromSqlraw</code> f\u00fcggv\u00e9ny haszn\u00e1lata sor\u00e1n tilos string interpol\u00e1ci\u00f3t haszn\u00e1lni, helyette nek\u00fcnk k\u00e9zzel kell az <code>SqlParameter</code>eket l\u00e9trehozni \u00e9s placeholdereket defini\u00e1lni az utas\u00edt\u00e1sban</p> </li> </ol>"},{"location":"seminar/jpa/","title":"JPA &amp; Spring Data","text":"<p>A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a JPA \u00e9s a Spring Data haszn\u00e1lat\u00e1t. A f\u0151bb t\u00e9m\u00e1k: entit\u00e1sok fejleszt\u00e9se, lek\u00e9rdez\u00e9sek megfogalmaz\u00e1sa k\u00fcl\u00f6nb\u00f6z\u0151 m\u00f3dokon, m\u00f3dos\u00edt\u00e1sok v\u00e9grehajt\u00e1sa. A k\u00f3dokat egy webalkalmaz\u00e1s projektbe integr\u00e1ljuk, amiben a projekt alapvet\u0151 konfigur\u00e1ci\u00f3ja \u00e9s egy tesztel\u00e9shez haszn\u00e1lhat\u00f3 egyszer\u0171 webes fel\u00fcletet m\u00e1r k\u00e9szen \u00e1ll.</p>"},{"location":"seminar/jpa/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Spring Tool Suite (Eclipse alap\u00fa IDE)</li> <li>Microsoft SQL Server Express edition (localdb ez\u00fattal nem j\u00f3)</li> <li>SQL Server Management Studio</li> <li>Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql</li> <li>Kiindul\u00f3 webalkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-jpa-kiindulo</li> </ul>"},{"location":"seminar/jpa/#amit-erdemes-atnezned","title":"Amit \u00e9rdemes \u00e1tn\u00e9zned","text":"<ul> <li>JPA el\u0151ad\u00e1s</li> <li>EJB, Spring el\u0151ad\u00e1s</li> </ul>"},{"location":"seminar/jpa/#gyakorlat-menete","title":"Gyakorlat menete","text":"<p>A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be.</p> <p>Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!</p>"},{"location":"seminar/jpa/#tippek-az-ide-hasznalatahoz","title":"Tippek az IDE haszn\u00e1lat\u00e1hoz","text":"<ul> <li>T\u00edpus (oszt\u00e1ly, interf\u00e9sz, enum) keres\u00e9se: Ctrl+Shift+T (Nem \u00e9rdemes a Project explorer-ben a mapp\u00e1kat nyitogatni)</li> <li>F\u00e1jl keres\u00e9se: Ctrl+Shift+R</li> <li>Hi\u00e1nyz\u00f3 importok megjav\u00edt\u00e1sa: Ctrl+Shift+O</li> <li>K\u00f3d form\u00e1z\u00e1sa: Ctrl+Shift+F</li> <li>Ha a Java Resources alatt egy package-en jobb klikk / New Class/Interfaces, akkor abba a package-be rakja az \u00faj elemet</li> <li>Ha a n\u00e9zeteket becsukjuk/\u00e1trendezz\u00fck, a default elrendez\u00e9s vissza\u00e1ll\u00edthat\u00f3: Window / Reset perspective</li> <li>Font megn\u00f6vel\u00e9se (a tan\u00e1ri g\u00e9pen hasznos):<ul> <li>Window men\u00fc / Preferences, ott elkezdj\u00fck g\u00e9pelni, hogy font, \u00edgy megtal\u00e1lja azt a be\u00e1ll\u00edt\u00e1st, hogy Fonts and Colors</li> <li>Azt kiv\u00e1lasztva, a Basic kateg\u00f3ria alatt kell a Text Fontot kijel\u00f6lni, \u00e9s a m\u00e9ret\u00e9t pl. 18-asra \u00e1ll\u00edtani</li> </ul> </li> </ul>"},{"location":"seminar/jpa/#feladat-0-adatbazis-letrehozasa","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa","text":"<ol> <li> <p>Csatlakozzunk Microsoft SQL Server Management Studio-val a szerverhez. Ez\u00fattal nem localdb-t haszn\u00e1lunk, a szerver c\u00edme: <code>localhost\\sqlexpress</code>. A bejelentkez\u00e9shez SQL Server Authentication m\u00f3dot v\u00e1lasszuk, a felhaszn\u00e1l\u00f3n\u00e9v \u00e9s a jelsz\u00f3 is <code>sa</code>.</p> </li> <li> <p>Hozzunk l\u00e9tre egy <code>adatvez</code> nev\u0171 adatb\u00e1zist. \u00dcgyelj\u00fcnk a n\u00e9vre, k\u00fcl\u00f6nben a Java projektben m\u00f3dos\u00edtanunk kell. Az adatb\u00e1zis l\u00e9trehoz\u00e1s\u00e1nak mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban. Ha a g\u00e9pen m\u00e1r l\u00e9tezik az adatb\u00e1zis, akkor nem kell \u00fajat l\u00e9trehozni.</p> </li> <li> <p>Futtassuk le az adatb\u00e1zis inicializ\u00e1l\u00f3 sql szkriptet az adatb\u00e1zisban. Akkor is futtassuk le a szkriptet, ha m\u00e1r l\u00e9tezne az adatb\u00e1zis (hogy a kezdeti \u00e1llapotot visszakapjuk.)</p> </li> </ol>"},{"location":"seminar/jpa/#feladat-1-ide-inditasa","title":"Feladat 1: IDE ind\u00edt\u00e1sa","text":"<ol> <li>Ind\u00edtsuk el a Spring Tool Suite-ot innen: <code>C:\\Tools\\hatteralkalmazasok\\eclipse\\SpringToolSuite4.exe</code>.</li> <li>Ind\u00edt\u00e1skor megk\u00e9rdezi, hova akarunk dolgozni (workspace), itt v\u00e1lasszuk ezt: <code>C:\\Tools\\hatteralkalmazasok\\workspaces\\adatvez</code></li> <li>Ha az indul\u00e1s ut\u00e1n a Project Explorer-ben ott van egy kor\u00e1bbi gyakorlatr\u00f3l a webshop nev\u0171 projekt, azt t\u00f6r\u00f6lj\u00fck ki: a projekten jobb klikk / Delete, amikor r\u00e1k\u00e9rdez, pip\u00e1ljuk be, hogy a f\u00e1jlrendszerr\u0151l is t\u00f6rl\u0151dj\u00f6n.</li> </ol>"},{"location":"seminar/jpa/#feladat-2-projekt-importalasa","title":"Feladat 2: Projekt import\u00e1l\u00e1sa","text":"<ol> <li>T\u00f6lts\u00fck le a m\u00e9r\u00e9shez tartoz\u00f3 projekt v\u00e1zat!<ul> <li>Nyissunk egy command prompt-ot</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul <code>c:\\work\\NEPTUN</code></li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone --depth 1 https://github.com/bmeviauac01/gyakorlat-jpa-kiindulo.git</code></li> </ul> </li> <li>Import\u00e1ljuk a let\u00f6lt\u00f6tt forr\u00e1sk\u00f3dot a workspace-be:<ul> <li>Nyissuk meg a File / Import...-ot</li> <li>Kezdj\u00fck el g\u00e9pelni a textboxba, hogy Existing Maven Projects, \u00edgy r\u00e1 fog sz\u0171rni erre a t\u00edpusra, \u00e9s v\u00e1lasszuk ki ezt</li> <li>Keress\u00fck meg a let\u00f6lt\u00f6tt webshop projektet (a <code>webshop</code> mapp\u00e1t a saj\u00e1t k\u00f6nyvt\u00e1runk alatt), Open Folder, ut\u00e1na a dialogban pip\u00e1ljuk be a webshop-ot (lehet, hogy by default be lesz pip\u00e1lva a pom.xml)</li> <li>Finish</li> </ul> </li> <li> <p>Tekints\u00fck \u00e1t r\u00f6viden a projektet:</p> <ul> <li> <p>Ez egy maven alap\u00fa projekt. A maven parancssori build eszk\u00f6z, ami IDE-khez is illeszthet\u0151. Fontos tulajdons\u00e1ga, hogy k\u00e9pes a sz\u00fcks\u00e9ges library f\u00fcgg\u0151s\u00e9geket online repository-kb\u00f3l let\u00f6lteni. Ha megnyitjuk a projekt gy\u00f6ker\u00e9ben <code>pom.xml</code>-t, a maven konfig f\u00e1jlj\u00e1t, dependency tagekben f\u00fcgg\u0151s\u00e9geket l\u00e1tunk, amik (tranzit\u00edv m\u00f3don) beh\u00fazz\u00e1k a Hibernate-et mint JPA implement\u00e1ci\u00f3t, a Spring Boot-ot, a Spring Data-t \u00e9s a webr\u00e9teghez sz\u00fcks\u00e9ges Spring MVC-t \u00e9s Thymeleaf-et. A laborban a maven offline m\u0171k\u00f6d\u00e9sre van konfigur\u00e1lva, \u00e9s el\u0151re le van t\u00f6ltve az \u00f6sszes f\u00fcgg\u0151s\u00e9g, \u00edgy megel\u0151zz\u00fck az esetleges h\u00e1l\u00f3zati probl\u00e9m\u00e1kat.</p> </li> <li> <p>Az application.properties-ben van p\u00e1r alapvet\u0151 be\u00e1ll\u00edt\u00e1s, itt a DB el\u00e9r\u00e9shez ellen\u0151rizz\u00fck az adatb\u00e1zis URL-t (spring.datasource.url), a usernevet (spring.datasource.username) \u00e9s jelsz\u00f3t (spring.datasource.password). Klasszikus Java EE alkalmaz\u00e1sban a <code>persistence.xml</code>-be \u00edrn\u00e1nk be az adatb\u00e1zis JNDI nev\u00e9t, de a Spring Boot XML n\u00e9lk\u00fcli konfigur\u00e1ci\u00f3t is t\u00e1mogat, itt ezt haszn\u00e1ljuk ki.</p> </li> <li> <p>A <code>WebshopApplication</code> a Spring Boot alkalmaz\u00e1s bel\u00e9p\u00e9si pontja. Egy hagyom\u00e1nyos webalkalmaz\u00e1st egy k\u00fcl\u00f6n processzben fut\u00f3 webkont\u00e9nerre (pl. Tomcat, Jetty) kellene telep\u00edteni. Spring Boot-os fejleszt\u00e9s eset\u00e9ben viszont maga a Spring Boot fog elind\u00edtani egy be\u00e1gyazott webkont\u00e9nert (alap\u00e9rtelmez\u00e9sben Tomcat-et).</p> </li> <li> <p>A webes fel\u00fclet egyetlen oldal, az <code>src\\main\\resources\\templates\\testPage.html</code>. Ebbe nem fogunk majd beleny\u00falni. Standard html + Thymeleaf-es attrib\u00fatumok l\u00e1that\u00f3ak benne.</p> </li> <li> <p><code>WebshopController</code>: a webr\u00e9teget megval\u00f3s\u00edt\u00f3 controller oszt\u00e1ly, ennek met\u00f3dusai kezelik az alkalmaz\u00e1shoz \u00e9rkez\u0151 HTTP k\u00e9r\u00e9seket. Jellemz\u0151en lek\u00e9rdez\u00e9sek eredm\u00e9ny\u00e9t akarjuk megjelen\u00edteni az oldalon, ez\u00e9rt a lek\u00e9rdez\u00e9s eredm\u00e9ny\u00e9t a modellbe tessz\u00fck valamilyen n\u00e9ven, amire hivatkozni tudunk a Thymeleaf seg\u00edts\u00e9g\u00e9vel. A <code>//TODO</code> r\u00e9szekre kell majd bek\u00f6tni az egyes feladatokat megval\u00f3s\u00edt\u00f3 met\u00f3dusok megh\u00edv\u00e1s\u00e1t.</p> </li> </ul> </li> </ol>"},{"location":"seminar/jpa/#feladat-3-entitasok-attekintese","title":"Feladat 3: Entit\u00e1sok \u00e1ttekint\u00e9se","text":"<ul> <li> <p>Az entit\u00e1sok m\u00e1r el\u0151re k\u00e9szen a <code>hu.bme.aut.adatvez.webshop.model</code> package-ben tal\u00e1lhat\u00f3k. Ezeket \u00e1ltal\u00e1ban vagy k\u00e9zzel \u00edrjuk meg, vagy gener\u00e1ljuk a DB t\u00e1bl\u00e1kb\u00f3l pl. az Eclipse-es JPA plugin seg\u00edts\u00e9g\u00e9vel.</p> </li> <li> <p>Az entit\u00e1sok k\u00f6z\u00fcl nyissunk meg egyet, pl. <code>Vat</code>, l\u00e1tszik benne a <code>@Entity</code>, a <code>@Id</code> annot\u00e1ci\u00f3, illetve a kapcsolatok defini\u00e1l\u00e1s\u00e1ra <code>@OneToMany</code> vagy <code>@ManyToOne</code></p> </li> <li> <p>Az entit\u00e1sokhoz a Criteria API haszn\u00e1latakor hasznos metamodel oszt\u00e1lyok is gener\u00e1l\u00f3dnak, ezekb\u0151l n\u00e9zz\u00fcnk meg egyet a <code>target\\generated-sources\\apt</code> alatt (A <code>pom.xml</code>-ben l\u00e1that\u00f3 maven-processor-plugin gener\u00e1lja egy\u00e9bk\u00e9nt \u0151ket a build sor\u00e1n.)</p> </li> </ul>"},{"location":"seminar/jpa/#feladat-4-lekerdezesek","title":"Feladat 4: Lek\u00e9rdez\u00e9sek","text":"<p>A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket! A lek\u00e9rdez\u00e9seket JPA \u00e9s Spring Data haszn\u00e1lata eset\u00e9n t\u00f6bb m\u00f3don is megval\u00f3s\u00edthatjuk. Az al\u00e1bbi feladatokban azt is megadjuk, milyen m\u00f3don kell elk\u00e9sz\u00edteni a lek\u00e9rdez\u00e9st, hogy mindegyikre l\u00e1ssunk p\u00e9ld\u00e1t.</p> <p>Fontos megjegyezni, hogy ezek a m\u00f3dszerre vonatkoz\u00f3 megk\u00f6t\u00e9sek csak oktat\u00e1si szempontok miatt szerepelnek, val\u00f3j\u00e1ban b\u00e1rmelyik m\u00f3dszerrel b\u00e1rmelyik lek\u00e9rdez\u00e9s megval\u00f3s\u00edthat\u00f3 lenne.</p> <p>Az egyes feladatokat megval\u00f3s\u00edt\u00f3 met\u00f3dusokat mindig a <code>WebshopController</code> oszt\u00e1ly megfelel\u0151 <code>//TODO</code> kommentjein\u00e9l kell megh\u00edvni, majd a webalkalmaz\u00e1st futtatni \u00e9s b\u00f6ng\u00e9sz\u0151b\u0151l tesztelni a http://localhost:9080 URL-en.</p> <p>a) List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron! M\u00f3dszer: Spring Data repository interf\u00e9sz, met\u00f3dusn\u00e9vb\u0151l sz\u00e1rmaztatott lek\u00e9rdez\u00e9s.</p> <p>b) \u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek! M\u00f3dszer: Spring Data repository custom implement\u00e1ci\u00f3val, injekt\u00e1lt EntityManagerrel k\u00e9sz\u00edtett JPQL query.</p> <p>c) List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait! M\u00f3dszer: Named query, amelyet Spring Data repository-b\u00f3l h\u00edvunk meg, vagy custom implement\u00e1ci\u00f3b\u00f3l, injekt\u00e1lt EntityManagerrel h\u00edvunk meg, vagy a met\u00f3dusn\u00e9v \u00e9s query n\u00e9v egyez\u00e9se alapj\u00e1n.</p> <p>Fut\u00e1s k\u00f6zben a Console n\u00e9zetben l\u00e1tsz\u00f3dnak a Hibernate \u00e1ltal gener\u00e1lt SQL utas\u00edt\u00e1sok az application.properties-beli <code>spring.jpa.show-sql=true</code> konfig miatt.</p>"},{"location":"seminar/jpa/#futtatas","title":"Futtat\u00e1s","text":"<p>Jobb klikk a webshop projekten &gt; Debug As / Spring Boot App Ez debug m\u00f3dban ind\u00edtja az alkalmaz\u00e1st, aminek hat\u00e1s\u00e1ra a be\u00e1gyazott webkont\u00e9ner elindul, \u00e9s b\u00f6ng\u00e9sz\u0151b\u0151l a http://localhost:9080 URL-en el\u00e9rhet\u0151 az alkalmaz\u00e1s. Ha ezt egyszer jobb klikkel megcsin\u00e1ltuk, akkor k\u00e9s\u0151bb a toolbar Debug ikonj\u00e1t lenyitva is megtehetj\u00fck:</p> <p></p> <p>A fut\u00f3 alkalmaz\u00e1st a Console n\u00e9zet piros Terminate ikonj\u00e1val lehet le\u00e1ll\u00edtani. Ha le\u00e1ll\u00edt\u00e1s n\u00e9lk\u00fcl pr\u00f3b\u00e1ljuk \u00fajra futtatni, akkor a m\u00e1sodik processz \u00fctk\u00f6z\u00e9st jelent a 9080-as porton, \u00e9s le\u00e1ll. Ilyenkor a sikertelen m\u00e1sodik futtat\u00e1s l\u00e1tszik a Console n\u00e9zetben, a Terminate gomb pedig inakt\u00edv, mivel ez a fut\u00e1s m\u00e1r le\u00e1llt. Nyomjuk meg a Terminate ikon melletti dupla sz\u00fcrke X ikont, ez el fogja t\u00e1vol\u00edtani a m\u00e1r le\u00e1ll\u00edtott futtat\u00e1sokat, \u00e9s csak az akt\u00edv futtat\u00e1s l\u00e1tszik, amin viszont m\u00e1r tudunk Terminate-et nyomni.</p> <p>Ha a teljes Console n\u00e9zetet bez\u00e1rjuk v\u00e9letlen\u00fcl, el\u0151 lehet szedni Alt+Shift+Q, C gyorsbillenty\u0171vel, vagy Window / Show View / Console men\u00fcvel.</p> <p>Az \u00fajrafuttat\u00e1shoz az F11-et is haszn\u00e1lhatjuk. Az el\u0151re elk\u00e9sz\u00edtett workspace-ben az is be van \u00e1ll\u00edtva, hogy ilyenkor a m\u00e1r fut\u00f3 alkalmaz\u00e1st le\u00e1ll\u00edtsa az \u00faj p\u00e9ld\u00e1ny futtat\u00e1sa el\u0151tt, teh\u00e1t a k\u00e9zi le\u00e1ll\u00edt\u00e1s (Terminate) megsp\u00f3rolhat\u00f3.</p> <p>A debug m\u00f3dban val\u00f3 futtat\u00e1s jellegzetess\u00e9ge, hogy a HTML \u00e9s bizonyos Java k\u00f3d m\u00f3dos\u00edt\u00e1sok azonnal \u00e9letbe l\u00e9pnek. (A b\u00f6ng\u00e9sz\u0151t persze friss\u00edteni kell.) \u00dajra kell viszont ind\u00edtani az alkalmaz\u00e1st, ha a Java k\u00f3dban:</p> <ul> <li>\u00faj t\u00edpust adtunk hozz\u00e1</li> <li>annot\u00e1ci\u00f3t adtunk hozz\u00e1/t\u00f6r\u00f6lt\u00fcnk/m\u00f3dos\u00edtottunk</li> <li>\u00faj oszt\u00e1ly- vagy tagv\u00e1ltoz\u00f3t, met\u00f3dust vett\u00fcnk fel</li> <li>met\u00f3dus szignat\u00far\u00e1t m\u00f3dos\u00edtottunk</li> </ul> <p>R\u00f6viden: a met\u00f3dus t\u00f6rzs\u00f6n bel\u00fcli v\u00e1ltoz\u00e1sokon k\u00edv\u00fcl mindig \u00fajraind\u00edt\u00e1s lesz sz\u00fcks\u00e9ges.</p> Megold\u00e1s <p>4.a feladat</p> <p>Nyissuk meg a <code>dao</code> package-ben l\u00e9v\u0151 <code>ProductRepository</code> interf\u00e9szt, amely a Spring Data-s <code>JpaRepository</code>-b\u00f3l sz\u00e1rmazik (\u00e9s az egyel\u0151re \u00fcres <code>ProductRepositoryCustom</code>-b\u00f3l). Tal\u00e1lunk benne k\u00e9s\u0151bbi feladathoz kapcsol\u00f3d\u00f3 met\u00f3dusokat, azokat csak figyelj\u00fck meg. Valamelyik <code>@Query</code> annot\u00e1ci\u00f3val defini\u00e1lja a futtatand\u00f3 lek\u00e9rdez\u00e9st, valamelyikn\u00e9l az is hi\u00e1nyzik. Nek\u00fcnk sem lesz sz\u00fcks\u00e9g <code>@Query</code> annot\u00e1ci\u00f3ra, mert a met\u00f3dus neve alapj\u00e1n a Spring Data k\u00e9pes kital\u00e1lni a query-t. Tegy\u00fck teh\u00e1t bele ezt az \u00faj met\u00f3dust:</p> <pre><code>package hu.bme.aut.adatvez.webshop.dao;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport hu.bme.aut.adatvez.webshop.model.Product;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt;, ProductRepositoryCustom {\n  ...\n  List&lt;Product&gt; findByStockGreaterThan(BigDecimal limit);\n}\n</code></pre> <p>A <code>WebshopController</code>-ben m\u00e1r be van injekt\u00e1lva egy <code>ProductRepository</code> t\u00edpus\u00fa tagv\u00e1ltoz\u00f3, h\u00edvjuk meg rajta a met\u00f3dust az 4.a TODO-n\u00e1l:</p> <pre><code>@Controller\npublic class WebshopController {\n\n  @Autowired\n  ProductRepository productRepository;\n\n  //...\n  // 4.a feladat\n  private List&lt;Product&gt; findProductsOver30() {\n    return productRepository.findByStockGreaterThan(BigDecimal.valueOf(30));\n  }\n}\n</code></pre> <p>4.b feladat</p> <p>A <code>dao</code> package-ben l\u00e9v\u0151 <code>ProductRepositoryCustom</code> interf\u00e9szbe vegy\u00fck fel egy <code>findProductsOrderedAtLeastTwice</code> nev\u0171 met\u00f3dust:</p> <pre><code>package hu.bme.aut.adatvez.webshop.dao;\n\nimport hu.bme.aut.adatvez.webshop.model.Product;\nimport java.util.List;\n\npublic interface ProductRepositoryCustom {\n  List&lt;Product&gt; findProductsOrderedAtLeastTwice();\n}\n</code></pre> <p>A dao package-ben l\u00e9v\u0151 <code>ProductRepositoryImpl</code> oszt\u00e1ly hib\u00e1s lesz emiatt, mert nem implement\u00e1lja a <code>ProductRepositoryCustom</code>-ot. Nyissuk meg az oszt\u00e1lyt, \u00e9s az oszt\u00e1ly elej\u00e9n, a sor elej\u00e9n megjelen\u0151 kis villanyk\u00f6rt\u00e9re kattintva belegener\u00e1ltathatjuk a nem implement\u00e1lt met\u00f3dus v\u00e1z\u00e1t:</p> <p></p> <p>Ut\u00e1na a t\u00f6rzsbe \u00edrhatjuk az implement\u00e1ci\u00f3t, melynek l\u00e9nyege: injekt\u00e1lt EntityManager-rel hozzuk l\u00e9tre \u00e9s futtatjuk le a query-t. (Most l\u00e1tszik igaz\u00e1n, hogy az el\u0151z\u0151, Spring Data-s megold\u00e1s mennyi boilerplate k\u00f3dot sp\u00f3rolt meg nek\u00fcnk.)</p> <pre><code>package hu.bme.aut.adatvez.webshop.dao;\n\nimport hu.bme.aut.adatvez.webshop.model.Product;\n\nimport java.util.List;\n\nimport jakarta.persistence.EntityManager;\nimport jakarta.persistence.PersistenceContext;\n\npublic class ProductRepositoryImpl implements ProductRepositoryCustom {\n\n  @PersistenceContext\n  EntityManager em;\n\n  @Override\n  public List&lt;Product&gt; findProductsOrderedAtLeastTwice(){\n    return em.createQuery(\"SELECT DISTINCT p FROM Product p \" +\n                          \"LEFT JOIN FETCH p.orderitems \" +\n                          \"WHERE size(p.orderitems) &gt;= :itemsMin\", Product.class)\n          .setParameter(\"itemsMin\", 2)\n          .getResultList();\n  }\n}\n</code></pre> <p>Megjegyz\u00e9s a megold\u00e1shoz: az els\u0151 \u00f6tlet\u00fcnk ez lehetne: <code>SELECT p FROM Product p WHERE size(p.orderitems) /= :itemsMin</code>. \u00cdrjuk be \u00e9s pr\u00f3b\u00e1ljuk ki el\u0151bb ezt, ilyenkor viszont <code>org.hibernate.LazyInitializationException</code> dob\u00f3dik tesztel\u00e9skor, mert lecsatolt \u00e1llapotban akarunk kapcsol\u00f3d\u00f3 entit\u00e1st el\u00e9rni (amikor a t\u00e1bl\u00e1zatot gener\u00e1lja a webr\u00e9teg, \u00e9s az orderitems list\u00e1ra hivatkozunk). Lehets\u00e9ges megold\u00e1sok:</p> <ul> <li>Az application.properties-ben <code>spring.jpa.open-in-view=true</code> (ez lenne am\u00fagy a default Spring Boot eset\u00e9ben, de a p\u00e9lda projektben direkt false-ra van \u00e1ll\u00edtva): Ilyenkor az EntityManager m\u00e1r a webes k\u00e9r\u00e9s legelej\u00e9n l\u00e9trej\u00f6n, \u00e9s csak a view renderel\u00e9se ut\u00e1n z\u00e1r\u00f3dik be, vagyis a Spring bean-beli met\u00f3dusok visszat\u00e9r\u00e9se ut\u00e1n is menedzselt \u00e1llapotban lenne a Product entit\u00e1s, \u00e9s el lehetne k\u00e9rni a kapcsol\u00f3d\u00f3 orderitems list\u00e1t.</li> <li>vagy <code>@OneToMany(fetch=EAGER)</code> az orderitems v\u00e1ltoz\u00f3ra</li> <li>vagy EntityGraph defini\u00e1l\u00e1sa \u00e9s annak alkalmaz\u00e1sa a query l\u00e9trehoz\u00e1sakor</li> <li>vagy <code>LEFT JOIN FETCH</code>, mi ezt v\u00e1lasztottuk a fenti megold\u00e1sban. E mell\u00e9 a <code>DISTINCT</code> is kell, k\u00fcl\u00f6nben minden kapcsol\u00f3d\u00f3 Orderitem p\u00e9ld\u00e1nyra k\u00fcl\u00f6n Product sor is lesz.</li> </ul> <p>A megh\u00edv\u00e1s a <code>WebshopController</code>-ben trivi\u00e1lis:</p> <pre><code>// 4.b feladat\nprivate List&lt;Product&gt; findProductsOrderedAtLeastTwice() {\n  // TODO\n  return productRepository.findProductsOrderedAtLeastTwice();\n}\n</code></pre> <p>4.c feladat</p> <p>A <code>Product</code> oszt\u00e1lyt nyissuk meg, ott a gyorsabb halad\u00e1s \u00e9rdek\u00e9ben m\u00e1r fogunk tal\u00e1lni k\u00e9sz named query-ket, a m\u00e1sodikat kell haszn\u00e1lnunk:</p> <pre><code>@NamedQueries({\n@NamedQuery(name=\"Product.findAll\", query=\"SELECT p FROM Product p\"),\n@NamedQuery(name=\"Product.findMostExpensive\", query=\"SELECT p FROM Product p WHERE p.price IN (SELECT MAX(p2.price) FROM Product p2)\")\n})\n</code></pre> <p>A named query-t k\u00e9t m\u00f3don is megh\u00edvhatjuk. Ha lass\u00fa a halad\u00e1s, el\u00e9g az els\u0151 m\u00f3dszerrel megcsin\u00e1lni. Az els\u0151 m\u00f3dszer, hogy a named query-vel egyez\u0151 nev\u0171 met\u00f3dust tesz\u00fcnk a <code>ProductRepository</code>-ba (lesz\u00e1m\u00edtva a Product. el\u0151tagot.) Vagyis:</p> <pre><code>public List&lt;Product&gt; findMostExpensive();\n</code></pre> <p>A m\u00e1sik lehet\u0151s\u00e9g, hogy a <code>ProductRepositoryImpl</code>-ben, <code>EntityManager</code>-en kereszt\u00fcl h\u00edvjuk meg a named query-t:</p> <pre><code>@Override\npublic List&lt;Product&gt; findMostExpensiveProducts(){\n  return em.createNamedQuery(\"Product.findMostExpensive\", Product.class).getResultList();\n}\n</code></pre> <p>Ilyenkor ezt a met\u00f3dust ki kell m\u00e9g tenni a <code>ProductRepositoryCustom</code> interf\u00e9szbe. Leggyorsabb \u00edgy: Jobb klikk / Refactor / Pull up, \u00e9s ott a met\u00f3dus kiv\u00e1laszthat\u00f3</p> <p>V\u00e9g\u00fcl valamelyik verzi\u00f3t h\u00edvjuk meg a <code>WebshopController</code> megfelel\u0151 pontj\u00e1n:</p> <pre><code>// 4.c feladat\nprivate List&lt;Product&gt; findMostExpensiveProducts() {\n  // TODO\n  // return productRepository.findMostExpensiveProducts();\n  return productRepository.findMostExpensive();\n}\n</code></pre>"},{"location":"seminar/jpa/#feladat-5-adatmodositas","title":"Feladat 5: Adatm\u00f3dos\u00edt\u00e1s","text":"<p>A JPA nemcsak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl m\u00f3dos\u00edt\u00e1sok is v\u00e9grehajthat\u00f3ak.</p> <p>a) \u00cdrj olyan JPQL lek\u00e9rdez\u00e9st a <code>ProductRepository</code> interf\u00e9szbe, mely a \"Building items\" \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal!</p> <p>b) \u00cdrj egy olyan met\u00f3dust, amely l\u00e9trehoz egy \u00faj kateg\u00f3ri\u00e1t \"Expensive toys\" n\u00e9vvel, ha m\u00e9g nem l\u00e9tezik ilyen, \u00e9s sorold \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft!</p> <p>c) Egyszer\u0171 \u00f6n\u00e1ll\u00f3 feladat: az 5.b feladat k\u00f6z\u00f6s megold\u00e1s\u00e1ban egy <code>EntityManager</code>-en kereszt\u00fcl lefuttatott lek\u00e9rdez\u00e9ssel ellen\u0151rizz\u00fck, hogy l\u00e9tezik-e \"Expensive toys\" nev\u0171 kateg\u00f3ria. Val\u00f3s\u00edtsd meg ugyanezt a lek\u00e9rdez\u00e9st Spring Data repository interf\u00e9szben, met\u00f3dus n\u00e9vb\u0151l sz\u00e1rmaztatott lek\u00e9rdez\u00e9ssel, \u00e9s h\u00edvd meg a megfelel\u0151 ponton.</p> Megold\u00e1s <p>5.a feladat</p> <p>A <code>ProductRepository</code> interf\u00e9szben egy UPDATE query-t defini\u00e1lunk. Azt, hogy ez m\u00f3dos\u00edt\u00f3 query, k\u00f6z\u00f6lni kell a Spring Data-val (<code>@Modifying</code>), valamint tranzakci\u00f3ba is kell tenn\u00fcnk <code>@Transactional</code>, az <code>org.springframework...</code> package-b\u0151l):</p> <pre><code>@Modifying\n@Transactional\n@Query(\"UPDATE Product p SET p.price=p.price*1.1 WHERE p.id IN\n(SELECT p2.id FROM Product p2 WHERE p2.category.name=:categoryName)\")\nvoid categoryRaisePrice(@Param(\"categoryName\") String categoryName);\n</code></pre> <p>Megh\u00edv\u00e1sa a <code>WebshopController</code>-b\u0151l:</p> <pre><code>// 5.a feladat\n@RequestMapping(value = \"/raisePriceOfBuildingItems\", method = {\n        RequestMethod.POST, RequestMethod.GET })\nprivate String raisePriceOfBuildingItems() {\n  // TODO\n  productRepository.categoryRaisePrice(\"Building items\");\n  return \"redirect:/\";\n}\n</code></pre> <p>B\u00f6ng\u00e9sz\u0151ben a gomb megnyom\u00e1sa ut\u00e1n a gomb alatti t\u00e1bl\u00e1zatban l\u00e1tsz\u00f3dik az \u00e1t\u00e1raz\u00e1s hat\u00e1sa.</p> <p>5.b feladat</p> <p>A <code>dao</code> package-be \u00faj oszt\u00e1ly, <code>CategoryService</code> n\u00e9ven, <code>@Service</code> annot\u00e1ci\u00f3val, szint\u00e9n <code>@Transactional</code> met\u00f3dussal:</p> <pre><code>@Service\npublic class CategoryService {\n\n  @PersistenceContext\n  private EntityManager em;\n\n  @Autowired\n  ProductRepository productRepository;\n\n  @Transactional\n  public void moveToExpensiveToys(double priceLimit){\n    String name = \"Expensive toys\";\n    Category categoryExpensive = null;\n    List&lt;Category&gt; resultList =\n      em.createQuery(\"SELECT c from Category c WHERE c.name=:name\", Category.class)\n        .setParameter(\"name\", name)\n        .getResultList();\n\n    if(resultList.isEmpty()){\n      //0 vagy null id \u00e9rt\u00e9k eset\u00e9n fog a @GeneratedValue m\u0171k\u00f6d\u00e9sbe l\u00e9pni. Most primit\u00edv long az id-nk, az csak 0 tud lenni, null nem.\n      categoryExpensive = new Category(0, name);\n      em.persist(categoryExpensive);\n    }else{\n      categoryExpensive = resultList.get(0);\n    }\n\n    List&lt;Product&gt; expensiveProducts = productRepository.findByPriceGreaterThan(priceLimit);\n\n    for (Product product : expensiveProducts) {\n      categoryExpensive.addProduct(product);\n    }\n  }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy a menedzselt entit\u00e1s p\u00e9ld\u00e1nyokat (amit tranzakci\u00f3n bel\u00fcl tal\u00e1lunk meg query-vel, vagy most persist-\u00e1ltunk frissen) nem kell explicit m\u00f3don visszamenteni, tranzakci\u00f3 v\u00e9g\u00e9n automatikusan DB-be \u00edr\u00f3dnak a mem\u00f3riabeli v\u00e1ltoz\u00e1sok.</p> <p>Megh\u00edv\u00e1s a <code>WebshopController</code>-b\u0151l:</p> <pre><code>@Autowired\nCategoryService categoryService;\n...\n\n// 5.b feladat\n@RequestMapping(value = \"/moveToExpensiveToys\", method = {\n        RequestMethod.POST, RequestMethod.GET })\nprivate String moveToExpensiveToys() {\n  // TODO\n  categoryService.moveToExpensiveToys(8000.0);\n  return \"redirect:/\";\n}\n</code></pre> <p>B\u00f6ng\u00e9sz\u0151ben a gomb megnyom\u00e1sa ut\u00e1n l\u00e1tsz\u00f3dik a Dr\u00e1ga j\u00e1t\u00e9kok kateg\u00f3ria tartalma</p> <p>5.c feladat</p> <p>A <code>dao</code> package-ben hozzunk l\u00e9tre egy \u00faj interf\u00e9szt <code>CategoryRepository</code> n\u00e9ven, a <code>ProductRepository</code> mint\u00e1j\u00e1ra (a Custom-os lesz\u00e1rmaz\u00e1s nem kell, mert nem lesznek custom lek\u00e9rdez\u00e9seink) egy met\u00f3dussal:</p> <pre><code>public interface CategoryRepository extends JpaRepository&lt;Category, Long&gt;{\n  List&lt;Category&gt; findByName(String name);\n}\n</code></pre> <p>Ezut\u00e1n a <code>CategoryService</code> \u00edgy egyszer\u0171s\u00f6dik le:</p> <pre><code>@Service\npublic class CategoryService {\n...\n\n  @Autowired\n  CategoryRepository categoryRepository;\n\n  @Transactional\n  public void moveToExpensiveToys(double priceLimit){\n    // ...\n    List&lt;Category&gt; resultList = categoryRepository.findByName(name);\n    //  ...\n  }\n}\n</code></pre>"},{"location":"seminar/jpa/#feladat-6-tarolt-eljarasok-hasznalata","title":"Feladat 6: T\u00e1rolt elj\u00e1r\u00e1sok haszn\u00e1lata","text":"<p>H\u00edvd meg a JPA-b\u00f3l a CreateNewPaymentMethod nev\u0171 t\u00e1rolt elj\u00e1r\u00e1st, mely \u00faj fizet\u00e9si m\u00f3d r\u00f6gz\u00edt\u00e9s\u00e9re szolg\u00e1l, \u00e9s visszaadja az \u00faj rekord azonos\u00edt\u00f3j\u00e1t!</p> <ul> <li> <p>Az SQL Server Management Studioban ellen\u0151rizz\u00fck, hogy az adatb\u00e1zis tartalmazza-e a CreateNewPaymentMethod nev\u0171 t\u00e1rolt elj\u00e1r\u00e1st!</p> </li> <li> <p>Ha nem, akkor az al\u00e1bbi k\u00f3dot futtasd le a Management Studioban a t\u00e1rolt elj\u00e1r\u00e1s l\u00e9trehoz\u00e1s\u00e1hoz!</p> <pre><code>CREATE PROCEDURE CreateNewPaymentMethod\n(\n@Method nvarchar(20),\n@Deadline int\n)\nAS\ninsert into PaymentMethod\nvalues(@Method,@Deadline)\nselect scope_identity() as NewId\n</code></pre> </li> </ul> Megold\u00e1s <p>A <code>PaymentMethod</code> entit\u00e1son megtal\u00e1ljuk az al\u00e1bbi annot\u00e1ci\u00f3t. Vess\u00fck \u00f6ssze a t\u00e1rolt elj\u00e1r\u00e1st defini\u00e1l\u00f3 k\u00f3ddal a v\u00e1ltoz\u00f3 neveket!</p> <pre><code>@NamedStoredProcedureQueries({\n  @NamedStoredProcedureQuery(name = \"createMethodSP\",\n      procedureName = \"CreateNewPaymentMethod\",\n      parameters = {\n            @StoredProcedureParameter(mode = ParameterMode.IN, name = \"Method\", type = String.class),\n            @StoredProcedureParameter(mode = ParameterMode.IN, name = \"Deadline\", type = BigDecimal.class)\n          })\n})\npublic class Paymentmethod implements Serializable {\n...\n</code></pre> <p>A named stored procedure query megh\u00edvhat\u00f3 Spring Data repositoryb\u00f3l (<code>dao</code> package-en New Interface ... / PaymentmethodRepository):</p> <pre><code>public interface PaymentmethodRepository extends JpaRepository&lt;Paymentmethod, Long&gt; {\n\n  @Procedure(name=\"createMethodSP\")\n  void newMethod(@Param(\"Method\") String method, @Param(\"Deadline\") BigDecimal deadline);\n}\n</code></pre> <p>Spring Data n\u00e9lk\u00fcl \u00edgy menne, <code>EntityManager</code>-en kereszt\u00fcl, erre val\u00f3sz\u00edn\u0171leg m\u00e1r nem lesz id\u0151:</p> <pre><code>@Service\npublic class PaymentmethodService {\n\n  @PersistenceContext\n  private EntityManager em;\n\n  public void createNewMethod(Paymentmethod paymentMethod){\n    StoredProcedureQuery sp = em.createNamedStoredProcedureQuery(\"createMethodSP\");\n    sp.setParameter(\"Method\", paymentMethod.getMethod());\n    sp.setParameter(\"Deadline\", paymentMethod.getDeadline());\n    sp.execute();\n  }\n}\n</code></pre> <p>A webr\u00e9tegbeli megh\u00edv\u00e1s:</p> <ul> <li>Injekt\u00e1ljuk a <code>WebshopController</code>-be a <code>PaymentmethodRepository</code> interf\u00e9szt:</li> </ul> <pre><code>@Autowired\nPaymentmethodRepository paymentmethodRepository;\n</code></pre> <ul> <li> <p>A WebshopController utols\u00f3 TODO-j\u00e1n\u00e1l h\u00edvjuk meg</p> <pre><code>paymentmethodRepository.newMethod(paymentMethod.getMethod(), paymentMethod.getDeadline());\n</code></pre> </li> <li> <p>A <code>Paymentmethod</code> entit\u00e1s <code>deadline</code> \u00e9s <code>method</code> tagv\u00e1ltoz\u00f3in valid\u00e1ci\u00f3s constraint-eket tal\u00e1lunk. Ezek az annot\u00e1ci\u00f3k a Bean Validation API r\u00e9szei, amivel a webes r\u00e9tegben haszn\u00e1lt Spring MVC, de a JPA \u00e9s integr\u00e1l\u00f3dik, \u00edgy a webr\u00e9tegbeli \u00e9s adatr\u00e9tegbeli valid\u00e1ci\u00f3 konzisztens m\u00f3don, redundanciamentesen defini\u00e1lhat\u00f3.</p> <pre><code>@NotNull\nprivate BigDecimal deadline;\n\n@Column(name=\"METHOD\")\n@NotEmpty\nprivate String method;\n</code></pre> </li> </ul>"},{"location":"seminar/mongodb/","title":"MongoDB","text":"<p>A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a MongoDB \u00e1ltal\u00e1nos c\u00e9l\u00fa dokumentumkezel\u0151 adatb\u00e1zis alapvet\u0151 m\u0171k\u00f6d\u00e9s\u00e9t, valamint a MongoDB C#/.NET Driver haszn\u00e1lat\u00e1t.</p> <p>Entity Framework Core provider</p> <p>A MongoDB-hoz is l\u00e9tezik m\u00e1r Entity Framework Core provider, azonban a gyakorlaton a MongoDB C#/.NET Driver haszn\u00e1lat\u00e1t fogjuk gyakorolni, hogy a hallgat\u00f3k megismerj\u00e9k a MongoDB alacsonyabb szint\u0171 saj\u00e1toss\u00e1gait.</p>"},{"location":"seminar/mongodb/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>MongoDB Community Edition</li> <li>Microsoft Visual Studio 2022</li> <li>VSCode</li> <li>MongoDB for VSCode kieg\u00e9sz\u00edt\u0151</li> <li>Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mongo.js</li> <li>Kiindul\u00f3 alkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-mongo-kiindulo</li> </ul> <p>Amit \u00e9rdemes \u00e1tn\u00e9zned:</p> <ul> <li>C# nyelv \u00e9s Linq kifejez\u00e9sek</li> <li>MongoDB el\u0151ad\u00e1s</li> <li>MongoDB haszn\u00e1lata seg\u00e9dlet</li> </ul>"},{"location":"seminar/mongodb/#gyakorlat-menete","title":"Gyakorlat menete","text":"<p>A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen.</p> <p>Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!</p>"},{"location":"seminar/mongodb/#feladat-0-adatbazis-letrehozasa-projekt-megnyitasa","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, projekt megnyit\u00e1sa","text":"<ol> <li> <p>Nyiss egy PowerShell konzolt (a Start men\u00fcben keress r\u00e1 a PowerShell-re \u00e9s ind\u00edtsd el, de ne az \"ISE\" v\u00e9g\u0171t, az nem a konzol).</p> </li> <li> <p>M\u00e1sold be az al\u00e1bbi sorokat \u00e9s futtasd le enterrel. Az utols\u00f3 utas\u00edt\u00e1sban az el\u00e9r\u00e9si \u00fat lehet, hogy kisebb jav\u00edt\u00e1st ig\u00e9nyel, pl. m\u00e1s verzi\u00f3sz\u00e1m miatt.</p> <pre><code>Remove-Item c:\\work\\mongodatabase -Recurse -ErrorAction Ignore\nNew-Item -Type Directory c:\\work\\mongodatabase\nc:\\tools\\mongodb\\bin\\mongod.exe --dbpath c:\\work\\mongodatabase\n</code></pre> <p>Ezt az ablakot hagyjuk nyitva, mert ebben fut a szerver. Le\u00e1ll\u00edtani Ctrl+C billenty\u0171kombin\u00e1ci\u00f3val lehet majd a v\u00e9g\u00e9n.</p> </li> <li> <p>Ind\u00edtsuk el a VSCode-ot \u00e9s csatlakozzunk a MongoDB szerverhez.</p> <p></p> </li> <li> <p>Hozzuk l\u00e9tre az adatb\u00e1zist a kapcsolat nev\u00e9n (localhost) jobb eg\u00e9rrel kattintva. Ez egy playground script ablakot nyit, ahova m\u00e1soljuk be az adatb\u00e1zis l\u00e9trehoz\u00f3 script\u00fcnket innen, \u00e9s futtassuk le az fejl\u00e9cben tal\u00e1lhat\u00f3 fekete \"lej\u00e1tsz\u00e1s\" gombbal Az adatb\u00e1zis neve <code>datadriven</code> legyen. Ennek hat\u00e1s\u00e1ra l\u00e9tre kell j\u00f6nnie a collection-\u00f6knek - nyissuk le az adatb\u00e1zis elemeit ennek ellen\u0151rz\u00e9s\u00e9hez.</p> <p></p> <p></p> </li> <li> <p>T\u00f6lts\u00fck le a kiindul\u00f3 projekt v\u00e1zat!</p> <ul> <li>Nyissunk egy \u00faj command prompt-ot vagy PowerShell konzolt (ne azt haszn\u00e1ljuk, amelyikben a szerver fut)</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul <code>c:\\work\\NEPTUN</code></li> <li> <p>Adjuk ki a k\u00f6vetkez\u0151 parancsot:</p> <pre><code>git clone https://github.com/bmeviauac01/gyakorlat-mongo-kiindulo.git\n</code></pre> </li> </ul> </li> <li> <p>Nyissuk meg a forr\u00e1sban az sln f\u00e1jlt Visual Studio-val. Vizsg\u00e1ljuk meg a projektet.</p> <ul> <li>Ez egy .NET konzol alkalmaz\u00e1s. Fel\u00e9p\u00edt\u00e9s\u00e9ben hasonl\u00edt az Entity Framework gyakorlaton l\u00e1totthoz: az <code>Entities</code> mapp\u00e1ban tal\u00e1lhat\u00f3k az entit\u00e1s oszt\u00e1lyok, a megold\u00e1st pedig a <code>Program.cs</code> f\u00e1jlba \u00edrjuk.</li> <li>N\u00e9zz\u00fck meg a <code>Program.cs</code> tartalm\u00e1t. Itt m\u00e1r megtal\u00e1lhat\u00f3 a MongoDB kommunik\u00e1ci\u00f3hoz sz\u00fcks\u00e9ges inicializ\u00e1ci\u00f3.<ul> <li>Az <code>IMongoClient</code> interf\u00e9sz tartalmazza az adatb\u00e1zissal val\u00f3 kommunik\u00e1ci\u00f3hoz sz\u00fcks\u00e9ges met\u00f3dusokat. Ezeket nem fogjuk k\u00f6zvetlen\u00fcl haszn\u00e1lni.</li> <li>Az <code>IMongoDatabase</code> interf\u00e9sz reprezent\u00e1lja a <code>datadriven</code> adatb\u00e1zist a MongoDB-n bel\u00fcl.</li> <li>A k\u00fcl\u00f6nb\u00f6z\u0151 <code>IMongoCollection&lt;TEntity&gt;</code> interf\u00e9szek pedig a k\u00fcl\u00f6nb\u00f6z\u0151 kollekci\u00f3kat reprezent\u00e1lj\u00e1k. Ezeket haszn\u00e1lva tudunk lek\u00e9rdez\u00e9seket \u00e9s m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1sokat kiadni.</li> </ul> </li> <li>Az adatb\u00e1zisunk entit\u00e1sainak C# oszt\u00e1lyra val\u00f3 lek\u00e9pez\u00e9se az <code>Entities</code> mapp\u00e1ban tal\u00e1lhat\u00f3. K\u00fcl\u00f6nbs\u00e9g itt az Entity Frameworkh\u00f6z k\u00e9pest, hogy itt ezt nek\u00fcnk k\u00e9zzel kell elk\u00e9sz\u00edten\u00fcnk.<ul> <li>Az entit\u00e1sok egy r\u00e9sz\u00e9nek a lek\u00e9pez\u00e9se m\u00e1r megtal\u00e1lhat\u00f3 itt.</li> <li>A labor sor\u00e1n m\u00e9g visszat\u00e9r\u00fcnk ide, \u00e9s fogunk magunk is k\u00e9sz\u00edteni entit\u00e1s oszt\u00e1lyt.</li> </ul> </li> </ul> </li> </ol>"},{"location":"seminar/mongodb/#feladat-1-lekerdezesek","title":"Feladat 1: Lek\u00e9rdez\u00e9sek","text":"<p>A lek\u00e9pzett adatmodellen fogalmazd meg az al\u00e1bbi lek\u00e9rdez\u00e9seket a MongoDB C#/.NET Driver haszn\u00e1lat\u00e1val. \u00cdrd ki konzolra az eredm\u00e9nyeket.</p> <ol> <li> <p>List\u00e1zd azon term\u00e9kek nev\u00e9t \u00e9s rakt\u00e1rk\u00e9szlet\u00e9t, melyb\u0151l t\u00f6bb mint 30 darab van rakt\u00e1ron!</p> </li> <li> <p>\u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon megrendel\u00e9seket, melyekhez legal\u00e1bb k\u00e9t megrendel\u00e9st\u00e9tel tartozik!</p> </li> <li> <p>K\u00e9sz\u00edts olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azokat a megrendel\u00e9seket, melyek \u00f6ssz\u00e9rt\u00e9ke t\u00f6bb mint 30000 Ft! Az eredm\u00e9nyhalmaz ki\u00edr\u00e1sakor a vev\u0151 ID-t k\u00f6vet\u0151en soronk\u00e9nt szerepeljenek az egyes t\u00e9telek (Term\u00e9k ID, mennyis\u00e9g, nett\u00f3 \u00e1r).</p> </li> <li> <p>List\u00e1zd ki a legdr\u00e1g\u00e1bb term\u00e9k adatait!</p> </li> <li> <p>\u00cdrj olyan lek\u00e9rdez\u00e9st, mely kilist\u00e1zza azon term\u00e9keket, melyb\u0151l legal\u00e1bb k\u00e9tszer rendeltek!</p> </li> </ol> Megold\u00e1s <ol> <li> <p>Ehhez a feladathoz csup\u00e1n a term\u00e9keket reprezent\u00e1l\u00f3 gy\u0171jtem\u00e9nyben kell egy egyszer\u0171 lek\u00e9rdez\u00e9st kiadnunk. A sz\u0171r\u00e9si felt\u00e9telt k\u00e9tf\u00e9lek\u00e9ppen is megfogalmazhatjuk: lambda kifejez\u00e9s seg\u00edts\u00e9g\u00e9vel, \u00e9s k\u00e9zzel \u00f6sszerakva is.</p> <pre><code>Console.WriteLine(\"***** Els\u0151 feladat *****\");\n\n// 1.1 els\u0151 megold\u00e1s\nConsole.WriteLine(\"\\t1.1 1. megold\u00e1s:\");\nvar qProductAndStock1 = productsCollection\n    .Find(p =&gt; p.Stock &gt; 30)\n    .ToList();\n\nforeach (var p in qProductAndStock1)\n    Console.WriteLine($\"\\t\\tName={p.Name}\\tStock={p.Stock}\");\n\n// 1.1 m\u00e1sodik megold\u00e1s\nConsole.WriteLine(\"\\t1.1 2. megold\u00e1s:\");\nvar qProductAndStock2 = productsCollection\n    .Find(Builders&lt;Product&gt;.Filter.Gt(p =&gt; p.Stock, 30))\n    .ToList();\n\nforeach (var p in qProductAndStock2)\n    Console.WriteLine($\"\\t\\tName={p.Name}\\tStock={p.Stock}\");\n</code></pre> </li> <li> <p>Ez a feladat nagyon hasonl\u00f3 ez el\u0151z\u0151h\u00f6z. Figyelj\u00fck meg, hogy az SQL-es adatb\u00e1zis s\u00e9ma eset\u00e9n ehhez m\u00e1r <code>JOIN</code>-t (<code>Navigation Property</code>) kellett alkalmazni. Ezzel szemben itt minden sz\u00fcks\u00e9ges adat a megrendel\u00e9s kollekci\u00f3ban tal\u00e1lhat\u00f3.</p> <pre><code>// 1.2 els\u0151 megold\u00e1s\nConsole.WriteLine(\"\\t1.2 1. megold\u00e1s:\");\nvar qOrderItems1 = ordersCollection\n    .Find(o =&gt; o.OrderItems.Length &gt;= 2)\n    .ToList();\n\nforeach (var o in qOrderItems1)\n    Console.WriteLine($\"\\t\\tCustomerID={o.CustomerID}\\tOrderID={o.ID}\\tItems={o.OrderItems.Length}\");\n\n// 1.2 m\u00e1sodik megold\u00e1s\nConsole.WriteLine(\"\\t1.2 2. megold\u00e1s:\");\nvar qOrderItems2 = ordersCollection\n    .Find(Builders&lt;Order&gt;.Filter.SizeGte(o =&gt; o.OrderItems, 2))\n    .ToList();\n\nforeach (var o in qOrderItems2)\n    Console.WriteLine($\"\\t\\tCustomerID={o.CustomerID}\\tOrderID={o.ID}\\tItems={o.OrderItems.Length}\");\n</code></pre> </li> <li> <p>Ehhez a feladathoz m\u00e1r nem elegend\u0151 sz\u00e1munkra a sima lek\u00e9rdez\u00e9s kifejez\u0151ereje, \u00edgy az aggreg\u00e1ci\u00f3s pipeline-t kell alkalmaznunk. Figyelj\u00fck meg azonban, hogy a s\u00e9ma fel\u00e9p\u00edt\u00e9se miatt tov\u00e1bbra is minden sz\u00fcks\u00e9ges adat rendelkez\u00e9sre \u00e1ll egyetlen gy\u0171jtem\u00e9nyben.</p> <pre><code>// 1.3\nConsole.WriteLine(\"\\t1.3:\");\nvar qOrderTotal = ordersCollection\n    .Aggregate()\n    .Project(order =&gt; new\n    {\n        CustomerID = order.CustomerID,\n        OrderItems = order.OrderItems,\n        Total = order.OrderItems.Sum(oi =&gt; oi.Amount * oi.Price)\n    })\n    .Match(order =&gt; order.Total &gt; 30000)\n    .ToList();\n\nforeach (var o in qOrderTotal)\n{\n    Console.WriteLine($\"\\t\\tCustomerID={o.CustomerID}\");\n    foreach (var oi in o.OrderItems)\n        Console.WriteLine($\"\\t\\t\\tProductID={oi.ProductID}\\tPrice={oi.Price}\\tAmount={oi.Amount}\");\n}\n</code></pre> </li> <li> <p>A legdr\u00e1g\u00e1bb term\u00e9kek lek\u00e9rdez\u00e9s\u00e9hez k\u00e9t lek\u00e9rdez\u00e9st kell kiadnunk: el\u0151sz\u00f6r lek\u00e9rdezz\u00fck a legmagasabb \u00e1rat, ut\u00e1na pedig lek\u00e9rdezz\u00fck azokat a term\u00e9keket, melyeknek a nett\u00f3\u00e1ra megegyezik ezzel az \u00e9rt\u00e9kkel.</p> <pre><code>// 1.4\nConsole.WriteLine(\"\\t1.4:\");\nvar maxPrice = productsCollection\n    .Find(_ =&gt; true)\n    .SortByDescending(p =&gt; p.Price)\n    .Limit(1)\n    .Project(p =&gt; p.Price)\n    .Single();\n\nvar qProductMax = productsCollection\n    .Find(p =&gt; p.Price == maxPrice)\n    .ToList();\n\nforeach (var t in qProductMax)\n    Console.WriteLine($\"\\t\\tName={t.Name}\\tPrice={t.Price}\");\n</code></pre> </li> <li> <p>Ez a feladat az\u00e9rt neh\u00e9z a jelenlegi adatb\u00e1ziss\u00e9m\u00e1nk mellett, mert itt m\u00e1r nem igaz az, hogy egyetlen kollekci\u00f3ban rendelkez\u00e9sre \u00e1ll minden adat. Sz\u00fcks\u00e9g\u00fcnk van ugyanis a term\u00e9k kollekci\u00f3b\u00f3l a term\u00e9k nev\u00e9re \u00e9s rakt\u00e1rk\u00e9szlet\u00e9re, a megrendel\u00e9sek kollekci\u00f3b\u00f3l pedig a term\u00e9khez tartoz\u00f3 megrendel\u00e9sek sz\u00e1m\u00e1ra.</p> <p>Ilyen helyzetben MongoDB eset\u00e9n k\u00e9nytelenek vagyunk kliensoldalon (\u00e9rtsd: C# k\u00f3db\u00f3l) \"joinolni\". A megold\u00e1s itt teh\u00e1t hogy lek\u00e9rdezz\u00fck az \u00f6sszes megrendel\u00e9st, majd pedig C#-b\u00f3l, LINQ seg\u00edts\u00e9g\u00e9vel \u00f6sszegy\u0171jtj\u00fck az adott term\u00e9khez tartoz\u00f3 megrendel\u00e9st\u00e9teleket. Ezut\u00e1n lek\u00e9rdezz\u00fck az adatb\u00e1zisb\u00f3l a term\u00e9keket is, hogy azok adatai is rendelkez\u00e9s\u00fcnkre \u00e1lljanak.</p> <pre><code>// 1.5\nConsole.WriteLine(\"\\t1.5:\");\nvar qOrders = ordersCollection\n    .Find(_ =&gt; true)\n    .ToList();\n\nvar productOrders = qOrders\n    .SelectMany(o =&gt; o.OrderItems) // Egyetlen list\u00e1ba gy\u0171jti a t\u00e9teleket\n    .GroupBy(oi =&gt; oi.ProductID)\n    .Where(p =&gt; p.Count() &gt;= 2);\n\nvar qProducts = productsCollection\n    .Find(_ =&gt; true)\n    .ToList();\nvar productLookup = qProducts.ToDictionary(p =&gt; p.ID);\n\nforeach (var p in productOrders)\n{\n    var product = productLookup.GetValueOrDefault(p.Key);\n    Console.WriteLine($\"\\t\\tName={product?.Name}\\tStock={product?.Stock}\\tOrders={p.Count()}\");\n}\n</code></pre> <p>A fenti nem t\u00fal eleg\u00e1ns megold\u00e1s, \u00e9s csak kis adatb\u00e1zisok eset\u00e9n m\u0171k\u00f6dik. Ha val\u00f3di k\u00f6r\u00fclm\u00e9nyek k\u00f6z\u00f6tt szembes\u00fcl\u00fcnk ezzel a feladattal, k\u00e9t lehet\u0151s\u00e9g\u00fcnk van: \u00e1tdolgozni az adatb\u00e1zis s\u00e9m\u00e1t (pl. a megrendel\u00e9sbe belementeni a term\u00e9k adatait - denormaliz\u00e1ci\u00f3), avagy a MongoDB aggreg\u00e1ci\u00f3s pipeline-j\u00e1nak haszn\u00e1lat\u00e1val a fenti m\u00f3dszerhez hasonl\u00f3ra \"r\u00e1venni\" a MongoDB szervert (amire k\u00e9pes ugyan, de le fogja terhelni)</p> </li> </ol>"},{"location":"seminar/mongodb/#feladat-2-entitasosztaly-letrehozasa","title":"Feladat 2: Entit\u00e1soszt\u00e1ly l\u00e9trehoz\u00e1sa","text":"<ol> <li> <p>Vizsg\u00e1ld meg a <code>Product</code> \u00e9s a <code>VAT</code> entit\u00e1soszt\u00e1lyokat. Mi\u00e9rt van a <code>Product</code> entit\u00e1sban <code>[BsonId]</code>-val ell\u00e1tott mez\u0151, \u00e9s mi\u00e9rt nincs az <code>VAT</code> oszt\u00e1lyban?</p> </li> <li> <p>Hozz l\u00e9tre entit\u00e1soszt\u00e1lyt a <code>Category</code> entit\u00e1snak, \u00e9s vedd fel hozz\u00e1 a megfelel\u0151 <code>IMongoCollection&lt;Category&gt;</code> mez\u0151t.</p> </li> </ol> Megold\u00e1s <ol> <li> <p>A <code>Product</code> oszt\u00e1ly a <code>products</code> gy\u0171jtem\u00e9nyt reprezent\u00e1lja az adatb\u00e1zisban, ez\u00e9rt tartozik hozz\u00e1 egyedi <code>ObjectID</code> ami alapj\u00e1n hivatkozni tudunk r\u00e1 az adatb\u00e1zis fel\u00e9. Ezzel szemben az <code>VAT</code> oszt\u00e1ly a <code>Product</code> egy be\u00e1gyazott objektuma, \u00f6nmag\u00e1ban nem jelenik meg gy\u0171jtem\u00e9nyk\u00e9nt. Ez\u00e9rt nem tartozik hozz\u00e1 <code>ObjectID</code> \u00e9rt\u00e9k.</p> </li> <li> <p>Hozzunk l\u00e9tre \u00faj POCO oszt\u00e1lyt <code>Category</code> n\u00e9ven.</p> <p>N\u00e9zz\u00fck meg el\u0151sz\u00f6r VSCode-ban, hogy milyen adattagok tal\u00e1lhat\u00f3k a <code>categories</code> kollekci\u00f3ban l\u00e9v\u0151 dokumentumokban.</p> <p></p> <p>Ez alapj\u00e1n l\u00e9tre tudjuk hozni a <code>Category</code> oszt\u00e1lyt an <code>Entities</code> mapp\u00e1ban.</p> <pre><code>using MongoDB.Bson;\nusing MongoDB.Bson.Serialization.Attributes;\n\nnamespace BME.DataDriven.Mongo.Entitites\n{\n    public class Category\n    {\n        [BsonId]\n        public ObjectId ID { get; set; }\n        public string Name { get; set; }\n        public ObjectId? ParentCategoryID { get; set; }\n    }\n}\n</code></pre> <p>A <code>Program.cs</code> f\u00e1jlban vegy\u00fcl fel az \u00faj kollekci\u00f3 interf\u00e9szt.</p> <pre><code>private static IMongoCollection&lt;Category&gt; categoriesCollection;\n</code></pre> <p>Az <code>initialize</code> met\u00f3dusban pedig inicializ\u00e1ljuk is ezt a kollekci\u00f3t.</p> <pre><code>categoriesCollection = database.GetCollection&lt;Category&gt;(\"categories\");\n</code></pre> </li> </ol>"},{"location":"seminar/mongodb/#feladat-3-adatmodositasok","title":"Feladat 3: Adatm\u00f3dos\u00edt\u00e1sok","text":"<p>Az <code>IMongoColection&lt;TEntity&gt;</code> interf\u00e9sz nem csak lek\u00e9rdez\u00e9shez haszn\u00e1lhat\u00f3, hanem rajta kereszt\u00fcl m\u00f3dos\u00edt\u00e1sok is v\u00e9grehajthat\u00f3ak.</p> <ol> <li> <p>\u00cdrj olyan MongoDB C#/.NET Driverre \u00e9p\u00fcl\u0151 C# k\u00f3dot, mely a \"LEGO\" kateg\u00f3ri\u00e1j\u00fa term\u00e9kek \u00e1r\u00e1t megemeli 10 sz\u00e1zal\u00e9kkal!</p> </li> <li> <p>Hozz l\u00e9tre egy \u00faj kateg\u00f3ri\u00e1t a Expensive toys n\u00e9ven, \u00e9s sorod \u00e1t ide az \u00f6sszes olyan term\u00e9ket, melynek \u00e1ra, nagyobb, mint 8000 Ft!</p> </li> <li> <p>T\u00f6r\u00f6ld ki az \u00f6sszes olyan kateg\u00f3ri\u00e1t, amelyhez nem tartozik term\u00e9k.</p> </li> </ol> Megold\u00e1s <ol> <li> <p>El\u0151sz\u00f6r lek\u00e9rdezz\u00fck a megfelel\u0151 kateg\u00f3ria ID-j\u00e1t, majd az ehhez tartoz\u00f3 term\u00e9kekre adunk ki m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st.</p> <pre><code>Console.WriteLine(\"***** Harmadik feladat *****\");\n\n//3.1\nConsole.WriteLine(\"\\t3.1:\");\nvar categoryLegoId = categoriesCollection\n    .Find(c =&gt; c.Name == \"LEGO\")\n    .Project(c =&gt; c.ID)\n    .Single();\n\nvar qProductLego = productsCollection\n    .Find(p =&gt; p.CategoryID == categoryLegoId)\n    .ToList();\nConsole.WriteLine(\"\\t\\tM\u00f3dos\u00edt\u00e1s el\u0151tt:\");\nforeach (var p in qProductLego)\n    Console.WriteLine($\"\\t\\t\\tName={p.Name}\\tStock={p.Stock}\\t\u00c1r={p.Price}\");\n\nproductsCollection.UpdateMany(\n    filter: p =&gt; p.CategoryID == categoryLegoId,\n    update: Builders&lt;Product&gt;.Update.Mul(p =&gt; p.Price, 1.1));\n\nqProductLego = productsCollection\n    .Find(p =&gt; p.CategoryID == categoryLegoId)\n    .ToList();\nConsole.WriteLine(\"\\t\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n:\");\nforeach (var p in qProductLego)\n    Console.WriteLine($\"\\t\\t\\tName={p.Name}\\tStock={p.Stock}\\t\u00c1r={p.Price}\");\n</code></pre> </li> <li> <p>MongoDB seg\u00edts\u00e9g\u00e9vel tranzakci\u00f3 n\u00e9lk\u00fcl atomikusan el tudjuk v\u00e9gezni a k\u00f6vetkez\u0151 feladatot: \"K\u00e9rem a <code>Expensive toys</code> kateg\u00f3ri\u00e1t. Amennyiben nem l\u00e9tezik, hozd l\u00e9tre.\" Ehhez a <code>FindOneAndUpdate</code> parancs haszn\u00e1lat\u00e1ra van sz\u00fcks\u00e9g\u00fcnk.</p> <pre><code>//3.2\nConsole.WriteLine(\"\\t3.2:\");\nvar catExpensiveToys = categoriesCollection.FindOneAndUpdate&lt;Category&gt;(\n    filter: c =&gt; c.Name == \"Expensive toys\",\n    update: Builders&lt;Category&gt;.Update.SetOnInsert(c =&gt; c.Name, \"Expensive toys\"),\n    options: new FindOneAndUpdateOptions&lt;Category, Category&gt; { IsUpsert = true, ReturnDocument = ReturnDocument.After });\n\nproductsCollection.UpdateMany(\n    filter: p =&gt; p.Price &gt; 8000,\n    update: Builders&lt;Product&gt;.Update.Set(p =&gt; p.CategoryID, catExpensiveToys.ID));\n\nvar qProdExpensive = productsCollection\n    .Find(p =&gt; p.CategoryID == catExpensiveToys.ID)\n    .ToList();\nforeach (var p in qProdExpensive)\n    Console.WriteLine($\"\\t\\tName={p.Name}\\tPrice={p.Price}\");\n</code></pre> </li> <li> <p>Lek\u00e9rdezz\u00fck azokat a kateg\u00f3ri\u00e1kat amelyekhez tartozik term\u00e9k, majd pedig t\u00f6r\u00f6lj\u00fck azokat, amelyek nem tartoznak ezek k\u00f6z\u00e9.</p> <pre><code>//3.3\nConsole.WriteLine(\"\\t3.3:\");\nConsole.WriteLine($\"\\t\\tM\u00f3dos\u00edt\u00e1s el\u0151tt {categoriesCollection.CountDocuments(_ =&gt; true)} db kateg\u00f3ria\");\n\nvar qProductCategory = new HashSet&lt;ObjectId&gt;(\n    productsCollection\n        .Find(_ =&gt; true)\n        .Project(p =&gt; p.CategoryID)\n        .ToList());\n\ncategoriesCollection.DeleteMany(c =&gt; !qProductCategory.Contains(c.ID));\n\nConsole.WriteLine($\"\\t\\tM\u00f3dos\u00edt\u00e1s ut\u00e1n {categoriesCollection.CountDocuments(_ =&gt; true)} db kateg\u00f3ria\");\n</code></pre> <p>Vegy\u00fck \u00e9szre, hogy ez az utas\u00edt\u00e1s nem atomikus. Ha k\u00f6zben vettek fel \u00faj term\u00e9ket, akkor lehet, hogy olyan kateg\u00f3ri\u00e1t t\u00f6rl\u00fcnk amihez az\u00f3ta tartozik term\u00e9k. Nem vett\u00fck figyelembe tov\u00e1bb\u00e1 a kateg\u00f3ri\u00e1k hierarchi\u00e1j\u00e1t sem.</p> </li> </ol>"},{"location":"seminar/mssql/","title":"Microsoft SQL Server programoz\u00e1sa","text":"<p>A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k megismerj\u00e9k a Microsoft SQL Server platform szerver oldali programoz\u00e1s\u00e1nak alapjait, elsaj\u00e1t\u00edts\u00e1k az alapfogalmakat \u00e9s a fejleszt\u0151eszk\u00f6z haszn\u00e1lat\u00e1t.</p>"},{"location":"seminar/mssql/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Microsoft SQL Server (LocalDB vagy Express edition)</li> <li>SQL Server Management Studio</li> <li>Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql</li> </ul> <p>Amit \u00e9rdemes \u00e1tn\u00e9zned:</p> <ul> <li>SQL nyelv</li> <li>Microsoft SQL Server programoz\u00e1sa (t\u00e1rolt elj\u00e1r\u00e1sok, triggerek)</li> <li>Microsoft SQL Server haszn\u00e1lata seg\u00e9dlet</li> </ul>"},{"location":"seminar/mssql/#gyakorlat-menete","title":"Gyakorlat menete","text":"<p>Az els\u0151 n\u00e9gy feladatot (bele\u00e9rtve a megold\u00e1sok tesztel\u00e9s\u00e9t is) a gyakorlatvezet\u0151vel egy\u00fctt oldjuk meg. Az utols\u00f3 feladat \u00f6n\u00e1ll\u00f3 munka, amennyiben marad r\u00e1 id\u0151.</p> <p>Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!</p>"},{"location":"seminar/mssql/#feladat-0-adatbazis-letrehozasa-ellenorzese","title":"Feladat 0: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se","text":"<p>Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban.)</p>"},{"location":"seminar/mssql/#feladat-1-sql-parancsok-emlekezteto","title":"Feladat 1: SQL parancsok (eml\u00e9keztet\u0151)","text":"<p>\u00cdrjon SQL lek\u00e9rdez\u00e9s/utas\u00edt\u00e1st az al\u00e1bbi feladatokhoz.</p> <ol> <li> <p>H\u00e1ny nem teljes\u00edtett megrendel\u00e9s\u00fcnk van (a st\u00e1tusz alapj\u00e1n)?</p> Megold\u00e1s <pre><code>select count(*)\nfrom [Order] o join Status s on o.StatusID = s.ID\nwhere s.Name != 'Delivered'\n</code></pre> <p>A <code>join</code> mellett az oszlopf\u00fcggv\u00e9ny (aggreg\u00e1ci\u00f3) haszn\u00e1lat\u00e1ra l\u00e1tunk p\u00e9ld\u00e1t. (A t\u00e1bl\u00e1k kapcsol\u00e1s\u00e1ra nem csak ez a szintaktika haszn\u00e1lhat\u00f3, el\u0151ad\u00e1son szerepelt alternat\u00edv is.)</p> </li> <li> <p>Melyek azok a fizet\u00e9si m\u00f3dok, amit soha nem v\u00e1lasztottak a megrendel\u0151ink?</p> Megold\u00e1s <pre><code>select p.Method\nfrom [Order] o right outer join PaymentMethod p on o.PaymentMethodID = p.ID\nwhere o.ID is null\n</code></pre> <p>A megold\u00e1s kulcsa az <code>outer join</code>, aminek k\u00f6sz\u00f6nhet\u0151en l\u00e1thatjuk, mely fizet\u00e9si m\u00f3d rekordhoz nem tartozik egyetlen megrendel\u00e9s se.</p> </li> <li> <p>R\u00f6gz\u00edts\u00fcnk be egy \u00faj vev\u0151t! K\u00e9rdezz\u00fck le az \u00fajonnan l\u00e9trej\u00f6tt rekord kulcs\u00e1t!</p> Megold\u00e1s <pre><code>insert into Customer(Name, Login, Password, Email)\nvalues ('Teszt Elek', 't.elek', '********', 't.elek@email.com')\n\nselect @@IDENTITY\n</code></pre> <p>Az <code>insert</code> ut\u00e1n javasolt ki\u00edrni az oszlopneveket az egy\u00e9rtelm\u0171s\u00e9g v\u00e9gett, b\u00e1r nem k\u00f6telez\u0151. Vegy\u00fck \u00e9szre, hogy az ID oszlopnak nem adunk \u00e9rt\u00e9ket, mert azt a t\u00e1bla defin\u00edci\u00f3jakor meghat\u00e1rozva a szerver adja automatikusan. Ez\u00e9rt kell ut\u00e1na lek\u00e9rdezn\u00fcnk, hogy tudjuk, milyen ID-t adott.</p> </li> <li> <p>A kateg\u00f3ri\u00e1k k\u00f6z\u00f6tt hib\u00e1san szerepel a Tricycle kateg\u00f3ria n\u00e9v. Jav\u00edtsuk \u00e1t a kateg\u00f3ria nev\u00e9t Tricycles-re!</p> Megold\u00e1s <pre><code>update Category\nset Name = 'Tricycles'\nwhere Name = 'Tricycle'\n</code></pre> </li> <li> <p>Melyik term\u00e9k kateg\u00f3ri\u00e1ban van a legt\u00f6bb term\u00e9k?</p> Megold\u00e1s <pre><code>select top 1 Name, (select count(*) from Product where Product.CategoryID = c.ID) as cnt\nfrom Category c\norder by cnt desc\n</code></pre> <p>A k\u00e9rd\u00e9sre t\u00f6bb alternat\u00edv lek\u00e9rdez\u00e9s is esz\u00fcnkbe juthat. Ez csak egyike a lehets\u00e9ges megold\u00e1soknak. Itt l\u00e1thatunk p\u00e9ld\u00e1t az allek\u00e9rdez\u00e9sre is.</p> </li> </ol>"},{"location":"seminar/mssql/#feladat-2-termekkategoria-rogzitese","title":"Feladat 2: Term\u00e9kkateg\u00f3ria r\u00f6gz\u00edt\u00e9se","text":"<p>Hozzon l\u00e9tre egy t\u00e1rolt elj\u00e1r\u00e1st, aminek a seg\u00edts\u00e9g\u00e9vel egy \u00faj kateg\u00f3ri\u00e1t vehet\u00fcnk fel. Az elj\u00e1r\u00e1s bemen\u0151 param\u00e9tere a felv\u00e9telre ker\u00fcl\u0151 kateg\u00f3ria neve, \u00e9s opcion\u00e1lisan a sz\u00fcl\u0151kateg\u00f3ria neve. Dobjon hib\u00e1t, ha a kateg\u00f3ria l\u00e9tezik, vagy a sz\u00fcl\u0151kateg\u00f3ria nem l\u00e9tezik. A kateg\u00f3ria els\u0151dleges kulcs\u00e1nak gener\u00e1l\u00e1s\u00e1t b\u00edzza az adatb\u00e1zisra.</p> Megold\u00e1s <p>T\u00e1rolt elj\u00e1r\u00e1s</p> <pre><code>create or alter procedure AddNewCategory\n    @Name nvarchar(50),\n    @ParentName nvarchar(50)\nas\n\nbegin tran\n\n-- L\u00e9tezik-e ilyen n\u00e9vvel m\u00e1r kateg\u00f3ria\ndeclare @ID int\nselect @ID = ID\nfrom Category with (TABLOCKX)\nwhere upper(Name) = upper(@Name)\n\nif @ID is not null\nbegin\n    rollback\n    raiserror ('Category %s already exists',16,1,@Name)\n    return\nend\n\n-- Sz\u00fcl\u0151 kateg\u00f3ri\u00e1nak l\u00e9teznie kell\ndeclare @ParentID int\nif @ParentName is not null\nbegin\n    select @ParentID = ID\n    from Category\n    where upper(Name) = upper(@ParentName)\n\n    if @ParentID is null\n    begin\n        rollback\n        raiserror ('Category %s does not exist',16,1,@ParentName)\n        return\n    end\nend\n\ninsert into Category\nvalues(@Name,@ParentID)\n\ncommit\n</code></pre> <p>Tesztel\u00e9s</p> <p>Nyissunk egy \u00faj Query ablakot \u00e9s adjuk ki az al\u00e1bbi parancsot.</p> <p><code>exec AddNewCategory 'Beach balls', NULL</code></p> <p>Ennek siker\u00fclnie kell. Ellen\u0151rizz\u00fck ut\u00e1na a t\u00e1bla tartalm\u00e1t.</p> <p>Ism\u00e9telj\u00fck meg a fenti besz\u00far\u00e1st, ekkor m\u00e1r hib\u00e1t kell dobjon.</p> <p>Pr\u00f3b\u00e1ljuk ki sz\u00fcl\u0151kateg\u00f3ri\u00e1val is.</p> <p><code>exec AddNewCategory 'LEGO Star Wars', 'LEGO'</code></p>"},{"location":"seminar/mssql/#feladat-3-megrendelestetel-statuszanak-karbantartasa","title":"Feladat 3: Megrendel\u00e9st\u00e9tel st\u00e1tusz\u00e1nak karbantart\u00e1sa","text":"<p>\u00cdrjon triggert, ami a megrendel\u00e9s st\u00e1tusz\u00e1nak v\u00e1ltoz\u00e1sa eset\u00e9n a hozz\u00e1 tartoz\u00f3 egyes t\u00e9telek st\u00e1tusz\u00e1t a megfelel\u0151re m\u00f3dos\u00edtja, ha azok r\u00e9gi st\u00e1tusza megegyezett a megrendel\u00e9s r\u00e9gi st\u00e1tusz\u00e1val. A t\u00f6bbi t\u00e9telt nem \u00e9rinti a st\u00e1tusz v\u00e1ltoz\u00e1sa.</p> Megold\u00e1s <p>Trigger</p> <pre><code>create or alter trigger UpdateOrderStatus\non [Order]\nfor update\nas\n\nupdate OrderItem\nset StatusID = i.StatusID\nfrom OrderItem oi\ninner join inserted i on i.Id=oi.OrderID\ninner join deleted d on d.ID=oi.OrderID\nwhere i.StatusID != d.StatusID\nand oi.StatusID=d.StatusID\n</code></pre> <p>Sz\u00e1njunk egy kis id\u0151t az <code>update ... from</code> utas\u00edt\u00e1s m\u0171k\u00f6d\u00e9si elv\u00e9nek meg\u00e9rt\u00e9s\u00e9re. Az alapelvek a k\u00f6vetkez\u0151k. Akkor haszn\u00e1ljuk, ha a m\u00f3dos\u00edtand\u00f3 t\u00e1bla bizonyos mez\u0151it m\u00e1s t\u00e1bla vagy t\u00e1bl\u00e1k tartalma alapj\u00e1n szeretn\u00e9nk be\u00e1ll\u00edtani. A szintaktika alapvet\u0151en a m\u00e1r megszokott <code>update ... set...</code> form\u00e1t k\u00f6veti, kieg\u00e9sz\u00edtve egy <code>from</code> szakasszal, melyben m\u00e1r a <code>select from</code> utas\u00edt\u00e1sn\u00e1l megismerttel azonos szintaktik\u00e1val m\u00e1s t\u00e1bl\u00e1kb\u00f3l illeszthet\u00fcnk (<code>join</code>) adatokat a m\u00f3dos\u00edtand\u00f3 t\u00e1bl\u00e1hoz. \u00cdgy a <code>set</code> szakaszban az illesztett t\u00e1bl\u00e1k oszlopai is felhaszn\u00e1lhat\u00f3k adatforr\u00e1sk\u00e9nt (vagyis \u00e1llhatnak az egyenl\u0151s\u00e9g jobb oldal\u00e1n).</p> <p>Tesztel\u00e9s</p> <p>Ellen\u0151rizz\u00fck a megrendel\u00e9s \u00e9s a t\u00e9telek st\u00e1tusz\u00e1t:</p> <pre><code>select OrderItem.StatusID, [Order].StatusID\nfrom OrderItem join [Order] on OrderItem.OrderID=[Order].ID\nwhere OrderID = 1\n</code></pre> <p>V\u00e1ltoztassuk meg a megrendel\u00e9st:</p> <pre><code>update [Order]\nset StatusID=4\nwhere ID=1\n</code></pre> <p>Ellen\u0151rizz\u00fck a megrendel\u00e9st \u00e9s a t\u00e9teleket (update ut\u00e1n minden st\u00e1tusznak meg kell v\u00e1ltoznia):</p> <pre><code>select OrderItem.StatusID, [Order].StatusID\nfrom OrderItem join [Order] on OrderItem.OrderID=[Order].ID\nwhere OrderID = 1\n</code></pre>"},{"location":"seminar/mssql/#feladat-4-vevo-megrendeleseinek-osszegzese","title":"Feladat 4: Vev\u0151 megrendel\u00e9seinek \u00f6sszegz\u00e9se","text":"<p>T\u00e1roljuk el a vev\u0151 \u00f6sszes megrendel\u00e9s\u00e9nek v\u00e9g\u00f6sszeg\u00e9t a Vev\u0151 t\u00e1bl\u00e1ban!</p> <ol> <li>Adjuk hozz\u00e1 az a t\u00e1bl\u00e1hoz az \u00faj oszlopot: <code>alter table Customer add Total float</code></li> <li>Sz\u00e1moljuk ki az aktu\u00e1lis v\u00e9g\u00f6sszeget. A megold\u00e1shoz haszn\u00e1ljunk kurzort, ami minden vev\u0151n megy v\u00e9gig.</li> </ol> Megold\u00e1s <pre><code>declare cur_customer cursor\n    for select ID from Customer\ndeclare @CustomerId int\ndeclare @Total float\n\nopen cur_customer\nfetch next from cur_customer into @CustomerId\nwhile @@FETCH_STATUS = 0\nbegin\n\n    select @Total = sum(oi.Amount * oi.Price)\n    from CustomerSite s\n    inner join [Order] o on o.CustomerSiteID=s.ID\n    inner join OrderItem oi on oi.OrderID=o.ID\n    where s.CustomerID = @CustomerId\n\n    update Customer\n    set Total = ISNULL(@Total, 0)\n    where ID = @CustomerId\n\n    fetch next from cur_customer into @CustomerId\nend\n\nclose cur_customer\ndeallocate cur_customer\n</code></pre> <p>Ellen\u0151rizz\u00fck a <code>Customer</code> t\u00e1bla tartalm\u00e1t.</p>"},{"location":"seminar/mssql/#feladat-5-vevo-osszmegrendelesenek-karbantartasa-onallo-feladat","title":"Feladat 5: Vev\u0151 \u00f6sszmegrendel\u00e9s\u00e9nek karbantart\u00e1sa (\u00f6n\u00e1ll\u00f3 feladat)","text":"<p>Az el\u0151z\u0151 feladatban kisz\u00e1molt \u00e9rt\u00e9k az aktu\u00e1lis \u00e1llapotot tartalmazza csak. K\u00e9sz\u00edts\u00fcnk triggert, amivel karbantartjuk azt az \u00f6sszeget minden megrendel\u00e9st \u00e9rint\u0151 v\u00e1ltoz\u00e1s eset\u00e9n. Az \u00f6sszeg \u00fajrasz\u00e1mol\u00e1sa helyett csak friss\u00edtse a v\u00e1ltoz\u00e1sokkal az \u00e9rt\u00e9ket!</p> Megold\u00e1s <p>A megold\u00e1s kulcsa meghat\u00e1rozni, mely t\u00e1bl\u00e1ra kell a triggert tenni. A megrendel\u00e9sek v\u00e1ltoz\u00e1sa \u00e9rdekes sz\u00e1munkra, de val\u00f3j\u00e1ban a v\u00e9g\u00f6sszeg a megrendel\u00e9shez felvett t\u00e9telek m\u00f3dosul\u00e1sakor fog v\u00e1ltozni, \u00edgy erre a t\u00e1bl\u00e1ra kell a trigger.</p> <p>A feladat neh\u00e9zs\u00e9g\u00e9t az adja, hogy az <code>inserted</code> \u00e9s <code>deleted</code> t\u00e1bl\u00e1kban nem csak egy vev\u0151 adatai m\u00f3dosulhatnak. Egy lehets\u00e9ges megold\u00e1s a kor\u00e1bban haszn\u00e1lt kurzoros megk\u00f6zel\u00edt\u00e9s (itt a v\u00e1ltoz\u00e1sokon kell iter\u00e1lni). Avagy megpr\u00f3b\u00e1lhatjuk meg\u00edrni egy utas\u00edt\u00e1sban is, \u00fcgyelve arra, hogy vev\u0151k szerint csoportos\u00edtsuk a v\u00e1ltoz\u00e1sokat.</p> <p>Trigger</p> <pre><code>create or alter trigger CustomerTotalUpdate\non OrderItem\nfor insert, update, delete\nas\n\nupdate Customer\nset Total=isnull(Total,0) + TotalChange\nfrom Customer\ninner join\n    (select s.CustomerId, sum(Amount * Price) as TotalChange\n    from CustomerSite s\n    inner join [Order] o on o.CustomerSiteID=s.ID\n    inner join inserted i on i.OrderID=o.ID\n    group by s.CustomerId) CustomerChange on Customer.ID = CustomerChange.CustomerId\n\nupdate Customer\nset Total=isnull(Total,0) - TotalChange\nfrom Customer\ninner join\n    (select s.CustomerId, sum(Amount * Price) as TotalChange\n    from CustomerSite s\n    inner join [Order] o on o.CustomerSiteID=s.ID\n    inner join deleted d on d.OrderID=o.ID\n    group by s.CustomerID) CustomerChange on Customer.ID = CustomerChange.CustomerId\n</code></pre> <p>Tesztel\u00e9s</p> <p>N\u00e9zz\u00fck meg az \u00f6sszmegrendel\u00e9sek aktu\u00e1lis \u00e9rt\u00e9k\u00e9t, jegyezz\u00fck meg a sz\u00e1mokat.</p> <pre><code>select ID, Total\nfrom Customer\n</code></pre> <p>M\u00f3dos\u00edtsunk egy megrendel\u00e9s mennyis\u00e9g\u00e9n.</p> <pre><code>update OrderItem\nset Amount=3\nwhere ID=1\n</code></pre> <p>N\u00e9zz\u00fck meg az \u00f6sszegeket ism\u00e9t, meg kellett v\u00e1ltoznia a sz\u00e1mnak.</p> <pre><code>select ID, Total\nfrom Customer\n</code></pre>"},{"location":"seminar/rest/","title":"REST API &amp; ASP.NET Web API","text":"<p>A gyakorlat c\u00e9lja, hogy a hallgat\u00f3k gyakorolj\u00e1k a REST API-k tervez\u00e9s\u00e9t, \u00e9s megismerj\u00e9k a .NET Web API technol\u00f3gi\u00e1j\u00e1t.</p>"},{"location":"seminar/rest/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Microsoft Visual Studio 2022 (nem VS Code)</li> <li>Microsoft SQL Server (LocalDB vagy Express edition)</li> <li>SQL Server Management Studio</li> <li>Postman: https://www.getpostman.com/downloads/</li> <li>Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql</li> <li>Kiindul\u00f3 alkalmaz\u00e1s k\u00f3dja: https://github.com/bmeviauac01/gyakorlat-rest-kiindulo</li> </ul> <p>Amit \u00e9rdemes \u00e1tn\u00e9zned:</p> <ul> <li>C# nyelv</li> <li>Entity Framework \u00e9s Linq</li> <li>REST API \u00e9s Web API el\u0151ad\u00e1s</li> </ul>"},{"location":"seminar/rest/#gyakorlat-menete","title":"Gyakorlat menete","text":"<p>A gyakorlat v\u00e9gig vezetett, a gyakorlatvezet\u0151 utas\u00edt\u00e1sai szerint haladjunk. Egy-egy r\u00e9szfeladatot pr\u00f3b\u00e1ljunk meg el\u0151sz\u00f6r \u00f6n\u00e1ll\u00f3an megoldani, ut\u00e1na besz\u00e9lj\u00fck meg a megold\u00e1st k\u00f6z\u00f6sen. Az utols\u00f3 \u00e9s utols\u00f3 el\u0151tti feladat opcion\u00e1lis, ha belef\u00e9r az id\u0151be.</p> <p>Eml\u00e9keztet\u0151k\u00e9nt a megold\u00e1sok is megtal\u00e1lhat\u00f3ak az \u00fatmutat\u00f3ban is. El\u0151bb azonban pr\u00f3b\u00e1ljuk magunk megoldani a feladatot!</p>"},{"location":"seminar/rest/#0-feladat-adatbazis-letrehozasa-ellenorzese","title":"0. Feladat: Adatb\u00e1zis l\u00e9trehoz\u00e1sa, ellen\u0151rz\u00e9se","text":"<p>Az adatb\u00e1zis az adott g\u00e9phez k\u00f6t\u00f6tt, ez\u00e9rt nem biztos, hogy a kor\u00e1bban l\u00e9trehozott adatb\u00e1zis most is l\u00e9tezik. Ez\u00e9rt el\u0151sz\u00f6r ellen\u0151rizz\u00fck, \u00e9s ha nem tal\u00e1ljuk, akkor hozzuk l\u00e9tre \u00fajra az adatb\u00e1zist. (Ennek mik\u00e9ntj\u00e9t l\u00e1sd az els\u0151 gyakorlat anyag\u00e1ban.)</p>"},{"location":"seminar/rest/#1-feladat-projekt-megnyitasa","title":"1. Feladat: Projekt megnyit\u00e1sa","text":"<ol> <li> <p>T\u00f6lts\u00fck le a m\u00e9r\u00e9shez tartoz\u00f3 projekt v\u00e1zat!</p> <ul> <li>Nyissunk egy command prompt-ot</li> <li>Navig\u00e1ljunk el egy tetsz\u0151leges mapp\u00e1ba, p\u00e9ld\u00e1ul <code>c:\\work\\NEPTUN</code></li> <li>Adjuk ki a k\u00f6vetkez\u0151 parancsot: <code>git clone --depth 1 https://github.com/bmeviauac01/gyakorlat-rest-kiindulo.git</code></li> </ul> </li> <li> <p>Nyissuk meg a lekl\u00f3nozott k\u00f6nyvt\u00e1r alatti sln f\u00e1jlt Visual Studio-val.</p> </li> <li> <p>Vizsg\u00e1ljuk meg a projektet.</p> <ul> <li>Ez egy ASP.NET Core Web API projekt. Kifejezetten REST API-k kiszolg\u00e1l\u00e1s\u00e1hoz k\u00e9sz\u00fclt. Ha F5-tel elind\u00edtjuk, akkor mag\u00e1ban tartalmaz egy webszervert a k\u00e9r\u00e9sek kiszolg\u00e1l\u00e1s\u00e1hoz.</li> <li>N\u00e9zz\u00fck meg a <code>Program.cs</code> tartalm\u00e1t. L\u00e9nyeg\u00e9ben k\u00e9t r\u00e9szb\u0151l \u00e1ll:<ul> <li>L\u00e9trehoz egy <code>WebApplicationBuilder</code> objektumot, amelynek a <code>Services</code> tulajdons\u00e1g\u00e1n kereszt\u00fcl tudjuk konfigur\u00e1lni a Dependency Injection kont\u00e9nert.</li> <li><code>Build</code> ut\u00e1n az ASP.NET Core middleware pipeline-t tudjuk konfigur\u00e1lni, ahol jelenleg csak a controllerek t\u00e1mogat\u00e1s\u00e1t tal\u00e1lhatjuk. Majd futtatjuk ezt az alkalmaz\u00e1st egy be\u00e1gyazott webszerver (Kestrel) seg\u00edts\u00e9g\u00e9vel.</li> </ul> </li> <li>Az adatb\u00e1zisunk Entity Framework lek\u00e9pz\u00e9se (Code First modellel) megtal\u00e1lhat\u00f3 a <code>Dal</code> mapp\u00e1ban. Az <code>DataDrivenDbContext</code> lesz az el\u00e9r\u00e9s k\u00f6zponti oszt\u00e1lya. - A connection string az alkalmaz\u00e1s konfigur\u00e1ci\u00f3s \u00e1llom\u00e1ny\u00e1ban az <code>appsettings.json</code>-ben tal\u00e1lhat\u00f3.</li> <li>A <code>Controllers</code> mapp\u00e1ban m\u00e1r van egy teszt controller. Nyissuk meg \u00e9s vizsg\u00e1ljuk meg. Vegy\u00fck \u00e9szre az <code>[ApiController]</code> \u00e9s <code>[Route]</code> attrib\u00fatumokat, valamint a lesz\u00e1rmaz\u00e1st. Ett\u0151l lesz egy oszt\u00e1ly Web API controller. Minden tov\u00e1bbi automatikusan m\u0171k\u00f6dik, a controller met\u00f3dusai a megadott k\u00e9r\u00e9sekre (az \u00fatvonal \u00e9s http met\u00f3dus f\u00fcggv\u00e9ny\u00e9ben) meg fognak h\u00edv\u00f3dni (teh\u00e1t nincs tov\u00e1bbi konfigur\u00e1ci\u00f3ra sz\u00fcks\u00e9g).</li> </ul> </li> <li> <p>\u00cdrjuk \u00e1t az <code>appsettings.json</code> \u00e1llom\u00e1nyban az adatb\u00e1zisunk nev\u00e9t a connection string-ben a neptun k\u00f3dunkra.</p> </li> <li> <p>Ind\u00edtsuk el az alkalmaz\u00e1st. Ford\u00edt\u00e1s ut\u00e1n egy konzol alkalmaz\u00e1s indul el (b\u00f6ng\u00e9sz\u0151t most nem ind\u00edt automatikusan), ahol l\u00e1tjuk a logokat. Nyissunk egy b\u00f6ng\u00e9sz\u0151t, \u00e9s a http://localhost:5000/api/values c\u00edmet \u00edrjuk be. Kapnunk kell egy JSON v\u00e1laszt. \u00c1ll\u00edtsuk le az alkalmaz\u00e1st: vagy Ctrl+C_ a konzol alkalmaz\u00e1sban, vagy Visual Studio-ban \u00e1ll\u00edtsuk le.</p> </li> </ol>"},{"location":"seminar/rest/#2-feladat-elso-controller-es-metodus-teszteles-postmannel","title":"2. Feladat: Els\u0151 Controller \u00e9s met\u00f3dus, tesztel\u00e9s Postmannel","text":"<p>K\u00e9sz\u00edts\u00fcnk egy \u00faj Web API controllert, ami visszaad egy \u00fcdv\u00f6zl\u0151 sz\u00f6veget. Pr\u00f3b\u00e1ljuk ki a m\u0171k\u00f6d\u00e9st Postman haszn\u00e1lat\u00e1val.</p> <ol> <li>T\u00f6r\u00f6lj\u00fck ki a <code>ValuesController</code> oszt\u00e1lyt. Adjuk hozz\u00e1 helyette egy \u00faj Api Controller-t \u00fcresen <code>HelloController</code> n\u00e9ven: a Solution Explorer-ben a Controllers mapp\u00e1ra jobb eg\u00e9rrel kattintva Add / Controller... / API Controller - Empty. A <code>HelloController</code> a <code>/api/hello</code> url alatt legyen el\u00e9rhet\u0151.</li> <li>K\u00e9sz\u00edts\u00fcnk egy <code>GET</code> k\u00e9r\u00e9sre v\u00e1laszol\u00f3 met\u00f3dust, ami egy sz\u00f6veggel t\u00e9r vissza. Pr\u00f3b\u00e1ljuk ki Postman-nel: a GET k\u00e9r\u00e9st http://localhost:5000/api/hello c\u00edmre kell k\u00fclden\u00fcnk.</li> <li>M\u00f3dos\u00edtsuk a REST k\u00e9r\u00e9st kiszolg\u00e1l\u00f3 met\u00f3dust \u00fagy, hogy opcion\u00e1lisan fogadjon el egy nevet query param\u00e9terben, azaz az urlben, \u00e9s ha kap ilyet, akkor a v\u00e1lasza legyen \"Hello\" + a kapott n\u00e9v. Pr\u00f3b\u00e1ljuk ki ezt is Postmannel: Ha adunk nevet, akkor azt a http://localhost:5000/api/hello?name=alma url-je k\u00fcldj\u00fck.</li> <li>V\u00e9g\u00fcl k\u00e9sz\u00edts\u00fcnk egy \u00faj REST Api v\u00e9gpontot (\u00faj f\u00fcggv\u00e9nyt), ami a http://localhost:5000/api/hello/alma url-en fog v\u00e1laszolni pont \u00fagy, ahogy az el\u0151z\u0151 is tette (csak most a n\u00e9v a path r\u00e9sze).</li> </ol> Megold\u00e1s <pre><code>[Route(\"api/[controller]\")]\n[ApiController]\npublic class HelloController : ControllerBase\n{\n    // 2. alfeladat\n    //[HttpGet]\n    //public string Hello()\n    //{\n    //    return \"Hello!\";\n    //}\n\n    // 3. alfeladat\n    [HttpGet]\n    public string Hello([FromQuery] string name)\n    {\n        return string.IsNullOrEmpty(name)\n            ? \"Hello noname!\"\n            : $\"Hello {name}\";\n    }\n\n    // 4. alfeladat\n    [HttpGet(\"{personName}\")] // a route-ban a {} k\u00f6z\u00f6tti n\u00e9v meg kell egyezzen a param\u00e9ter nev\u00e9vel\n    public string HelloRoute(string personName)\n    {\n        return \"Hello route \" + personName;\n    }\n}\n</code></pre> <p>Foglaljuk \u00f6ssze, mi kell ahhoz, hogy egy WebAPI v\u00e9gpontot k\u00e9sz\u00edts\u00fcnk:</p> <ul> <li>Lesz\u00e1rmazni a <code>ControllerBase</code>-b\u0151l \u00e9s az <code>[ApiController]</code> attrib\u00fatumot r\u00e1tenni az oszt\u00e1lyra.<ul> <li>Ebben a p\u00e9ld\u00e1ban nem lenne fontos lesz\u00e1rmazni a <code>CotrollerBase</code>-b\u0151l, mert a keretrendszer nem k\u00f6veteli meg, \u00e9s nem haszn\u00e1ljuk az \u0151sben l\u00e9v\u0151 f\u00fcggv\u00e9nyeket sem itt.</li> </ul> </li> <li>Megadni, milyen http k\u00e9r\u00e9sre v\u00e1laszol a v\u00e9gpont a megfelel\u0151 <code>[Http*]</code> attrib\u00fatummal.</li> <li>Megadni a route-ot, ak\u00e1r az oszt\u00e1lyon, ak\u00e1r a met\u00f3duson (vagy mindkett\u0151n) a <code>[Route]</code> vagy a <code>[HttpXXX]</code> attrib\u00fatummal.</li> <li>Megfelel\u0151 form\u00e1j\u00fa met\u00f3dust k\u00e9sz\u00edteni (pl. visszat\u00e9r\u00e9si \u00e9rt\u00e9k, param\u00e9terek).</li> </ul>"},{"location":"seminar/rest/#3-feladat-termekek-keresese-api","title":"3. Feladat: Term\u00e9kek keres\u00e9se API","text":"<p>Egy val\u00f3di API term\u00e9szetesen nem konstansokat ad vissza. K\u00e9sz\u00edts\u00fcnk API-t a webshopban \u00e1rult term\u00e9kek k\u00f6z\u00f6tti keres\u00e9shez.</p> <ul> <li>K\u00e9sz\u00edts\u00fcnk ehhez egy \u00faj controller-t.</li> <li>Lehessen list\u00e1zni a term\u00e9keket, de csak lapozva (max 5 elem minden lapon).</li> <li>Lehessen keresni term\u00e9k n\u00e9vre.</li> <li>A visszaadott term\u00e9k entit\u00e1s ne az adatb\u00e1zis lek\u00e9pz\u00e9sb\u0151l j\u00f6v\u0151 entit\u00e1s legyen, hanem k\u00e9sz\u00edts\u00fcnk egy \u00faj, \u00fan. DTO (data transfer object) <code>record</code> oszt\u00e1lyt egy \u00faj, <code>Dtos</code> mapp\u00e1ban.</li> </ul>"},{"location":"seminar/rest/#dto-k-hasznalata","title":"DTO-k haszn\u00e1lata","text":"<p>A visszaadott term\u00e9k entit\u00e1s ne az adatb\u00e1zis lek\u00e9pz\u00e9sb\u0151l j\u00f6v\u0151 entit\u00e1s legyen, hanem k\u00e9sz\u00edts\u00fcnk egy \u00faj, \u00fan. DTO (data transfer object) oszt\u00e1lyt egy \u00faj, <code>Dtos</code> mapp\u00e1ban. K\u00e9sz\u00edts\u00fcnk <code>Product</code> n\u00e9ven egy rekord oszt\u00e1lyt a DTO sz\u00e1m\u00e1ra.</p> <p>Rekordok C#-ban</p> <p>A <code>record</code> kulcssz\u00f3 egy olyan t\u00edpust reprezent\u00e1l (alap\u00e9rtelmezetten class), ami a fejl\u00e9cben meghat\u00e1rozott konstruktorral \u00e9s <code>init</code> only setterrel rendelkez\u0151 tulajdons\u00e1gokkal rendelkezik. Ez\u00e1ltal egy record immutable viselked\u00e9ssel b\u00edr, ami jobban illeszkedik egy DTO viselked\u00e9s\u00e9hez. A rekordok ezen k\u00edv\u00fcl egy\u00e9b k\u00e9nyelmi szolg\u00e1ltat\u00e1sokkal is rendelkeznek (l\u00e1sd b\u0151vebben), de ezeket mi nem fogjuk itt kihaszn\u00e1lni.</p> Megold\u00e1s Dtos/Product.cs<pre><code>namespace Bme.DataDriven.Rest.Dtos;\n\npublic record Product(int Id, string Name, double? Price, int? Stock);\n</code></pre>"},{"location":"seminar/rest/#listazo-vegpont-keszitese","title":"List\u00e1z\u00f3 v\u00e9gpont k\u00e9sz\u00edt\u00e9se","text":"<p>K\u00e9sz\u00edts\u00fck el a k\u00f6vetelm\u00e9nyeknek megfelel\u0151 v\u00e9gpontot egy \u00faj <code>ProductController</code> oszt\u00e1lyban, majd pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st.</p> Megold\u00e1s <pre><code>using Microsoft.AspNetCore.Mvc;\n\nnamespace Bme.DataDriven.Rest.Controllers;\n\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class ProductController : ControllerBase\n{\n    private readonly Dal.DataDrivenDbContext _dbContext;\n\n    // Az adatbazist igy kaphatjuk meg. A kornyezet adja a Dependency Injection szolgaltatast.\n    // A DbContext automatikusan megszunik a keres veges (DI beallitas).\n    public ProductController(Dal.DataDrivenDbContext dbContext)\n    {\n        _dbContext = dbContext;\n    }\n\n    [HttpGet]\n    public List&lt;Dtos.Product&gt; List([FromQuery] string search = null, [FromQuery] int from = 0)\n    {\n        var filteredList = string.IsNullOrEmpty(search)\n            ? _dbContext.Product // ha nincs nev alapu kereses, az osszes termek\n            : _dbContext.Product.Where(p =&gt; p.Name.Contains(search)); // nev alapjan kereses\n\n        return filteredList\n            .Skip(from) // lapozashoz: hanyadik termektol kezdve\n            .Take(5) // egy lapon max 5 termek\n            .Select(p =&gt; new Dtos.Product(p.Id, p.Name, p.Price, p.Stock)) // adatbazis entitas -&gt; DTO\n            .ToList(); // a fenti IQueryable kiertekelesesen kieroltetese, kulonben hibara futnank\n    }\n}\n</code></pre> <p>Az adatb\u00e1zis kontextust DI-on kereszt\u00fck konstruktor param\u00e9terk\u00e9nt k\u00e9rhetj\u00fck el egyszer\u0171en.</p> <p>Vegy\u00fck \u00e9szre, hogy a JSON soros\u00edt\u00e1ssal nem kellett foglalkoznunk. Az API csak DTO-t ad vissza, a soros\u00edt\u00e1sr\u00f3l automatikusan gondoskodik a keretrendszer.</p> <p>Lapoz\u00e1st az\u00e9rt \u00e9rdemes beiktatni, hogy korl\u00e1tozzuk a visszaadott v\u00e1laszt (ahogy a felhaszn\u00e1l\u00f3i fel\u00fcleteken is szok\u00e1s lapozni). Erre tipikus megold\u00e1s ez a \"-t\u00f3l\" jelleg\u0171 megold\u00e1s.</p> <p>Lapoz\u00e1s m\u00e1sk\u00e9ppen</p> <p>Lapoz\u00e1st sok fajta m\u00f3don tervezhetj\u00fck a REST API-k eset\u00e9ben. A fenti megold\u00e1s a legegyszer\u0171bb, de elk\u00e9pzelhet\u0151 olyan megk\u00f6zel\u00edt\u00e9s is, hogy a kliens meghat\u00e1rozhassa a lapm\u00e9retet \u00e9s az abszol\u00fat <code>from</code> offset helyett a k\u00e9rt lap index\u00e9t adja meg a k\u00e9r\u00e9sben.</p> <p>A met\u00f3dus eredm\u00e9nye a <code>ToList</code>-et megel\u0151z\u0151en egy <code>IQueryable&lt;T&gt;</code>. Eml\u00e9kezz\u00fcnk arra, hogy az <code>IQueryable&lt;T&gt;</code> nem tartalmazza az eredm\u00e9nyt, az csak egy le\u00edr\u00f3.</p> <p><code>IQueryable&lt;T&gt;</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k \u00e9s <code>DbContext</code> \u00e9letciklus</p> <p>Ha nem lenne a v\u00e9g\u00e9n <code>ToList</code>, akkor hib\u00e1ra futna az alkalmaz\u00e1s, mert amikor a JSON soros\u00edt\u00e1s elkezden\u00e9 iter\u00e1lni a gy\u0171jtem\u00e9nyt, m\u00e1r egy megsz\u0171nt adatb\u00e1zis kapcsolaton pr\u00f3b\u00e1lna dolgozni. A WebAPI v\u00e9gpontokb\u00f3l soha ne adjunk emiatt <code>IQueryable</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9ket!</p> <p>Az okok arra vezethet\u0151ek vissza, hogy alap\u00e9rtelmezetten a <code>DbContext</code> t\u00edpusok <code>Scoped</code> \u00e9letciklussal ker\u00fclnek beregisztr\u00e1l\u00e1sra a DI kont\u00e9nerbe, \u00e9s ASP.NET Core eset\u00e9ben alap\u00e9rtelmezetten egy HTTP k\u00e9r\u00e9s sor\u00e1n keletkezik egy scope. Viszont a soros\u00edt\u00e1s m\u00e1r k\u00edv\u00fcl esne ezen a scope-on.</p>"},{"location":"seminar/rest/#4-feladat-termekek-adatainak-szerkesztes-api","title":"4. Feladat: Term\u00e9kek adatainak szerkeszt\u00e9s API","text":"<p>Eg\u00e9sz\u00edts\u00fck ki a term\u00e9kek keres\u00e9s\u00e9hez sz\u00fcletett API-t az al\u00e1bbi funkci\u00f3kkal:</p> <ul> <li>Lehessen egy adott term\u00e9k adatait lek\u00e9rdezni a term\u00e9k id-ja alapj\u00e1n a <code>/api/products/id</code> url-en.</li> <li>Tudjunk m\u00f3dos\u00edtani meglev\u0151 term\u00e9ket (nevet, \u00e1rat, rakt\u00e1rk\u00e9szletet).</li> <li>Lehessen felvenni \u00faj term\u00e9ket (ehhez k\u00e9sz\u00edts\u00fcnk egy \u00faj DTO oszt\u00e1lyt, amiben csak a n\u00e9v, rakt\u00e1rk\u00e9szlet \u00e9s \u00e1r van).</li> <li>Lehessen t\u00f6r\u00f6lni egy term\u00e9ket az id-ja alapj\u00e1n.</li> </ul> <p>Mindegyik v\u00e9gpontot tesztelj\u00fck!</p> REST API tervez\u00e9si konvenci\u00f3k cheatsheet <p>REST API-k eset\u00e9ben minden URL (path r\u00e9sze) egy-egy er\u0151forr\u00e1st reprezent\u00e1l, amelyeken HTTP ig\u00e9kkel tudunk m\u0171veleteket v\u00e9gezni, a szerver pedig HTTP st\u00e1tuszk\u00f3dok \u00e9s DTO-k form\u00e1j\u00e1ban v\u00e1laszol.</p> <p>Tipikus CRUD er\u0151forr\u00e1sok, \u00e9s m\u0171veleteik</p> Ige URL Sikeres v\u00e1laszk\u00f3d Le\u00edr\u00e1s GET /api/product 200 OK er\u0151forr\u00e1sok list\u00e1ja GET /api/product?name=Test 200 OK er\u0151forr\u00e1sok list\u00e1ja (sz\u0171rt) POST /api/product 201 Created list\u00e1ba besz\u00far\u00e1s GET /api/product/1 200 OK egy adott azonos\u00edt\u00f3j\u00fa er\u0151forr\u00e1s lek\u00e9rdez\u00e9se PUT, PATCH /api/product/1 200 OK egy adott azonos\u00edt\u00f3j\u00fa er\u0151forr\u00e1s m\u00f3dos\u00edt\u00e1sa DELETE /api/product/1 204 NoContent egy adott azonos\u00edt\u00f3j\u00fa er\u0151forr\u00e1s t\u00f6rl\u00e9se <p>Tipikus hiba\u00e1gi v\u00e1laszk\u00f3dok REST API-k eset\u00e9ben</p> Ki hib\u00e1zott V\u00e1laszk\u00f3d Le\u00edr\u00e1s Kliens 400 Bad Request Kliens szemantikailag hib\u00e1s adatokat k\u00fcld\u00f6tt Kliens 401 Unauthorized Bejelentkez\u00e9s sz\u00fcks\u00e9ges Kliens 403 Forbidden Van bejelentkezett user, de nincs joga a m\u0171velethez Kliens 404 Not Found Er\u0151forr\u00e1s nem tal\u00e1lhat\u00f3 Szerver 500 Internal Server Error Nem v\u00e1rt hiba t\u00f6rt\u00e9nt"},{"location":"seminar/rest/#lekeres-id-szerint","title":"Lek\u00e9r\u00e9s ID szerint","text":"<p>A lek\u00e9r\u00e9s sor\u00e1n gondoljuk arra is, ha a k\u00e9r\u00e9sben olyan ID \u00e9rkezik, amely nem l\u00e9tezik az adatb\u00e1zisban. Ilyenkor <code>404 Not Found</code> HTTP st\u00e1tuszk\u00f3ddal t\u00e9rj\u00fcnk vissza. Ehhez haszn\u00e1ljuk az <code>ActionResult&lt;T&gt;</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9ket, \u00e9s a <code>ControllerBase</code>-ben l\u00e9v\u0151 seg\u00e9df\u00fcggv\u00e9nyeket.</p> Megold\u00e1s <pre><code>[HttpGet(\"{id}\")]\npublic ActionResult&lt;Dtos.Product&gt; Get(int id)\n{\n    var dbProduct = _dbContext.Product.SingleOrDefault(p =&gt; p.Id == id);\n    return dbProduct != null\n        ? Ok(new Dtos.Product(dbProduct.Id, dbProduct.Name, dbProduct.Price, dbProduct.Stock)) // siker eseten visszaadjuk az adatot magat\n        : NotFound(); // 404 http valasz, ha nem talalhato a keresett elem\n}\n</code></pre> <p>ActionResult alap\u00e9rtelmezett m\u00f3don <p>A v\u00e1laszk\u00f3d testreszab\u00e1sa az <code>ActionResult&lt;T&gt;</code> oszt\u00e1ly \u00e9s seg\u00e9df\u00fcggv\u00e9nyei seg\u00edts\u00e9g\u00e9vel egy\u00e9rtelm\u0171. Viszont gondoljunk bele, hogy az el\u0151z\u0151 feladatokban csak DTO-val t\u00e9rt\u00fcnk vissza, ahol a keretrendszer a 200 OK alap\u00e9rtelmez\u00e9ssel \u00e9lt, \u00edgy nem volt fontos explicit <code>ActionResult&lt;T&gt;</code>-vel visszat\u00e9rni.</p> <p>M\u00e9g egy egyszer\u0171s\u00edt\u00e9st ad a keretrendszer, m\u00e9gpedig akkor is visszat\u00e9rhet\u00fcnk a nat\u00far DTO-val, ha a controller action visszat\u00e9r\u00e9si \u00e9rt\u00e9ke <code>ActionResult&lt;T&gt;</code> pl.:</p> <pre><code>return dbProduct != null\n    ? new Dtos.Product(dbProduct.Id, dbProduct.Name, dbProduct.Price, dbProduct.Stock)\n    : NotFound();\n</code></pre>"},{"location":"seminar/rest/#uj-termek-beszurasa","title":"\u00daj term\u00e9k besz\u00far\u00e1sa","text":"<ul> <li>K\u00e9sz\u00edts\u00fck el a szerver ir\u00e1ny\u00e1ba \u00e9rkez\u0151 DTO oszt\u00e1lyt rekordk\u00e9nt, \u00e9s a besz\u00far\u00f3 v\u00e9gpontot.</li> <li>A besz\u00far\u00e1s tipikusan a list\u00e1s er\u0151forr\u00e1s URL-j\u00e9re k\u00fcld\u00f6tt POST k\u00e9r\u00e9s</li> <li>V\u00e1laszk\u00e9nt t\u00e9rj\u00fcnk vissza a besz\u00fart adatokkal \u00e9s a <code>Location</code> headerben a besz\u00fart er\u0151forr\u00e1s URL-j\u00e9vel. Ehhez a <code>CreatedAtAction</code> met\u00f3dus lesz seg\u00edts\u00e9g\u00fcnkre.</li> </ul> Megold\u00e1s <pre><code>namespace Bme.DataDriven.Rest.Dtos;\n\npublic record NewProduct(string Name, double? Price, int? Stock);\n</code></pre> <pre><code>[HttpPost]\npublic ActionResult&lt;Dtos.Product&gt; Add([FromBody] Dtos.NewProduct newProduct)\n{\n    var dbProduct = new Dal.Product()\n    {\n        Name = newProduct.Name,\n        Price = newProduct.Price,\n        Stock = newProduct.Stock,\n        CategoryId = 1, // nem szep, ideiglenes megoldas\n        VatId = 1 // nem szep, ideiglenes megoldas\n    };\n\n    // mentes az adatbazisba\n    _dbContext.Product.Add(dbProduct);\n    _dbContext.SaveChanges();\n\n    // igy mondjuk meg, hol kerdezheto le a beszurt elem\n    return CreatedAtAction(\n        nameof(Get),\n        new { id = dbProduct.Id },\n        new Dtos.Product(dbProduct.Id, dbProduct.Name, dbProduct.Price, dbProduct.Stock)); \n}\n</code></pre> <p>\u00daj term\u00e9k besz\u00far\u00e1s\u00e1hoz Postman-ben az al\u00e1bbi be\u00e1ll\u00edt\u00e1sokra lesz sz\u00fcks\u00e9g:</p> <ul> <li>POST k\u00e9r\u00e9s a helyes URL-re</li> <li>A Body f\u00fcl alatt a <code>raw</code> \u00e9s jobb oldalon a <code>JSON</code> kiv\u00e1laszt\u00e1sa</li> <li> <p>Az al\u00e1bbi body json:</p> <pre><code>{\n    \"name\": \"BME-s kardig\u00e1n\",\n    \"price\": 8900,\n    \"stock\": 100\n}\n</code></pre> </li> </ul> <p>A tesztel\u00e9s sor\u00e1n n\u00e9zz\u00fck meg a kapott v\u00e1lasz Header-jeit is! A besz\u00far\u00e1s eset\u00e9n keress\u00fck meg benne a <code>Location</code> kulcsot. Itt adja vissza a rendszer, hol k\u00e9rdezhet\u0151 le az eredm\u00e9ny. Emellett \u00e1ltal\u00e1ban a POST k\u00e9r\u00e9s a v\u00e1laszban is vissza szokta adni a besz\u00fart adatokat.</p>"},{"location":"seminar/rest/#termek-modositasa","title":"Term\u00e9k m\u00f3dos\u00edt\u00e1sa","text":"<ul> <li>A m\u00f3dos\u00edt\u00e1st tipikusan a PUT ige reprezent\u00e1lja.</li> <li>Nem l\u00e9tez\u0151 er\u0151forr\u00e1s m\u00f3dos\u00edt\u00e1sa 404-es hibak\u00f3dot eredm\u00e9nyezzen.</li> <li>A m\u00f3dos\u00edt\u00e1s megval\u00f3s\u00edt\u00e1sa sor\u00e1n haszn\u00e1ljuk a megl\u00e9v\u0151 <code>Product</code> DTO-t \u00e9s valid\u00e1ljuk le, hogy azonos-e a path-ba \u00e9s a body-ban kapott ID. Ehhez a <code>ModelState</code> tulajdons\u00e1got \u00e9s a <code>BadRequest</code> f\u00fcggv\u00e9nyeket tudjuk haszn\u00e1lni.</li> <li>A m\u00f3dos\u00edt\u00e1s szok\u00e1sos m\u00f3don EF-en kereszt\u00fcl zajlik.</li> <li>A m\u00f3dos\u00edt\u00f3 f\u00fcggv\u00e9ny is tipikusan vissza szokott t\u00e9rni a m\u00f3dos\u00edtott adatokkal.</li> </ul> Megold\u00e1s <pre><code>[HttpPut(\"{id}\")]\npublic ActionResult&lt;Dtos.Product&gt; Modify([FromRoute]int id, [FromBody]Dtos.Product updated)\n{\n    if (id != updated.Id)\n    {\n        ModelState.AddModelError(nameof(id), \"Nem megfelel\u0151 a kapott ID\");\n        return BadRequest(ModelState);\n    }\n\n    var dbProduct = _dbContext.Product.SingleOrDefault(p =&gt; p.Id == id);\n    if (dbProduct == null)\n        return NotFound();\n\n    // modositasok elvegzese\n    dbProduct.Name = updated.Name;\n    dbProduct.Price = updated.Price;\n    dbProduct.Stock = updated.Stock;\n\n    // mentes az adatbazisban\n    _dbContext.SaveChanges();\n\n    return new Dtos.Product(dbProduct.Id, dbProduct.Name, dbProduct.Price, dbProduct.Stock);\n}\n</code></pre> <p>A m\u00f3dos\u00edt\u00e1s tesztel\u00e9s\u00e9hez az al\u00e1bbi be\u00e1ll\u00edt\u00e1sokra lesz sz\u00fcks\u00e9g:</p> <ul> <li>PUT k\u00e9r\u00e9s a helyes URL-re</li> <li>A Body f\u00fcl alatt a <code>raw</code> \u00e9s jobb oldalon a <code>JSON</code> kiv\u00e1laszt\u00e1sa</li> <li> <p>Az al\u00e1bbi body json:</p> <pre><code>{\n    \"id\": 10,\n    \"name\": \"Egy \u00f3ra csend\",\n    \"price\": 440,\n    \"stock\": 10\n}\n</code></pre> </li> </ul> <p></p> <p>Pr\u00f3b\u00e1ljuk ki a k\u00e9r\u00e9st \u00fagyis, hogy nem egyezik a path-ban \u00e9s a body-ban l\u00e9v\u0151 k\u00e9t ID. Ilyenkor 400-as Bad Requestet kell kapjunk a hiba r\u00e9szleteivel.</p> <p>DTO-k valid\u00e1ci\u00f3ja</p> <p>A DTO-kat egy\u00e9b valid\u00e1ci\u00f3knak is al\u00e1vethetj\u00fck, amire haszn\u00e1lhatjuk az ASP.NET Core be\u00e9p\u00edtett valid\u00e1ci\u00f3s attrib\u00fatumait vagy ak\u00e1r egy\u00e9b k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1rakat, mint a FluentValidation.</p> <p>PUT vs PATCH</p> <p>A m\u00f3dos\u00edt\u00e1s m\u0171veletre a PUT vagy a PATCH ig\u00e9ket szok\u00e1s haszn\u00e1lni, amelyek k\u00f6z\u00f6tt a f\u0151 k\u00fcl\u00f6nbs\u00e9g, hogy a PUT a teljes m\u00f3dos\u00edtott er\u0151forr\u00e1st v\u00e1rja bemenetk\u00e9nt, a PATCH viszont csak egy r\u00e9szleges adathalmazt (tipikusan kulcs \u00e9rt\u00e9k p\u00e1rokat). .NET k\u00f6rnyezetben a PUT-ot egyszer\u0171bb implement\u00e1lni, de a PATCH-re is van be\u00e9p\u00edtett t\u00e1mogat\u00e1s.</p>"},{"location":"seminar/rest/#termek-torlese","title":"Term\u00e9k t\u00f6rl\u00e9se","text":"<ul> <li>A t\u00f6rl\u00e9shez a DELETE HTTP ig\u00e9t haszn\u00e1ljuk, v\u00e1laszk\u00e9nt 204 No Content v\u00e1laszt \u00e1ll\u00edtson el\u0151 sikeres \u00e1gon.</li> <li>Nem l\u00e9tez\u0151 er\u0151forr\u00e1s itt is 404-et eredm\u00e9nyezzen.</li> </ul> Megold\u00e1s <pre><code>[HttpDelete(\"{id}\")]\npublic ActionResult Delete(int id)\n{\n    var dbProduct = _dbContext.Product.SingleOrDefault(p =&gt; p.Id == id);\n    if (dbProduct == null)\n        return NotFound();\n\n    _dbContext.Product.Remove(dbProduct);\n    _dbContext.SaveChanges();\n\n    return NoContent(); // a sikeres torlest 204 NoContent valasszal jelezzuk (lehetne meg 200 OK is, ha beletennenk an entitast)\n}\n</code></pre> <p>Idempotens t\u00f6rl\u00e9s m\u0171velet</p> <p>Egy tipikus tervez\u0151i d\u00f6nt\u00e9s szokott az lenni, hogy a t\u00f6rl\u00e9s m\u0171velet legyen idempotens, teh\u00e1t egym\u00e1s ut\u00e1n t\u00f6bbsz\u00f6r lefuttatva is azonos eredm\u00e9nyt adjon. Ez a mi eset\u00fcnkben nem lesz igaz, mert nem l\u00e9tez\u0151 er\u0151forr\u00e1sra 404-et k\u00fcld\u00fcnk, m\u00edg l\u00e9tez\u0151re 204-et. Ezt a m\u0171veletet \u00fagy lehetne idempotenss\u00e9 tenni, ha minden esetben 204-es st\u00e1tuszk\u00f3ddal t\u00e9rn\u00e9nk vissza, m\u00e9g akkor is, ha nem csin\u00e1ltunk semmit.</p>"},{"location":"seminar/rest/#5-feladat-opcionalis-uj-termek-letrehozasa-kategoria-es-afakulcs","title":"5. Feladat (opcion\u00e1lis): \u00daj term\u00e9k l\u00e9trehoz\u00e1sa: kateg\u00f3ria \u00e9s \u00e1fakulcs","text":"<p>Az \u00faj term\u00e9k l\u00e9trehoz\u00e1sa sor\u00e1n meg kellene adnunk m\u00e9g a kateg\u00f3ri\u00e1t \u00e9s az \u00e1fakulcsot is. M\u00f3dos\u00edtsuk a fenti term\u00e9k besz\u00far\u00e1st \u00fagy, hogy a kateg\u00f3ria nev\u00e9t \u00e9s az \u00e1fakulcs sz\u00e1m\u00e9rt\u00e9k\u00e9t is meg lehessen adni. A kapott adatok alapj\u00e1n keresd ki a megfelel\u0151 <code>VAT</code> \u00e9s <code>Category</code> rekordokat az adatb\u00e1zisb\u00f3l, vagy hozz l\u00e9tre \u00fajat, ha nem l\u00e9teznek.</p> Megold\u00e1s NewProduct.cs<pre><code>public record NewProduct(\n    string Name,\n    double? Price,\n    int? Stock,\n    int VatPercentage,\n    string CategoryName);\n</code></pre> ProductController.cs<pre><code>[HttpPost]\npublic ActionResult&lt;Dtos.Product&gt; Add([FromBody]Dtos.NewProduct newProduct)\n{\n    var dbVat = _dbContext.Vat.SingleOrDefault(v =&gt; v.Percentage == newProduct.VatPercentage);\n    if (dbVat == null)\n        dbVat = new Dal.VAT() { Percentage = newProduct.VatPercentage };\n\n    var dbCat = _dbContext.Category.SingleOrDefault(c =&gt; c.Name == newProduct.CategoryName);\n    if (dbCat == null)\n        dbCat = new Dal.Category() { Name = newProduct.CategoryName };\n\n    var dbProduct = new Dal.Product()\n    {\n        Name = newProduct.Name,\n        Price = newProduct.Price,\n        Stock = newProduct.Stock,\n        Category = dbCat,\n        VAT = dbVat,\n    };\n\n    // mentes az adatbazisba\n    _dbContext.Product.Add(dbProduct);\n    _dbContext.SaveChanges();\n\n    // igy mondjuk meg, hol kerdezheto le a beszurt elem\n    return CreatedAtAction(\n        nameof(Get),\n        new { id = dbProduct.Id },\n        new Dtos.Product(dbProduct.Id, dbProduct.Name, dbProduct.Price, dbProduct.Stock)); \n}\n</code></pre>"},{"location":"seminar/rest/#feladat-6-opcionalis-aszinkron-kontroller-metodus","title":"Feladat 6 (opcion\u00e1lis): Aszinkron kontroller met\u00f3dus","text":"<p>Az el\u0151bbi feladatot \u00edrjuk \u00e1t aszinkronra, azaz haszn\u00e1ljunk <code>async-await</code>-et. Az aszinkron v\u00e9grehajt\u00e1ssal a kiszolg\u00e1l\u00f3 hat\u00e9konyabban haszn\u00e1lja a rendelkez\u00e9sre \u00e1ll\u00f3 sz\u00e1lainkat amikor az adatb\u00e1zis m\u0171veletekre v\u00e1runk. Az\u00e9rt tudjuk ezt k\u00f6nnyed\u00e9n megtenni, mert az Entity Framework alapb\u00f3l biztos\u00edt sz\u00e1munkra aszinkron v\u00e9grehajt\u00e1st, \u00edgy a kontroller met\u00f3dusunkban ezt fel tudjuk haszn\u00e1lni.</p> Megold\u00e1s <pre><code>[HttpPost]\npublic async Task&lt;ActionResult&lt;Dtos.Product&gt;&gt; Add([FromBody]Dtos.NewProduct newProduct)\n{\n    var dbVat = await _dbContext.Vat.SingleOrDefaultAsync(v =&gt; v.Percentage == newProduct.VatPercentage);\n    if (dbVat == null)\n        dbVat = new Dal.VAT() { Percentage = newProduct.VatPercentage };\n\n    var dbCat = await _dbContext.Category.SingleOrDefaultAsync(c =&gt; c.Name == newProduct.CategoryName);\n    if (dbCat == null)\n        dbCat = new Dal.Category() { Name = newProduct.CategoryName };\n\n    var dbProduct = new Dal.Product()\n    {\n        Name = newProduct.Name,\n        Price = newProduct.Price,\n        Stock = newProduct.Stock,\n        Category = dbCat,\n        VAT = dbVat,\n    };\n\n    // mentes az adatbazisba\n    _dbContext.Product.Add(dbProduct);\n    await _dbContext.SaveChangesAsync();\n\n    // igy mondjuk meg, hol kerdezheto le a beszurt elem\n    return CreatedAtAction(\n        nameof(Get),\n        new { id = dbProduct.Id },\n        new Dtos.Product(dbProduct.Id, dbProduct.Name, dbProduct.Price, dbProduct.Stock)); \n}\n</code></pre> <p>Vegy\u00fck \u00e9szre, mennyire egyszer\u0171 volt a dolgunk. Az Entity Framework \u00e1ltal biztos\u00edtott <code>...Async</code> met\u00f3dusokat haszn\u00e1ljuk, mindegyiket <code>await</code>-elve, \u00e9s a met\u00f3dus szignat\u00far\u00e1j\u00e1t kellett \u00e1t\u00edrnunk <code>Task&lt;T&gt;</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171re (hogy k\u00edv\u00fclr\u0151l bev\u00e1rhat\u00f3 legyen aszinkron) \u00e9s ell\u00e1tni <code>async</code> kulcssz\u00faval (hogy <code>await</code>-et tudjunk benne haszn\u00e1lni). Minden m\u00e1sr\u00f3l tov\u00e1bbra is a keretrendszer gondoskodik.</p> <p>Aszinkronit\u00e1s szerveralkalmaz\u00e1sokban</p> <p>Az <code>async-await</code> .NET keretrendszer k\u00e9pess\u00e9g, amelyet az ASP.NET Core \u00e9s az Entity Framework is t\u00e1mogat. Sz\u00e1mos m\u00e1s helyen is tal\u00e1lkozhatunk azonban vele, p\u00e9ld\u00e1ul kliensalkalmaz\u00e1sok eset\u00e9ben.</p> <p>Szerveralkalmaz\u00e1sokn\u00e1l els\u0151dleges c\u00e9lunk az \u00e1tereszt\u0151k\u00e9pess\u00e9g n\u00f6vel\u00e9se az\u00e1ltal, hogy az aszinkron v\u00e1rakoz\u00e1s k\u00f6zben (eset\u00fcnkben DB m\u0171velet), a kiszolg\u00e1l\u00f3 sz\u00e1l m\u00e1sik HTTP k\u00e9r\u00e9ssel is tudjon foglalkozni.</p>"},{"location":"seminar/transactions/","title":"Tranzakci\u00f3kezel\u00e9s","text":"<p>A gyakorlat c\u00e9lja a rel\u00e1ci\u00f3s adatb\u00e1zisok \u00e9s a Microsoft SQL Server tranzakci\u00f3kezel\u00e9s\u00e9nek megismer\u00e9se, a serializable izol\u00e1ci\u00f3s szint gyakorlati haszn\u00e1lhat\u00f3s\u00e1g\u00e1nak korl\u00e1tai, egyedi adat egym\u00e1sra hat\u00e1sok szab\u00e1lyoz\u00e1sa read committed izol\u00e1ci\u00f3s szinten.</p>"},{"location":"seminar/transactions/#elofeltetelek","title":"El\u0151felt\u00e9telek","text":"<p>A labor elv\u00e9gz\u00e9s\u00e9hez sz\u00fcks\u00e9ges eszk\u00f6z\u00f6k:</p> <ul> <li>Microsoft SQL Server (LocalDB vagy Express edition)</li> <li>SQL Server Management Studio</li> <li>Adatb\u00e1zis l\u00e9trehoz\u00f3 script: mssql.sql</li> </ul> <p>Amit \u00e9rdemes \u00e1tn\u00e9zned:</p> <ul> <li>Tranzakci\u00f3k tulajdons\u00e1gai, izol\u00e1ci\u00f3s szintek</li> <li>Microsoft SQL Server haszn\u00e1lata seg\u00e9dlet</li> </ul>"},{"location":"seminar/transactions/#gyakorlat-menete","title":"Gyakorlat menete","text":"<p>A gyakorlat vezetett. A szoftverekkel t\u00f6rt\u00e9n\u0151 megismerked\u00e9s ut\u00e1n a gyakorlatvezet\u0151 instrukci\u00f3i alapj\u00e1n egy\u00fctt ker\u00fclnek elv\u00e9gz\u00e9sre a feladatok. A tapasztalt viselked\u00e9sekre magyar\u00e1zatot keres\u00fcnk, \u00e9s azt a csoport egy\u00fctt megbesz\u00e9li.</p> <p>A viselked\u00e9sek magyar\u00e1zat\u00e1t r\u00f6viden \u00f6sszefoglalja az \u00fatmutat\u00f3 is. El\u0151bb azonban gondolkodjunk el magunk a k\u00e9rd\u00e9seken!</p>"},{"location":"seminar/transactions/#feladat-1-adatbazis-letrehozasa-ms-sql-serveren","title":"Feladat 1: Adatb\u00e1zis l\u00e9trehoz\u00e1sa MS SQL Serveren","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt sz\u00fcks\u00e9g\u00fcnk lesz egy adatb\u00e1zisra. Az adatb\u00e1zis tipikusan egy k\u00f6zponti kiszolg\u00e1l\u00f3n helyezkedik el, de fejleszt\u00e9s k\u00f6zben sokszor a saj\u00e1t g\u00e9p\u00fcnk\u00f6n fut. Mi ez ut\u00f3bbi opci\u00f3t v\u00e1lasztjuk.</p> <ol> <li> <p>Kapcsol\u00f3djon a Microsoft SQL Serverhez SQL Server Management Studio Seg\u00edts\u00e9g\u00e9vel. Ind\u00edtsa el az alkalmaz\u00e1st, \u00e9s az al\u00e1bbi adatokkal kapcsol\u00f3djon.</p> <ul> <li>Server name: <code>(localdb)\\mssqllocaldb</code></li> <li>Authentication: <code>Windows authentication</code></li> </ul> </li> <li> <p>Hozzon l\u00e9tre egy \u00faj adatb\u00e1zist (ha m\u00e9g nem l\u00e9tezik), az adatb\u00e1zis neve legyen a Neptun k\u00f3dja: Object Explorer-ben Databases-en jobb kattint\u00e1s, \u00e9s Create Database.</p> </li> <li> <p>Hozza l\u00e9tre a minta adatb\u00e1zist a gener\u00e1l\u00f3 script lefuttat\u00e1s\u00e1val. Nyisson egy \u00faj Query ablakot, m\u00e1solja be a script tartalm\u00e1t, \u00e9s futtassa le. \u00dcgyeljen az eszk\u00f6zt\u00e1ron lev\u0151 leg\u00f6rd\u00fcl\u0151 men\u00fcben a megfelel\u0151 adatb\u00e1zis kiv\u00e1laszt\u00e1s\u00e1ra.</p> <p></p> </li> <li> <p>Ellen\u0151rizze, hogy l\u00e9trej\u00f6ttek-e a t\u00e1bl\u00e1k. Ha a Tables mappa ki volt m\u00e1r nyitva, akkor friss\u00edteni kell.</p> <p>.</p> </li> <li> <p>B\u00e1r l\u00e9trej\u00f6ttek az \u00faj t\u00e1bl\u00e1k, a Management Studio sokszor m\u00e9gis pirosan al\u00e1h\u00fazza amikor g\u00e9pel\u00fcnk. Ennek elker\u00fcl\u00e9se \u00e9rdek\u00e9ben az Edit &gt; IntelliSense &gt; Refresh Local Cache men\u00fcpontot kiv\u00e1lasztva vagy a Ctrl+Shift+R billenty\u0171kombin\u00e1ci\u00f3val az IntelliSense gyors\u00edt\u00f3t\u00e1r\u00e1t friss\u00edts\u00fck.</p> <p>.</p> </li> </ol>"},{"location":"seminar/transactions/#feladat-2-parhuzamos-tranzakciok","title":"Feladat 2: P\u00e1rhuzamos tranzakci\u00f3k","text":"<p>Nyisson k\u00e9t Query ablakot p\u00e1rhuzamos tranzakci\u00f3k szimul\u00e1l\u00e1s\u00e1hoz a New Query gomb k\u00e9tszeri megnyom\u00e1s\u00e1val. \u00c9rdemes az ablakokat egym\u00e1s mell\u00e9 tenni: a Query f\u00fcl fejl\u00e9c\u00e9re jobb eg\u00e9rrel kattintva v\u00e1lasszuk a New Vertical Tab Group opci\u00f3t:</p> <p></p> <p>Haszn\u00e1lja az al\u00e1bbi \u00fctemez\u00e9st a parancsok v\u00e9grehajt\u00e1s\u00e1ra. A T1 tranzakci\u00f3 a 4-es megrendel\u00e9s st\u00e1tusz\u00e1t ellen\u0151rzi, m\u00edg a T2 tranzakci\u00f3 megv\u00e1ltoztatja a st\u00e1tuszt csomagolv\u00e1r\u00f3l sz\u00e1ll\u00edt\u00e1s alattira.</p> <ol> <li> <p>T1 tranzakci\u00f3</p> <pre><code>-- List\u00e1zzuk ki a megrendel\u00e9s \u00e9s a hozz\u00e1 tartoz\u00f3 t\u00e9telek st\u00e1tusz\u00e1t\nselect s1.Name, p.Name, s2.Name\nfrom [Order] o, OrderItem oi, Status s1, status s2, Product p\nwhere o.Id=oi.OrderID\nand o.ID=4\nand o.StatusID=s1.ID\nand oi.StatusID=s2.ID\nand p.ID=oi.ProductID\n</code></pre> <p><code>[Order]</code></p> <p>Az <code>[Order]</code> t\u00e1bla nev\u00e9ben az\u00e9rt kell a sz\u00f6gletes z\u00e1r\u00f3jel, hogy jelezz\u00fck, t\u00e1bla n\u00e9vr\u0151l van sz\u00f3, \u00e9s nem az <code>order by</code> parancs kezdet\u00e9r\u0151l.</p> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>-- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9s \u00e1llapot\u00e1t\nupdate [Order]\nset StatusID=4\nwhere ID=4\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3: els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve</p> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>-- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9shez tartoz\u00f3 t\u00e9telek \u00e1llapot\u00e1t\nupdate OrderItem\nset StatusID=4\nwhere OrderID=4\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3: els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve</p> </li> </ol> Mit tapasztalt? Mi\u00e9rt? <p>Kezdetben minden t\u00e9tel \"Packaged\" st\u00e1tuszban van, ami \u00edgy konzisztens (nem lehet egy darab t\u00e9tel \"in transit\", azaz post\u00e1z\u00e1s alatt, ha a megrendel\u00e9s nincs). Viszont, amint v\u00e1ltozatunk a megrendel\u00e9s \u00e1llapot\u00e1n, a csomag st\u00e1tusza ellentmond\u00e1sosnak l\u00e1tszik a t\u00e9telek st\u00e1tusz\u00e1val. Az adatb\u00e1zis nem inkonzisztens, mert a bels\u0151 szab\u00e1lyai (integrit\u00e1si krit\u00e9riumai) alapj\u00e1n nincs probl\u00e9ma. De \u00fczleti \u00e9rtelemben ellentmond\u00e1sos a tartalom.</p> <p>Az SQL Server alap\u00e9rtelmez\u00e9sben auto commit \u00fczemm\u00f3dban fut, azaz egy utas\u00edt\u00e1s az egy tranzakci\u00f3, amit automatikusan lez\u00e1r. Teh\u00e1t a probl\u00e9ma, hogy a m\u00f3dos\u00edt\u00e1saink nem egy tranzakci\u00f3t k\u00e9peznek.</p> <p>A helyes viselked\u00e9shez \u00f6ssze kellene fogni a k\u00e9t adatm\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1st egy tranzakci\u00f3ba.</p>"},{"location":"seminar/transactions/#feladat-3-tranzakcio-inditasa-read-committed-izolacios-szint","title":"Feladat 3: Tranzakci\u00f3 ind\u00edt\u00e1sa, read committed izol\u00e1ci\u00f3s szint","text":"<p>Ism\u00e9telje meg az el\u0151z\u0151 feladatot \u00fagy, hogy a k\u00e9t adatm\u00f3dos\u00edt\u00e1s egy tranzakci\u00f3t k\u00e9pezzen:</p> <ul> <li>A T2 tranzakci\u00f3 kezdjen egy <code>begin tran</code>, \u00e9s v\u00e9gz\u0151dj\u00f6n egy <code>commit</code> utas\u00edt\u00e1ssal.</li> <li>Az adatm\u00f3dos\u00edt\u00e1sn\u00e1l a st\u00e1tuszt ez\u00fattal 3-asra \u00e1ll\u00edtsuk (hogy \u00e9rdemi v\u00e1ltoz\u00e1s legyen az adatokban).</li> </ul> Mit tapasztalt? Mi\u00e9rt? <p>Amint elkezdt\u00fck a st\u00e1tusz m\u00f3dos\u00edt\u00e1s\u00e1t T2-ben, a lek\u00e9rdez\u0151 T1-es utas\u00edt\u00e1s v\u00e1rni fog. Addig v\u00e1r, am\u00edg az adatm\u00f3dos\u00edt\u00f3 tranzakci\u00f3 be nem fejez\u0151dik. Ez az\u00e9rt van, mert a <code>select</code> utas\u00edt\u00e1s olvas\u00e1si z\u00e1rat akar elhelyezni, de m\u00e1sik tranzakci\u00f3 \u00e9ppen m\u00f3dos\u00edtja az adott rekordot, \u00edgy kiz\u00e1r\u00f3 z\u00e1rat helyezett el rajta.</p> <p>Jegyezz\u00fck meg, hogy az alap izol\u00e1ci\u00f3s szint, a read committed ezen a platformon azt jelenti, hogy m\u00f3dos\u00edt\u00e1s alatt lev\u0151 adat nem olvashat\u00f3. Ez egy implement\u00e1ci\u00f3s k\u00e9rd\u00e9s, az SQL szabv\u00e1ny ezt nem r\u00f6gz\u00edti. M\u00e1s adatb\u00e1zis platform viselkedhet m\u00e1shogy is (pl. az Oracle Server biztos\u00edtja, hogy a rekordok commit\u00e1lt k\u00e9pe mindenk\u00e9ppen olvashat\u00f3 marad). M\u00e1s izol\u00e1ci\u00f3s szinten az MSSQL szerver is m\u00e1shogy viselkedik, a snapshot izol\u00e1ci\u00f3s szint haszn\u00e1lata eset\u00e9n a m\u00f3dos\u00edt\u00e1s megkezd\u00e9se el\u0151tti v\u00e1ltozat olvashat\u00f3.</p>"},{"location":"seminar/transactions/#feladat-4-tranzakcio-megszakitasa-rollback-read-committed-izolacios-szinten","title":"Feladat 4: Tranzakci\u00f3 megszak\u00edt\u00e1sa (rollback) read committed izol\u00e1ci\u00f3s szinten","text":"<p>Kezdj\u00fck el lefuttatni az el\u0151z\u0151 parancs sorozatot, a tranzakci\u00f3val egy\u00fctt, de a m\u00f3dos\u00edt\u00f3 tranzakci\u00f3t szak\u00edtsuk meg a k\u00f6zep\u00e9n.</p> <ol> <li> <p>T1 tranzakci\u00f3</p> <pre><code>-- List\u00e1zzuk ki a megrendel\u00e9s \u00e9s a hozz\u00e1 tartoz\u00f3 t\u00e9telek st\u00e1tusz\u00e1t\nselect s1.Name, p.Name, s2.Name\nfrom [Order] o, OrderItem oi, Status s1, status s2, Product p\nwhere o.Id=oi.OrderID\nand o.ID=4\nand o.StatusID=s1.ID\nand oi.StatusID=s2.ID\nand p.ID=oi.ProductID\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>-- \u00daj tranzakci\u00f3t kezd\u00fcnk\nbegin tran\n\n-- \u00c1ll\u00edtsuk \u00e1t a megrendel\u00e9s \u00e1llapot\u00e1t\nupdate [Order]\nset StatusID=4\nwhere ID=4\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3: els\u0151 l\u00e9p\u00e9sben kiadott parancs megism\u00e9telve</p> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>-- Szak\u00edtsuk meg a tranzakci\u00f3t\nrollback\n</code></pre> </li> </ol> Mit tapasztalt? Mi\u00e9rt? <p>Az el\u0151z\u0151ekben tapasztaltakhoz hasonl\u00f3an a m\u00f3dos\u00edt\u00e1s megkezdte ut\u00e1n az olvas\u00f3 utas\u00edt\u00e1s v\u00e1rakoz\u00e1sra k\u00e9nyszer\u00fclt. Amikor megszak\u00edtottuk a tranzakci\u00f3t, akkor \u00e9rkezett meg az eredm\u00e9ny. Mivel read committed izol\u00e1ci\u00f3s szinten vagyunk, nem l\u00e1tjuk a m\u00f3dos\u00edt\u00e1s alatt lev\u0151 tartalmat. Amint a m\u00f3dos\u00edt\u00f3 tranzakci\u00f3 befejez\u0151dik, ak\u00e1r sikeres <code>commit</code>, ak\u00e1r <code>rollback</code> miatt, el\u00e9rhet\u0151v\u00e9 v\u00e1lnak a rekordok.</p> <p>Vegy\u00fck \u00e9szre, hogy pont elker\u00fclt\u00fck a piszkos olvas\u00e1s probl\u00e9m\u00e1j\u00e1t. Ha a m\u00f3dos\u00edt\u00e1s fut\u00e1sa k\u00f6zben megjelent volna a f\u00e9lk\u00e9sz eredm\u00e9ny, a <code>rollback</code> miatt az a tranzakci\u00f3 \u00e9rv\u00e9nytelen adattal dolgozna tov\u00e1bb.</p>"},{"location":"seminar/transactions/#feladat-5-megrendeles-rogzitese-serializable-izolacios-szinten","title":"Feladat 5: Megrendel\u00e9s r\u00f6gz\u00edt\u00e9se serializable izol\u00e1ci\u00f3s szinten","text":"<p>A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r <code>rollback</code> utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz.</p> <p>Legyen k\u00e9t p\u00e1rhuzamos tranzakci\u00f3nk, melyek megrendel\u00e9st r\u00f6gz\u00edtenek. Egy term\u00e9kre nem vehet\u00fcnk fel t\u00f6bb megrendel\u00e9st, mint ami a rakt\u00e1rk\u00e9szlet. Az\u00e9rt, hogy a tranzakci\u00f3k egym\u00e1sra hat\u00e1s\u00e1t elk\u00fcl\u00f6n\u00edts\u00fck, kapcsoljunk \u00e1t serializable izol\u00e1ci\u00f3s szintre.</p> <ol> <li> <p>T1 tranzakci\u00f3</p> <pre><code>set transaction isolation level serializable\nbegin tran\n\n-- Ellen\u0151rizz\u00fck, hogy mennyi van rakt\u00e1ron egy term\u00e9kb\u0151l\nselect *\nfrom Product\nwhere ID=2\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>set transaction isolation level serializable\nbegin tran\n\nselect *\nfrom Product\nwhere ID=2\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3</p> <pre><code>-- Ellen\u0151rizz\u00fck, hogy h\u00e1ny, m\u00e9g fel nem dolgozott megrendel\u00e9s van erre a term\u00e9kre\nselect sum(Amount)\nfrom OrderItem\nwhere ProductID=2\nand StatusID=1\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>select sum(Amount)\nfrom OrderItem\nwhere ProductID=2\nand StatusID=1\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3</p> <pre><code>-- Mivel teljes\u00edthet\u0151 a megrendel\u00e9s, r\u00f6gz\u00edts\u00fck\ninsert into OrderItem(OrderID,ProductID,Amount,StatusID)\nvalues(2,2,3,1)\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>insert into OrderItem(OrderID,ProductID,Amount,StatusID)\nvalues(3,2,3,1)\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3</p> <pre><code>commit\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>commit\n</code></pre> </li> </ol> Mit tapasztalt? Mi\u00e9rt? <p>Holtpont fog kialakulni, mivel a serializable izol\u00e1ci\u00f3s szint miatt mindk\u00e9t tranzakci\u00f3 megtiltja a megrendel\u00e9st\u00e9tel t\u00e1bla m\u00f3dos\u00edt\u00e1s\u00e1t. A <code>select sum</code> miatt, \u00e9s a megism\u00e9telhet\u0151 olvas\u00e1s elv\u00e1r\u00e1s miatt a rekordokat olvas\u00f3 z\u00e1rral l\u00e1tja el a rendszer. Viszont \u00edgy nem futhat le a m\u00e1sik tranzakci\u00f3ban az <code>insert</code>, amely kiz\u00e1r\u00f3lagos z\u00e1rat ig\u00e9nyelne. Ez mindk\u00e9t tranzakci\u00f3 eset\u00e9n azt jelenti, hogy a m\u00e1sik \u00e1ltal fogott z\u00e1rra v\u00e1r.</p> <p>A holtpont eredm\u00e9nye, hogy az egyik tranzakci\u00f3t le fogja \u00e1ll\u00edtani a szerver. Ez elv\u00e1rt \u00e9s helyes m\u0171k\u00f6d\u00e9st eredm\u00e9nyez, mivel megakad\u00e1lyozza, hogy a k\u00e9t tranzakci\u00f3 k\u00f6zt adat egym\u00e1srahat\u00e1s legyen (\u00edgy nem fordulhat el\u0151, hogy t\u00f6bb term\u00e9ket adunk el, mint amennyi van).</p> <p>Ism\u00e9telj\u00fck meg a fenti m\u0171veletsort, csak a megrendel\u00e9s r\u00f6gz\u00edt\u00e9sekor m\u00e1s-m\u00e1s term\u00e9k ID-t haszn\u00e1ljunk! Ezzel azt szimul\u00e1ljuk, hogy k\u00e9t megrendel\u0151 m\u00e1s-m\u00e1s term\u00e9ket rendel meg.</p> <ul> <li>A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r <code>rollback</code> utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz.</li> <li>Ahol utas\u00edt\u00e1sban <code>ID</code> vagy <code>ProductID</code> szerepel, ott egyik tranzakci\u00f3ban a 2-es, m\u00e1sikban a 3-as term\u00e9ket haszn\u00e1ljuk.</li> </ul> Mit tapasztalt? Mi\u00e9rt? <p>Ha k\u00fcl\u00f6nb\u00f6z\u0151 term\u00e9kre t\u00f6rt\u00e9nik a r\u00f6gz\u00edt\u00e9s, akkor is holtpont fog kialakulni. Olyan a z\u00e1rol\u00e1si rendszer, hogy a <code>select sum</code> az eg\u00e9sz t\u00e1bl\u00e1t z\u00e1rolja, mivel nem tudja megk\u00fcl\u00f6nb\u00f6ztetni <code>ProductID</code> szerint a rekordokat. Ez term\u00e9szetes is, mivel csak az \u00fczleti logik\u00e1b\u00f3l ad\u00f3dik, hogy ha k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 term\u00e9kre t\u00f6rt\u00e9nik a megrendel\u00e9s r\u00f6gz\u00edt\u00e9se, akkor azok t\u00f6rt\u00e9nhetn\u00e9nek egyszerre is. Az adatb\u00e1zis ezt nem tudhatja.</p> <p>Azaz a serializable izol\u00e1ci\u00f3s szint t\u00fal szigor\u00fa, \u00fczleti logik\u00e1t figyelembe v\u00e9ve nagyobb p\u00e1rhuzamos\u00edt\u00e1s engedhet\u0151 meg. Ez\u00e9rt is ritk\u00e1n haszn\u00e1ljuk a gyakorlatban.</p>"},{"location":"seminar/transactions/#feladat-6-megrendeles-rogzitese-read-committed-izolacios-szinten","title":"Feladat 6: Megrendel\u00e9s r\u00f6gz\u00edt\u00e9se read committed izol\u00e1ci\u00f3s szinten","text":"<p>Gondoljuk v\u00e9gig, az el\u0151z\u0151 feladat eset\u00e9n mi t\u00f6rt\u00e9nne, ha a nem \u00e1ll\u00edtjuk \u00e1t a tranzakci\u00f3k izol\u00e1ci\u00f3s szintj\u00e9t? Lenne holtpont? \u00c9s helyes lenne a m\u0171k\u00f6d\u00e9s?</p> Mit v\u00e1runk? Mi\u00e9rt? <p>Ha nem v\u00e1ltoztatunk izol\u00e1ci\u00f3s szintet, akkor helytelen m\u0171k\u00f6d\u00e9s \u00e1llhatna el\u0151. Mivel a read committed izol\u00e1ci\u00f3s szint nem biztos\u00edtja sz\u00e1munkra azt, hogy am\u00edg fut a tranzakci\u00f3nk, addig egy m\u00e1sik tranzakci\u00f3 ber\u00f6gz\u00edtsen rekordokat. Teh\u00e1t lefuthatna az <code>insert</code>, ami miatt v\u00e9geredm\u00e9nyben t\u00f6bb \u00e1rut adn\u00e1nk el, mint ami a rakt\u00e1rban van. Ez a nem megism\u00e9telhet\u0151 olvas\u00e1s probl\u00e9m\u00e1ja.</p> <p>Err\u0151l az oldalr\u00f3l n\u00e9zve teh\u00e1t a serializable izol\u00e1ci\u00f3s szint nem volt feleslegesen szigor\u00fa. T\u00e9nyleg megv\u00e9dett minket egy probl\u00e9m\u00e1t\u00f3l.</p>"},{"location":"seminar/transactions/#feladat-7-manualis-zarolas","title":"Feladat 7: Manu\u00e1lis z\u00e1rol\u00e1s","text":"<p>A feladat megkezd\u00e9se el\u0151tt el\u0151sz\u00f6r is szak\u00edtsuk meg a f\u00e9lbemaradt tranzakci\u00f3kat. Mindk\u00e9t ablakban adjunk ki p\u00e1r <code>rollback</code> utas\u00edt\u00e1st az esetleg ottmaradt tranzakci\u00f3k le\u00e1ll\u00edt\u00e1s\u00e1hoz.</p> <p>Read committed izol\u00e1ci\u00f3s szintet haszn\u00e1lva dolgozzon ki megold\u00e1st, amely csak az azonos term\u00e9kekre t\u00f6rt\u00e9n\u0151 p\u00e1rhuzamos adatr\u00f6gz\u00edt\u00e9seket akad\u00e1lyozza meg. Term\u00e9szetesen felt\u00e9telezheti hogy mindegyik p\u00e1rhuzamos folyamat ugyanazt a programlogik\u00e1t k\u00f6veti.</p> <p>A megold\u00e1shoz kihaszn\u00e1ljuk, hogy lehets\u00e9ges manu\u00e1lisan z\u00e1rakat elhelyezni. Ezek a z\u00e1rak is, \u00fagy, mint a t\u00f6bbi z\u00e1r, a tranzakci\u00f3 v\u00e9g\u00e9ig \u00e9lnek.</p> <pre><code>select *\nfrom tablename with(XLOCK)\n...\n</code></pre> Hova kell ezt a z\u00e1rat elhelyezni? Hogyan n\u00e9z ki \u00edgy a megrendel\u00e9s folyamata? <p>A megold\u00e1s kulcsa, hogy j\u00f3 helyre tegy\u00fck a z\u00e1rat. A k\u00e9rd\u00e9s, hogy mit is kellene z\u00e1rolni? A v\u00e1lasz, hogy a term\u00e9ket (Product): azt akarjuk megg\u00e1tolni, hogy ugyanabb\u00f3l a term\u00e9kb\u0151l r\u00f6gz\u00edthet\u0151 legyen m\u00e9g egy elad\u00e1s. Teh\u00e1t a term\u00e9kre, konkr\u00e9tan a term\u00e9k t\u00e1bl\u00e1ban arra a sorra tessz\u00fck a z\u00e1rat, ami a term\u00e9ket reprezent\u00e1lja.</p> <p>Ennek a megold\u00e1snak a h\u00e1tr\u00e1nya, hogy nagyon alaposan \u00e1t kell gondolnunk, hogyan \u00e9s hol v\u00e9gezz\u00fck a z\u00e1rol\u00e1st.</p> <p>A l\u00e9p\u00e9seink teh\u00e1t a k\u00f6vetkez\u0151k.</p> <ol> <li> <p>T1 tranzakci\u00f3</p> <pre><code>set transaction isolation level read committed\nbegin tran\n\nselect *\nfrom Product with (xlock)\nwhere ID=2\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>set transaction isolation level read committed\nbegin tran\n\nselect *\nfrom Product with (xlock)\nwhere ID=3\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3</p> <pre><code>select sum(Amount)\nfrom OrderItem\nwhere ProductID=2\nand StatusID=1\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>select sum(Amount)\nfrom OrderItem\nwhere ProductID=3\nand StatusID=1\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3</p> <pre><code>insert into OrderItem(OrderID,ProductID,Amount,StatusID)\nvalues(2,2,3,1)\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>insert into OrderItem(OrderID,ProductID,Amount,StatusID)\nvalues(3,3,3,1)\n</code></pre> </li> <li> <p>T1 tranzakci\u00f3</p> <pre><code>commit\n</code></pre> </li> <li> <p>T2 tranzakci\u00f3</p> <pre><code>commit\n</code></pre> </li> </ol>"},{"location":"seminar/transactions/#feladat-8-tabla-szintu-zarolas","title":"Feladat 8: T\u00e1bla szint\u0171 z\u00e1rol\u00e1s","text":"<p>A sor szint\u0171 z\u00e1rol\u00e1s mellett lehet\u0151s\u00e9g\u00fcnk van t\u00e1bla szinten is z\u00e1rolni:</p> <pre><code>select *\nfrom tablanev with(TABLOCKX)\n...\n</code></pre> B\u00e1r ez egyszer\u0171 megold\u00e1snak t\u0171nik, gondoljuk v\u00e9gig, mi\u00e9rt nem \u00e9rdemes ezt haszn\u00e1lni? <p>Jelen esetben a t\u00e1bla szint\u0171 z\u00e1rat a megrendel\u00e9sekre kellene tenn\u00fcnk, hiszen a konkurens megrendel\u00e9seket akarjuk megakad\u00e1lyozni. De ez ugyanazzal az eredm\u00e9nnyel j\u00e1rna, mint a serializable izol\u00e1ci\u00f3s szint haszn\u00e1lata. Ugyan holtpont nem lenne, de a p\u00e1rhuzamos v\u00e9grehajt\u00e1st lehetetlenn\u00e9 tenn\u00e9. Teh\u00e1t a t\u00e1bla szint\u0171 z\u00e1rol\u00e1sra ugyanaz igaz: az \u00fczleti logik\u00e1b\u00f3l nagyobb p\u00e1rhuzamoss\u00e1g ad\u00f3dik.</p>"}]}