# 6. REST API with Spring Boot, Java, and Maven technologies

By completing the homework, you can earn **4 points**.

Using GitHub Classroom, create a repository for yourself. The **invitation URL can be found on Moodle**. Clone the repository created this way. It will contain the expected structure of the solution. Create a branch named `solution` and **work on that branch**. After completing the tasks, commit and push your solution.

The necessary software and tools for the solution can be found [here](../index.md#szukseges-eszkozok), and download [IntelliJ IDEA](https://www.jetbrains.com/idea/download/) (Community Edition, which is free).

## Task 0: Neptun Code

As a first step, write your Neptun code into the `neptun.txt` file located in the root directory!

## Task 1: Simple Query and OpenAPI Documentation (2 points)

The initial code skeleton can be found in the created and cloned repository. Open it with IntelliJ IDEA (Community) and start it. A console application should start, which hosts the web application. Try it out (while the program is running): open <http://localhost:8080/api/product> in a browser, where you should not see anything at first. Do you know why not?

Check the available code.

- It is advisable to run `mvn clean` before any major changes (adding dependencies, adding endpoints, adding new properties to entities).
- The `AdatvezRestApiApplication.java` initializes the application. This is a Spring Boot Java web application with Maven as the package manager.
- The application does not have database access for simplicity. The `ProductRepository` class provides data for testing.
- The `ProductsController` instantiates the `IProductRepository` with Spring Boot Beans.
    Can you identify which lines of code are responsible for these?

Tasks:

### Simple Query

1. Add the Maven dependency that keeps the application running continuously:

    ```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    ```

2. In the `hu.bme.aut.adatvezrestapiplushf.persistence.repositories.ProductRepository` class, replace the value of the `Neptun` field with your Neptun code. The string value should be your 6-character Neptun code.

    !!! warning "IMPORTANT"
        It is important to take a screenshot of the modified data, so this step is crucial.

### Task 3: Check if a Product Exists

Create an API endpoint to check if a product with a given ID exists. The query will use a `HEAD` type HTTP request to the `/api/product/{id}` URL. The response should be HTTP 200 or 404 (no extra content/body needed, just the status code).

- **Tip**: Use the Spring Boot response class (`ResponseEntity< *type of the response body* >`, and `return ResponseEntity.*response type*.build(*body*)`).

### OpenAPI documentation

OpenAPI (formerly known as Swagger) is a REST API documentation tool. Its purpose is similar to WSDL used for Web Services: to describe the API services in a standardized format. After completing the previous tasks, create an OpenAPI specification and documentation to describe the REST API.

1. The `swagger.json` is generated by the application itself (you don't need to write it manually) and is available by default at `/swagger/v3/swagger.json`. Change this to `/neptun_code/swagger.json`.

    - **Tip**: You can easily do this with Spring Boot and Maven by adding the appropriate dependency:

    ```xml
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc-openapi.version}</version>
        </dependency>
    ```

2. Set up the Swagger UI to be accessible at the `/neptun_code` URL. You can do this by setting the appropriate property in the `application.properties` file, similar to the previous step. This will be an alias (proxy) for the original path. Use your Neptun code in lowercase as the proxy.

3. Spring Boot applications run on port 8080 by default. Change it to 8000.
    - **Tip**: You only need to modify the `application.properties` file for this.

4. Start the web application and check the `swagger.json` at [http://localhost:8000/neptun_code/swagger.json](http://localhost:8000/neptun_code/swagger.json), and try out the Swagger UI at [http://localhost:8000/neptun_code](http://localhost:8000/swagger-ui/index.html).

5. Try out the SwaggerUI "Try it out" feature: it actually sends the request to the web application, and you can see the real response.

    ![SwaggerUI Try it out](swaggerui-try.png)

6. Create an API endpoint that returns the desired product (`Product`) based on its ID; the request should be of type `GET` to the `/api/product/{id}` URL, and the response should be either 200 with the data or 404 if the item does not exist. Verify using SwaggerUI or Postman.

!!! example "SUBMISSION"
    Upload the modified source code. Make sure that the `pom.xml` file is also updated with the added Maven packages!

        Take a screenshot of the `swagger.json` displayed in the browser. Ensure that the URL shows that the system serves it at the `/neptun/swagger.json` address with your own Neptun code. Save the image as `f1.png` and submit it as part of your solution!

## Task 2: Product Operations (2 points)

The most common database operations related to products are inserting a new product, querying an existing product, modifying or deleting a product, which are the CRUD (create, read, update, and delete) operations. We will create dedicated endpoints for these operations, through which the API user can perform the operations. In this task, you need to implement the most common endpoints in addition to the existing query.

1. Create an API endpoint that inserts a new product (`Product`) based on its ID; the request should be of type `POST` to the `/api/product` URL, expecting the new `Product` value in the request body, and the response should be either 201 or 409 if an item with the same name already exists.
    - **Tip**: Use the Spring Boot response class (`ResponseEntity< *type of the response body* >`, and `return ResponseEntity.*response types*.build(*body*)`).

2. Create an API endpoint that updates a product (`Product`) based on its ID; the request should be of type `PUT` to the `/api/product/{id}` URL, expecting the updated `Product` value in the request body, and the response should be either 204 with no content or 404 if the item does not exist.

3. Create an API endpoint that deletes a product (`Product`) based on its ID; the request should be of type `DELETE` to the `/api/product/{id}` URL, and the response should be either 204 with no content or 404 if the item does not exist.

4. Create an API endpoint that returns the total number of different products. (For example, to help pagination, the frontend can calculate how many pages there will be.) This should also be a `GET` request to the `/api/product/-/coun` endpoint. The returned data should be an instance of the `CountResult` class filled with the `count` (in JSON format, of course)..

    ??? question "Why is there a `/-` part in the URL?"
        To understand this, let's think about what the URL could be: we are interested in the number of products, so `/api/product/`, but what comes after that? It could be `/api/product/count`. However, this "conflicts" with URLs like `/api/product/123`, which are used to query a specific product. In practice, the two URLs could work together because the product ID is currently a number, so the framework recognizes that if the URL ends with `/123`, it should execute the endpoint expecting a product ID, and if it ends with `/count`, it should execute the one providing the count. But this only works if the ID is an integer. If the product identifier were a string, there would be a problem. In such cases, you need to "invent" a URL that does not conflict. The `/-` part indicates that a product identifier is _not_ traveling there.

!!! example "SUBMISSION"
    Upload the modified source code.

    Additionally, take a screenshot from Postman (or another testing tool) showing the result of a successful product retrieval. The screenshot should display all details of the request and response (request type, URL, response code, response content). The response must include your **Neptun code** in the name. Save the image as `f2.png` and submit it as part of your solution!

!!! important "YOU ARE NOT DONE YET"
    After pushing your code, create a PR and assign your instructor to it! (details: [submitting the homework](../GitHub.md) page)

## Task 3: Partial Update of Product (Bonus Points)

!!! note ""
    Earning the points.

The `Product` and `CountResult` classes contain written getter and setter functions by default. These can be simplified with `lombok` annotations, which replace frequently written lines of code, in this case with the `@Getter` and `@Setter` annotations, making the code more readable.
These can be applied only to fields, making them specific:

```java
   private @Getter @Setter int ID;
```

But it can also be applied to the entire class, and then it will apply to all fields of the class:

```java
    @Getter
    @Setter
    public class Product {}
```

This is useful to know because when using JPA, the `lombok` `@Data` annotation is often used, which includes the mentioned annotations and others that are useful when using the class (`@RequiredArgsConstructor`, `@ToString`, `@EqualsAndHashCode`).
The `lombok` package can also be added to the project with Maven, but it is already included.

1. **Which package is this?**
2. **Refactor the Product class to use annotations for getter and setter functions for all fields!**
    - Comment out the unnecessary code snippet!

!!! example "SUBMISSION"
    Upload the modified source code.

    Additionally, take a screenshot from the `pom.xml` file showing the section responsible for the `lombok` annotations, which demonstrates the result of a successful partial modification. Save the image as `f3.png` and submit it as part of your solution!
